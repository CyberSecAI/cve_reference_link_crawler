=== Content from github.com_1c838204_20250110_200004.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fsecurity%2Fadvisories%2FGHSA-3mcp-9wr4-cjqf)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fsecurity%2Fadvisories%2FGHSA-3mcp-9wr4-cjqf)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=dropwizard%2Fdropwizard)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dropwizard](/dropwizard)
/
**[dropwizard](/dropwizard/dropwizard)**
Public

* [Notifications](/login?return_to=%2Fdropwizard%2Fdropwizard) You must be signed in to change notification settings
* [Fork
  3.4k](/login?return_to=%2Fdropwizard%2Fdropwizard)
* [Star
   8.5k](/login?return_to=%2Fdropwizard%2Fdropwizard)

* [Code](/dropwizard/dropwizard)
* [Issues
  10](/dropwizard/dropwizard/issues)
* [Pull requests
  5](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

Additional navigation options

* [Code](/dropwizard/dropwizard)
* [Issues](/dropwizard/dropwizard/issues)
* [Pull requests](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

# Remote Code Execution (RCE) vulnerability in dropwizard-validation <2.0.2

High

[joschi](/joschi)
published
GHSA-3mcp-9wr4-cjqf
Feb 24, 2020

## Package

maven

dropwizard-validation
([Maven](/advisories?query=ecosystem%3Amaven))

## Affected versions

<1.3.19, <2.0.2

## Patched versions

1.3.19, 2.0.2

## Description

### Summary

A server-side template injection was identified in the self-validating ([`@SelfValidating`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidating.html)) feature of **dropwizard-validation** enabling attackers to inject arbitrary Java EL expressions, leading to Remote Code Execution (RCE) vulnerability.

If you're using a self-validating bean (via [`@SelfValidating`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidating.html)), an upgrade to Dropwizard 1.3.19 or 2.0.2 is strongly recommended.

### Impact

This issue may allow Remote Code Execution (RCE), allowing to run arbitrary code on the host system (with the privileges of the Dropwizard service account privileges) by injecting arbitrary [Java Expression Language (EL)](https://docs.jboss.org/hibernate/validator/6.1/reference/en-US/html_single/#section-interpolation-with-message-expressions) expressions when using the self-validating feature ([`@SelfValidating`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidating.html), [`@SelfValidation`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidation.html)) in **dropwizard-validation**.

### Patches

The issue has been fixed in **dropwizard-validation** **1.3.19** and **2.0.2**. We strongly recommend upgrading to one of these versions.

### Workarounds

If you are not able to upgrade to one of the aforementioned versions of **dropwizard-validation** but still want to use the [`@SelfValidating`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidating.html) feature, make sure to properly sanitize any message you're adding to the [`ViolationCollector`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/ViolationCollector.html) in the method annotated with [`@SelfValidation`](https://javadoc.io/static/io.dropwizard/dropwizard-project/2.0.2/io/dropwizard/validation/selfvalidating/SelfValidation.html).

Example:

```
@SelfValidation
public void validateFullName(ViolationCollector col) {
    if (fullName.contains("_")) {
        // Sanitize fullName variable by escaping relevant characters such as "$"
        col.addViolation("Full name contains invalid characters:  " + sanitizeJavaEl(fullName));
    }
}
```

See also:

<https://github.com/dropwizard/dropwizard/blob/v2.0.2/dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java#L84-L98>

### References

* [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
* [#3160](https://github.com/dropwizard/dropwizard/pull/3160)
* <https://docs.oracle.com/javaee/7/tutorial/jsf-el.htm>
* <https://docs.jboss.org/hibernate/validator/6.1/reference/en-US/html_single/#section-interpolation-with-message-expressions>
* <https://beanvalidation.org/2.0/spec/#validationapi-message-defaultmessageinterpolation>

### For more information

If you have any questions or comments about this advisory:

* Open an issue in [dropwizard/dropwizard](https://github.com/dropwizard/dropwizard/issues/new)
* Start a discussion on the [dropwizard-dev mailing list](https://groups.google.com/forum/#!forum/dropwizard-dev)

### Security contact

If you want to responsibly disclose a security issue in Dropwizard or one of its official modules, please contact us via the published channels in our [security policy](https://github.com/dropwizard/dropwizard/security/policy):

<https://github.com/dropwizard/dropwizard/security/policy#reporting-a-vulnerability>

### Severity

High

### CVE ID

CVE-2020-5245

### Weaknesses

No CWEs

### Credits

* [![@pwntester](https://avatars.githubusercontent.com/u/125701?s=40&v=4)](/pwntester)
  [pwntester](/pwntester)
  Analyst

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_a74b8531_20250110_200001.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2Fd87d1e4f8e20f6494c0232bf8560c961b46db634)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2Fd87d1e4f8e20f6494c0232bf8560c961b46db634)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=dropwizard%2Fdropwizard)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dropwizard](/dropwizard)
/
**[dropwizard](/dropwizard/dropwizard)**
Public

* [Notifications](/login?return_to=%2Fdropwizard%2Fdropwizard) You must be signed in to change notification settings
* [Fork
  3.4k](/login?return_to=%2Fdropwizard%2Fdropwizard)
* [Star
   8.5k](/login?return_to=%2Fdropwizard%2Fdropwizard)

* [Code](/dropwizard/dropwizard)
* [Issues
  10](/dropwizard/dropwizard/issues)
* [Pull requests
  5](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

Additional navigation options

* [Code](/dropwizard/dropwizard)
* [Issues](/dropwizard/dropwizard/issues)
* [Pull requests](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

## Commit

[Permalink](/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Escape EL expressions in ViolationCollector ([#3157](https://github.com/dropwizard/dropwizard/pull/3157))

[Browse files](/dropwizard/dropwizard/tree/d87d1e4f8e20f6494c0232bf8560c961b46db634)
Browse the repository at this point in the history

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
```

* Loading branch information

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

[joschi](/dropwizard/dropwizard/commits?author=joschi "View all commits by joschi")
authored
Feb 20, 2020

1 parent
[af0833b](/dropwizard/dropwizard/commit/af0833b110a054742b543db27e4877976ca1ac27)

commit d87d1e4

 Show file tree

 Hide file tree

Showing
**2 changed files**
with
**197 additions**
and
**91 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* dropwizard-validation/src

  + main/java/io/dropwizard/validation/selfvalidating

    - dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java
      [ViolationCollector.java](#diff-60f14d8abd144634265d91ff7488172de8a78dc2c7b4464af23847cdd57bb353)
  + test/java/io/dropwizard/validation

    - dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java
      [SelfValidationTest.java](#diff-b7170e91fbcccf596bfe268895ba7a6e22d78efe24510db68f1746bfdaadfd4b)

## There are no files selected for viewing

80 changes: 75 additions & 5 deletions

80
[...-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java](#diff-60f14d8abd144634265d91ff7488172de8a78dc2c7b4464af23847cdd57bb353 "dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java")

Show comments

[View file](/dropwizard/dropwizard/blob/d87d1e4f8e20f6494c0232bf8560c961b46db634/dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
|  |  | @@ -1,12 +1,16 @@ |
|  |  | package io.dropwizard.validation.selfvalidating; |
|  |  |  |
|  |  | import javax.annotation.Nullable; |
|  |  | import javax.validation.ConstraintValidatorContext; |
|  |  | import java.util.regex.Matcher; |
|  |  | import java.util.regex.Pattern; |
|  |  |  |
|  |  | /\*\* |
|  |  | \* This class is a simple wrapper around the ConstraintValidatorContext of hibernate validation. |
|  |  | \* It collects all the violations of the SelfValidation methods of an object. |
|  |  | \*/ |
|  |  | public class ViolationCollector { |
|  |  | private static final Pattern ESCAPE\_PATTERN = Pattern.compile("\\$\\{"); |
|  |  |  |
|  |  | private boolean violationOccurred = false; |
|  |  | private ConstraintValidatorContext context; |
| Expand All | | @@ -17,14 +21,80 @@ public ViolationCollector(ConstraintValidatorContext context) { |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets violationOccurred to true. |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param msg the message of the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \*/ |
|  |  | public void addViolation(String msg) { |
|  |  | public void addViolation(String message) { |
|  |  | violationOccurred = true; |
|  |  | context.buildConstraintViolationWithTemplate(msg) |
|  |  | .addConstraintViolation(); |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 2.0.2 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property with the violation |
|  |  | \* @param index the index of the element with the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 2.0.2 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, Integer index, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addBeanNode().inIterable().atIndex(index) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property with the violation |
|  |  | \* @param key the key of the element with the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 2.0.2 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, String key, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addBeanNode().inIterable().atKey(key) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | @Nullable |
|  |  | private String escapeEl(@Nullable String s) { |
|  |  | if (s == null || s.isEmpty()) { |
|  |  | return s; |
|  |  | } |
|  |  |  |
|  |  | final Matcher m = ESCAPE\_PATTERN.matcher(s); |
|  |  | final StringBuffer sb = new StringBuffer(s.length() + 16); |
|  |  | while (m.find()) { |
|  |  | m.appendReplacement(sb, "\\\\\\${"); |
|  |  | } |
|  |  | m.appendTail(sb); |
|  |  |  |
|  |  | return sb.toString(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
| Expand Down | |  |

 Loading

Oops, something went wrong.
 Retry

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `d87d1e4`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2Fd87d1e4f8e20f6494c0232bf8560c961b46db634) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_6ab90265_20250110_200002.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3157)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3157)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fpull_requests_fragments%2Fpull_request_layout&source=header-repo&source_repo=dropwizard%2Fdropwizard)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dropwizard](/dropwizard)
/
**[dropwizard](/dropwizard/dropwizard)**
Public

* [Notifications](/login?return_to=%2Fdropwizard%2Fdropwizard) You must be signed in to change notification settings
* [Fork
  3.4k](/login?return_to=%2Fdropwizard%2Fdropwizard)
* [Star
   8.5k](/login?return_to=%2Fdropwizard%2Fdropwizard)

* [Code](/dropwizard/dropwizard)
* [Issues
  10](/dropwizard/dropwizard/issues)
* [Pull requests
  5](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

Additional navigation options

* [Code](/dropwizard/dropwizard)
* [Issues](/dropwizard/dropwizard/issues)
* [Pull requests](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2Fdropwizard%2Fdropwizard%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2Fdropwizard%2Fdropwizard%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# Escape EL expressions in ViolationCollector #3157

 Merged

[joschi](/joschi)
merged 6 commits into
[master](/dropwizard/dropwizard/tree/master "dropwizard/dropwizard:master")
from
[issue-3153](/dropwizard/dropwizard/tree/issue-3153 "dropwizard/dropwizard:issue-3153")

Feb 20, 2020

 Merged

# [Escape EL expressions in ViolationCollector](#top) #3157

[joschi](/joschi)
merged 6 commits into
[master](/dropwizard/dropwizard/tree/master "dropwizard/dropwizard:master")
from
[issue-3153](/dropwizard/dropwizard/tree/issue-3153 "dropwizard/dropwizard:issue-3153")

Feb 20, 2020

[Conversation
2](/dropwizard/dropwizard/pull/3157)
[Commits
6](/dropwizard/dropwizard/pull/3157/commits)
[Checks
0](/dropwizard/dropwizard/pull/3157/checks)
[Files changed](/dropwizard/dropwizard/pull/3157/files)

## Conversation

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

[![joschi](https://avatars.githubusercontent.com/u/43951?s=60&v=4)](/joschi)

Copy link

Member

### @joschi **[joschi](/joschi)** commented [Feb 19, 2020](#issue-567931743)

Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)

Sorry, something went wrong.

All reactions

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Escape EL expressions in ViolationCollector](/dropwizard/dropwizard/pull/3157/commits/b9a433a97c6f860e4d47208c3f572b5ff25fe720 "Escape EL expressions in ViolationCollector

Fixes #3153")`
 …

`[b9a433a](/dropwizard/dropwizard/pull/3157/commits/b9a433a97c6f860e4d47208c3f572b5ff25fe720)`

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
added
the
[security](/dropwizard/dropwizard/labels/security)
label
[Feb 19, 2020](#event-3053845604)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
added this to the [2.0.2](/dropwizard/dropwizard/milestone/54) milestone
[Feb 19, 2020](#event-3053845609)

 [![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
requested a review
from a team
[February 19, 2020 23:48](#event-3053845616)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
self-assigned this
[Feb 19, 2020](#event-3053845630)

[![evnm](https://avatars.githubusercontent.com/u/110020?s=60&v=4)](/evnm)

**[evnm](/evnm)**
approved these changes
[Feb 20, 2020](#pullrequestreview-361529621)

 [View reviewed changes](/dropwizard/dropwizard/pull/3157/files/b9a433a97c6f860e4d47208c3f572b5ff25fe720)

Copy link

Member

### @evnm **[evnm](/evnm)** left a comment

There was a problem hiding this comment.

### Choose a reason for hiding this comment

The reason will be displayed to describe this comment to others. [Learn more](https://docs.github.com/articles/managing-disruptive-comments/#hiding-a-comment).

Choose a reason

Spam
Abuse
Off Topic
Outdated
Duplicate
Resolved

Hide comment

Thanks for jumping on this.

Sorry, something went wrong.

All reactions

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Don't run tests in SelfValidationTest concurrently](/dropwizard/dropwizard/pull/3157/commits/12011399b3d52b1d7379a44cc2031c60db8eea99 "Don't run tests in SelfValidationTest concurrently")`

`[1201139](/dropwizard/dropwizard/pull/3157/commits/12011399b3d52b1d7379a44cc2031c60db8eea99)`

[![nickbabcock](https://avatars.githubusercontent.com/u/2106129?s=60&v=4)](/nickbabcock)

**[nickbabcock](/nickbabcock)**
reviewed
[Feb 20, 2020](#pullrequestreview-361538885)

 [View reviewed changes](/dropwizard/dropwizard/pull/3157/files/b9a433a97c6f860e4d47208c3f572b5ff25fe720)

[...ard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java](/dropwizard/dropwizard/pull/3157/files/b9a433a97c6f860e4d47208c3f572b5ff25fe720#diff-60f14d8abd144634265d91ff7488172de8a78dc2c7b4464af23847cdd57bb353)

|  |  | String messageTemplate = escapeEl(message); |
| --- | --- | --- |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addBeanNode().inIterable().atKey(key) |

Copy link

Contributor

### @nickbabcock **[nickbabcock](/nickbabcock)** [Feb 20, 2020](#discussion_r381627676)

There was a problem hiding this comment.

### Choose a reason for hiding this comment

The reason will be displayed to describe this comment to others. [Learn more](https://docs.github.com/articles/managing-disruptive-comments/#hiding-a-comment).

Choose a reason

Spam
Abuse
Off Topic
Outdated
Duplicate
Resolved

Hide comment

Thanks for digging into the javax.validation API to find these nuggets

Sorry, something went wrong.

All reactions

 [joschi](/joschi)
added 4 commits
[February 20, 2020 01:47](#commits-pushed-a78a724)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Declare resource locks on "logger" in SelfValidationTest](/dropwizard/dropwizard/pull/3157/commits/a78a7246a15f20683ddd5b2e446644e662f99860 "Declare resource locks on \"logger\" in SelfValidationTest")`

`[a78a724](/dropwizard/dropwizard/pull/3157/commits/a78a7246a15f20683ddd5b2e446644e662f99860)`

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Revert "Declare resource locks on "logger" in SelfValidationTest"](/dropwizard/dropwizard/pull/3157/commits/ae54b0229b09a940ed0c0a7f589244a9e85dec6d "Revert \"Declare resource locks on \"logger\" in SelfValidationTest\"

This reverts commit a78a7246a15f20683ddd5b2e446644e662f99860.")`
 …

`[ae54b02](/dropwizard/dropwizard/pull/3157/commits/ae54b0229b09a940ed0c0a7f589244a9e85dec6d)`

```
This reverts commit [a78a724](https://github.com/dropwizard/dropwizard/commit/a78a7246a15f20683ddd5b2e446644e662f99860).
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Revert "Don't run tests in SelfValidationTest concurrently"](/dropwizard/dropwizard/pull/3157/commits/8457cb5655907e70e59de3e3a0cba60e9926f974 "Revert \"Don't run tests in SelfValidationTest concurrently\"

This reverts commit 12011399b3d52b1d7379a44cc2031c60db8eea99.")`
 …

`[8457cb5](/dropwizard/dropwizard/pull/3157/commits/8457cb5655907e70e59de3e3a0cba60e9926f974)`

```
This reverts commit [1201139](https://github.com/dropwizard/dropwizard/commit/12011399b3d52b1d7379a44cc2031c60db8eea99).
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Clear loggers before every test](/dropwizard/dropwizard/pull/3157/commits/0ebf544e4766bb3ec2fa811f460101948e41afe9 "Clear loggers before every test")`

`[0ebf544](/dropwizard/dropwizard/pull/3157/commits/0ebf544e4766bb3ec2fa811f460101948e41afe9)`

[![jplock](https://avatars.githubusercontent.com/u/49093?s=60&v=4)](/jplock)

**[jplock](/jplock)**
approved these changes
[Feb 20, 2020](#pullrequestreview-361545635)

 [View reviewed changes](/dropwizard/dropwizard/pull/3157/files/0ebf544e4766bb3ec2fa811f460101948e41afe9)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
merged commit [`d87d1e4`](/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634)
into
master

[Feb 20, 2020](https://github.com/dropwizard/dropwizard/pull/3157#event-3054049727)

 [![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
deleted the
issue-3153

branch
[February 20, 2020 01:36](#event-3054049798)

[joschi](/joschi)
added a commit
that referenced
this pull request
[Feb 20, 2020](#ref-commit-aa9ae96)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Escape EL expressions in ViolationCollector](/dropwizard/dropwizard/commit/aa9ae9689d7d215f6115efb5850160e0a8cd35e5 "Escape EL expressions in ViolationCollector

Fixes #3153
Refs #3157
(cherry picked from commit d87d1e4f8e20f6494c0232bf8560c961b46db634)")`
…

`[aa9ae96](/dropwizard/dropwizard/commit/aa9ae9689d7d215f6115efb5850160e0a8cd35e5)`

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
(cherry picked from commit [d87d1e4](https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634))
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
mentioned this pull request
[Feb 20, 2020](#ref-pullrequest-567996964)

[Escape EL expressions in ViolationCollector
#3160](/dropwizard/dropwizard/pull/3160)
 Merged

[joschi](/joschi)
added a commit
that referenced
this pull request
[Feb 20, 2020](#ref-commit-28479f7)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Escape EL expressions in ViolationCollector (](/dropwizard/dropwizard/commit/28479f743a9d0aab6d0e963fc07f3dd98e8c8236 "Escape EL expressions in ViolationCollector (#3160)

Fixes #3153
Refs #3157
(cherry picked from commit d87d1e4f8e20f6494c0232bf8560c961b46db634)")[#3160](https://github.com/dropwizard/dropwizard/pull/3160)[)](/dropwizard/dropwizard/commit/28479f743a9d0aab6d0e963fc07f3dd98e8c8236 "Escape EL expressions in ViolationCollector (#3160)

Fixes #3153
Refs #3157
(cherry picked from commit d87d1e4f8e20f6494c0232bf8560c961b46db634)")`
…

`[28479f7](/dropwizard/dropwizard/commit/28479f743a9d0aab6d0e963fc07f3dd98e8c8236)`

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
(cherry picked from commit [d87d1e4](https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634))
```

[![@dtanedo](https://avatars.githubusercontent.com/u/16568535?s=40&v=4)](/dtanedo)
[dtanedo](/dtanedo)
mentioned this pull request
[Mar 12, 2020](#ref-issue-579761372)

[False Positive on simpleclient\_dropwizard-0.6.0.jar
jeremylong/DependencyCheck#2523](/jeremylong/DependencyCheck/issues/2523)

Closed

[joschi](/joschi)
added a commit
that referenced
this pull request
[Mar 26, 2020](#ref-commit-b4f34a2)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Disable message interpolation in ConstraintViolations by default](/dropwizard/dropwizard/commit/b4f34a26d5ec9d51caa8cfec2c452f8298c02c4d "Disable message interpolation in ConstraintViolations by default

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157")`
…

`[b4f34a2](/dropwizard/dropwizard/commit/b4f34a26d5ec9d51caa8cfec2c452f8298c02c4d)`

```
Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
```

[joschi](/joschi)
added a commit
that referenced
this pull request
[Mar 26, 2020](#ref-commit-a8b96df)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Disable message interpolation in ConstraintViolations by default](/dropwizard/dropwizard/commit/a8b96dfe5565fcd8bc44c8ed78a028294485c839 "Disable message interpolation in ConstraintViolations by default

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157")`
…

`[a8b96df](/dropwizard/dropwizard/commit/a8b96dfe5565fcd8bc44c8ed78a028294485c839)`

```
Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
mentioned this pull request
[Mar 26, 2020](#ref-pullrequest-588233709)

[Disable message interpolation in ConstraintViolations by default
#3208](/dropwizard/dropwizard/pull/3208)
 Merged

[joschi](/joschi)
added a commit
that referenced
this pull request
[Mar 26, 2020](#ref-commit-d5a512f)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Disable message interpolation in ConstraintViolations by default (](/dropwizard/dropwizard/commit/d5a512f7abf965275f2a6b913ac4fe778e424242 "Disable message interpolation in ConstraintViolations by default (#3208)

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157")[#3208](https://github.com/dropwizard/dropwizard/pull/3208)[)](/dropwizard/dropwizard/commit/d5a512f7abf965275f2a6b913ac4fe778e424242 "Disable message interpolation in ConstraintViolations by default (#3208)

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157")`
…

`[d5a512f](/dropwizard/dropwizard/commit/d5a512f7abf965275f2a6b913ac4fe778e424242)`

```
Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
```

[joschi](/joschi)
added a commit
that referenced
this pull request
[Mar 26, 2020](#ref-commit-55da67b)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Disable message interpolation in ConstraintViolations by default](/dropwizard/dropwizard/commit/55da67b2598209189e21928abe03d36fc1774617 "Disable message interpolation in ConstraintViolations by default

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157
Refs #3208")`
…

`[55da67b](/dropwizard/dropwizard/commit/55da67b2598209189e21928abe03d36fc1774617)`

```
Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
Refs [#3208](https://github.com/dropwizard/dropwizard/pull/3208)
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
mentioned this pull request
[Mar 26, 2020](#ref-pullrequest-588589075)

[Disable message interpolation in ConstraintViolations by default
#3209](/dropwizard/dropwizard/pull/3209)
 Merged

[joschi](/joschi)
added a commit
that referenced
this pull request
[Mar 26, 2020](#ref-commit-74e2115)
[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Disable message interpolation in ConstraintViolations by default (](/dropwizard/dropwizard/commit/74e211514db951a67b0e9ff75b0102704d4b2049 "Disable message interpolation in ConstraintViolations by default (#3209)

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157
Refs #3208")[#3209](https://github.com/dropwizard/dropwizard/pull/3209)[)](/dropwizard/dropwizard/commit/74e211514db951a67b0e9ff75b0102704d4b2049 "Disable message interpolation in ConstraintViolations by default (#3209)

Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs #3153
Refs #3157
Refs #3208")`
…

`[74e2115](/dropwizard/dropwizard/commit/74e211514db951a67b0e9ff75b0102704d4b2049)`

```
Disable message interpolation in ConstraintViolations by default but allow enabling it explicitly with `SelfValidating#escapeExpressions()`.

Additionally, `ConstraintViolations` now provides a set of methods which take a map of message parameters for interpolation.
The message parameters will be escaped by default.

Refs [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
Refs [#3208](https://github.com/dropwizard/dropwizard/pull/3208)
```

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3157)

Reviewers

[![@nickbabcock](https://avatars.githubusercontent.com/u/2106129?s=40&v=4)](/nickbabcock) [nickbabcock](/nickbabcock)

nickbabcock left review comments

[![@evnm](https://avatars.githubusercontent.com/u/110020?s=40&v=4)](/evnm) [evnm](/evnm)

evnm approved these changes

[![@jplock](https://avatars.githubusercontent.com/u/49093?s=40&v=4)](/jplock) [jplock](/jplock)

jplock approved these changes

Assignees

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi) [joschi](/joschi)

Labels

[security](/dropwizard/dropwizard/labels/security)

Projects

None yet

Milestone

 [**2.0.2**](/dropwizard/dropwizard/milestone/54 "2.0.2")

Development

Successfully merging this pull request may close these issues.

 [Security issue](https://github.com/dropwizard/dropwizard/issues/3153)

4 participants

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=52&v=4)](/joschi) [![@jplock](https://avatars.githubusercontent.com/u/49093?s=52&v=4)](/jplock) [![@evnm](https://avatars.githubusercontent.com/u/110020?s=52&v=4)](/evnm) [![@nickbabcock](https://avatars.githubusercontent.com/u/2106129?s=52&v=4)](/nickbabcock)

Add this suggestion to a batch that can be applied as a single commit.
This suggestion is invalid because no changes were made to the code.
Suggestions cannot be applied while the pull request is closed.
Suggestions cannot be applied while viewing a subset of changes.
Only one suggestion per line can be applied in a batch.
Add this suggestion to a batch that can be applied as a single commit.
Applying suggestions on deleted lines is not supported.
You must change the existing code in this line in order to create a valid suggestion.
Outdated suggestions cannot be applied.
This suggestion has been applied or marked resolved.
Suggestions cannot be applied from pending reviews.
Suggestions cannot be applied on multi-line comments.
Suggestions cannot be applied while the pull request is queued to merge.
Suggestion cannot be applied right now. Please check back later.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from docs.jboss.org_e14c14df_20250110_195959.html ===

# Hibernate Validator 6.1.7.Final - Jakarta Bean Validation Reference Implementation: Reference Guide

Hardy Ferentschik

Gunnar Morling

Guillaume Smet

2020-12-16

Table of Contents

* [Preface](#preface)
* [1. Getting started](#validator-gettingstarted)
  + [1.1. Project set up](#validator-gettingstarted-createproject)
    - [1.1.1. Unified EL](#validator-gettingstarted-uel)
    - [1.1.2. CDI](#section-getting-started-cdi)
    - [1.1.3. Running with a security manager](#section-getting-started-security-manager)
    - [1.1.4. Updating Hibernate Validator in WildFly](#_updating_hibernate_validator_in_wildfly)
    - [1.1.5. Running on Java 9](#validator-gettingstarted-java9)
  + [1.2. Applying constraints](#validator-gettingstarted-createmodel)
  + [1.3. Validating constraints](#_validating_constraints)
  + [1.4. Where to go next?](#validator-gettingstarted-whatsnext)
* [2. Declaring and validating bean constraints](#chapter-bean-constraints)
  + [2.1. Declaring bean constraints](#section-declaring-bean-constraints)
    - [2.1.1. Field-level constraints](#_field_level_constraints)
    - [2.1.2. Property-level constraints](#_property_level_constraints)
    - [2.1.3. Container element constraints](#container-element-constraints)
      * [2.1.3.1. With `Iterable`](#_with_code_iterable_code)
      * [2.1.3.2. With `List`](#_with_code_list_code)
      * [2.1.3.3. With `Map`](#_with_code_map_code)
      * [2.1.3.4. With `java.util.Optional`](#_with_code_java_util_optional_code)
      * [2.1.3.5. With custom container types](#_with_custom_container_types)
      * [2.1.3.6. Nested container elements](#_nested_container_elements)
    - [2.1.4. Class-level constraints](#validator-usingvalidator-classlevel)
    - [2.1.5. Constraint inheritance](#section-constraint-inheritance)
    - [2.1.6. Object graphs](#section-object-graph-validation)
  + [2.2. Validating bean constraints](#section-validating-bean-constraints)
    - [2.2.1. Obtaining a `Validator` instance](#section-obtaining-validator)
    - [2.2.2. Validator methods](#_validator_methods)
      * [2.2.2.1. `Validator#validate()`](#_code_validator_validate_code)
      * [2.2.2.2. `Validator#validateProperty()`](#_code_validator_validateproperty_code)
      * [2.2.2.3. `Validator#validateValue()`](#_code_validator_validatevalue_code)
    - [2.2.3. `ConstraintViolation`](#section-constraint-violation-methods)
      * [2.2.3.1. `ConstraintViolation` methods](#_code_constraintviolation_code_methods)
      * [2.2.3.2. Exploiting the property path](#_exploiting_the_property_path)
  + [2.3. Built-in constraints](#section-builtin-constraints)
    - [2.3.1. Jakarta Bean Validation constraints](#validator-defineconstraints-spec)
    - [2.3.2. Additional constraints](#validator-defineconstraints-hv-constraints)
      * [2.3.2.1. Country specific constraints](#_country_specific_constraints)
* [3. Declaring and validating method constraints](#chapter-method-constraints)
  + [3.1. Declaring method constraints](#section-declaring-method-constraints)
    - [3.1.1. Parameter constraints](#_parameter_constraints)
      * [3.1.1.1. Cross-parameter constraints](#_cross_parameter_constraints)
    - [3.1.2. Return value constraints](#_return_value_constraints)
    - [3.1.3. Cascaded validation](#_cascaded_validation)
    - [3.1.4. Method constraints in inheritance hierarchies](#section-method-constraints-inheritance-hierarchies)
  + [3.2. Validating method constraints](#section-validating-executable-constraints)
    - [3.2.1. Obtaining an `ExecutableValidator` instance](#section-obtaining-executable-validator)
    - [3.2.2. `ExecutableValidator` methods](#section-executable-validator-methods)
      * [3.2.2.1. `ExecutableValidator#validateParameters()`](#_code_executablevalidator_validateparameters_code)
      * [3.2.2.2. `ExecutableValidator#validateReturnValue()`](#_code_executablevalidator_validatereturnvalue_code)
      * [3.2.2.3. `ExecutableValidator#validateConstructorParameters()`](#_code_executablevalidator_validateconstructorparameters_code)
      * [3.2.2.4. `ExecutableValidator#validateConstructorReturnValue()`](#_code_executablevalidator_validateconstructorreturnvalue_code)
    - [3.2.3. `ConstraintViolation` methods for method validation](#_code_constraintviolation_code_methods_for_method_validation)
  + [3.3. Built-in method constraints](#section-builtin-method-constraints)
* [4. Interpolating constraint error messages](#chapter-message-interpolation)
  + [4.1. Default message interpolation](#section-message-interpolation)
    - [4.1.1. Special characters](#section-special-characters)
    - [4.1.2. Interpolation with message expressions](#section-interpolation-with-message-expressions)
    - [4.1.3. Examples](#_examples)
  + [4.2. Custom message interpolation](#section-custom-message-interpolation)
    - [4.2.1. `ResourceBundleLocator`](#section-resource-bundle-locator)
* [5. Grouping constraints](#chapter-groups)
  + [5.1. Requesting groups](#_requesting_groups)
  + [5.2. Group inheritance](#section-group-inheritance)
  + [5.3. Defining group sequences](#section-defining-group-sequences)
  + [5.4. Redefining the default group sequence](#section-default-group-class)
    - [5.4.1. `@GroupSequence`](#_code_groupsequence_code)
    - [5.4.2. `@GroupSequenceProvider`](#_code_groupsequenceprovider_code)
  + [5.5. Group conversion](#section-group-conversion)
* [6. Creating custom constraints](#validator-customconstraints)
  + [6.1. Creating a simple constraint](#validator-customconstraints-simple)
    - [6.1.1. The constraint annotation](#validator-customconstraints-constraintannotation)
    - [6.1.2. The constraint validator](#section-constraint-validator)
      * [6.1.2.1. The `ConstraintValidatorContext`](#_the_code_constraintvalidatorcontext_code)
      * [6.1.2.2. The `HibernateConstraintValidator` extension](#constraint-validator-hibernateconstraintvalidator)
      * [6.1.2.3. Passing a payload to the constraint validator](#constraint-validator-payload)
    - [6.1.3. The error message](#validator-customconstraints-errormessage)
    - [6.1.4. Using the constraint](#validator-customconstraints-using)
  + [6.2. Class-level constraints](#section-class-level-constraints)
    - [6.2.1. Custom property paths](#section-custom-property-paths)
  + [6.3. Cross-parameter constraints](#section-cross-parameter-constraints)
  + [6.4. Constraint composition](#section-constraint-composition)
* [7. Value extraction](#chapter-valueextraction)
  + [7.1. Built-in value extractors](#section-valueextraction-builtinvalueextractors)
  + [7.2. Implementing a `ValueExtractor`](#_implementing_a_code_valueextractor_code)
  + [7.3. Non generic containers](#_non_generic_containers)
  + [7.4. JavaFX value extractors](#section-valueextraction-javafx)
  + [7.5. Registering a `ValueExtractor`](#section-valueextraction-registeringvalueextractor)
  + [7.6. Resolution algorithms](#_resolution_algorithms)
* [8. Configuring via XML](#chapter-xml-configuration)
  + [8.1. Configuring the validator factory in *validation.xml*](#section-configuration-validation-xml)
  + [8.2. Mapping constraints via `constraint-mappings`](#section-mapping-xml-constraints)
* [9. Bootstrapping](#chapter-bootstrapping)
  + [9.1. Retrieving `ValidatorFactory` and `Validator`](#section-retrieving-validator-factory-validator)
    - [9.1.1. `ValidationProviderResolver`](#section-validation-provider-resolver)
  + [9.2. Configuring a `ValidatorFactory`](#section-configuring-validator-factory)
    - [9.2.1. `MessageInterpolator`](#section-validator-factory-message-interpolator)
    - [9.2.2. `TraversableResolver`](#section-validator-factory-traversable-resolver)
    - [9.2.3. `ConstraintValidatorFactory`](#_code_constraintvalidatorfactory_code)
    - [9.2.4. `ParameterNameProvider`](#section-parameter-name-provider)
    - [9.2.5. `ClockProvider` and temporal validation tolerance](#section-clock-provider)
    - [9.2.6. Registering `ValueExtractor`s](#section-bootstrapping-valueextractors)
    - [9.2.7. Adding mapping streams](#_adding_mapping_streams)
    - [9.2.8. Provider-specific settings](#section-provider-specific-settings)
    - [9.2.9. Configuring the `ScriptEvaluatorFactory`](#section-script-evaluator-factory)
      * [9.2.9.1. XML configuration](#_xml_configuration)
      * [9.2.9.2. Programmatic configuration](#_programmatic_configuration)
      * [9.2.9.3. Custom `ScriptEvaluatorFactory` implementation examples](#_custom_code_scriptevaluatorfactory_code_implementation_examples)
  + [9.3. Configuring a Validator](#section-configuring-validator)
* [10. Using constraint metadata](#validator-metadata-api)
  + [10.1. `BeanDescriptor`](#_code_beandescriptor_code)
  + [10.2. `PropertyDescriptor`](#section-property-descriptor)
  + [10.3. `MethodDescriptor` and `ConstructorDescriptor`](#_code_methoddescriptor_code_and_code_constructordescriptor_code)
  + [10.4. `ElementDescriptor`](#validator-metadata-api-elementdescriptor)
  + [10.5. `ContainerDescriptor` and `ContainerElementTypeDescriptor`](#_code_containerdescriptor_code_and_code_containerelementtypedescriptor_code)
  + [10.6. `GroupConversionDescriptor`](#section-group-conversion-descriptor)
  + [10.7. `ConstraintDescriptor`](#section-constraint-descriptor)
* [11. Integrating with other frameworks](#validator-integration)
  + [11.1. ORM integration](#validator-checkconstraints-orm)
    - [11.1.1. Database schema-level validation](#validator-checkconstraints-db)
    - [11.1.2. Hibernate ORM event-based validation](#validator-checkconstraints-orm-hibernateevent)
    - [11.1.3. JPA](#_jpa)
  + [11.2. JSF & Seam](#section-presentation-layer)
  + [11.3. CDI](#section-integration-with-cdi)
    - [11.3.1. Dependency injection](#_dependency_injection)
    - [11.3.2. Method validation](#_method_validation)
      * [11.3.2.1. Validated executable types](#_validated_executable_types)
  + [11.4. Java EE](#_java_ee)
  + [11.5. JavaFX](#_javafx)
* [12. Hibernate Validator Specifics](#validator-specifics)
  + [12.1. Public API](#_public_api)
  + [12.2. Fail fast mode](#section-fail-fast)
  + [12.3. Relaxation of requirements for method validation in class hierarchies](#section-method-validation-prerequisite-relaxation)
  + [12.4. Programmatic constraint definition and declaration](#section-programmatic-api)
  + [12.5. Applying programmatic constraint declarations to the default validator factory](#section-programmatic-api-contributor)
  + [12.6. Advanced constraint composition features](#section-advanced-constraint-composition)
    - [12.6.1. Validation target specification for purely composed constraints](#_validation_target_specification_for_purely_composed_constraints)
    - [12.6.2. Boolean composition of constraints](#section-boolean-constraint-composition)
  + [12.7. Extensions of the Path API](#section-extensions-path-api)
  + [12.8. Dynamic payload as part of `ConstraintViolation`](#section-dynamic-payload)
  + [12.9. `ParameterMessageInterpolator`](#non-el-message-interpolator)
  + [12.10. `ResourceBundleLocator`](#_code_resourcebundlelocator_code)
  + [12.11. Customizing the locale resolution](#section-locale-resolver)
  + [12.12. Custom contexts](#_custom_contexts)
    - [12.12.1. `HibernateConstraintValidatorContext`](#section-hibernateconstraintvalidatorcontext)
    - [12.12.2. `HibernateMessageInterpolatorContext`](#_code_hibernatemessageinterpolatorcontext_code)
  + [12.13. Paranamer based `ParameterNameProvider`](#section-paranamer-parameternameprovider)
  + [12.14. Providing constraint definitions](#section-constraint-definition-contribution)
    - [12.14.1. Constraint definitions via `ServiceLoader`](#_constraint_definitions_via_code_serviceloader_code)
    - [12.14.2. Adding constraint definitions programmatically](#section-programmatic-constraint-definition)
  + [12.15. Customizing class-loading](#section-constraint-customizing-class-loading)
  + [12.16. Customizing the getter property selection strategy](#section-getter-property-selection-strategy)
  + [12.17. Customizing the property name resolution for constraint violations](#section-property-node-name-provider)
* [13. Annotation Processor](#validator-annotation-processor)
  + [13.1. Prerequisites](#validator-annotationprocessor-prerequisites)
  + [13.2. Features](#validator-annotationprocessor-features)
  + [13.3. Options](#validator-annotationprocessor-options)
  + [13.4. Using the Annotation Processor](#validator-annotationprocessor-usage)
    - [13.4.1. Command line builds](#validator-annotationprocessor-commandline)
      * [13.4.1.1. Maven](#validator-annotationprocessor-maven)
      * [13.4.1.2. Gradle](#validator-annotationprocessor-gradle)
      * [13.4.1.3. Apache Ant](#validator-annotationprocessor-ant)
      * [13.4.1.4. javac](#validator-annotationprocessor-javac)
    - [13.4.2. IDE builds](#validator-annotationprocessor-ide)
      * [13.4.2.1. Eclipse](#_eclipse)
      * [13.4.2.2. IntelliJ IDEA](#validator-annotationprocessor-idea)
      * [13.4.2.3. NetBeans](#validator-annotationprocessor-netbeans)
  + [13.5. Known issues](#validator-annotationprocessor-known-issues)
* [14. Further reading](#validator-further-reading)

## Preface

Validating data is a common task that occurs throughout all application layers, from the
presentation to the persistence layer. Often the same validation logic is implemented in each layer
which is time consuming and error-prone. To avoid duplication of these validations, developers often
bundle validation logic directly into the domain model, cluttering domain classes with validation
code which is really metadata about the class itself.

![application layers](images/application-layers.png)

Jakarta Bean Validation 2.0 - defines a metadata model and API for entity and method validation.
The default metadata source are annotations, with the ability to override and extend the meta-data
through the use of XML. The API is not tied to a specific application tier nor programming model. It
is specifically not tied to either web or persistence tier, and is available for both server-side
application programming, as well as rich client Swing application developers.

![application layers2](images/application-layers2.png)

Hibernate Validator is the reference implementation of Jakarta Bean Validation. The implementation itself as
well as the Jakarta Bean Validation API and TCK are all provided and distributed under the
[Apache Software License 2.0](http://www.apache.org/licenses/LICENSE-2.0).

Hibernate Validator 6 and Jakarta Bean Validation 2.0 require Java 8 or later.

## 1. Getting started

This chapter will show you how to get started with Hibernate Validator, the reference implementation (RI) of Jakarta Bean Validation. For the following quick-start you need:

* A JDK 8
* [Apache Maven](http://maven.apache.org/)
* An Internet connection (Maven has to download all required libraries)

### 1.1. Project set up

In order to use Hibernate Validator within a Maven project, simply add the following dependency to
your *pom.xml*:

Example 1.1: Hibernate Validator Maven dependency
```
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.1.7.Final</version>
</dependency>
```

This transitively pulls in the dependency to the Jakarta Bean Validation API
(`jakarta.validation:jakarta.validation-api:2.0.2`).

#### 1.1.1. Unified EL

Hibernate Validator requires an implementation of [Jakarta Expression Language](https://projects.eclipse.org/projects/ee4j.el)
for evaluating dynamic expressions in constraint
violation messages (see [Section 4.1, “Default message interpolation”](#section-message-interpolation)). When your application runs in a Java EE
container such as JBoss AS, an EL implementation is already provided by the container. In a Java SE
environment, however, you have to add an implementation as dependency to your POM file. For instance
you can add the following dependency to use the Jakarta EL [reference
implementation](https://github.com/eclipse-ee4j/el-ri):

Example 1.2: Maven dependencies for Unified EL reference implementation
```
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>jakarta.el</artifactId>
    <version>3.0.3</version>
</dependency>
```

|  | For environments where one cannot provide a EL implementation Hibernate Validator is offering a [Section 12.9, “`ParameterMessageInterpolator`”](#non-el-message-interpolator). However, the use of this interpolator is not Jakarta Bean Validation specification compliant. |
| --- | --- |

#### 1.1.2. CDI

Jakarta Bean Validation defines integration points with CDI
([Contexts and Dependency Injection for Jakarta EE](https://projects.eclipse.org/projects/ee4j.cdi)).
If your application runs in an
environment which does not provide this integration out of the box, you may use the Hibernate
Validator CDI portable extension by adding the following Maven dependency to your POM:

Example 1.3: Hibernate Validator CDI portable extension Maven dependency
```
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator-cdi</artifactId>
    <version>6.1.7.Final</version>
</dependency>
```

Note that adding this dependency is usually not required for applications running on a Java EE
application server. You can learn more about the integration of Jakarta Bean Validation and CDI in
[Section 11.3, “CDI”](#section-integration-with-cdi).

#### 1.1.3. Running with a security manager

Hibernate Validator supports running with a [security manager](http://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html) being enabled.
To do so, you must assign several permissions to the code bases of Hibernate Validator, the Jakarta Bean Validation API, Classmate and JBoss Logging and also to the code base calling Jakarta Bean Validation.
The following shows how to do this via a [policy file](http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html) as processed by the Java default policy implementation:

Example 1.4: Policy file for using Hibernate Validator with a security manager
```
grant codeBase "file:path/to/hibernate-validator-6.1.7.Final.jar" {
    permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
    permission java.lang.RuntimePermission "accessDeclaredMembers";
    permission java.lang.RuntimePermission "setContextClassLoader";

    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";

    // Only needed when working with XML descriptors (validation.xml or XML constraint mappings)
    permission java.util.PropertyPermission "mapAnyUriToUri", "read";
};

grant codeBase "file:path/to/jakarta.validation-api-2.0.2.jar" {
    permission java.io.FilePermission "path/to/hibernate-validator-6.1.7.Final.jar", "read";
};

grant codeBase "file:path/to/jboss-logging-3.3.2.Final.jar" {
    permission java.util.PropertyPermission "org.jboss.logging.provider", "read";
    permission java.util.PropertyPermission "org.jboss.logging.locale", "read";
};

grant codeBase "file:path/to/classmate-1.3.4.jar" {
    permission java.lang.RuntimePermission "accessDeclaredMembers";
};

grant codeBase "file:path/to/validation-caller-x.y.z.jar" {
    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";
};
```

#### 1.1.4. Updating Hibernate Validator in WildFly

The [WildFly application server](http://wildfly.org/) contains Hibernate Validator out of the box.
In order to update the server modules for Jakarta Bean Validation API and Hibernate Validator to the latest and greatest, the patch mechanism of WildFly can be used.

You can download the patch file from [SourceForge](http://sourceforge.net/projects/hibernate/files/hibernate-validator) or from Maven Central using the following dependency:

Example 1.5: Maven dependency for WildFly 19.0.0.Final patch file
```
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator-modules</artifactId>
    <version>6.1.7.Final</version>
    <classifier>wildfly-19.0.0.Final-patch</classifier>
    <type>zip</type>
</dependency>
```

We also provide a patch for WildFly 18.0.1.Final:

Example 1.6: Maven dependency for WildFly 18.0.1.Final patch file
```
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator-modules</artifactId>
    <version>6.1.7.Final</version>
    <classifier>wildfly-18.0.1.Final-patch</classifier>
    <type>zip</type>
</dependency>
```

Having downloaded the patch file, you can apply it to WildFly by running this command:

Example 1.7: Applying the WildFly patch
```
$JBOSS_HOME/bin/jboss-cli.sh patch apply hibernate-validator-modules-6.1.7.Final-wildfly-19.0.0.Final-patch.zip
```

In case you want to undo the patch and go back to the version of Hibernate Validator originally coming with the server, run the following command:

Example 1.8: Rolling back the WildFly patch
```
$JBOSS_HOME/bin/jboss-cli.sh patch rollback --reset-configuration=true
```

You can learn more about the WildFly patching infrastructure in general [here](https://developer.jboss.org/wiki/SingleInstallationPatching/) and [here](http://www.mastertheboss.com/jboss-server/jboss-configuration/managing-wildfly-and-eap-patches).

#### 1.1.5. Running on Java 9

As of Hibernate Validator 6.1.7.Final, support for Java 9 and the Java Platform Module System (JPMS) is experimental.
There are no JPMS module descriptors provided yet, but Hibernate Validator is usable as automatic modules.

These are the module names as declared using the `Automatic-Module-Name` header:

* Jakarta Bean Validation API: `java.validation`
* Hibernate Validator core: `org.hibernate.validator`
* Hibernate Validator CDI extension: `org.hibernate.validator.cdi`
* Hibernate Validator test utilities: `org.hibernate.validator.testutils`
* Hibernate Validator annotation processor: `org.hibernate.validator.annotationprocessor`

These module names are preliminary and may be changed when providing real module descriptors in a future release.

|  | When using Hibernate Validator with CDI, be careful to not enable the `java.xml.ws.annotation` module of the JDK. This module contains a subset of Jakarta Annotations, but some annotations such as `javax.annotation.Priority` are missing. This causes the method validation interceptor of Hibernate Validator to not be registered, i.e. method validation won’t work.   Instead, add the full Jakarta Annotations API to the unnamed module (i.e. the classpath), e.g. by pulling in the *jakarta.annotation:jakarta.annotation-api* dependency (there already is a transitive dependency to the Jakarta Annotations API when depending on *org.hibernate.validator:hibernate-validator-cdi*).   If you need to enable the `java.xml.ws.annotation` module for some reason, you should patch it with the contents of the full API by appending `--patch-module java.xml.ws.annotation=/path/to/complete-jakarta.annotation-api.jar` to your *java* invocation. |
| --- | --- |

### 1.2. Applying constraints

Let’s dive directly into an example to see how to apply constraints.

Example 1.9: Class Car annotated with constraints
```
package org.hibernate.validator.referenceguide.chapter01;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}
```

The `@NotNull`, `@Size` and `@Min` annotations are used to declare the constraints which should be applied
to the fields of a Car instance:

* `manufacturer` must never be `null`
* `licensePlate` must never be `null` and must be between 2 and 14 characters long
* `seatCount` must be at least 2

|  | You can find the complete source code of all examples used in this reference guide in the Hibernate Validator [source repository](https://github.com/hibernate/hibernate-validator/tree/master/documentation/src/test) on GitHub. |
| --- | --- |

### 1.3. Validating constraints

To perform a validation of these constraints, you use a `Validator` instance. Let’s have a look at a
unit test for `Car`:

Example 1.10: Class CarTest showing validation examples
```
package org.hibernate.validator.referenceguide.chapter01;

import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CarTest {

    private static Validator validator;

    @BeforeClass
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void manufacturerIsNull() {
        Car car = new Car( null, "DD-AB-123", 4 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
    }

    @Test
    public void licensePlateTooShort() {
        Car car = new Car( "Morris", "D", 4 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "size must be between 2 and 14",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void seatCountTooLow() {
        Car car = new Car( "Morris", "DD-AB-123", 1 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "must be greater than or equal to 2",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void carIsValid() {
        Car car = new Car( "Morris", "DD-AB-123", 2 );

        Set<ConstraintViolation<Car>> constraintViolations =
                validator.validate( car );

        assertEquals( 0, constraintViolations.size() );
    }
}
```

In the `setUp()` method a `Validator` object is retrieved from the `ValidatorFactory`. A `Validator`
instance is thread-safe and may be reused multiple times. It thus can safely be stored in a static
field and be used in the test methods to validate the different `Car` instances.

The `validate()` method returns a set of `ConstraintViolation` instances, which you can iterate over in
order to see which validation errors occurred. The first three test methods show some expected
constraint violations:

* The `@NotNull` constraint on `manufacturer` is violated in `manufacturerIsNull()`
* The `@Size` constraint on `licensePlate` is violated in `licensePlateTooShort()`
* The `@Min` constraint on `seatCount` is violated in `seatCountTooLow()`

If the object validates successfully, `validate()` returns an empty set as you can see in `carIsValid()`.

Note that only classes from the package `javax.validation` are used. These are provided from the Bean
Validation API. No classes from Hibernate Validator are directly referenced, resulting in portable
code.

### 1.4. Where to go next?

That concludes the 5 minutes tour through the world of Hibernate Validator and Jakarta Bean Validation.
Continue exploring the code examples or look at further examples referenced in
[Chapter 14, *Further reading*](#validator-further-reading).

To learn more about the validation of beans and properties, just continue reading
[Chapter 2, *Declaring and validating bean constraints*](#chapter-bean-constraints). If you are interested in using Jakarta Bean Validation for the validation of
method pre- and postcondition refer to [Chapter 3, *Declaring and validating method constraints*](#chapter-method-constraints). In case your application has
specific validation requirements have a look at [Chapter 6, *Creating custom constraints*](#validator-customconstraints).

## 2. Declaring and validating bean constraints

In this chapter you will learn how to declare (see [Section 2.1, “Declaring bean constraints”](#section-declaring-bean-constraints)) and
validate (see [Section 2.2, “Validating bean constraints”](#section-validating-bean-constraints)) bean constraints.
[Section 2.3, “Built-in constraints”](#section-builtin-constraints) provides an overview of all built-in constraints coming with
Hibernate Validator.

If you are interested in applying constraints to method parameters and return values, refer to
[Chapter 3, *Declaring and validating method constraints*](#chapter-method-constraints).

### 2.1. Declaring bean constraints

Constraints in Jakarta Bean Validation are expressed via Java annotations. In this section you will learn
how to enhance an object model with these annotations. There are four types of bean constraints:

* field constraints
* property constraints
* container element constraints
* class constraints

|  | Not all constraints can be placed on all of these levels. In fact, none of the default constraints defined by Jakarta Bean Validation can be placed at class level. The `java.lang.annotation.Target` annotation in the constraint annotation itself determines on which elements a constraint can be placed. See [Chapter 6, *Creating custom constraints*](#validator-customconstraints) for more information. |
| --- | --- |

#### 2.1.1. Field-level constraints

Constraints can be expressed by annotating a field of a class. [Example 2.1, “Field-level constraints”](#example-field-level) shows a field
level configuration example:

Example 2.1: Field-level constraints
```
package org.hibernate.validator.referenceguide.chapter02.fieldlevel;

public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    //getters and setters...
}
```

When using field-level constraints field access strategy is used to access the value to be
validated. This means the validation engine directly accesses the instance variable and does not
invoke the property accessor method even if such an accessor exists.

Constraints can be applied to fields of any access type (public, private etc.). Constraints on
static fields are not supported, though.

|  | When validating byte code enhanced objects, property level constraints should be used, because the byte code enhancing library won’t be able to determine a field access via reflection. |
| --- | --- |

#### 2.1.2. Property-level constraints

If your model class adheres to the
[JavaBeans](http://www.oracle.com/technetwork/articles/javaee/spec-136004.html) standard, it
is also possible to annotate the properties of a bean class instead of its fields.
[Example 2.2, “Property-level constraints”](#example-property-level) uses the same entity as in [Example 2.1, “Field-level constraints”](#example-field-level), however, property level
constraints are used.

Example 2.2: Property-level constraints
```
package org.hibernate.validator.referenceguide.chapter02.propertylevel;

public class Car {

    private String manufacturer;

    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    @AssertTrue
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}
```

|  | The property’s getter method has to be annotated, not its setter. That way also read-only properties can be constrained which have no setter method. |
| --- | --- |

When using property level constraints property access strategy is used to access the value to be
validated, i.e. the validation engine accesses the state via the property accessor method.

|  | It is recommended to stick either to field *or* property annotations within one class. It is not recommended to annotate a field *and* the accompanying getter method as this would cause the field to be validated twice. |
| --- | --- |

#### 2.1.3. Container element constraints

It is possible to specify constraints directly on the type argument of a
parameterized type: these constraints are called container element constraints.

This requires that `ElementType.TYPE_USE` is specified via `@Target`
in the constraint definition. As of Jakarta Bean Validation 2.0, built-in Jakarta Bean Validation as well as
Hibernate Validator specific constraints specify `ElementType.TYPE_USE` and can be used
directly in this context.

Hibernate Validator validates container element constraints specified on the following standard
Java containers:

* implementations of `java.util.Iterable` (e.g. `List`s, `Set`s),
* implementations of `java.util.Map`, with support for keys and values,
* `java.util.Optional`, `java.util.OptionalInt`, `java.util.OptionalDouble`, `java.util.OptionalLong`,
* the various implementations of JavaFX’s `javafx.beans.observable.ObservableValue`.

It also supports container element constraints on custom container types (see [Chapter 7, *Value extraction*](#chapter-valueextraction)).

|  | In versions prior to 6, a subset of container element constraints were supported. A `@Valid` annotation was required at the container level to enable them. This is not required anymore as of Hibernate Validator 6. |
| --- | --- |

We present below a couple of examples illustrating container element constraints on various Java types.

In these examples, `@ValidPart` is a custom constraint allowed to be used in the `TYPE_USE` context.

##### 2.1.3.1. With `Iterable`

When applying constraints on an `Iterable` type argument, Hibernate Validator will validate each
element. [Example 2.3, “Container element constraint on `Set`”](#example-container-element-constraints-iterable) shows an example of a
`Set` with a container element constraint.

Example 2.3: Container element constraint on `Set`
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.set;

import java.util.HashSet;
import java.util.Set;

public class Car {

    private Set<@ValidPart String> parts = new HashSet<>();

    public void addPart(String part) {
        parts.add( part );
    }

    //...

}
```

```
Car car = new Car();
car.addPart( "Wheel" );
car.addPart( null );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation =
        constraintViolations.iterator().next();
assertEquals(
        "'null' is not a valid car part.",
        constraintViolation.getMessage()
);
assertEquals( "parts[].<iterable element>",
        constraintViolation.getPropertyPath().toString() );
```

Note how the property path clearly states that the violation comes from an element of the iterable.

##### 2.1.3.2. With `List`

When applying constraints on a `List` type argument, Hibernate Validator will validate each
element. [Example 2.4, “Container element constraint on `List`”](#example-container-element-constraints-list) shows an example of a
`List` with a container element constraint.

Example 2.4: Container element constraint on `List`
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.list;

public class Car {

    private List<@ValidPart String> parts = new ArrayList<>();

    public void addPart(String part) {
        parts.add( part );
    }

    //...

}
```

```
Car car = new Car();
car.addPart( "Wheel" );
car.addPart( null );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation =
        constraintViolations.iterator().next();
assertEquals(
        "'null' is not a valid car part.",
        constraintViolation.getMessage()
);
assertEquals( "parts[1].<list element>",
        constraintViolation.getPropertyPath().toString() );
```

Here, the property path also contains the index of the invalid element.

##### 2.1.3.3. With `Map`

Container element constraints are also validated on map keys and values.
[Example 2.5, “Container element constraint on map keys and values”](#example-container-element-constraints-map) shows an example of a `Map` with a constraint on the key
and a constraint on the value.

Example 2.5: Container element constraint on map keys and values
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.map;

import java.util.HashMap;
import java.util.Map;

import javax.validation.constraints.NotNull;

public class Car {

    public enum FuelConsumption {
        CITY,
        HIGHWAY
    }

    private Map<@NotNull FuelConsumption, @MaxAllowedFuelConsumption Integer> fuelConsumption = new HashMap<>();

    public void setFuelConsumption(FuelConsumption consumption, int value) {
        fuelConsumption.put( consumption, value );
    }

    //...

}
```

```
Car car = new Car();
car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation =
        constraintViolations.iterator().next();
assertEquals(
        "20 is outside the max fuel consumption.",
        constraintViolation.getMessage()
);
assertEquals(
        "fuelConsumption[HIGHWAY].<map value>",
        constraintViolation.getPropertyPath().toString()
);
```

```
Car car = new Car();
car.setFuelConsumption( null, 5 );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation =
        constraintViolations.iterator().next();
assertEquals(
        "must not be null",
        constraintViolation.getMessage()
);
assertEquals(
        "fuelConsumption<K>[].<map key>",
        constraintViolation.getPropertyPath().toString()
);
```

The property paths of the violations are particularly interesting:

* The key of the invalid element is included in the property path (in the second example, the key is `null`).
* In the first example, the violation concerns the `<map value>`, in the second one, the `<map key>`.
* In the second example, you might have noticed the presence of the type argument `<K>`, more on this later.

##### 2.1.3.4. With `java.util.Optional`

When applying a constraint on the type argument of `Optional`, Hibernate Validator will automatically
unwrap the type and validate the internal value. [Example 2.6, “Container element constraint on Optional”](#example-container-element-constraints-optional) shows
an example of an `Optional` with a container element constraint.

Example 2.6: Container element constraint on Optional
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.optional;

public class Car {

    private Optional<@MinTowingCapacity(1000) Integer> towingCapacity = Optional.empty();

    public void setTowingCapacity(Integer alias) {
        towingCapacity = Optional.of( alias );
    }

    //...

}
```

```
Car car = new Car();
car.setTowingCapacity( 100 );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation = constraintViolations.iterator().next();
assertEquals(
        "Not enough towing capacity.",
        constraintViolation.getMessage()
);
assertEquals(
        "towingCapacity",
        constraintViolation.getPropertyPath().toString()
);
```

Here, the property path only contains the name of the property as we are considering `Optional` as a "transparent"
container.

##### 2.1.3.5. With custom container types

Container element constraints can also be used with custom containers.

A `ValueExtractor` must be registered for the custom type allowing to retrieve
the value(s) to validate (see [Chapter 7, *Value extraction*](#chapter-valueextraction) for more information about how to implement
your own `ValueExtractor` and how to register it).

[Example 2.7, “Container element constraint on custom container type”](#example-container-element-constraints-custom-container-type) shows an example of a custom
parameterized type with a type argument constraint.

Example 2.7: Container element constraint on custom container type
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class Car {

    private GearBox<@MinTorque(100) Gear> gearBox;

    public void setGearBox(GearBox<Gear> gearBox) {
        this.gearBox = gearBox;
    }

    //...

}
```

```
package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class GearBox<T extends Gear> {

    private final T gear;

    public GearBox(T gear) {
        this.gear = gear;
    }

    public Gear getGear() {
        return this.gear;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class Gear {
    private final Integer torque;

    public Gear(Integer torque) {
        this.torque = torque;
    }

    public Integer getTorque() {
        return torque;
    }

    public static class AcmeGear extends Gear {
        public AcmeGear() {
            super( 60 );
        }
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter02.containerelement.custom;

public class GearBoxValueExtractor implements ValueExtractor<GearBox<@ExtractedValue ?>> {

    @Override
    public void extractValues(GearBox<@ExtractedValue ?> originalValue, ValueExtractor.ValueReceiver receiver) {
        receiver.value( null, originalValue.getGear() );
    }
}
```

```
Car car = new Car();
car.setGearBox( new GearBox<>( new Gear.AcmeGear() ) );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation =
        constraintViolations.iterator().next();
assertEquals(
        "Gear is not providing enough torque.",
        constraintViolation.getMessage()
);
assertEquals(
        "gearBox",
        constraintViolation.getPropertyPath().toString()
);
```

##### 2.1.3.6. Nested container elements

Constraints are also supported on nested container elements.

When validating a `Car` object as presented in [Example 2.8, “Constraints on nested container elements”](#example-container-element-nested), both the `@NotNull`
constraints on `Part` and `Manufacturer` will be enforced.

Example 2.8: Constraints on nested container elements
```
package org.hibernate.validator.referenceguide.chapter02.containerelement.nested;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.validation.constraints.NotNull;

public class Car {

    private Map<@NotNull Part, List<@NotNull Manufacturer>> partManufacturers =
            new HashMap<>();

    //...
}
```

#### 2.1.4. Class-level constraints

Last but not least, a constraint can also be placed on the class level. In this case not a single
property is subject of the validation but the complete object. Class-level constraints are useful if
the validation depends on a correlation between several properties of an object.

The `Car` class in [Example 2.9, “Class-level constraint”](#example-class-level) has the two attributes `seatCount` and `passengers` and it
should be ensured that the list of passengers does not have more entries than available seats. For
that purpose the `@ValidPassengerCount` constraint is added on the class level. The validator of that
constraint has access to the complete `Car` object, allowing to compare the numbers of seats and
passengers.

Refer to [Section 6.2, “Class-level constraints”](#section-class-level-constraints) to learn in detail how to implement this custom
constraint.

Example 2.9: Class-level constraint
```
package org.hibernate.validator.referenceguide.chapter02.classlevel;

@ValidPassengerCount
public class Car {

    private int seatCount;

    private List<Person> passengers;

    //...
}
```

#### 2.1.5. Constraint inheritance

When a class implements an interface or extends another class, all constraint annotations declared
on the super-type apply in the same manner as the constraints specified on the class itself. To make
things clearer let’s have a look at the following example:

Example 2.10: Constraint inheritance
```
package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class Car {

    private String manufacturer;

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    //...
}
```

```
package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class RentalCar extends Car {

    private String rentalStation;

    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    //...
}
```

Here the class `RentalCar` is a subclass of `Car` and adds the property `rentalStation`. If an instance of
`RentalCar` is validated, not only the `@NotNull` constraint on `rentalStation` is evaluated, but also the
constraint on `manufacturer` from the parent class.

The same would be true, if `Car` was not a superclass but an interface implemented by `RentalCar`.

Constraint annotations are aggregated if methods are overridden. So if `RentalCar` overrode the
`getManufacturer()` method from `Car`, any constraints annotated at the overriding method would be
evaluated in addition to the `@NotNull` constraint from the superclass.

#### 2.1.6. Object graphs

The Jakarta Bean Validation API does not only allow to validate single class instances but also complete
object graphs (cascaded validation). To do so, just annotate a field or property representing a
reference to another object with `@Valid` as demonstrated in [Example 2.11, “Cascaded validation”](#example-cascaded-validation).

Example 2.11: Cascaded validation
```
package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Car {

    @NotNull
    @Valid
    private Person driver;

    //...
}
```

```
package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Person {

    @NotNull
    private String name;

    //...
}
```

If an instance of `Car` is validated, the referenced `Person` object will be validated as well, as the
`driver` field is annotated with `@Valid`. Therefore the validation of a `Car` will fail if the `name` field
of the referenced `Person` instance is `null`.

The validation of object graphs is recursive, i.e. if a reference marked for cascaded validation
points to an object which itself has properties annotated with `@Valid`, these references will be
followed up by the validation engine as well. The validation engine will ensure that no infinite
loops occur during cascaded validation, for example if two objects hold references to each other.

Note that `null` values are getting ignored during cascaded validation.

As constraints, object graph validation also works for container elements. That means any type argument
of a container can be annotated with `@Valid`, which will cause each contained element to be validated when the
parent object is validated.

|  | Cascaded validation is also supported for nested container elements. |
| --- | --- |

Example 2.12: Cascaded validation of containers
```
package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Car {

    private List<@NotNull @Valid Person> passengers = new ArrayList<Person>();

    private Map<@Valid Part, List<@Valid Manufacturer>> partManufacturers = new HashMap<>();

    //...
}
```

```
package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Part {

    @NotNull
    private String name;

    //...
}
```

```
package org.hibernate.validator.referenceguide.chapter02.objectgraph.containerelement;

public class Manufacturer {

    @NotNull
    private String name;

    //...
}
```

When validating an instance of the `Car` class shown in [Example 2.12, “Cascaded validation of containers”](#example-cascaded-validation-list), a
`ConstraintViolation` will be created:

* if any of the `Person` objects contained in the passengers list has a `null` name;
* if any of the `Part` objects contained in the map keys has a `null` name;
* if any of the `Manufacturer` objects contained in the list nested in the map values
  has a `null` name.

|  | In versions prior to 6, Hibernate Validator supported cascaded validation for a subset of container elements and it was implemented at the container level (e.g. you would use `@Valid private List<Person>` to enable cascaded validation for `Person`).   This is still supported but is not recommended. Please use container element level `@Valid` annotations instead as it is more expressive. |
| --- | --- |

### 2.2. Validating bean constraints

The `Validator` interface is the most important object in Jakarta Bean Validation. The next section shows how
to obtain a `Validator` instance. Afterwards you’ll learn how to use the different methods of the
`Validator` interface.

#### 2.2.1. Obtaining a `Validator` instance

The first step towards validating an entity instance is to get hold of a `Validator` instance. The
road to this instance leads via the `Validation` class and a `ValidatorFactory`. The easiest way is to
use the static method `Validation#buildDefaultValidatorFactory()`:

Example 2.13: `Validation#buildDefaultValidatorFactory()`
```
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
validator = factory.getValidator();
```

This bootstraps a validator in the default configuration. Refer to [Chapter 9, *Bootstrapping*](#chapter-bootstrapping) to
learn more about the different bootstrapping methods and how to obtain a specifically configured
`Validator` instance.

#### 2.2.2. Validator methods

The `Validator` interface contains three methods that can be used to either validate entire entities
or just single properties of the entity.

All three methods return a `Set<ConstraintViolation>`. The set is empty, if the validation succeeds.
Otherwise a `ConstraintViolation` instance is added for each violated constraint.

All the validation methods have a var-args parameter which can be used to specify which validation
groups shall be considered when performing the validation. If the parameter is not specified, the
default validation group (`javax.validation.groups.Default`) is used. The topic of validation groups
is discussed in detail in [Chapter 5, *Grouping constraints*](#chapter-groups).

##### 2.2.2.1. `Validator#validate()`

Use the `validate()` method to perform validation of all constraints of a given bean.
[Example 2.14, “Using `Validator#validate()`”](#example-validator-validate) shows the validation of an instance of the `Car` class from
[Example 2.2, “Property-level constraints”](#example-property-level) which fails to satisfy the `@NotNull` constraint on the `manufacturer`
property. The validation call therefore returns one `ConstraintViolation` object.

Example 2.14: Using `Validator#validate()`
```
Car car = new Car( null, true );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
```

##### 2.2.2.2. `Validator#validateProperty()`

With help of the `validateProperty()` you can validate a single named property of a given object. The
property name is the JavaBeans property name.

Example 2.15: Using `Validator#validateProperty()`
```
Car car = new Car( null, true );

Set<ConstraintViolation<Car>> constraintViolations = validator.validateProperty(
        car,
        "manufacturer"
);

assertEquals( 1, constraintViolations.size() );
assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
```

##### 2.2.2.3. `Validator#validateValue()`

By using the `validateValue()` method you can check whether a single property of a given class can be
validated successfully, if the property had the specified value:

Example 2.16: Using `Validator#validateValue()`
```
Set<ConstraintViolation<Car>> constraintViolations = validator.validateValue(
        Car.class,
        "manufacturer",
        null
);

assertEquals( 1, constraintViolations.size() );
assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
```

|  | `@Valid` is not honored by `validateProperty()` or `validateValue()`. |
| --- | --- |

`Validator#validateProperty()` is for example used in the integration of Jakarta Bean Validation into JSF 2
(see [Section 11.2, “JSF & Seam”](#section-presentation-layer)) to perform a validation of the values entered into a form
before they are propagated to the model.

#### 2.2.3. `ConstraintViolation`

##### 2.2.3.1. `ConstraintViolation` methods

Now it is time to have a closer look at what a `ConstraintViolation` is.
Using the different methods of `ConstraintViolation` a lot of useful information about the cause of the validation failure can be determined.
The following gives an overview of these methods.
The values under "Example" column refer to [Example 2.14, “Using `Validator#validate()`”](#example-validator-validate).

`getMessage()`

The interpolated error message

Example

"must not be null"

`getMessageTemplate()`

The non-interpolated error message

Example

"{…​ NotNull.message}"

`getRootBean()`

The root bean being validated

Example

car

`getRootBeanClass()`

The class of the root bean being validated

Example

`Car.class`

`getLeafBean()`

If a bean constraint, the bean instance the constraint is
applied on; if a property constraint, the bean instance hosting
the property the constraint is applied on

Example

`car`

`getPropertyPath()`

The property path to the validated value from root bean

Example

contains one node with kind `PROPERTY` and name "manufacturer"

`getInvalidValue()`

The value failing to pass the constraint

Example

`null`

`getConstraintDescriptor()`

Constraint metadata reported to fail

Example

descriptor for `@NotNull`

##### 2.2.3.2. Exploiting the property path

To determine the element that triggered the violation, you need to exploit the result of the `getPropertyPath()`
method.

The returned `Path` is composed of `Node`s describing the path to the element.

More information about the structure of the `Path` and the various types of `Node`s can be found in
[the `ConstraintViolation` section](http://beanvalidation.org/2.0/spec/#validationapi-constraintviolation) of the
Jakarta Bean Validation specification.

### 2.3. Built-in constraints

Hibernate Validator comprises a basic set of commonly used constraints. These are foremost the
constraints defined by the Jakarta Bean Validation specification (see [Section 2.3.1, “Jakarta Bean Validation constraints”](#validator-defineconstraints-spec)).
Additionally, Hibernate Validator provides useful custom constraints (see
[Section 2.3.2, “Additional constraints”](#validator-defineconstraints-hv-constraints)).

#### 2.3.1. Jakarta Bean Validation constraints

Below you can find a list of all constraints specified in the Jakarta Bean Validation API.
All these constraints apply to the field/property level, there are no class-level constraints defined in the Jakarta Bean Validation specification.
If you are using the Hibernate object-relational mapper, some of the constraints are taken into account when creating the DDL for your model (see "Hibernate metadata impact").

|  | Hibernate Validator allows some constraints to be applied to more data types than required by the Jakarta Bean Validation specification (e.g. `@Max` can be applied to strings). Relying on this feature can impact portability of your application between Jakarta Bean Validation providers. |
| --- | --- |

`@AssertFalse`

Checks that the annotated element is false

Supported data types

`Boolean`, `boolean`

Hibernate metadata impact

None

`@AssertTrue`

Checks that the annotated element is true

Supported data types

`Boolean`, `boolean`

Hibernate metadata impact

None

`@DecimalMax(value=, inclusive=)`

Checks whether the annotated value is less than the specified maximum, when `inclusive`=false. Otherwise whether the value is less than or equal to the specified maximum. The parameter value is the string representation of the max value according to the `BigDecimal` string representation.

Supported data types

`BigDecimal`, `BigInteger`, `CharSequence`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `Number` and `javax.money.MonetaryAmount` (if the [JSR 354 API](https://jcp.org/en/jsr/detail?id=354) and an implementation is on the class path)

Hibernate metadata impact

None

`@DecimalMin(value=, inclusive=)`

Checks whether the annotated value is larger than the specified minimum, when `inclusive`=false. Otherwise whether the value is larger than or equal to the specified minimum. The parameter value is the string representation of the min value according to the `BigDecimal` string representation.

Supported data types

`BigDecimal`, `BigInteger`, `CharSequence`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

None

`@Digits(integer=, fraction=)`

Checks whether the annotated value is a number having up to `integer` digits and `fraction` fractional digits

Supported data types

BigDecimal, `BigInteger`, `CharSequence`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

Defines column precision and scale

`@Email`

Checks whether the specified character sequence is a valid email address. The optional parameters `regexp` and `flags` allow to specify an additional regular expression (including regular expression flags) which the email must match.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Future`

Checks whether the annotated date is in the future

Supported data types

`java.util.Date`, `java.util.Calendar`, `java.time.Instant`, `java.time.LocalDate`, `java.time.LocalDateTime`, `java.time.LocalTime`, `java.time.MonthDay`, `java.time.OffsetDateTime`, `java.time.OffsetTime`, `java.time.Year`, `java.time.YearMonth`, `java.time.ZonedDateTime`, `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`, `java.time.chrono.MinguoDate`, `java.time.chrono.ThaiBuddhistDate`; additionally supported by HV, if the [Joda Time](http://www.joda.org/joda-time/) date/time API is on the classpath: any implementations of `ReadablePartial` and `ReadableInstant`

Hibernate metadata impact

None

`@FutureOrPresent`

Checks whether the annotated date is in the present or in the future

Supported data types

`java.util.Date`, `java.util.Calendar`, `java.time.Instant`, `java.time.LocalDate`, `java.time.LocalDateTime`, `java.time.LocalTime`, `java.time.MonthDay`, `java.time.OffsetDateTime`, `java.time.OffsetTime`, `java.time.Year`, `java.time.YearMonth`, `java.time.ZonedDateTime`, `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`, `java.time.chrono.MinguoDate`, `java.time.chrono.ThaiBuddhistDate`; additionally supported by HV, if the [Joda Time](http://www.joda.org/joda-time/) date/time API is on the classpath: any implementations of `ReadablePartial` and `ReadableInstant`

Hibernate metadata impact

None

`@Max(value=)`

Checks whether the annotated value is less than or equal to the specified maximum

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

Adds a check constraint on the column

`@Min(value=)`

Checks whether the annotated value is higher than or equal to the specified minimum

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

Adds a check constraint on the column

`@NotBlank`

Checks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to `@NotEmpty` is that this constraint can only be applied on character sequences and that trailing white-spaces are ignored.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@NotEmpty`

Checks whether the annotated element is not null nor empty

Supported data types

`CharSequence`, `Collection`, `Map` and arrays

Hibernate metadata impact

None

`@NotNull`

Checks that the annotated value is not `null`

Supported data types

Any type

Hibernate metadata impact

Column(s) are not nullable

`@Negative`

Checks if the element is strictly negative. Zero values are considered invalid.

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

None

`@NegativeOrZero`

Checks if the element is negative or zero.

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

None

`@Null`

Checks that the annotated value is `null`

Supported data types

Any type

Hibernate metadata impact

None

`@Past`

Checks whether the annotated date is in the past

Supported data types

`java.util.Date`,`java.util.Calendar`, `java.time.Instant`, `java.time.LocalDate`, `java.time.LocalDateTime`, `java.time.LocalTime`, `java.time.MonthDay`, `java.time.OffsetDateTime`, `java.time.OffsetTime`, `java.time.Year`, `java.time.YearMonth`, `java.time.ZonedDateTime`, `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`, `java.time.chrono.MinguoDate`, `java.time.chrono.ThaiBuddhistDate`; Additionally supported by HV, if the [Joda Time](http://www.joda.org/joda-time/) date/time API is on the classpath: any implementations of `ReadablePartial` and `ReadableInstant`

Hibernate metadata impact

None

`@PastOrPresent`

Checks whether the annotated date is in the past or in the present

Supported data types

`java.util.Date`,`java.util.Calendar`, `java.time.Instant`, `java.time.LocalDate`, `java.time.LocalDateTime`, `java.time.LocalTime`, `java.time.MonthDay`, `java.time.OffsetDateTime`, `java.time.OffsetTime`, `java.time.Year`, `java.time.YearMonth`, `java.time.ZonedDateTime`, `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`, `java.time.chrono.MinguoDate`, `java.time.chrono.ThaiBuddhistDate`; Additionally supported by HV, if the [Joda Time](http://www.joda.org/joda-time/) date/time API is on the classpath: any implementations of `ReadablePartial` and `ReadableInstant`

Hibernate metadata impact

None

`@Pattern(regex=, flags=)`

Checks if the annotated string matches the regular expression `regex` considering the given flag `match`

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Positive`

Checks if the element is strictly positive. Zero values are considered invalid.

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

None

`@PositiveOrZero`

Checks if the element is positive or zero.

Supported data types

`BigDecimal`, `BigInteger`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of `CharSequence` (the numeric value represented by the character sequence is evaluated), any sub-type of `Number` and `javax.money.MonetaryAmount`

Hibernate metadata impact

None

`@Size(min=, max=)`

Checks if the annotated element’s size is between `min` and `max` (inclusive)

Supported data types

`CharSequence`, `Collection`, `Map` and arrays

Hibernate metadata impact

Column length will be set to `max`

|  | On top of the parameters listed above each constraint has the parameters message, groups and payload. This is a requirement of the Jakarta Bean Validation specification. |
| --- | --- |

#### 2.3.2. Additional constraints

In addition to the constraints defined by the Jakarta Bean Validation API, Hibernate Validator provides several useful custom constraints which are listed below.
With one exception also these constraints apply to the field/property level, only `@ScriptAssert` is a class-level constraint.

`@CreditCardNumber(ignoreNonDigitCharacters=)`

Checks that the annotated character sequence passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also [Anatomy of a credit card number](http://www.dirigodev.com/blog/ecommerce/anatomy-of-a-credit-card-number/). `ignoreNonDigitCharacters` allows to ignore non digit characters. The default is `false`.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Currency(value=)`

Checks that the currency unit of the annotated `javax.money.MonetaryAmount` is part of the specified currency units.

Supported data types

any sub-type of `javax.money.MonetaryAmount` (if the [JSR 354 API](https://jcp.org/en/jsr/detail?id=354) and an implementation is on the class path)

Hibernate metadata impact

None

`@DurationMax(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)`

Checks that annotated `java.time.Duration` element is not greater than the one constructed from annotation parameters. Equality is allowed if `inclusive` flag is set to `true`.

Supported data types

`java.time.Duration`

Hibernate metadata impact

None

`@DurationMin(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)`

Checks that annotated `java.time.Duration` element is not less than the one constructed from annotation parameters. Equality is allowed if `inclusive` flag is set to `true`.

Supported data types

`java.time.Duration`

Hibernate metadata impact

None

`@EAN`

Checks that the annotated character sequence is a valid [EAN](http://en.wikipedia.org/wiki/International_Article_Number_%28EAN%29) barcode. type determines the type of barcode. The default is EAN-13.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@ISBN`

Checks that the annotated character sequence is a valid [ISBN](https://en.wikipedia.org/wiki/International_Standard_Book_Number). `type` determines the type of ISBN. The default is ISBN-13.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Length(min=, max=)`

Validates that the annotated character sequence is between `min` and `max` included

Supported data types

`CharSequence`

Hibernate metadata impact

Column length will be set to max

`@CodePointLength(min=, max=, normalizationStrategy=)`

Validates that code point length of the annotated character sequence is between `min` and `max` included. Validates normalized value if `normalizationStrategy` is set.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@LuhnCheck(startIndex= , endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)`

Checks that the digits within the annotated character sequence pass the Luhn checksum algorithm (see also [Luhn algorithm](http://en.wikipedia.org/wiki/Luhn_algorithm)). `startIndex` and `endIndex` allow to only run the algorithm on the specified sub-string. `checkDigitIndex` allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, `ignoreNonDigitCharacters` allows to ignore non digit characters.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Mod10Check(multiplier=, weight=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)`

Checks that the digits within the annotated character sequence pass the generic mod 10 checksum algorithm. `multiplier` determines the multiplier for odd numbers (defaults to 3), `weight` the weight for even numbers (defaults to 1). `startIndex` and `endIndex` allow to only run the algorithm on the specified sub-string. `checkDigitIndex` allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, `ignoreNonDigitCharacters` allows to ignore non digit characters.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Mod11Check(threshold=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=, treatCheck10As=, treatCheck11As=)`

Checks that the digits within the annotated character sequence pass the mod 11 checksum algorithm. `threshold` specifies the threshold for the mod11 multiplier growth; if no value is specified the multiplier will grow indefinitely. `treatCheck10As` and `treatCheck11As` specify the check digits to be used when the mod 11 checksum equals 10 or 11, respectively. Default to X and 0, respectively. `startIndex`, `endIndex` `checkDigitIndex` and `ignoreNonDigitCharacters` carry the same semantics as in `@Mod10Check`.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Normalized(form=)`

Validates that the annotated character sequence is normalized according to the given `form`.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@Range(min=, max=)`

Checks whether the annotated value lies between (inclusive) the specified minimum and maximum

Supported data types

`BigDecimal`, `BigInteger`, `CharSequence`, `byte`, `short`, `int`, `long` and the respective wrappers of the primitive types

Hibernate metadata impact

None

`@SafeHtml(whitelistType= , additionalTags=, additionalTagsWithAttributes=, baseURI=)`

Checks whether the annotated value contains potentially malicious fragments such as `<script/>`. In order to use this constraint, the [jsoup](http://jsoup.org/) library must be part of the class path. With the `whitelistType` attribute a predefined whitelist type can be chosen which can be refined via `additionalTags` or `additionalTagsWithAttributes`. The former allows to add tags without any attributes, whereas the latter allows to specify tags and optionally allowed attributes as well as accepted protocols for the attributes using the annotation `@SafeHtml.Tag`.
In addition, `baseURI` allows to specify the base URI used to resolve relative URIs.

Supported data types

`CharSequence`

Hibernate metadata impact

None

`@ScriptAssert(lang=, script=, alias=, reportOn=)`

Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 ("Scripting for the JavaTM Platform") must be a part of the class path. The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path. Even though this is a class-level constraint, one can use the `reportOn` attribute to report a constraint violation on a specific property rather than the whole object.

Supported data types

Any type

Hibernate metadata impact

None

`@UniqueElements`

Checks that the annotated collection only contains unique elements. The equality is determined using the `equals()` method. The default message does not include the list of duplicate elements but you can include it by overriding the message and using the `{duplicates}` message parameter. The list of duplicate elements is also included in the dynamic payload of the constraint violation.

Supported data types

`Collection`

Hibernate metadata impact

None

`@URL(protocol=, host=, port=, regexp=, flags=)`

Checks if the annotated character sequence is a valid URL according to RFC2396. If any of the optional parameters `protocol`, `host` or `port` are specified, the corresponding URL fragments must match the specified values. The optional parameters `regexp` and `flags` allow to specify an additional regular expression (including regular expression flags) which the URL must match. Per default this constraint used the `java.net.URL` constructor to verify whether a given string represents a valid URL. A regular expression based version is also available - `RegexpURLValidator` - which can be configured via XML (see [Section 8.2, “Mapping constraints via `constraint-mappings`”](#section-mapping-xml-constraints)) or the programmatic API (see [Section 12.14.2, “Adding constraint definitions programmatically”](#section-programmatic-constraint-definition)).

Supported data types

`CharSequence`

Hibernate metadata impact

None

##### 2.3.2.1. Country specific constraints

Hibernate Validator offers also some country specific constraints, e.g. for the validation of social
security numbers.

|  | If you have to implement a country specific constraint, consider making it a contribution to Hibernate Validator! |
| --- | --- |

`@CNPJ`

Checks that the annotated character sequence represents a Brazilian corporate tax payer registry number (Cadastro de Pessoa Jurídica)

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Brazil

`@CPF`

Checks that the annotated character sequence represents a Brazilian individual taxpayer registry number (Cadastro de Pessoa Física)

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Brazil

`@TituloEleitoral`

Checks that the annotated character sequence represents a Brazilian voter ID card number ([Título Eleitoral](http://www.exceldoseujeito.com.br/2008/12/19/validar-cpf-cnpj-e-titulo-de-eleitor-parte-ii/))

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Brazil

`@NIP`

Checks that the annotated character sequence represents a Polish VAT identification number ([NIP](https://pl.wikipedia.org/wiki/NIP))

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Poland

`@PESEL`

Checks that the annotated character sequence represents a Polish national identification number ([PESEL](https://pl.wikipedia.org/wiki/PESEL))

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Poland

`@REGON`

Checks that the annotated character sequence represents a Polish taxpayer identification number ([REGON](https://pl.wikipedia.org/wiki/REGON)). Can be applied to both 9 and 14 digits versions of REGON

Supported data types

`CharSequence`

Hibernate metadata impact

None

Country

Poland

|  | In some cases neither the Jakarta Bean Validation constraints nor the custom constraints provided by Hibernate Validator will fulfill your requirements. In this case you can easily write your own constraint. You can find more information in [Chapter 6, *Creating custom constraints*](#validator-customconstraints). |
| --- | --- |

## 3. Declaring and validating method constraints

As of Bean Validation 1.1, constraints can not only be applied to JavaBeans and their properties,
but also to the parameters and return values of the methods and constructors of any Java type. That
way Jakarta Bean Validation constraints can be used to specify

* the preconditions that must be satisfied by the caller before a method or constructor may be
  invoked (by applying constraints to the parameters of an executable)
* the postconditions that are guaranteed to the caller after a method or constructor invocation
  returns (by applying constraints to the return value of an executable)

|  | For the purpose of this reference guide, the term *method constraint* refers to both, method and constructor constraints, if not stated otherwise. Occasionally, the term *executable* is used when referring to methods and constructors. |
| --- | --- |

This approach has several advantages over traditional ways of checking the correctness of parameters
and return values:

* the checks don’t have to be performed manually (e.g. by throwing `IllegalArgumentException` or
  similar), resulting in less code to write and maintain
* an executable’s pre- and postconditions don’t have to be expressed again in its documentation,
  since the constraint annotations will automatically be included in the generated JavaDoc. This
  avoids redundancies and reduces the chance of inconsistencies between implementation and
  documentation

|  | In order to make annotations show up in the JavaDoc of annotated elements, the annotation types themselves must be annotated with the meta annotation @Documented. This is the case for all built-in constraints and is considered a best practice for any custom constraints. |
| --- | --- |

In the remainder of this chapter you will learn how to declare parameter and return value
constraints and how to validate them using the `ExecutableValidator` API.

### 3.1. Declaring method constraints

#### 3.1.1. Parameter constraints

You specify the preconditions of a method or constructor by adding constraint annotations to its
parameters as demonstrated in [Example 3.1, “Declaring method and constructor parameter constraints”](#example-declaring-parameter-constraints).

Example 3.1: Declaring method and constructor parameter constraints
```
package org.hibernate.validator.referenceguide.chapter03.parameter;

public class RentalStation {

    public RentalStation(@NotNull String name) {
        //...
    }

    public void rentCar(
            @NotNull Customer customer,
            @NotNull @Future Date startDate,
            @Min(1) int durationInDays) {
        //...
    }
}
```

The following preconditions are declared here:

* The `name` passed to the `RentalCar` constructor must not be `null`
* When invoking the `rentCar()` method, the given `customer` must not be `null`, the rental’s start
  date must not be `null` as well as be in the future and finally the rental duration must be at least
  one day

Note that declaring method or constructor constraints itself does not automatically cause their
validation upon invocation of the executable. Instead, the `ExecutableValidator` API (see
[Section 3.2, “Validating method constraints”](#section-validating-executable-constraints)) must be used to perform the validation, which is
often done using a method interception facility such as AOP, proxy objects etc.

Constraints may only be applied to instance methods, i.e. declaring constraints on static methods is
not supported. Depending on the interception facility you use for triggering method validation,
additional restrictions may apply, e.g. with respect to the visibility of methods supported as
target of interception. Refer to the documentation of the interception technology to find out
whether any such limitations exist.

##### 3.1.1.1. Cross-parameter constraints

Sometimes validation does not only depend on a single parameter but on several or even all
parameters of a method or constructor. This kind of requirement can be fulfilled with help of a
cross-parameter constraint.

Cross-parameter constraints can be considered as the method validation equivalent to class-level
constraints. Both can be used to implement validation requirements which are based on several
elements. While class-level constraints apply to several properties of a bean, cross-parameter
constraints apply to several parameters of an executable.

In contrast to single-parameter constraints, cross-parameter constraints are declared on the method
or constructor as you can see in [Example 3.2, “Declaring a cross-parameter constraint”](#example-using-cross-parameter-constraint). Here the cross-
parameter constraint `@LuggageCountMatchesPassengerCount` declared on the `load()` method is used to
ensure that no passenger has more than two pieces of luggage.

Example 3.2: Declaring a cross-parameter constraint
```
package org.hibernate.validator.referenceguide.chapter03.crossparameter;

public class Car {

    @LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
    public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
        //...
    }
}
```

As you will learn in the next section, return value constraints are also declared on the method
level. In order to distinguish cross-parameter constraints from return value constraints, the
constraint target is configured in the `ConstraintValidator` implementation using the
`@SupportedValidationTarget` annotation. You can find out about the details in
[Section 6.3, “Cross-parameter constraints”](#section-cross-parameter-constraints) which shows how to implement your own cross-parameter constraint.

In some cases a constraint can be applied to an executable’s parameters (i.e. it is a cross-
parameter constraint), but also to the return value. One example for this are custom constraints
which allow to specify validation rules using expression or script languages.

Such constraints must define a member `validationAppliesTo()` which can be used at declaration time to
specify the constraint target. As shown in [Example 3.3, “Specifying a constraint’s target”](#example-specifying-constraint-target) you apply the
constraint to an executable’s parameters by specifying
`validationAppliesTo = ConstraintTarget.PARAMETERS`, while `ConstraintTarget.RETURN_VALUE` is used
to apply the constraint to the executable return value.

Example 3.3: Specifying a constraint’s target
```
package org.hibernate.validator.referenceguide.chapter03.crossparameter.constrainttarget;

public class Garage {

    @ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
    public Car buildCar(List<Part> parts) {
        //...
        return null;
    }

    @ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
    public Car paintCar(int color) {
        //...
        return null;
    }
}
```

Although such a constraint is applicable to the parameters and return value of an executable, the
target can often be inferred automatically. This is the case, if the constraint is declared on

* a void method with parameters (the constraint applies to the parameters)
* an executable with return value but no parameters (the constraint applies to the return value)
* neither a method nor a constructor, but a field, parameter etc. (the constraint applies to the
  annotated element)

In these situations you don’t have to specify the constraint target. It is still recommended to do
so if it increases readability of the source code. If the constraint target is not specified in
situations where it can’t be determined automatically, a `ConstraintDeclarationException` is raised.

#### 3.1.2. Return value constraints

The postconditions of a method or constructor are declared by adding constraint annotations to the
executable as shown in [Example 3.4, “Declaring method and constructor return value constraints”](#example-declaring-return-value-constraints).

Example 3.4: Declaring method and constructor return value constraints
```
package org.hibernate.validator.referenceguide.chapter03.returnvalue;

public class RentalStation {

    @ValidRentalStation
    public RentalStation() {
        //...
    }

    @NotNull
    @Size(min = 1)
    public List<@NotNull Customer> getCustomers() {
        //...
        return null;
    }
}
```

The following constraints apply to the executables of `RentalStation`:

* Any newly created `RentalStation` object must satisfy the `@ValidRentalStation` constraint
* The customer list returned by `getCustomers()` must not be `null` and must contain at least on element
* The customer list returned by `getCustomers()` must no contain `null` objects

|  | As you can see in the above example, container element constraints are supported on method return value. They are also supported on method parameters. |
| --- | --- |

#### 3.1.3. Cascaded validation

Similar to the cascaded validation of JavaBeans properties (see
[Section 2.1.6, “Object graphs”](#section-object-graph-validation)), the `@Valid` annotation can be used to mark executable
parameters and return values for cascaded validation. When validating a parameter or return value
annotated with `@Valid`, the constraints declared on the parameter or return value object are
validated as well.

In [Example 3.5, “Marking executable parameters and return values for cascaded validation”](#example-cascaded-executable-validation), the `car` parameter of the method `Garage#checkCar()` as
well as the return value of the `Garage` constructor are marked for cascaded validation.

Example 3.5: Marking executable parameters and return values for cascaded validation
```
package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Garage {

    @NotNull
    private String name;

    @Valid
    public Garage(String name) {
        this.name = name;
    }

    public boolean checkCar(@Valid @NotNull Car car) {
        //...
        return false;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    public Car(String manufacturer, String licencePlate) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
    }

    //getters and setters ...
}
```

When validating the arguments of the `checkCar()` method, the constraints on the properties of the
passed `Car` object are evaluated as well. Similarly, the `@NotNull` constraint on the name field of
`Garage` is checked when validating the return value of the `Garage` constructor.

Generally, the cascaded validation works for executables in exactly the same way as it does for
JavaBeans properties.

In particular, `null` values are ignored during cascaded validation (naturally this can’t happen
during constructor return value validation) and cascaded validation is performed recursively, i.e.
if a parameter or return value object which is marked for cascaded validation itself has properties
marked with `@Valid`, the constraints declared on the referenced elements will be validated as well.

Same as for fields and properties, cascaded validation can also be declared on container
elements (e.g. elements of collections, maps or custom containers) of return values and parameters.

In this case, each element contained by the container gets validated.
So when validating the arguments of the `checkCars()` method in
[Example 3.6, “Container elements of method parameter marked for cascaded validation”](#example-cascaded-executable-validation-container-elements), each element instance of the passed list
will be validated and a `ConstraintViolation` created when any of the contained `Car` instances is invalid.

Example 3.6: Container elements of method parameter marked for cascaded validation
```
package org.hibernate.validator.referenceguide.chapter03.cascaded.containerelement;

public class Garage {

    public boolean checkCars(@NotNull List<@Valid Car> cars) {
        //...
        return false;
    }
}
```

#### 3.1.4. Method constraints in inheritance hierarchies

When declaring method constraints in inheritance hierarchies, it is important to be aware of the
following rules:

* The preconditions to be satisfied by the caller of a method may not be strengthened in subtypes
* The postconditions guaranteed to the caller of a method may not be weakened in subtypes

These rules are motivated by the concept of *behavioral subtyping* which requires that wherever a
type `T` is used, also a subtype `S` of `T` may be used without altering the program’s behavior.

As an example, consider a class invoking a method on an object with the static type `T`. If the
runtime type of that object was `S` and `S` imposed additional preconditions, the client class might
fail to satisfy these preconditions as is not aware of them. The rules of behavioral subtyping are
also known as the [Liskov
substitution principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle).

The Jakarta Bean Validation specification implements the first rule by disallowing parameter constraints on
methods which override or implement a method declared in a supertype (superclass or interface).
[Example 3.7, “Illegal method parameter constraint in subtype”](#example-illegal-parameter-constraints) shows a violation of this rule.

Example 3.7: Illegal method parameter constraint in subtype
```
package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public interface Vehicle {

    void drive(@Max(75) int speedInMph);
}
```

```
package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public class Car implements Vehicle {

    @Override
    public void drive(@Max(55) int speedInMph) {
        //...
    }
}
```

The `@Max` constraint on `Car#drive()` is illegal since this method implements the interface method
`Vehicle#drive()`. Note that parameter constraints on overriding methods are also disallowed, if the
supertype method itself doesn’t declare any parameter constraints.

Furthermore, if a method overrides or implements a method declared in several parallel supertypes
(e.g. two interfaces not extending each other or a class and an interface not implemented by that
class), no parameter constraints may be specified for the method in any of the involved types. The
types in [Example 3.8, “Illegal method parameter constraint in parallel types of a hierarchy”](#example-illegal-parameter-constraints-parallel-types) demonstrate a violation of that
rule. The method `RacingCar#drive()` overrides `Vehicle#drive()` as well as `Car#drive()`.
Therefore the constraint on `Vehicle#drive()` is illegal.

Example 3.8: Illegal method parameter constraint in parallel types of a hierarchy
```
package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Vehicle {

    void drive(@Max(75) int speedInMph);
}
```

```
package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Car {

    void drive(int speedInMph);
}
```

```
package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public class RacingCar implements Car, Vehicle {

    @Override
    public void drive(int speedInMph) {
        //...
    }
}
```

The previously described restrictions only apply to parameter constraints. In contrast, return value
constraints may be added in methods overriding or implementing any supertype methods.

In this case, all the method’s return value constraints apply for the subtype method, i.e. the
constraints declared on the subtype method itself as well as any return value constraints on
overridden/implemented supertype methods. This is legal as putting additional return value
constraints in place may never represent a weakening of the postconditions guaranteed to the caller
of a method.

So when validating the return value of the method `Car#getPassengers()` shown in
[Example 3.9, “Return value constraints on supertype and subtype method”](#example-return-value-constraints-in-hierarchy), the `@Size` constraint on the method itself as well
as the `@NotNull` constraint on the implemented interface method `Vehicle#getPassengers()` apply.

Example 3.9: Return value constraints on supertype and subtype method
```
package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public interface Vehicle {

    @NotNull
    List<Person> getPassengers();
}
```

```
package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public class Car implements Vehicle {

    @Override
    @Size(min = 1)
    public List<Person> getPassengers() {
        //...
        return null;
    }
}
```

If the validation engine detects a violation of any of the aforementioned rules, a
`ConstraintDeclarationException` will be raised.

|  | The rules described in this section only apply to methods but not constructors. By definition, constructors never override supertype constructors. Therefore, when validating the parameters or the return value of a constructor invocation only the constraints declared on the constructor itself apply, but never any constraints declared on supertype constructors. |
| --- | --- |

|  | Enforcement of these rules may be relaxed by setting the configuration parameters contained in the `MethodValidationConfiguration` property of the `HibernateValidatorConfiguration` before creating the `Validator` instance. See also [Section 12.3, “Relaxation of requirements for method validation in class hierarchies”](#section-method-validation-prerequisite-relaxation). |
| --- | --- |

### 3.2. Validating method constraints

The validation of method constraints is done using the `ExecutableValidator` interface.

In [Section 3.2.1, “Obtaining an `ExecutableValidator` instance”](#section-obtaining-executable-validator) you will learn how to obtain an `ExecutableValidator`
instance while [Section 3.2.2, “`ExecutableValidator` methods”](#section-executable-validator-methods) shows how to use the different methods
offered by this interface.

Instead of calling the `ExecutableValidator` methods directly from within application code, they are
usually invoked via a method interception technology such as AOP, proxy objects, etc. This causes
executable constraints to be validated automatically and transparently upon method or constructor
invocation. Typically a `ConstraintViolationException` is raised by the integration layer in case any
of the constraints is violated.

#### 3.2.1. Obtaining an `ExecutableValidator` instance

You can retrieve an `ExecutableValidator` instance via `Validator#forExecutables()` as shown in
[Example 3.10, “Obtaining an `ExecutableValidator` instance”](#example-obtaining-executable-validator).

Example 3.10: Obtaining an `ExecutableValidator` instance
```
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();
```

In the example the executable validator is retrieved from the default validator factory, but if
required you could also bootstrap a specifically configured factory as described in
[Chapter 9, *Bootstrapping*](#chapter-bootstrapping), for instance in order to use a specific parameter name provider
(see [Section 9.2.4, “`ParameterNameProvider`”](#section-parameter-name-provider)).

#### 3.2.2. `ExecutableValidator` methods

The `ExecutableValidator` interface offers altogether four methods:

* `validateParameters()` and `validateReturnValue()` for method validation
* `validateConstructorParameters()` and `validateConstructorReturnValue()` for constructor validation

Just as the methods on `Validator`, all these methods return a `Set<ConstraintViolation>` which contains
a `ConstraintViolation` instance for each violated constraint and which is empty if the validation
succeeds. Also all the methods have a var-args groups parameter by which you can pass the validation
groups to be considered for validation.

The examples in the following sections are based on the methods on constructors of the `Car` class
shown in [Example 3.11, “Class `Car` with constrained methods and constructors”](#example-executable-validator-class-car).

Example 3.11: Class `Car` with constrained methods and constructors
```
package org.hibernate.validator.referenceguide.chapter03.validation;

public class Car {

    public Car(@NotNull String manufacturer) {
        //...
    }

    @ValidRacingCar
    public Car(String manufacturer, String team) {
        //...
    }

    public void drive(@Max(75) int speedInMph) {
        //...
    }

    @Size(min = 1)
    public List<Passenger> getPassengers() {
        //...
        return Collections.emptyList();
    }
}
```

##### 3.2.2.1. `ExecutableValidator#validateParameters()`

The method `validateParameters()` is used to validate the arguments of a method invocation.
[Example 3.12, “Using `ExecutableValidator#validateParameters()`”](#example-executable-validator-validate-parameters) shows an example. The validation results in a
violation of the `@Max` constraint on the parameter of the `drive()` method.

Example 3.12: Using `ExecutableValidator#validateParameters()`
```
Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set<ConstraintViolation<Car>> violations = executableValidator.validateParameters(
        object,
        method,
        parameterValues
);

assertEquals( 1, violations.size() );
Class<? extends Annotation> constraintType = violations.iterator()
        .next()
        .getConstraintDescriptor()
        .getAnnotation()
        .annotationType();
assertEquals( Max.class, constraintType );
```

Note that `validateParameters()` validates all the parameter constraints of a method, i.e. constraints
on individual parameters as well as cross-parameter constraints.

##### 3.2.2.2. `ExecutableValidator#validateReturnValue()`

Using `validateReturnValue()` the return value of a method can be validated. The validation in
[Example 3.13, “Using `ExecutableValidator#validateReturnValue()`”](#example-executable-validator-validate-return-value) yields one constraint violation since the
`getPassengers()` method is expected to return at least one `Passenger` instance.

Example 3.13: Using `ExecutableValidator#validateReturnValue()`
```
Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "getPassengers" );
Object returnValue = Collections.<Passenger>emptyList();
Set<ConstraintViolation<Car>> violations = executableValidator.validateReturnValue(
        object,
        method,
        returnValue
);

assertEquals( 1, violations.size() );
Class<? extends Annotation> constraintType = violations.iterator()
        .next()
        .getConstraintDescriptor()
        .getAnnotation()
        .annotationType();
assertEquals( Size.class, constraintType );
```

##### 3.2.2.3. `ExecutableValidator#validateConstructorParameters()`

The arguments of constructor invocations can be validated with `validateConstructorParameters()` as
shown in method [Example 3.14, “Using `ExecutableValidator#validateConstructorParameters()`”](#example-executable-validator-validate-constructor-parameters). Due to the
`@NotNull` constraint on the `manufacturer` parameter, the validation call returns one constraint
violation.

Example 3.14: Using `ExecutableValidator#validateConstructorParameters()`
```
Constructor<Car> constructor = Car.class.getConstructor( String.class );
Object[] parameterValues = { null };
Set<ConstraintViolation<Car>> violations = executableValidator.validateConstructorParameters(
        constructor,
        parameterValues
);

assertEquals( 1, violations.size() );
Class<? extends Annotation> constraintType = violations.iterator()
        .next()
        .getConstraintDescriptor()
        .getAnnotation()
        .annotationType();
assertEquals( NotNull.class, constraintType );
```

##### 3.2.2.4. `ExecutableValidator#validateConstructorReturnValue()`

Finally, by using `validateConstructorReturnValue()` you can validate a constructor’s return value. In
[Example 3.15, “Using `ExecutableValidator#validateConstructorReturnValue()`”](#example-executable-validator-validate-constructor-return-value), `validateConstructorReturnValue()`
returns one constraint violation, since the `Car` instance returned by the constructor doesn’t satisfy
the `@ValidRacingCar` constraint (not shown).

Example 3.15: Using `ExecutableValidator#validateConstructorReturnValue()`
```
//constructor for creating racing cars
Constructor<Car> constructor = Car.class.getConstructor( String.class, String.class );
Car createdObject = new Car( "Morris", null );
Set<ConstraintViolation<Car>> violations = executableValidator.validateConstructorReturnValue(
        constructor,
        createdObject
);

assertEquals( 1, violations.size() );
Class<? extends Annotation> constraintType = violations.iterator()
        .next()
        .getConstraintDescriptor()
        .getAnnotation()
        .annotationType();
assertEquals( ValidRacingCar.class, constraintType );
```

#### 3.2.3. `ConstraintViolation` methods for method validation

In addition to the methods introduced in [Section 2.2.3, “`ConstraintViolation`”](#section-constraint-violation-methods),
`ConstraintViolation` provides two more methods specific to the validation of executable parameters
and return values.

`ConstraintViolation#getExecutableParameters()` returns the validated parameter array in case of
method or constructor parameter validation, while `ConstraintViolation#getExecutableReturnValue()`
provides access to the validated object in case of return value validation.

All the other `ConstraintViolation` methods generally work for method validation in the same way as
for validation of beans. Refer to the
[JavaDoc](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/BeanDescriptor.html)
to learn more about the behavior of the individual methods and their return values during bean and
method validation.

Note that `getPropertyPath()` can be very useful in order to obtain detailed information about the
validated parameter or return value, e.g. for logging purposes. In particular, you can retrieve name
and argument types of the concerned method as well as the index of the concerned parameter from the
path nodes. How this can be done is shown in [Example 3.16, “Retrieving method and parameter information”](#example-executable-validation-property-path).

Example 3.16: Retrieving method and parameter information
```
Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set<ConstraintViolation<Car>> violations = executableValidator.validateParameters(
        object,
        method,
        parameterValues
);

assertEquals( 1, violations.size() );
Iterator<Node> propertyPath = violations.iterator()
        .next()
        .getPropertyPath()
        .iterator();

MethodNode methodNode = propertyPath.next().as( MethodNode.class );
assertEquals( "drive", methodNode.getName() );
assertEquals( Arrays.<Class<?>>asList( int.class ), methodNode.getParameterTypes() );

ParameterNode parameterNode = propertyPath.next().as( ParameterNode.class );
assertEquals( "speedInMph", parameterNode.getName() );
assertEquals( 0, parameterNode.getParameterIndex() );
```

The parameter name is determined using the current `ParameterNameProvider` (see
[Section 9.2.4, “`ParameterNameProvider`”](#section-parameter-name-provider)).

### 3.3. Built-in method constraints

In addition to the built-in bean and property-level constraints discussed in
[Section 2.3, “Built-in constraints”](#section-builtin-constraints), Hibernate Validator currently provides one method-level constraint,
`@ParameterScriptAssert`. This is a generic cross-parameter constraint which allows to implement
validation routines using any JSR 223 compatible ("Scripting for the JavaTM Platform") scripting
language, provided an engine for this language is available on the classpath.

To refer to the executable’s parameters from within the expression, use their name as obtained from
the active parameter name provider (see [Section 9.2.4, “`ParameterNameProvider`”](#section-parameter-name-provider)).
[Example 3.17, “Using `@ParameterScriptAssert`”](#example-parameterscriptassert) shows how the validation logic of the `@LuggageCountMatchesPassengerCount`
constraint from [Example 3.2, “Declaring a cross-parameter constraint”](#example-using-cross-parameter-constraint) could be expressed with the help of
`@ParameterScriptAssert`.

Example 3.17: Using `@ParameterScriptAssert`
```
package org.hibernate.validator.referenceguide.chapter03.parameterscriptassert;

public class Car {

    @ParameterScriptAssert(lang = "javascript", script = "luggage.size() <= passengers.size() * 2")
    public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
        //...
    }
}
```

## 4. Interpolating constraint error messages

Message interpolation is the process of creating error messages for violated Jakarta Bean Validation
constraints. In this chapter you will learn how such messages are defined and resolved and how you
can plug in custom message interpolators in case the default algorithm is not sufficient for your
requirements.

### 4.1. Default message interpolation

Constraint violation messages are retrieved from so called message descriptors. Each constraint
defines its default message descriptor using the message attribute. At declaration time, the default
descriptor can be overridden with a specific value as shown in [Example 4.1, “Specifying a message descriptor using the message attribute”](#example-overriding-message).

Example 4.1: Specifying a message descriptor using the message attribute
```
package org.hibernate.validator.referenceguide.chapter04;

public class Car {

    @NotNull(message = "The manufacturer name must not be null")
    private String manufacturer;

    //constructor, getters and setters ...
}
```

If a constraint is violated, its descriptor will be interpolated by the validation engine using the
currently configured `MessageInterpolator`. The interpolated error message can then be retrieved from
the resulting constraint violation by calling `ConstraintViolation#getMessage()`.

Message descriptors can contain *message parameters* as well as *message expressions* which will be
resolved during interpolation. Message parameters are string literals enclosed in `{}`, while
message expressions are string literals enclosed in `${}`. The following algorithm is applied during
method interpolation:

1. Resolve any message parameters by using them as key for the resource bundle *ValidationMessages*. If
   this bundle contains an entry for a given message parameter, that parameter will be replaced in the
   message with the corresponding value from the bundle. This step will be executed recursively in case
   the replaced value again contains message parameters. The resource bundle is expected to be provided
   by the application developer, e.g. by adding a file named *ValidationMessages.properties* to the
   classpath. You can also create localized error messages by providing locale specific variations of
   this bundle, such as *ValidationMessages\_en\_US.properties*. By default, the JVM’s default locale
   (`Locale#getDefault()`) will be used when looking up messages in the bundle.
2. Resolve any message parameters by using them as key for a resource bundle containing the standard
   error messages for the built-in constraints as defined in Appendix B of the Jakarta Bean Validation
   specification. In the case of Hibernate Validator, this bundle is named
   `org.hibernate.validator.ValidationMessages`. If this step triggers a replacement, step 1 is executed
   again, otherwise step 3 is applied.
3. Resolve any message parameters by replacing them with the value of the constraint annotation member
   of the same name. This allows to refer to attribute values of the constraint (e.g. `Size#min()`) in
   the error message (e.g. "must be at least ${min}").
4. Resolve any message expressions by evaluating them as expressions of the Unified Expression
   Language. See [Section 4.1.2, “Interpolation with message expressions”](#section-interpolation-with-message-expressions) to learn more about the usage of
   Unified EL in error messages.

|  | You can find the formal definition of the interpolation algorithm in section [6.3.1.1](http://beanvalidation.org/2.0/spec/#validationapi-message-defaultmessageinterpolation-resolutionalgorithm) of the Jakarta Bean Validation specification. |
| --- | --- |

#### 4.1.1. Special characters

Since the characters `{`, `}` and `$` have a special meaning in message descriptors, they need to be
escaped if you want to use them literally. The following rules apply:

* `\{` is considered as the literal `{`
* `\}` is considered as the literal `}`
* `\$` is considered as the literal `$`
* `\\` is considered as the literal `\`

#### 4.1.2. Interpolation with message expressions

As of Hibernate Validator 5 (Bean Validation 1.1) it is possible to use the
[Jakarta Expression Language](https://projects.eclipse.org/projects/ee4j.el) in constraint
violation messages. This allows to define error messages based on conditional logic and also enables
advanced formatting options. The validation engine makes the following objects available in the EL
context:

* the attribute values of the constraint mapped to the attribute names
* the currently validated value (property, bean, method parameter etc.) under the name *validatedValue*
* a bean mapped to the name formatter exposing the var-arg method
  `format(String format, Object…​ args)` which behaves like
  `java.util.Formatter.format(String format, Object…​ args)`.

The following section provides several examples for using EL expressions in error messages.

#### 4.1.3. Examples

[Example 4.2, “Specifying message descriptors”](#example-message-descriptors) shows how to make use of the different options for specifying
message descriptors.

Example 4.2: Specifying message descriptors
```
package org.hibernate.validator.referenceguide.chapter04.complete;

public class Car {

    @NotNull
    private String manufacturer;

    @Size(
            min = 2,
            max = 14,
            message = "The license plate '${validatedValue}' must be between {min} and {max} characters long"
    )
    private String licensePlate;

    @Min(
            value = 2,
            message = "There must be at least {value} seat${value > 1 ? 's' : ''}"
    )
    private int seatCount;

    @DecimalMax(
            value = "350",
            message = "The top speed ${formatter.format('%1$.2f', validatedValue)} is higher " +
                    "than {value}"
    )
    private double topSpeed;

    @DecimalMax(value = "100000", message = "Price must not be higher than ${value}")
    private BigDecimal price;

    public Car(
            String manufacturer,
            String licensePlate,
            int seatCount,
            double topSpeed,
            BigDecimal price) {
        this.manufacturer = manufacturer;
        this.licensePlate = licensePlate;
        this.seatCount = seatCount;
        this.topSpeed = topSpeed;
        this.price = price;
    }

    //getters and setters ...
}
```

Validating an invalid `Car` instance yields constraint violations with the messages shown by the
assertions in [Example 4.3, “Expected error messages”](#example-expected-error-messages):

* the `@NotNull` constraint on the `manufacturer` field causes the error message "must not be null", as
  this is the default message defined by the Jakarta Bean Validation specification and no specific descriptor
  is given in the message attribute
* the `@Size` constraint on the `licensePlate` field shows the interpolation of message parameters
  (`{min}`, `{max}`) and how to add the validated value to the error message using the EL
  expression `${validatedValue}`
* the `@Min` constraint on `seatCount` demonstrates how to use an EL expression with a ternary expression to
  dynamically choose singular or plural form, depending on an attribute of the constraint ("There must
  be at least 1 seat" vs. "There must be at least 2 seats")
* the message for the `@DecimalMax` constraint on `topSpeed` shows how to format the validated
  value using the formatter instance
* finally, the `@DecimalMax` constraint on `price` shows that parameter interpolation has precedence over
  expression evaluation, causing the `$` sign to show up in front of the maximum price

|  | Only actual constraint attributes can be interpolated using message parameters in the form `{attributeName}`. When referring to the validated value or custom expression variables added to the interpolation context (see [Section 12.12.1, “`HibernateConstraintValidatorContext`”](#section-hibernateconstraintvalidatorcontext)), an EL expression in the form `${attributeName}` must be used. |
| --- | --- |

Example 4.3: Expected error messages
```
Car car = new Car( null, "A", 1, 400.123456, BigDecimal.valueOf( 200000 ) );

String message = validator.validateProperty( car, "manufacturer" )
        .iterator()
        .next()
        .getMessage();
assertEquals( "must not be null", message );

message = validator.validateProperty( car, "licensePlate" )
        .iterator()
        .next()
        .getMessage();
assertEquals(
        "The license plate 'A' must be between 2 and 14 characters long",
        message
);

message = validator.validateProperty( car, "seatCount" ).iterator().next().getMessage();
assertEquals( "There must be at least 2 seats", message );

message = validator.validateProperty( car, "topSpeed" ).iterator().next().getMessage();
assertEquals( "The top speed 400.12 is higher than 350", message );

message = validator.validateProperty( car, "price" ).iterator().next().getMessage();
assertEquals( "Price must not be higher than $100000", message );
```

### 4.2. Custom message interpolation

If the default message interpolation algorithm does not fit your requirements, it is also possible to
plug in a custom `MessageInterpolator` implementation.

Custom interpolators must implement the interface `javax.validation.MessageInterpolator`. Note that
implementations must be thread-safe. It is recommended that custom message interpolators delegate
final implementation to the default interpolator, which can be obtained via
`Configuration#getDefaultMessageInterpolator()`.

In order to use a custom message interpolator it must be registered either by configuring it in the
Jakarta Bean Validation XML descriptor *META-INF/validation.xml* (see
[Section 8.1, “Configuring the validator factory in *validation.xml*”](#section-configuration-validation-xml)) or by passing it when bootstrapping a `ValidatorFactory` or
`Validator` (see [Section 9.2.1, “`MessageInterpolator`”](#section-validator-factory-message-interpolator) and
[Section 9.3, “Configuring a Validator”](#section-configuring-validator), respectively).

#### 4.2.1. `ResourceBundleLocator`

In some use cases, you want to use the message interpolation algorithm as defined by the Bean
Validation specification, but retrieve error messages from other resource bundles than
*ValidationMessages*. In this situation Hibernate Validator’s `ResourceBundleLocator` SPI can help.

The default message interpolator in Hibernate Validator, `ResourceBundleMessageInterpolator`,
delegates retrieval of resource bundles to that SPI. Using an alternative bundle only requires
passing an instance of `PlatformResourceBundleLocator` with the bundle name when bootstrapping the
`ValidatorFactory` as shown in [Example 4.4, “Using a specific resource bundle”](#example-using-specific-resource-bundle-locator).

Example 4.4: Using a specific resource bundle
```
Validator validator = Validation.byDefaultProvider()
        .configure()
        .messageInterpolator(
                new ResourceBundleMessageInterpolator(
                        new PlatformResourceBundleLocator( "MyMessages" )
                )
        )
        .buildValidatorFactory()
        .getValidator();
```

Of course you also could implement a completely different `ResourceBundleLocator`, which for instance
returns bundles backed by records in a database. In this case, you can obtain the default locator via
`HibernateValidatorConfiguration#getDefaultResourceBundleLocator()`, which you e.g. could use as
fall-back for your custom locator.

Besides `PlatformResourceBundleLocator`, Hibernate Validator provides another resource bundle locator
implementation out of the box, namely `AggregateResourceBundleLocator`, which allows to retrieve error
messages from more than one resource bundle. You could for instance use this implementation in a
multi-module application where you want to have one message bundle per module.
[Example 4.5, “Using `AggregateResourceBundleLocator`”](#example-using-aggregate-resource-bundle-locator) shows how to use `AggregateResourceBundleLocator`.

Example 4.5: Using `AggregateResourceBundleLocator`
```
Validator validator = Validation.byDefaultProvider()
        .configure()
        .messageInterpolator(
                new ResourceBundleMessageInterpolator(
                        new AggregateResourceBundleLocator(
                                Arrays.asList(
                                        "MyMessages",
                                        "MyOtherMessages"
                                )
                        )
                )
        )
        .buildValidatorFactory()
        .getValidator();
```

Note that the bundles are processed in the order as passed to the constructor. That means if several
bundles contain an entry for a given message key, the value will be taken from the first bundle in
the list containing the key.

## 5. Grouping constraints

All validation methods on `Validator` and `ExecutableValidator` discussed in earlier chapters also take
a var-arg argument `groups`. So far we have been ignoring this parameter, but it is time to have a
closer look.

### 5.1. Requesting groups

Groups allow you to restrict the set of constraints applied during validation. One use case for
validation groups are UI wizards where in each step only a specified subset of constraints should
get validated. The groups targeted are passed as var-arg parameters to the appropriate validate
method.

Let’s have a look at an example. The class `Person` in [Example 5.1, “Example class `Person`”](#example-person) has a `@NotNull`
constraint on `name`. Since no group is specified for this annotation the default group
`javax.validation.groups.Default` is assumed.

|  | When more than one group is requested, the order in which the groups are evaluated is not deterministic. If no group is specified the default group `javax.validation.groups.Default` is assumed. |
| --- | --- |

Example 5.1: Example class `Person`
```
package org.hibernate.validator.referenceguide.chapter05;

public class Person {

    @NotNull
    private String name;

    public Person(String name) {
        this.name = name;
    }

    // getters and setters ...
}
```

The class `Driver` in [Example 5.2, “Driver”](#example-driver) extends `Person` and adds the properties `age` and
`hasDrivingLicense`. Drivers must be at least 18 years old (`@Min(18)`) and have a driving license
(`@AssertTrue`). Both constraints defined on these properties belong to the group `DriverChecks` which
is just a simple tagging interface.

|  | Using interfaces makes the usage of groups type-safe and allows for easy refactoring. It also means that groups can inherit from each other via class inheritance. See [Section 5.2, “Group inheritance”](#section-group-inheritance). |
| --- | --- |

Example 5.2: Driver
```
package org.hibernate.validator.referenceguide.chapter05;

public class Driver extends Person {

    @Min(
            value = 18,
            message = "You have to be 18 to drive a car",
            groups = DriverChecks.class
    )
    public int age;

    @AssertTrue(
            message = "You first have to pass the driving test",
            groups = DriverChecks.class
    )
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter05;

public interface DriverChecks {
}
```

Finally the class `Car` ([Example 5.3, “Car”](#example-car)) has some constraints which are part of the default group as
well as `@AssertTrue` in the group `CarChecks` on the property `passedVehicleInspection` which indicates
whether a car passed the road worthy tests.

Example 5.3: Car
```
package org.hibernate.validator.referenceguide.chapter05;

public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    @AssertTrue(
            message = "The car has to pass the vehicle inspection first",
            groups = CarChecks.class
    )
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    public boolean isPassedVehicleInspection() {
        return passedVehicleInspection;
    }

    public void setPassedVehicleInspection(boolean passedVehicleInspection) {
        this.passedVehicleInspection = passedVehicleInspection;
    }

    public Driver getDriver() {
        return driver;
    }

    public void setDriver(Driver driver) {
        this.driver = driver;
    }

    // getters and setters ...
}
```

```
package org.hibernate.validator.referenceguide.chapter05;

public interface CarChecks {
}
```

Overall three different groups are used in the example:

* The constraints on `Person.name`, `Car.manufacturer`, `Car.licensePlate` and `Car.seatCount`
  all belong to the `Default` group
* The constraints on `Driver.age` and `Driver.hasDrivingLicense` belong to `DriverChecks`
* The constraint on `Car.passedVehicleInspection` belongs to the group `CarChecks`

[Example 5.4, “Using validation groups”](#example-drive-away) shows how passing different group combinations to the `Validator#validate()`
method results in different validation results.

Example 5.4: Using validation groups
```
// create a car and check that everything is ok with it.
Car car = new Car( "Morris", "DD-AB-123", 2 );
Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// but has it passed the vehicle inspection?
constraintViolations = validator.validate( car, CarChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
        "The car has to pass the vehicle inspection first",
        constraintViolations.iterator().next().getMessage()
);

// let's go to the vehicle inspection
car.setPassedVehicleInspection( true );
assertEquals( 0, validator.validate( car, CarChecks.class ).size() );

// now let's add a driver. He is 18, but has not passed the driving test yet
Driver john = new Driver( "John Doe" );
john.setAge( 18 );
car.setDriver( john );
constraintViolations = validator.validate( car, DriverChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
        "You first have to pass the driving test",
        constraintViolations.iterator().next().getMessage()
);

// ok, John passes the test
john.passedDrivingTest( true );
assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

// just checking that everything is in order now
assertEquals(
        0, validator.validate(
        car,
        Default.class,
        CarChecks.class,
        DriverChecks.class
).size()
);
```

The first `validate()` call in [Example 5.4, “Using validation groups”](#example-drive-away) is done using no explicit group. There are no
validation errors, even though the property `passedVehicleInspection` is per default `false` as
the constraint defined on this property does not belong to the default group.

The next validation using the `CarChecks` group fails until the car passes the vehicle inspection.
Adding a driver to the car and validating against `DriverChecks` again yields one constraint violation
due to the fact that the driver has not yet passed the driving test. Only after setting
`passedDrivingTest` to `true` the validation against `DriverChecks` passes.

The last `validate()` call finally shows that all constraints are passing by validating against all
defined groups.

### 5.2. Group inheritance

In [Example 5.4, “Using validation groups”](#example-drive-away), we need to call `validate()` for each validation group, or specify all of
them one by one.

In some situations, you may want to define a group of constraints which includes another group.
You can do that using group inheritance.

In [Example 5.5, “SuperCar”](#example-supercar), we define a `SuperCar` and a group `RaceCarChecks` that extends the `Default` group.
A `SuperCar` must have safety belts to be allowed to run in races.

Example 5.5: SuperCar
```
package org.hibernate.validator.referenceguide.chapter05.groupinheritance;

public class SuperCar extends Car {

    @AssertTrue(
            message = "Race car must have a safety belt",
            groups = RaceCarChecks.class
    )
    private boolean safetyBelt;

    // getters and setters ...

}
```

```
package org.hibernate.validator.referenceguide.chapter05.groupinheritance;

import javax.validation.groups.Default;

public interface RaceCarChecks extends Default {
}
```

In the example below, we will check if a `SuperCar` with one seat and no security belts is a valid car
and if it is a valid race-car.

Example 5.6: Using group inheritance
```
// create a supercar and check that it's valid as a generic Car
SuperCar superCar = new SuperCar( "Morris", "DD-AB-123", 1  );
assertEquals( "must be greater than or equal to 2", validator.validate( superCar ).iterator().next().getMessage() );

// check that this supercar is valid as generic car and also as race car
Set<ConstraintViolation<SuperCar>> constraintViolations = validator.validate( superCar, RaceCarChecks.class );

assertThat( constraintViolations ).extracting( "message" ).containsOnly(
        "Race car must have a safety belt",
        "must be greater than or equal to 2"
);
```

On the first call to `validate()`, we do not specify a group. There is one validation error because a
car must have at least one seat. It is the constraint from the `Default` group.

On the second call, we specify only the group `RaceCarChecks`. There are two validation errors: one
about the missing seat from the `Default` group, another one about the fact that there is no safety
belts coming from the `RaceCarChecks` group.

### 5.3. Defining group sequences

By default, constraints are evaluated in no particular order, regardless of which groups they belong
to. In some situations, however, it is useful to control the order in which constraints are evaluated.

In the example from [Example 5.4, “Using validation groups”](#example-drive-away) it could for instance be required that first all default
car constraints are passing before checking the road worthiness of the car. Finally, before driving
away, the actual driver constraints should be checked.

In order to implement such a validation order you just need to define an interface and annotate it
with `@GroupSequence`, defining the order in which the groups have to be validated (see
[Example 5.7, “Defining a group sequence”](#example-defining-group-sequence)). If at least one constraint fails in a sequenced group, none of the
constraints of the following groups in the sequence get validated.

Example 5.7: Defining a group sequence
```
package org.hibernate.validator.referenceguide.chapter05;

import javax.validation.GroupSequence;
import javax.validation.groups.Default;

@GroupSequence({ Default.class, CarChecks.class, DriverChecks.class })
public interface OrderedChecks {
}
```

|  | Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency either directly or indirectly, either through cascaded sequence definition or group inheritance. If a group containing such a circularity is evaluated, a `GroupDefinitionException` is raised. |
| --- | --- |

You then can use the new sequence as shown in in [Example 5.8, “Using a group sequence”](#example-group-sequence).

Example 5.8: Using a group sequence
```
Car car = new Car( "Morris", "DD-AB-123", 2 );
car.setPassedVehicleInspection( true );

Driver john = new Driver( "John Doe" );
john.setAge( 18 );
john.passedDrivingTest( true );
car.setDriver( john );

assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
```

### 5.4. Redefining the default group sequence

#### 5.4.1. `@GroupSequence`

Besides defining group sequences, the `@GroupSequence` annotation also allows to redefine the default
group for a given class. To do so, just add the `@GroupSequence` annotation to the class and specify
the sequence of groups which substitute `Default` for this class within the annotation.

[Example 5.9, “Class `RentalCar` with redefined default group”](#example-rental-car) introduces a new class `RentalCar` with a redefined default group.

Example 5.9: Class `RentalCar` with redefined default group
```
package org.hibernate.validator.referenceguide.chapter05;

@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
public class RentalCar extends Car {
    @AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
    private boolean rented;

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

    public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter05;

public interface RentalChecks {
}
```

With this definition you can evaluate the constraints belonging to `RentalChecks`, `CarChecks` and
`RentalCar` by just requesting the `Default` group as seen in [Example 5.10, “Validating an object with redefined default group”](#example-testCarIsRented).

Example 5.10: Validating an object with redefined default group
```
RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
rentalCar.setPassedVehicleInspection( true );
rentalCar.setRented( true );

Set<ConstraintViolation<RentalCar>> constraintViolations = validator.validate( rentalCar );

assertEquals( 1, constraintViolations.size() );
assertEquals(
        "Wrong message",
        "The car is currently rented out",
        constraintViolations.iterator().next().getMessage()
);

rentalCar.setRented( false );
constraintViolations = validator.validate( rentalCar );

assertEquals( 0, constraintViolations.size() );
```

|  | Since there must be no cyclic dependency in the group and group sequence definitions, one cannot just add `Default` to the sequence redefining `Default` for a class. Instead the class itself has to be added. |
| --- | --- |

The `Default` group sequence overriding is local to the class it is defined on and is not propagated
to associated objects. For the example, this means that adding `DriverChecks` to the default group
sequence of `RentalCar` would not have any effects. Only the group `Default` will be propagated to the
driver association.

Note that you can control the propagated group(s) by declaring a group conversion rule (see
[Section 5.5, “Group conversion”](#section-group-conversion)).

#### 5.4.2. `@GroupSequenceProvider`

In addition to statically redefining default group sequences via `@GroupSequence`, Hibernate Validator
also provides an SPI for the dynamic redefinition of default group sequences depending on the object
state.

For that purpose, you need to implement the interface `DefaultGroupSequenceProvider` and register this
implementation with the target class via the `@GroupSequenceProvider` annotation. In the rental car
scenario, you could for instance dynamically add the `CarChecks` as seen in
[Example 5.11, “Implementing and using a default group sequence provider”](#example-implementing-using-default-group-sequence-provider).

Example 5.11: Implementing and using a default group sequence provider
```
package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

public class RentalCarGroupSequenceProvider
        implements DefaultGroupSequenceProvider<RentalCar> {

    @Override
    public List<Class<?>> getValidationGroups(RentalCar car) {
        List<Class<?>> defaultGroupSequence = new ArrayList<Class<?>>();
        defaultGroupSequence.add( RentalCar.class );

        if ( car != null && !car.isRented() ) {
            defaultGroupSequence.add( CarChecks.class );
        }

        return defaultGroupSequence;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {

    @AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
    private boolean rented;

    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }

    public boolean isRented() {
        return rented;
    }

    public void setRented(boolean rented) {
        this.rented = rented;
    }
}
```

### 5.5. Group conversion

What if you wanted to validate the car related checks together with the driver checks? Of course you
could pass the required groups to the validate call explicitly, but what if you wanted to make these
validations occur as part of the `Default` group validation? Here `@ConvertGroup` comes into play which
allows you to use a different group than the originally requested one during cascaded validation.

Let’s have a look at [Example 5.12, “`@ConvertGroup` usage”](#example-group-conversion-dedault-to-driver-checks). Here `@GroupSequence({
CarChecks.class, Car.class })` is used to combine the car related constraints under the `Default` group
(see [Section 5.4, “Redefining the default group sequence”](#section-default-group-class)). There is also a `@ConvertGroup(from = Default.class, to =
DriverChecks.class)` which ensures the `Default` group gets converted to the `DriverChecks` group during
cascaded validation of the driver association.

Example 5.12: `@ConvertGroup` usage
```
package org.hibernate.validator.referenceguide.chapter05.groupconversion;

public class Driver {

    @NotNull
    private String name;

    @Min(
            value = 18,
            message = "You have to be 18 to drive a car",
            groups = DriverChecks.class
    )
    public int age;

    @AssertTrue(
            message = "You first have to pass the driving test",
            groups = DriverChecks.class
    )
    public boolean hasDrivingLicense;

    public Driver(String name) {
        this.name = name;
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // getters and setters ...
}
```

```
package org.hibernate.validator.referenceguide.chapter05.groupconversion;

@GroupSequence({ CarChecks.class, Car.class })
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    @AssertTrue(
            message = "The car has to pass the vehicle inspection first",
            groups = CarChecks.class
    )
    private boolean passedVehicleInspection;

    @Valid
    @ConvertGroup(from = Default.class, to = DriverChecks.class)
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    public boolean isPassedVehicleInspection() {
        return passedVehicleInspection;
    }

    public void setPassedVehicleInspection(boolean passedVehicleInspection) {
        this.passedVehicleInspection = passedVehicleInspection;
    }

    public Driver getDriver() {
        return driver;
    }

    public void setDriver(Driver driver) {
        this.driver = driver;
    }

    // getters and setters ...
}
```

As a result the validation in [Example 5.13, “Test case for `@ConvertGroup`”](#example-group-conversion-test) succeeds, even though the constraint
on `hasDrivingLicense` belongs to the `DriverChecks` group and only the `Default` group is requested in
the `validate()` call.

Example 5.13: Test case for `@ConvertGroup`
```
// create a car and validate. The Driver is still null and does not get validated
Car car = new Car( "VW", "USD-123", 4 );
car.setPassedVehicleInspection( true );
Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// create a driver who has not passed the driving test
Driver john = new Driver( "John Doe" );
john.setAge( 18 );

// now let's add a driver to the car
car.setDriver( john );
constraintViolations = validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
        "The driver constraint should also be validated as part of the default group",
        constraintViolations.iterator().next().getMessage(),
        "You first have to pass the driving test"
);
```

You can define group conversions wherever `@Valid` can be used, namely associations as well as method
and constructor parameters and return values. Multiple conversions can be specified using
`@ConvertGroup.List`.

However, the following restrictions apply:

* `@ConvertGroup` must only be used in combination with `@Valid`. If used without, a
  `ConstraintDeclarationException` is thrown.
* It is not legal to have multiple conversion rules on the same element with the same from value.
  In this case, a `ConstraintDeclarationException` is raised.
* The `from` attribute must not refer to a group sequence. A `ConstraintDeclarationException` is
  raised in this situation.

|  | Rules are not executed recursively. The first matching conversion rule is used and subsequent rules are ignored. For example if a set of `@ConvertGroup` declarations chains group `A` to `B` and `B` to `C`, the group `A` will be converted to `B` and not to `C`. |
| --- | --- |

## 6. Creating custom constraints

The Jakarta Bean Validation API defines a whole set of standard constraint annotations such as `@NotNull`,
`@Size` etc. In cases where these built-in constraints are not sufficient, you can easily create
custom constraints tailored to your specific validation requirements.

### 6.1. Creating a simple constraint

To create a custom constraint, the following three steps are required:

* Create a constraint annotation
* Implement a validator
* Define a default error message

#### 6.1.1. The constraint annotation

This section shows how to write a constraint annotation which can be used to ensure that a given
string is either completely upper case or lower case. Later on, this constraint will be applied to
the `licensePlate` field of the `Car` class from [Chapter 1, *Getting started*](#validator-gettingstarted) to ensure that
the field is always an upper-case string.

The first thing needed is a way to express the two case modes. While you could use `String` constants,
a better approach is using an enum for that purpose:

Example 6.1: Enum `CaseMode` to express upper vs. lower case
```
package org.hibernate.validator.referenceguide.chapter06;

public enum CaseMode {
    UPPER,
    LOWER;
}
```

The next step is to define the actual constraint annotation. If you’ve never designed an annotation
before, this may look a bit scary, but actually it’s not that hard:

Example 6.2: Defining the `@CheckCase` constraint annotation
```
package org.hibernate.validator.referenceguide.chapter06;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE })
@Retention(RUNTIME)
@Constraint(validatedBy = CheckCaseValidator.class)
@Documented
@Repeatable(List.class)
public @interface CheckCase {

    String message() default "{org.hibernate.validator.referenceguide.chapter06.CheckCase." +
            "message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    CaseMode value();

    @Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        CheckCase[] value();
    }
}
```

An annotation type is defined using the `@interface` keyword. All attributes of an annotation type are
declared in a method-like manner. The specification of the Jakarta Bean Validation API demands, that any
constraint annotation defines:

* an attribute `message` that returns the default key for creating error messages in case the
  constraint is violated
* an attribute `groups` that allows the specification of validation groups, to which this constraint
  belongs (see [Chapter 5, *Grouping constraints*](#chapter-groups)). This must default to an empty array of type Class<?>.
* an attribute `payload` that can be used by clients of the Jakarta Bean Validation API to assign custom
  payload objects to a constraint. This attribute is not used by the API itself. An example for a
  custom payload could be the definition of a severity:

  ```
  public class Severity {
      public interface Info extends Payload {
      }

      public interface Error extends Payload {
      }
  }
  ```

  ```
  public class ContactDetails {
      @NotNull(message = "Name is mandatory", payload = Severity.Error.class)
      private String name;

      @NotNull(message = "Phone number not specified, but not mandatory",
              payload = Severity.Info.class)
      private String phoneNumber;

      // ...
  }
  ```

  Now a client can after the validation of a `ContactDetails` instance access the severity of a
  constraint using `ConstraintViolation.getConstraintDescriptor().getPayload()` and adjust its behavior
  depending on the severity.

Besides these three mandatory attributes there is another one, `value`, allowing for the required case
mode to be specified. The name `value` is a special one, which can be omitted when using the
annotation, if it is the only attribute specified, as e.g. in `@CheckCase(CaseMode.UPPER)`.

In addition, the constraint annotation is decorated with a couple of meta annotations:

* `@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE})`: Defines the supported target
  element types for the constraint. `@CheckCase` may be used on fields (element type `FIELD`), JavaBeans properties
  as well as method return values (`METHOD`), method/constructor parameters (`PARAMETER`) and type argument of
  parameterized types (`TYPE_USE`). The element type `ANNOTATION_TYPE` allows for the creation of composed
  constraints (see [Section 6.4, “Constraint composition”](#section-constraint-composition)) based on `@CheckCase`.

  When creating a class-level constraint (see [Section 2.1.4, “Class-level constraints”](#validator-usingvalidator-classlevel)), the element
  type `TYPE` would have to be used. Constraints targeting the return value of a constructor need to
  support the element type `CONSTRUCTOR`. Cross-parameter constraints (see
  [Section 6.3, “Cross-parameter constraints”](#section-cross-parameter-constraints)) which are used to validate all the parameters of a method
  or constructor together, must support `METHOD` or `CONSTRUCTOR`, respectively.
* `@Retention(RUNTIME)`: Specifies, that annotations of this type will be available at runtime by the
  means of reflection
* `@Constraint(validatedBy = CheckCaseValidator.class)`: Marks the annotation type as constraint
  annotation and specifies the validator to be used to validate elements annotated with `@CheckCase`.
  If a constraint may be used on several data types, several validators may be specified, one for
  each data type.
* `@Documented`: Says, that the use of `@CheckCase` will be contained in the JavaDoc of elements
  annotated with it
* `@Repeatable(List.class)`: Indicates that the annotation can be repeated several times at the
  same place, usually with a different configuration. `List` is the containing annotation type.

This containing annotation type named `List` is also shown in the example. It allows to specify several
`@CheckCase` annotations on the same element, e.g. with different validation groups and messages.
While another name could be used, the Jakarta Bean Validation specification recommends to use the name
`List` and make the annotation an inner annotation of the corresponding constraint type.

#### 6.1.2. The constraint validator

Having defined the annotation, you need to create a constraint validator, which is able to validate
elements with a `@CheckCase` annotation. To do so, implement the Jakarta Bean Validation interface `ConstraintValidator`
as shown below:

Example 6.3: Implementing a constraint validator for the constraint `@CheckCase`
```
package org.hibernate.validator.referenceguide.chapter06;

public class CheckCaseValidator implements ConstraintValidator<CheckCase, String> {

    private CaseMode caseMode;

    @Override
    public void initialize(CheckCase constraintAnnotation) {
        this.caseMode = constraintAnnotation.value();
    }

    @Override
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
        if ( object == null ) {
            return true;
        }

        if ( caseMode == CaseMode.UPPER ) {
            return object.equals( object.toUpperCase() );
        }
        else {
            return object.equals( object.toLowerCase() );
        }
    }
}
```

The `ConstraintValidator` interface defines two type parameters which are set in the implementation.
The first one specifies the annotation type to be validated (`CheckCase`), the second one the type of
elements, which the validator can handle (`String`). In case a constraint supports several data types,
a `ConstraintValidator` for each allowed type has to be implemented and registered at the constraint
annotation as shown above.

The implementation of the validator is straightforward. The `initialize()` method gives you access to
the attribute values of the validated constraint and allows you to store them in a field of the
validator as shown in the example.

The `isValid()` method contains the actual validation logic. For `@CheckCase` this is the check whether
a given string is either completely lower case or upper case, depending on the case mode retrieved
in `initialize()`. Note that the Jakarta Bean Validation specification recommends to consider null values as
being valid. If `null` is not a valid value for an element, it should be annotated with `@NotNull`
explicitly.

##### 6.1.2.1. The `ConstraintValidatorContext`

[Example 6.3, “Implementing a constraint validator for the constraint `@CheckCase`”](#example-constraint-validator)
relies on the default error message generation by just returning `true` or `false` from the `isValid()`
method. Using the passed `ConstraintValidatorContext` object, it is possible to either add additional
error messages or completely disable the default error message generation and solely define custom
error messages. The `ConstraintValidatorContext` API is modeled as fluent interface and is best
demonstrated with an example:

Example 6.4: Using `ConstraintValidatorContext` to define custom error messages
```
package org.hibernate.validator.referenceguide.chapter06.constraintvalidatorcontext;

public class CheckCaseValidator implements ConstraintValidator<CheckCase, String> {

    private CaseMode caseMode;

    @Override
    public void initialize(CheckCase constraintAnnotation) {
        this.caseMode = constraintAnnotation.value();
    }

    @Override
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
        if ( object == null ) {
            return true;
        }

        boolean isValid;
        if ( caseMode == CaseMode.UPPER ) {
            isValid = object.equals( object.toUpperCase() );
        }
        else {
            isValid = object.equals( object.toLowerCase() );
        }

        if ( !isValid ) {
            constraintContext.disableDefaultConstraintViolation();
            constraintContext.buildConstraintViolationWithTemplate(
                    "{org.hibernate.validator.referenceguide.chapter06." +
                    "constraintvalidatorcontext.CheckCase.message}"
            )
            .addConstraintViolation();
        }

        return isValid;
    }
}
```

[Example 6.4, “Using `ConstraintValidatorContext` to define custom error messages”](#example-constraint-validator-context)
shows how you can disable the default error message generation and add a custom error message using
a specified message template. In this example the use of the `ConstraintValidatorContext` results in
the same error message as the default error message generation.

|  | It is important to add each configured constraint violation by calling `addConstraintViolation()`. Only after that the new constraint violation will be created. |
| --- | --- |

|  | **Be aware that the custom message template is passed directly to the Expression Language engine.**   Thus, you should be very careful when integrating user input in a custom message template as it will be interpreted by the Expression Language engine, which is usually not the behavior you want and **could allow malicious users to leak sensitive data or even execute arbitrary code**.   If you need to integrate user input in your message, you must [pass it as an expression variable](#section-hibernateconstraintvalidatorcontext) by unwrapping the context to `HibernateConstraintValidatorContext`.   The following validator is very unsafe as it includes user input in the violation message. If the validated `value` contains EL expressions, they will be executed by the EL engine.  ``` public class UnsafeValidator implements ConstraintValidator<ZipCode, String> {      @Override     public boolean isValid(String value, ConstraintValidatorContext context) {         if ( value == null ) {             return true;         }          context.disableDefaultConstraintViolation();          if ( isInvalid( value ) ) {             context                     .buildConstraintViolationWithTemplate( value + " is not a valid ZIP code" )                     .addConstraintViolation();              return false;         }          return true;     }      private boolean isInvalid(String value) {         // ...         return false;     } } ```    The following pattern must be used instead:  ``` public class SafeValidator implements ConstraintValidator<ZipCode, String> {      @Override     public boolean isValid(String value, ConstraintValidatorContext context) {         if ( value == null ) {             return true;         }          HibernateConstraintValidatorContext hibernateContext = context.unwrap(                 HibernateConstraintValidatorContext.class );         hibernateContext.disableDefaultConstraintViolation();          if ( isInvalid( value ) ) {             hibernateContext                     .addExpressionVariable( "validatedValue", value )                     .buildConstraintViolationWithTemplate( "${validatedValue} is not a valid ZIP code" )                     .addConstraintViolation();              return false;         }          return true;     }      private boolean isInvalid(String value) {         // ...         return false;     } } ```    By using expression variables, Hibernate Validator properly handles escaping and EL expressions won’t be executed. |
| --- | --- |

Refer to [Section 6.2.1, “Custom property paths”](#section-custom-property-paths) to learn how to use the `ConstraintValidatorContext` API to
control the property path of constraint violations for class-level constraints.

##### 6.1.2.2. The `HibernateConstraintValidator` extension

Hibernate Validator provides an extension to the `ConstraintValidator` contract: `HibernateConstraintValidator`.

The purpose of this extension is to provide more contextual information to the `initialize()` method
as, in the current `ConstraintValidator` contract, only the annotation is passed as parameter.

The `initialize()` method of `HibernateConstraintValidator` takes two parameters:

* The `ConstraintDescriptor` of the constraint at hand.
  You can get access to the annotation using `ConstraintDescriptor#getAnnotation()`.
* The `HibernateConstraintValidatorInitializationContext` which provides useful helpers and contextual
  information, such as the clock provider or the temporal validation tolerance.

This extension is marked as incubating so it might be subject to change.
The plan is to standardize it and to include it in Jakarta Bean Validation in the future.

The example below shows how to base your validators on `HibernateConstraintValidator`:

Example 6.5: Using the `HibernateConstraintValidator` contract
```
package org.hibernate.validator.referenceguide.chapter06;

public class MyFutureValidator implements HibernateConstraintValidator<MyFuture, Instant> {

    private Clock clock;

    private boolean orPresent;

    @Override
    public void initialize(ConstraintDescriptor<MyFuture> constraintDescriptor,
            HibernateConstraintValidatorInitializationContext initializationContext) {
        this.orPresent = constraintDescriptor.getAnnotation().orPresent();
        this.clock = initializationContext.getClockProvider().getClock();
    }

    @Override
    public boolean isValid(Instant instant, ConstraintValidatorContext constraintContext) {
        //...

        return false;
    }
}
```

|  | You should only implement one of the `initialize()` methods. Be aware that both are called when initializing the validator. |
| --- | --- |

##### 6.1.2.3. Passing a payload to the constraint validator

From time to time, you might want to condition the constraint validator behavior on some external parameters.

For instance, your zip code validator could vary depending on the locale of your application instance if you have one
instance per country.
Another requirement could be to have different behaviors on specific environments: the staging environment may not have
access to some external production resources necessary for the correct functioning of a validator.

The notion of constraint validator payload was introduced for all these use cases.
It is an object passed from the `Validator` instance to each constraint validator via the `HibernateConstraintValidatorContext`.

The example below shows how to set a constraint validator payload during the `ValidatorFactory` initialization.
Unless you override this default value, all the `Validator`s created by this `ValidatorFactory` will have this
constraint validator payload value set.

Example 6.6: Defining a constraint validator payload during the `ValidatorFactory` initialization
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .constraintValidatorPayload( "US" )
        .buildValidatorFactory();

Validator validator = validatorFactory.getValidator();
```

Another option is to set the constraint validator payload per `Validator` using a context:

Example 6.7: Defining a constraint validator payload using a `Validator` context
```
HibernateValidatorFactory hibernateValidatorFactory = Validation.byDefaultProvider()
        .configure()
        .buildValidatorFactory()
        .unwrap( HibernateValidatorFactory.class );

Validator validator = hibernateValidatorFactory.usingContext()
        .constraintValidatorPayload( "US" )
        .getValidator();

// [...] US specific validation checks

validator = hibernateValidatorFactory.usingContext()
        .constraintValidatorPayload( "FR" )
        .getValidator();

// [...] France specific validation checks
```

Once you have set the constraint validator payload, it can be used in your constraint validators as shown in the example below:

Example 6.8: Using the constraint validator payload in a constraint validator
```
package org.hibernate.validator.referenceguide.chapter06.constraintvalidatorpayload;

public class ZipCodeValidator implements ConstraintValidator<ZipCode, String> {

    public String countryCode;

    @Override
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
        if ( object == null ) {
            return true;
        }

        boolean isValid = false;

        String countryCode = constraintContext
                .unwrap( HibernateConstraintValidatorContext.class )
                .getConstraintValidatorPayload( String.class );

        if ( "US".equals( countryCode ) ) {
            // checks specific to the United States
        }
        else if ( "FR".equals( countryCode ) ) {
            // checks specific to France
        }
        else {
            // ...
        }

        return isValid;
    }
}
```

`HibernateConstraintValidatorContext#getConstraintValidatorPayload()` has a type parameter
and returns the payload only if the payload is of the given type.

|  | It is important to note that the constraint validator payload is different from the dynamic payload you can include in the constraint violation raised.   The whole purpose of this constraint validator payload is to be used to condition the behavior of your constraint validators. It is not included in the constraint violations, unless a specific `ConstraintValidator` implementation passes on the payload to emitted constraint violations by using the [constraint violation dynamic payload mechanism](#section-dynamic-payload). |
| --- | --- |

#### 6.1.3. The error message

The last missing building block is an error message which should be used in case a `@CheckCase`
constraint is violated. To define this, create a file *ValidationMessages.properties* with the
following contents (see also [Section 4.1, “Default message interpolation”](#section-message-interpolation)):

Example 6.9: Defining a custom error message for the `CheckCase` constraint
```
org.hibernate.validator.referenceguide.chapter06.CheckCase.message=Case mode must be {value}.
```

If a validation error occurs, the validation runtime will use the default value, that you specified
for the message attribute of the `@CheckCase` annotation to look up the error message in this resource
bundle.

#### 6.1.4. Using the constraint

You can now use the constraint in the `Car` class from the [Chapter 1, *Getting started*](#validator-gettingstarted) chapter to
specify that the `licensePlate` field should only contain upper-case strings:

Example 6.10: Applying the `@CheckCase` constraint
```
package org.hibernate.validator.referenceguide.chapter06;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    @CheckCase(CaseMode.UPPER)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}
```

Finally, [Example 6.11, “Validating objects with the `@CheckCase` constraint”](#example-using-checkcase) demonstrates how validating a `Car` instance with an invalid
license plate causes the `@CheckCase` constraint to be violated.

Example 6.11: Validating objects with the `@CheckCase` constraint
```
//invalid license plate
Car car = new Car( "Morris", "dd-ab-123", 4 );
Set<ConstraintViolation<Car>> constraintViolations =
        validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
        "Case mode must be UPPER.",
        constraintViolations.iterator().next().getMessage()
);

//valid license plate
car = new Car( "Morris", "DD-AB-123", 4 );

constraintViolations = validator.validate( car );

assertEquals( 0, constraintViolations.size() );
```

### 6.2. Class-level constraints

As discussed earlier, constraints can also be applied on the class level to validate the state of an
entire object. Class-level constraints are defined in the same way as are property constraints.
[Example 6.12, “Implementing a class-level constraint”](#example-implementing-classlevel-constraint) shows constraint annotation and validator of the
`@ValidPassengerCount` constraint you already saw in use in [Example 2.9, “Class-level constraint”](#example-class-level).

Example 6.12: Implementing a class-level constraint
```
package org.hibernate.validator.referenceguide.chapter06.classlevel;

@Target({ TYPE, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { ValidPassengerCountValidator.class })
@Documented
public @interface ValidPassengerCount {

    String message() default "{org.hibernate.validator.referenceguide.chapter06.classlevel." +
            "ValidPassengerCount.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

```
package org.hibernate.validator.referenceguide.chapter06.classlevel;

public class ValidPassengerCountValidator
        implements ConstraintValidator<ValidPassengerCount, Car> {

    @Override
    public void initialize(ValidPassengerCount constraintAnnotation) {
    }

    @Override
    public boolean isValid(Car car, ConstraintValidatorContext context) {
        if ( car == null ) {
            return true;
        }

        return car.getPassengers().size() <= car.getSeatCount();
    }
}
```

As the example demonstrates, you need to use the element type `TYPE` in the `@Target` annotation. This
allows the constraint to be put on type definitions. The validator of the constraint in the example
receives a `Car` in the `isValid()` method and can access the complete object state to decide whether
the given instance is valid or not.

#### 6.2.1. Custom property paths

By default the constraint violation for a class-level constraint is reported on the level of the
annotated type, e.g. `Car`.

In some cases it is preferable though that the violation’s property path refers to one of the
involved properties. For instance you might want to report the `@ValidPassengerCount` constraint
against the passengers property instead of the `Car` bean.

[Example 6.13, “Adding a new `ConstraintViolation` with custom property path”](#example-custom-error)
shows how this can be done by using the constraint validator context passed to `isValid()` to build a
custom constraint violation with a property node for the property passengers. Note that you also
could add several property nodes, pointing to a sub-entity of the validated bean.

Example 6.13: Adding a new `ConstraintViolation` with custom property path
```
package org.hibernate.validator.referenceguide.chapter06.custompath;

public class ValidPassengerCountValidator
        implements ConstraintValidator<ValidPassengerCount, Car> {

    @Override
    public void initialize(ValidPassengerCount constraintAnnotation) {
    }

    @Override
    public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
        if ( car == null ) {
            return true;
        }

        boolean isValid = car.getPassengers().size() <= car.getSeatCount();

        if ( !isValid ) {
            constraintValidatorContext.disableDefaultConstraintViolation();
            constraintValidatorContext
                    .buildConstraintViolationWithTemplate( "{my.custom.template}" )
                    .addPropertyNode( "passengers" ).addConstraintViolation();
        }

        return isValid;
    }
}
```

### 6.3. Cross-parameter constraints

Jakarta Bean Validation distinguishes between two different kinds of constraints.

Generic constraints (which have been discussed so far) apply to the annotated element, e.g. a type,
field, container element, method parameter or return value etc.
Cross-parameter constraints, in contrast, apply to the array of parameters of a method or constructor
and can be used to express validation logic which depends on several parameter values.

In order to define a cross-parameter constraint, its validator class must be annotated with
`@SupportedValidationTarget(ValidationTarget.PARAMETERS)`. The type parameter `T` from the
`ConstraintValidator` interface must resolve to either `Object` or `Object[]` in order to receive the
array of method/constructor arguments in the `isValid()` method.

The following example shows the definition of a cross-parameter constraint which can be used to
check that two `Date` parameters of a method are in the correct order:

Example 6.14: Cross-parameter constraint
```
package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = ConsistentDateParametersValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ConsistentDateParameters {

    String message() default "{org.hibernate.validator.referenceguide.chapter04." +
            "crossparameter.ConsistentDateParameters.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

The definition of a cross-parameter constraint isn’t any different from defining a generic
constraint, i.e. it must specify the members `message()`, `groups()` and `payload()` and be annotated with
`@Constraint`. This meta annotation also specifies the corresponding validator, which is shown in
[Example 6.15, “Generic and cross-parameter constraint”](#example-cross-parameter-validator). Note that besides the element types `METHOD` and `CONSTRUCTOR`
also `ANNOTATION_TYPE` is specified as target of the annotation, in order to enable the creation of
composed constraints based on `@ConsistentDateParameters` (see
[Section 6.4, “Constraint composition”](#section-constraint-composition)).

|  | Cross-parameter constraints are specified directly on the declaration of a method or constructor, which is also the case for return value constraints. In order to improve code readability, it is therefore recommended to choose constraint names - such as `@ConsistentDateParameters` - which make the constraint target apparent. |
| --- | --- |

Example 6.15: Generic and cross-parameter constraint
```
package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ConsistentDateParametersValidator implements
        ConstraintValidator<ConsistentDateParameters, Object[]> {

    @Override
    public void initialize(ConsistentDateParameters constraintAnnotation) {
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 2 ) {
            throw new IllegalArgumentException( "Illegal method signature" );
        }

        //leave null-checking to @NotNull on individual parameters
        if ( value[0] == null || value[1] == null ) {
            return true;
        }

        if ( !( value[0] instanceof Date ) || !( value[1] instanceof Date ) ) {
            throw new IllegalArgumentException(
                    "Illegal method signature, expected two " +
                            "parameters of type Date."
            );
        }

        return ( (Date) value[0] ).before( (Date) value[1] );
    }
}
```

As discussed above, the validation target `PARAMETERS` must be configured for a cross-parameter
validator by using the `@SupportedValidationTarget` annotation. Since a cross-parameter constraint
could be applied to any method or constructor, it is considered a best practice to check for the
expected number and types of parameters in the validator implementation.

As with generic constraints, `null` parameters should be considered valid and `@NotNull` on the
individual parameters should be used to make sure that parameters are not `null`.

|  | Similar to class-level constraints, you can create custom constraint violations on single parameters instead of all parameters when validating a cross-parameter constraint. Just obtain a node builder from the `ConstraintValidatorContext` passed to `isValid()` and add a parameter node by calling `addParameterNode()`. In the example you could use this to create a constraint violation on the end date parameter of the validated method. |
| --- | --- |

In rare situations a constraint is both, generic and cross-parameter. This is the case if a
constraint has a validator class which is annotated with
`@SupportedValidationTarget({ValidationTarget.PARAMETERS, ValidationTarget.ANNOTATED_ELEMENT})` or if
it has a generic and a cross-parameter validator class.

When declaring such a constraint on a method which has parameters and also a return value, the
intended constraint target can’t be determined. Constraints which are generic and cross-parameter at
the same time must therefore define a member `validationAppliesTo()` which allows the constraint user
to specify the constraint’s target as shown in [Example 6.16, “Generic and cross-parameter constraint”](#example-dual-cross-parameter-constraint).

Example 6.16: Generic and cross-parameter constraint
```
package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = {
        ScriptAssertObjectValidator.class,
        ScriptAssertParametersValidator.class
})
@Target({ TYPE, FIELD, PARAMETER, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ScriptAssert {

    String message() default "{org.hibernate.validator.referenceguide.chapter04." +
            "crossparameter.ScriptAssert.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    String script();

    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
}
```

The `@ScriptAssert` constraint has two validators (not shown), a generic and a cross-parameter one and
thus defines the member `validationAppliesTo()`. The default value `IMPLICIT` allows to derive the
target automatically in situations where this is possible (e.g. if the constraint is declared on a
field or on a method which has parameters but no return value).

If the target can not be determined implicitly, it must be set by the user to either `PARAMETERS` or
`RETURN_VALUE` as shown in [Example 6.17, “Specifying the target for a generic and cross-parameter constraint”](#example-dual-cross-parameter-constraint-usage).

Example 6.17: Specifying the target for a generic and cross-parameter constraint
```
@ScriptAssert(script = "arg1.size() <= arg0", validationAppliesTo = ConstraintTarget.PARAMETERS)
public Car buildCar(int seatCount, List<Passenger> passengers) {
    //...
    return null;
}
```

### 6.4. Constraint composition

Looking at the `licensePlate` field of the `Car` class in [Example 6.10, “Applying the `@CheckCase` constraint”](#example-car-with-checkcase), you see three
constraint annotations already. In more complex scenarios, where even more constraints could be applied
to one element, this might easily become a bit confusing. Furthermore, if there was a `licensePlate`
field in another class, you would have to copy all constraint declarations to the other class as
well, violating the DRY principle.

You can address this kind of problem by creating higher level constraints, composed from several
basic constraints. [Example 6.18, “Creating a composing constraint `@ValidLicensePlate`”](#example-composed-constraint) shows a composed constraint annotation which
comprises the constraints `@NotNull`, `@Size` and `@CheckCase`:

Example 6.18: Creating a composing constraint `@ValidLicensePlate`
```
package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, TYPE_USE })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
@Documented
public @interface ValidLicensePlate {

    String message() default "{org.hibernate.validator.referenceguide.chapter06." +
            "constraintcomposition.ValidLicensePlate.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

To create a composed constraint, simply annotate the constraint declaration with its comprising
constraints. If the composed constraint itself requires a validator, this validator is to be
specified within the `@Constraint` annotation. For composed constraints which don’t need an additional
validator such as `@ValidLicensePlate`, just set `validatedBy()` to an empty array.

Using the new composed constraint at the `licensePlate` field is fully equivalent to the previous
version, where the three constraints were declared directly at the field itself:

Example 6.19: Application of composing constraint `ValidLicensePlate`
```
package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

public class Car {

    @ValidLicensePlate
    private String licensePlate;

    //...
}
```

The set of `ConstraintViolation`s retrieved when validating a `Car` instance will contain an entry for
each violated composing constraint of the `@ValidLicensePlate` constraint. If you rather prefer a
single `ConstraintViolation` in case any of the composing constraints is violated, the
`@ReportAsSingleViolation` meta constraint can be used as follows:

Example 6.20: Using @ReportAsSingleViolation
```
package org.hibernate.validator.referenceguide.chapter06.constraintcomposition.reportassingle;

//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

    String message() default "{org.hibernate.validator.referenceguide.chapter06." +
            "constraintcomposition.reportassingle.ValidLicensePlate.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

## 7. Value extraction

Value extraction is the process of extracting values from a container so that
they can be validated.

It is used when dealing with [container element
constraints](#container-element-constraints) and [cascaded validation inside
containers](#example-cascaded-validation-list).

### 7.1. Built-in value extractors

Hibernate Validator comes with built-in value extractors for the usual Java container
types so, except if you are using your own custom container types (or the ones
of external libraries such as [Guava](https://github.com/google/guava)'s `Multimap`),
you should not have to add your own value extractors.

Built-in value extractors are present for all the following container types:

* `java.util.Iterable`;
* `java.util.List`;
* `java.util.Map`: for keys and values;
* `java.util.Optional`, `java.util.OptionalInt`, `java.util.OptionalLong` and `java.util.OptionalDouble`;
* [JavaFX](http://docs.oracle.com/javase/8/javase-clienttechnologies.htm)'s `ObservableValue` (see [Section 7.4, “JavaFX value extractors”](#section-valueextraction-javafx)
  for more details).

The complete list of built-in value extractors with all the details on how they
behave can be found in the
[Jakarta Bean Validation specification](http://beanvalidation.org/2.0/spec/#valueextractordefinition-builtinvalueextractors).

### 7.2. Implementing a `ValueExtractor`

To extract values from a custom container, one needs to implement a `ValueExtractor`.

|  | Implementing a `ValueExtractor` is not enough, you also need to register it. See [Section 7.5, “Registering a `ValueExtractor`”](#section-valueextraction-registeringvalueextractor) for more details. |
| --- | --- |

`ValueExtractor` is a very simple API as the only purpose of a value extractor is to provide
the extracted values to a `ValueReceiver`.

For instance, let’s consider the case of Guava’s `Optional`. It is an easy example
as we can shape its value extractor after the `java.util.Optional` one:

Example 7.1: A `ValueExtractor` for Guava’s `Optional`
```
package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class OptionalValueExtractor
        implements ValueExtractor<Optional<@ExtractedValue ?>> {

    @Override
    public void extractValues(Optional<?> originalValue, ValueReceiver receiver) {
        receiver.value( null, originalValue.orNull() );
    }
}
```

Some explanations are in order:

* The `@ExtractedValue` annotation marks the type argument under consideration: it
  is going to be used to resolve the type of the validated value;
* We use the `value()` method of the receiver as `Optional` is a pure wrapper type;
* We don’t want to add a node to the property path of the constraint violation
  as we want the violation to be reported as if it were directly on the property
  so we pass a `null` node name to `value()`.

A more interesting example is the case of Guava’s `Multimap`: we would like to be
able to validate both the keys and the values of this container type.

Let’s first consider the case of the values. A value extractor extracting them
is required:

Example 7.2: A `ValueExtractor` for `Multimap` values
```
package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class MultimapValueValueExtractor
        implements ValueExtractor<Multimap<?, @ExtractedValue ?>> {

    @Override
    public void extractValues(Multimap<?, ?> originalValue, ValueReceiver receiver) {
        for ( Entry<?, ?> entry : originalValue.entries() ) {
            receiver.keyedValue( "<multimap value>", entry.getKey(), entry.getValue() );
        }
    }
}
```

It allows to validate constraints for the values of the `Multimap`:

Example 7.3: Constraints on the values of a `Multimap`
```
private Multimap<String, @NotBlank String> map1;
```

Another value extractor is required to be able to put constraints on the keys
of a `Multimap`:

Example 7.4: A `ValueExtractor` for `Multimap` keys
```
package org.hibernate.validator.referenceguide.chapter07.valueextractor;

public class MultimapKeyValueExtractor
        implements ValueExtractor<Multimap<@ExtractedValue ?, ?>> {

    @Override
    public void extractValues(Multimap<?, ?> originalValue, ValueReceiver receiver) {
        for ( Object key : originalValue.keySet() ) {
            receiver.keyedValue( "<multimap key>", key, key );
        }
    }
}
```

Once these two value extractors are registered, you can declare constraints on the
keys and values of a `Multimap`:

Example 7.5: Constraints on the keys and values of a `Multimap`
```
private Multimap<@NotBlank String, @NotBlank String> map2;
```

The differences between the two value extractors may be a bit subtle at a first
glance so let’s shed some light on them:

* The `@ExtractedValue` annotation marks the targeted type argument (either
  `K` or `V` in this case).
* We use different node names (`<multimap key>` vs. `<multimap value>`).
* In one case, we pass the values to the receiver (third argument of the
  `keyedValue()` call), in the other, we pass the keys.

Depending on your container type, you should choose the `ValueReceiver`
method fitting the best:

`value()`

for a simple wrapping container - it is used for `Optional`s

`iterableValue()`

for an iterable container - it is used for `Set`s

`indexedValue()`

for a container containing indexed values - it is used for `List`s

`keyedValue()`

for a container containing keyed values - it is used for `Map`s.
It is used for both the keys and the values. In the case of keys,
the key is also passed as the validated value.

For all these methods, you need to pass a node name: it is the name included in
the node added to the property path of the constraint violation. As mentioned
earlier, if the node name is `null`, no node is added to the property path:
it is be useful for pure wrapper types similar to `Optional`.

The choice of the method used is important as it adds contextual information to the
property path of the constraint violation e.g. the index or the key of the
validated value.

### 7.3. Non generic containers

You might have noticed that, until now, we only implemented value extractors
for generic containers.

Hibernate Validator also supports value extraction for non generic containers.

Let’s take the case of `java.util.OptionalInt` which wraps a primitive `int`
into an `Optional`-like container.

A first attempt at a value extractor for `OptionalInt` would look like:

Example 7.6: A `ValueExtractor` for `OptionalInt`
```
package org.hibernate.validator.referenceguide.chapter07.nongeneric;

public class OptionalIntValueExtractor
        implements ValueExtractor<@ExtractedValue(type = Integer.class) OptionalInt> {

    @Override
    public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
        receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
    }
}
```

There is an obvious thing missing for a non generic container: we don’t have
a type parameter. It has two consequences:

* we cannot determine the type of the validated value using the type argument;
* we cannot add constraints on the type argument (e.g. `Container<@NotNull String>`).

First things first, we need a way to tell Hibernate Validator that the value
extracted from an `OptionalInt` is of type `Integer`.
As you can see in the above example, the `type` attribute of the `@ExtractedValue`
annotation allows to provide this information to the validation engine.

Then you have to tell the validation engine that the `Min` constraint you want to
add to the `OptionalInt` property relates to the wrapped value and not the wrapper.

Jakarta Bean Validation provides the `Unwrapping.Unwrap` payload for this situation:

Example 7.7: Using `Unwrapping.Unwrap` payload
```
@Min(value = 5, payload = Unwrapping.Unwrap.class)
private OptionalInt optionalInt1;
```

If we take a step back, most - if not all - the constraints we would like to add to an
`OptionalInt` property would be applied to the wrapped value so having a way to make it
the default would be nice.

This is exactly what the `@UnwrapByDefault` annotation is for:

Example 7.8: A `ValueExtractor` for `OptionalInt` marked with `@UnwrapByDefault`
```
package org.hibernate.validator.referenceguide.chapter07.nongeneric;

@UnwrapByDefault
public class UnwrapByDefaultOptionalIntValueExtractor
        implements ValueExtractor<@ExtractedValue(type = Integer.class) OptionalInt> {

    @Override
    public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
        receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
    }
}
```

When declaring this value extractor for `OptionalInt`, constraint annotations will
by default be applied to the wrapped value:

Example 7.9: Implicit unwrapping thanks to `@UnwrapByDefault`
```
@Min(5)
private OptionalInt optionalInt2;
```

Note that you can still declare an annotation for the wrapper itself by using
the `Unwrapping.Skip` payload:

Example 7.10: Avoid implicit unwrapping with `Unwrapping.Skip`
```
@NotNull(payload = Unwrapping.Skip.class)
@Min(5)
private OptionalInt optionalInt3;
```

|  | The `@UnwrapByDefault` value extractor for `OptionalInt` is part of the built-in value extractors: there is no need to add one. |
| --- | --- |

### 7.4. JavaFX value extractors

Bean properties in JavaFX are typically not of simple data types like `String`
or `int`, but are wrapped in `Property` types which allows to make them observable,
use them for data binding etc.

Thus, value extraction is required to be able to apply constraints on the
wrapped values.

The JavaFX `ObservableValue` value extractor is marked with `@UnwrapByDefault`.
As such, the constraints hosted on the container target the wrapped value by
default.

Thus, you can constrain a `StringProperty` as below:

Example 7.11: Constraining a `StringProperty`
```
@NotBlank
private StringProperty stringProperty;
```

Or a `LongProperty`:

Example 7.12: Constraining a `LongProperty`
```
@Min(5)
private LongProperty longProperty;
```

The iterable property types, namely `ReadOnlyListProperty`,
`ListProperty` and their `Set` and `Map` counterparts are generic and, as such,
container element constraints can be used. Thus, they have specific value
extractors that are not marked with `@UnwrapByDefault`.

A `ReadOnlyListProperty` would naturally be constrained as a `List`:

Example 7.13: Constraining a `ReadOnlyListProperty`
```
@Size(min = 1)
private ReadOnlyListProperty<@NotBlank String> listProperty;
```

### 7.5. Registering a `ValueExtractor`

Hibernate Validator does not detect automatically the value extractors in the
classpath so they have to be registered.

There are several ways to register value extractors (in increasing order of
priority):

Provided by the validation engine itself

See [Section 7.1, “Built-in value extractors”](#section-valueextraction-builtinvalueextractors).

Via the Java service loader mechanism

The file `META-INF/services/javax.validation.valueextraction.ValueExtractor`
must be provided, with the fully-qualified names of one or more value
extractor implementations as its contents, each on a separate line.

In the `META-INF/validation.xml` file

See [Section 8.1, “Configuring the validator factory in *validation.xml*”](#section-configuration-validation-xml) for more information about
how to register value extractors in the XML configuration.

By calling `Configuration#addValueExtractor(ValueExtractor<?>)`

See [Section 9.2.6, “Registering `ValueExtractor`s”](#section-bootstrapping-valueextractors)
for more information.

By invoking `ValidatorContext#addValueExtractor(ValueExtractor<?>)`

It only declares the value extractor for this `Validator` instance.

A value extractor for a given type and type parameter specified at a higher
priority overrides any other extractors for the same type and type parameter
given at lower priorities.

### 7.6. Resolution algorithms

In most cases, you should not have to worry about this but, if you are overriding
existing value extractors, you can find a detailed description of the value
extractors resolution algorithms in the Jakarta Bean Validation specification:

* for [container element constraints](http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-constraints),
* for [cascaded validation](http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-algorithm-cascaded),
* and for [implicit unwrapping](http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping).

One important thing to have in mind is that:

* for container element constraints, the declared type is used to resolve the value
  extractors;
* for cascaded validation, it is the runtime type.

## 8. Configuring via XML

So far we have used the default configuration source for Jakarta Bean Validation, namely annotations.
However, there also exist two kinds of XML descriptors allowing configuration via XML. The first
descriptor describes general Jakarta Bean Validation behaviour and is provided as *META-INF/validation.xml*.
The second one describes constraint declarations and closely matches the constraint declaration
approach via annotations. Let’s have a look at these two document types.

|  | The XSD files are available via <http://xmlns.jcp.org/xml/ns/validation/configuration> and <http://xmlns.jcp.org/xml/ns/validation/mapping>.   More information about the XML schemas can be found on the [Jakarta Bean Validation website](http://beanvalidation.org/xml/ns/validation/). |
| --- | --- |

### 8.1. Configuring the validator factory in *validation.xml*

The key to enable XML configuration for Hibernate Validator is the file *META-INF/validation.xml*.
If this file exists on the classpath its configuration will be applied when the `ValidatorFactory`
gets created. [Figure 1, “Validation configuration schema”](#image-validation-configuration) shows a model view of the XML schema to which
*validation.xml* has to adhere.

![validation-configuration-2.0.xsd](images/validation-configuration-2.0.png)

Figure 1. Validation configuration schema

[Example 8.1, “`validation.xml`”](#example-validation-xml)
shows the several configuration options of *validation.xml*. All settings are optional and the same
configuration options are also available programmatically through `javax.validation.Configuration`. In
fact, the XML configuration will be overridden by values explicitly specified via the programmatic
API. It is even possible to ignore the XML configuration completely via
`Configuration#ignoreXmlConfiguration()`. See also [Section 9.2, “Configuring a `ValidatorFactory`”](#section-configuring-validator-factory).

Example 8.1: `validation.xml`
```
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
        version="2.0">

    <default-provider>com.acme.ValidationProvider</default-provider>

    <message-interpolator>com.acme.MessageInterpolator</message-interpolator>
    <traversable-resolver>com.acme.TraversableResolver</traversable-resolver>
    <constraint-validator-factory>
        com.acme.ConstraintValidatorFactory
    </constraint-validator-factory>
    <parameter-name-provider>com.acme.ParameterNameProvider</parameter-name-provider>
    <clock-provider>com.acme.ClockProvider</clock-provider>

    <value-extractor>com.acme.ContainerValueExtractor</value-extractor>

    <executable-validation enabled="true">
        <default-validated-executable-types>
            <executable-type>CONSTRUCTORS</executable-type>
            <executable-type>NON_GETTER_METHODS</executable-type>
            <executable-type>GETTER_METHODS</executable-type>
        </default-validated-executable-types>
    </executable-validation>

    <constraint-mapping>META-INF/validation/constraints-car.xml</constraint-mapping>

    <property name="hibernate.validator.fail_fast">false</property>
</validation-config>
```

|  | There must only be one file named *META-INF/validation.xml* on the classpath. If more than one is found an exception is thrown. |
| --- | --- |

The node `default-provider` allows to choose the Jakarta Bean Validation provider. This is useful if there is
more than one provider on the classpath. `message-interpolator`, `traversable-resolver`,
`constraint-validator-factory`, `parameter-name-provider` and `clock-provider` allow to customize
the used implementations for the interfaces `MessageInterpolator`, `TraversableResolver`,
`ConstraintValidatorFactory`, `ParameterNameProvider` and `ClockProvider` defined in the
`javax.validation` package.
See the sub-sections of [Section 9.2, “Configuring a `ValidatorFactory`”](#section-configuring-validator-factory) for more information about these
interfaces.

`value-extractor` allows to declare additional value extractors either to extract values from custom
container types or to override the built-in value extractors. See [Chapter 7, *Value extraction*](#chapter-valueextraction) for
more information about how to implement `javax.validation.valueextraction.ValueExtractor`.

`executable-validation` and its subnodes define defaults for method validation. The Jakarta Bean Validation
specification defines constructor and non getter methods as defaults. The enabled attribute acts as
global switch to turn method validation on and off (see also [Chapter 3, *Declaring and validating method constraints*](#chapter-method-constraints)).

Via the `constraint-mapping` element you can list an arbitrary number of additional XML files
containing the actual constraint configuration. Mapping file names must be specified using their
fully-qualified name on the classpath. Details on writing mapping files can be found in the next
section.

Last but not least, you can specify provider specific properties via the `property` nodes. In the
example, we are using the Hibernate Validator specific `hibernate.validator.fail_fast` property (see
[Section 12.2, “Fail fast mode”](#section-fail-fast)).

### 8.2. Mapping constraints via `constraint-mappings`

Expressing constraints in XML is possible via files adhering to the schema seen in
[Figure 2, “Validation mapping schema”](#image-mapping-configuration). Note that these mapping files are only processed if listed via
constraint-mapping in *validation.xml*.

![validation-mapping-2.0.xsd](images/validation-mapping-2.0.png)

Figure 2. Validation mapping schema

[Example 8.2, “Bean constraints configured via XML”](#example-constraints-car) shows how the classes Car and RentalCar from [Example 5.3, “Car”](#example-car) resp.
[Example 5.9, “Class `RentalCar` with redefined default group”](#example-rental-car) could be mapped in XML.

Example 8.2: Bean constraints configured via XML
```
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">

    <default-package>org.hibernate.validator.referenceguide.chapter05</default-package>
    <bean class="Car" ignore-annotations="true">
        <field name="manufacturer">
            <constraint annotation="javax.validation.constraints.NotNull"/>
        </field>
        <field name="licensePlate">
            <constraint annotation="javax.validation.constraints.NotNull"/>
        </field>
        <field name="seatCount">
            <constraint annotation="javax.validation.constraints.Min">
                <element name="value">2</element>
            </constraint>
        </field>
        <field name="driver">
            <valid/>
        </field>
        <field name="partManufacturers">
            <container-element-type type-argument-index="0">
                <valid/>
            </container-element-type>
            <container-element-type type-argument-index="1">
                <container-element-type>
                    <valid/>
                    <constraint annotation="javax.validation.constraints.NotNull"/>
                </container-element-type>
            </container-element-type>
        </field>
        <getter name="passedVehicleInspection" ignore-annotations="true">
            <constraint annotation="javax.validation.constraints.AssertTrue">
                <message>The car has to pass the vehicle inspection first</message>
                <groups>
                    <value>CarChecks</value>
                </groups>
                <element name="max">10</element>
            </constraint>
        </getter>
    </bean>
    <bean class="RentalCar" ignore-annotations="true">
        <class ignore-annotations="true">
            <group-sequence>
                <value>RentalCar</value>
                <value>CarChecks</value>
            </group-sequence>
        </class>
    </bean>
    <constraint-definition annotation="org.mycompany.CheckCase">
        <validated-by include-existing-validators="false">
            <value>org.mycompany.CheckCaseValidator</value>
        </validated-by>
    </constraint-definition>
</constraint-mappings>
```

[Example 8.3, “Method constraints configured via XML”](#example-rental-station-xml) shows how the constraints from
[Example 3.1, “Declaring method and constructor parameter constraints”](#example-declaring-parameter-constraints), [Example 3.4, “Declaring method and constructor return value constraints”](#example-declaring-return-value-constraints)
and [Example 3.3, “Specifying a constraint’s target”](#example-specifying-constraint-target) can be expressed in XML.

Example 8.3: Method constraints configured via XML
```
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">

    <default-package>org.hibernate.validator.referenceguide.chapter08</default-package>

    <bean class="RentalStation" ignore-annotations="true">
        <constructor>
            <return-value>
                <constraint annotation="ValidRentalStation"/>
            </return-value>
        </constructor>

        <constructor>
            <parameter type="java.lang.String">
                <constraint annotation="javax.validation.constraints.NotNull"/>
            </parameter>
        </constructor>

        <method name="getCustomers">
            <return-value>
                <constraint annotation="javax.validation.constraints.NotNull"/>
                <constraint annotation="javax.validation.constraints.Size">
                    <element name="min">1</element>
                </constraint>
            </return-value>
        </method>

        <method name="rentCar">
            <parameter type="Customer">
                <constraint annotation="javax.validation.constraints.NotNull"/>
            </parameter>
            <parameter type="java.util.Date">
                <constraint annotation="javax.validation.constraints.NotNull"/>
                <constraint annotation="javax.validation.constraints.Future"/>
            </parameter>
            <parameter type="int">
                <constraint annotation="javax.validation.constraints.Min">
                    <element name="value">1</element>
                </constraint>
            </parameter>
        </method>

        <method name="addCars">
            <parameter type="java.util.List">
                <container-element-type>
                    <valid/>
                    <constraint annotation="javax.validation.constraints.NotNull"/>
                </container-element-type>
            </parameter>
        </method>
    </bean>

    <bean class="Garage" ignore-annotations="true">
        <method name="buildCar">
            <parameter type="java.util.List"/>
            <cross-parameter>
                <constraint annotation="ELAssert">
                    <element name="expression">...</element>
                    <element name="validationAppliesTo">PARAMETERS</element>
                </constraint>
            </cross-parameter>
        </method>
        <method name="paintCar">
            <parameter type="int"/>
            <return-value>
                <constraint annotation="ELAssert">
                    <element name="expression">...</element>
                    <element name="validationAppliesTo">RETURN_VALUE</element>
                </constraint>
            </return-value>
        </method>
    </bean>

</constraint-mappings>
```

The XML configuration is closely mirroring the programmatic API. For this reason it should suffice
to just add some comments. `default-package` is used for all fields where a class name is expected. If
the specified class is not fully qualified the configured default package will be used. Every
mapping file can then have several bean nodes, each describing the constraints on the entity with
the specified class name.

|  | A given class can only be configured once across all configuration files. The same applies for constraint definitions for a given constraint annotation. It can only occur in one mapping file. If these rules are violated a `ValidationException` is thrown. |
| --- | --- |

Setting `ignore-annotations` to `true` means that constraint annotations placed on the configured bean
are ignored. The default for this value is true. `ignore-annotations` is also available for the nodes
`class`, `fields`, `getter`, `constructor`, `method`, `parameter`, `cross-parameter` and `return-value`.
If not explicitly specified on these levels the configured bean value applies.

The nodes `class`, `field`, `getter`, `container-element-type`, `constructor` and `method`
(and its sub node parameter) determine on which level the constraint gets placed.
The `valid` node is used to enable cascaded validation and the `constraint` node to add a constraint
on the corresponding level.
Each constraint definition must define the class via the `annotation` attribute.
The constraint attributes required by the Jakarta Bean Validation specification (`message`, `groups` and
`payload`) have dedicated nodes. All other constraint specific attributes are configured using the
`element` node.

|  | `container-element-type` allows to define the cascaded validation behavior and the constraints for container elements. In the above examples, you can see an example of nested container element constraints on a `List` nested in the values of a `Map`. `type-argument-index` is used to precise which type argument of the `Map` is concerned by the configuration. It can be ommitted if the type only has one type argument (e.g. the `List`s in our examples). |
| --- | --- |

The `class` node also allows to reconfigure the default group sequence (see
[Section 5.4, “Redefining the default group sequence”](#section-default-group-class)) via the `group-sequence` node. Not shown in the example is the use
of `convert-group` to
specify group conversions (see [Section 5.5, “Group conversion”](#section-group-conversion)). This node is available on `field`,
`getter`, `container-element-type`, `parameter` and `return-value` and specifies a `from` and a `to`
attributes to specify the groups.

Last but not least, the list of `ConstraintValidator` instances associated to a given constraint
can be altered via the `constraint-definition` node. The annotation attribute represents the constraint
annotation being altered. The `validated-by` element represent the (ordered) list of `ConstraintValidator`
implementations associated to the constraint. If `include-existing-validator` is set to `false`,
validators defined on the constraint annotation are ignored. If set to `true`, the list of constraint
validators described in XML is concatenated to the list of validators specified on the annotation.

|  | One use case for constraint-definition is to change the default constraint definition for `@URL`. Historically, Hibernate Validator’s default constraint validator for this constraint uses the `java.net.URL` constructor to verify that an URL is valid. However, there is also a purely regular expression based version available which can be configured using XML:  Using XML to register a regular expression based constraint definition for `@URL` ``` <constraint-definition annotation="org.hibernate.validator.constraints.URL">   <validated-by include-existing-validators="false">     <value>org.hibernate.validator.constraintvalidators.RegexpURLValidator</value>   </validated-by> </constraint-definition> ``` |
| --- | --- |

## 9. Bootstrapping

In [Section 2.2.1, “Obtaining a `Validator` instance”](#section-obtaining-validator), you already saw one way of creating a `Validator` instance - via
`Validation#buildDefaultValidatorFactory()`. In this chapter, you will learn how to use the other
methods in `javax.validation.Validation` in order to bootstrap specifically configured validators.

### 9.1. Retrieving `ValidatorFactory` and `Validator`

You obtain a `Validator` by retrieving a `ValidatorFactory` via one of the static methods on
`javax.validation.Validation` and calling `getValidator()` on the factory instance.

[Example 9.1, “Bootstrapping default `ValidatorFactory` and `Validator`”](#example-build-default-validator-factory) shows how to obtain a validator from the default
validator factory:

Example 9.1: Bootstrapping default `ValidatorFactory` and `Validator`
```
ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

|  | The generated `ValidatorFactory` and `Validator` instances are thread-safe and can be cached. As Hibernate Validator uses the factory as context for caching constraint metadata it is recommended to work with one factory instance within an application. |
| --- | --- |

Jakarta Bean Validation supports working with several providers such as Hibernate Validator within one
application. If more than one provider is present on the classpath, it is not guaranteed which one
is chosen when creating a factory via `buildDefaultValidatorFactory()`.

In this case, you can explicitly specify the provider to use via `Validation#byProvider()`, passing the
provider’s `ValidationProvider` class as shown in [Example 9.2, “Bootstrapping `ValidatorFactory` and `Validator` using a specific provider”](#example-using-specific-provider).

Example 9.2: Bootstrapping `ValidatorFactory` and `Validator` using a specific provider
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

Note that the configuration object returned by `configure()` allows to specifically customize the
factory before calling `buildValidatorFactory()`. The available options are discussed later in this
chapter.

Similarly you can retrieve the default validator factory for configuration which is demonstrated in
[Example 9.3, “Retrieving the default `ValidatorFactory` for configuration”](#example-configuring-default-provider).

Example 9.3: Retrieving the default `ValidatorFactory` for configuration
```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

|  | If a `ValidatorFactory` instance is no longer in use, it should be disposed by calling `ValidatorFactory#close()`. This will free any resources possibly allocated by the factory. |
| --- | --- |

#### 9.1.1. `ValidationProviderResolver`

By default, available Jakarta Bean Validation providers are discovered using the
[Java
Service Provider](http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider) mechanism.

For that purpose, each provider includes the file *META-
INF/services/javax.validation.spi.ValidationProvider*, containing the fully qualified classname of
its `ValidationProvider` implementation. In the case of Hibernate Validator, this is
`org.hibernate.validator.HibernateValidator`.

Depending on your environment and its classloading specifics, provider discovery via the Java’s
service loader mechanism might not work. In this case, you can plug in a custom
`ValidationProviderResolver` implementation which performs the provider retrieval. An example is OSGi,
where you could implement a provider resolver which uses OSGi services for provider discovery.

To use a custom provider resolver, pass it via `providerResolver()` as shown in
[Example 9.4, “Using a custom `ValidationProviderResolver`”](#example-using-custom-validation-provider-resolver).

Example 9.4: Using a custom `ValidationProviderResolver`
```
package org.hibernate.validator.referenceguide.chapter09;

public class OsgiServiceDiscoverer implements ValidationProviderResolver {

    @Override
    public List<ValidationProvider<?>> getValidationProviders() {
        //...
        return null;
    }
}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .providerResolver( new OsgiServiceDiscoverer() )
        .configure()
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

### 9.2. Configuring a `ValidatorFactory`

By default, validator factories retrieved from `Validation` and any validators they create are
configured as per the XML descriptor *META-INF/validation.xml* (see [Chapter 8, *Configuring via XML*](#chapter-xml-configuration)),
if present.

If you want to disable the XML based configuration, you can do so by invoking
`Configuration#ignoreXmlConfiguration()`.

The different values of the XML configuration can be accessed via
`Configuration#getBootstrapConfiguration()`. This can for instance be helpful if you want to integrate
Jakarta Bean Validation into a managed environment and want to create managed instances of the objects
configured via XML.

Using the fluent configuration API, you can override one or more of the settings when bootstrapping
the factory. The following sections show how to make use of the different options. Note that the
`Configuration` class exposes the default implementations of the different extension points which can
be useful if you want to use these as delegates for your custom implementations.

#### 9.2.1. `MessageInterpolator`

Message interpolators are used by the validation engine to create user readable error messages from
constraint message descriptors.

In case the default message interpolation algorithm described in [Chapter 4, *Interpolating constraint error messages*](#chapter-message-interpolation)
is not sufficient for your needs, you can pass in your own implementation of the `MessageInterpolator`
interface via `Configuration#messageInterpolator()` as shown in
[Example 9.5, “Using a custom `MessageInterpolator`”](#example-using-custom-message-interpolator).

Example 9.5: Using a custom `MessageInterpolator`
```
package org.hibernate.validator.referenceguide.chapter09;

public class MyMessageInterpolator implements MessageInterpolator {

    @Override
    public String interpolate(String messageTemplate, Context context) {
        //...
        return null;
    }

    @Override
    public String interpolate(String messageTemplate, Context context, Locale locale) {
        //...
        return null;
    }
}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .messageInterpolator( new MyMessageInterpolator() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

#### 9.2.2. `TraversableResolver`

In some cases the validation engine should not access the state of a bean property.
The most obvious example for that is a lazily loaded property or association of a JPA entity.
Validating this lazy property or association would mean that its state would have to be accessed,
triggering a load from the database.

Which properties can be accessed and which ones not is controlled by querying the
`TraversableResolver` interface. [Example 9.6, “Using a custom `TraversableResolver`”](#example-using-custom-traversable-resolver) shows how to use a
custom traversable resolver implementation.

Example 9.6: Using a custom `TraversableResolver`
```
package org.hibernate.validator.referenceguide.chapter09;

public class MyTraversableResolver implements TraversableResolver {

    @Override
    public boolean isReachable(
            Object traversableObject,
            Node traversableProperty,
            Class<?> rootBeanType,
            Path pathToTraversableObject,
            ElementType elementType) {
        //...
        return false;
    }

    @Override
    public boolean isCascadable(
            Object traversableObject,
            Node traversableProperty,
            Class<?> rootBeanType,
            Path pathToTraversableObject,
            ElementType elementType) {
        //...
        return false;
    }
}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .traversableResolver( new MyTraversableResolver() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

If no specific traversable resolver has been configured, the default behavior is to consider all properties as reachable and cascadable.
When using Hibernate Validator together with a JPA 2 provider such as Hibernate ORM, only those properties will be considered reachable
which already have been loaded by the persistence provider and all properties will be considered cascadable.

By default, the traversable resolver calls are cached per validation call.
This is especially important in a JPA environment where calling `isReachable()` has a significant cost.

This caching adds some overhead.
In the case your custom traversable resolver is very fast, it might be better to consider turning off the cache.

You can disable the cache either via the XML configuration:

Example 9.7: Disabling the `TraversableResolver` result cache via the XML configuration
```
<?xml version="1.0" encoding="UTF-8"?>
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration validation-configuration-2.0.xsd"
        version="2.0">
    <default-provider>org.hibernate.validator.HibernateValidator</default-provider>

    <property name="hibernate.validator.enable_traversable_resolver_result_cache">false</property>
</validation-config>
```

or via the programmatic API:

Example 9.8: Disabling the `TraversableResolver` result cache via the programmatic API
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .traversableResolver( new MyFastTraversableResolver() )
        .enableTraversableResolverResultCache( false )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

#### 9.2.3. `ConstraintValidatorFactory`

`ConstraintValidatorFactory` is the extension point for customizing how constraint validators are
instantiated and released.

The default `ConstraintValidatorFactory` provided by Hibernate Validator requires a public no-arg
constructor to instantiate `ConstraintValidator` instances (see [Section 6.1.2, “The constraint validator”](#section-constraint-validator)).
Using a custom `ConstraintValidatorFactory` offers for example the possibility to use dependency
injection in constraint validator implementations.

To configure a custom constraint validator factory call `Configuration#constraintValidatorFactory()`
(see [Example 9.9, “Using a custom `ConstraintValidatorFactory`”](#example-using-custom-constraint-validator-factory).

Example 9.9: Using a custom `ConstraintValidatorFactory`
```
package org.hibernate.validator.referenceguide.chapter09;

public class MyConstraintValidatorFactory implements ConstraintValidatorFactory {

    @Override
    public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key) {
        //...
        return null;
    }

    @Override
    public void releaseInstance(ConstraintValidator<?, ?> instance) {
        //...
    }
}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .constraintValidatorFactory( new MyConstraintValidatorFactory() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

|  | Any constraint implementations relying on `ConstraintValidatorFactory` behaviors specific to an implementation (dependency injection, no no-arg constructor and so on) are not considered portable. |
| --- | --- |

|  | `ConstraintValidatorFactory` implementations should not cache validator instances as the state of each instance can be altered in the `initialize()` method. |
| --- | --- |

#### 9.2.4. `ParameterNameProvider`

In case a method or constructor parameter constraint is violated, the `ParameterNameProvider`
interface is used to retrieve the parameter name and make it available to the user via the
property path of the constraint violation.

The default implementation returns parameter names as obtained through the Java reflection API.
If you compile your sources using the `-parameters` compiler flag, the actual parameter names as
in the source code will be returned. Otherwise synthetic names in the form of `arg0`, `arg1` etc.
will be used.

To use a custom parameter name provider either pass an instance of
the provider during bootstrapping as shown in [Example 9.10, “Using a custom `ParameterNameProvider`”](#example-using-custom-parameter-name-provider),
or specify the fully qualified class name of the provider as value for
the `<parameter-name-provider>` element in the *META-INF/validation.xml* file
(see [Section 8.1, “Configuring the validator factory in *validation.xml*”](#section-configuration-validation-xml)). This is demonstrated in
[Example 9.10, “Using a custom `ParameterNameProvider`”](#example-using-custom-parameter-name-provider).

Example 9.10: Using a custom `ParameterNameProvider`
```
package org.hibernate.validator.referenceguide.chapter09;

public class MyParameterNameProvider implements ParameterNameProvider {

    @Override
    public List<String> getParameterNames(Constructor<?> constructor) {
        //...
        return null;
    }

    @Override
    public List<String> getParameterNames(Method method) {
        //...
        return null;
    }
}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .parameterNameProvider( new MyParameterNameProvider() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

|  | Hibernate Validator comes with a custom `ParameterNameProvider` implementation based on the [ParaNamer](https://github.com/paul-hammant/paranamer/) library which provides several ways for obtaining parameter names at runtime. Refer to [Section 12.13, “Paranamer based `ParameterNameProvider`”](#section-paranamer-parameternameprovider) to learn more about this specific implementation. |
| --- | --- |

#### 9.2.5. `ClockProvider` and temporal validation tolerance

For time related validation (`@Past` and `@Future` constraints for instance), it might be useful to define what is
considered `now`.

This is especially important when you want to test your constraints in a reliable manner.

The reference time is defined by the `ClockProvider` contract. The responsibility of the `ClockProvider` is to
provide a `java.time.Clock` defining `now` for time related validators.

Example 9.11: Using a custom `ClockProvider`
```
package org.hibernate.validator.referenceguide.chapter09;

import java.time.Clock;
import java.time.ZonedDateTime;

import javax.validation.ClockProvider;

public class FixedClockProvider implements ClockProvider {

    private Clock clock;

    public FixedClockProvider(ZonedDateTime dateTime) {
        clock = Clock.fixed( dateTime.toInstant(), dateTime.getZone() );
    }

    @Override
    public Clock getClock() {
        return clock;
    }

}
```

```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .clockProvider( new FixedClockProvider( ZonedDateTime.of( 2016, 6, 15, 0, 0, 0, 0, ZoneId.of( "Europe/Paris" ) ) ) )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

Alternatively, you can specify the fully-qualified classname of a `ClockProvider` implementation using the
`<clock-provider>` element when configuring the default validator factory via *META-INF/validation.xml*
(see [Chapter 8, *Configuring via XML*](#chapter-xml-configuration)).

|  | When validating `@Future` and `@Past` constraints, you might want to obtain the current time.   You can obtain the `ClockProvider` in your validators by calling the `ConstraintValidatorContext#getClockProvider()` method.   For instance, this might be useful if you want to replace the default message of the `@Future` constraint with a more explicit one. |
| --- | --- |

When dealing with distributed architectures, you might need some tolerance when applying temporal constraints
such as `@Past` or `@Future`.

You can set a temporal validation tolerance by bootstrapping your `ValidatorFactory` as below:

Example 9.12: Using temporal validation tolerance
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .temporalValidationTolerance( Duration.ofMillis( 10 ) )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

Alternatively, you can define it in the XML configuration by setting the `hibernate.validator.temporal_validation_tolerance` property
in your *META-INF/validation.xml*.

The value of this property must be a `long` defining the tolerance in milliseconds.

|  | When implementing your own temporal constraints, you might need to have access to the temporal validation tolerance.   It can be obtained by calling the `HibernateConstraintValidatorInitializationContext#getTemporalValidationTolerance()` method.   Note that to get access to this context at initialization, your constraint validator has to implement the `HibernateConstraintValidator` contract (see [Section 6.1.2.2, “The `HibernateConstraintValidator` extension”](#constraint-validator-hibernateconstraintvalidator)). This contract is currently marked as incubating: it might be subject to change in the future. |
| --- | --- |

#### 9.2.6. Registering `ValueExtractor`s

As mentioned in [Chapter 7, *Value extraction*](#chapter-valueextraction), additional value extractors can be registered during bootstrapping
(see [Section 7.5, “Registering a `ValueExtractor`”](#section-valueextraction-registeringvalueextractor) for the other ways to register a value extractor).

[Example 9.13, “Registering additional value extractors”](#example-registering-value-extractor) shows how we would register the value extractors we previously created
to extract the keys and the values of Guava’s `Multimap`.

Example 9.13: Registering additional value extractors
```
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .addValueExtractor( new MultimapKeyValueExtractor() )
        .addValueExtractor( new MultimapValueValueExtractor() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

#### 9.2.7. Adding mapping streams

As discussed earlier, you can configure the constraints applied to your Java beans using XML based
constraint mappings.

Besides the mapping files specified in *META-INF/validation.xml*, you can add further mappings via
`Configuration#addMapping()` (see [Example 9.14, “Adding constraint mapping streams”](#example-adding-mapping-streams)). Note that the passed input
stream(s) must adhere to the XML schema for constraint mappings presented in
[Section 8.2, “Mapping constraints via `constraint-mappings`”](#section-mapping-xml-constraints).

Example 9.14: Adding constraint mapping streams
```
InputStream constraintMapping1 = null;
InputStream constraintMapping2 = null;
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
        .configure()
        .addMapping( constraintMapping1 )
        .addMapping( constraintMapping2 )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

You should close any passed input stream after the validator factory has been created.

#### 9.2.8. Provider-specific settings

Via the configuration object returned by `Validation#byProvider()`, provider specific options can be
configured.

In the case of Hibernate Validator, this e.g. allows you to enable the fail fast mode and pass one or
more programmatic constraint mappings as demonstrated in
[Example 9.15, “Setting Hibernate Validator specific options”](#example-hibernate-validator-specific-options).

Example 9.15: Setting Hibernate Validator specific options
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .failFast( true )
        .addMapping( (ConstraintMapping) null )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

Alternatively, provider-specific options can be passed via `Configuration#addProperty()`. Hibernate
Validator supports enabling the fail fast mode that way, too:

Example 9.16: Enabling a Hibernate Validator specific option via `addProperty()`
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .addProperty( "hibernate.validator.fail_fast", "true" )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

Refer to [Section 12.2, “Fail fast mode”](#section-fail-fast) and [Section 12.4, “Programmatic constraint definition and declaration”](#section-programmatic-api) to learn more about the fail fast
mode and the constraint declaration API.

#### 9.2.9. Configuring the `ScriptEvaluatorFactory`

For constraints like `@ScriptAssert` and `@ParameterScriptAssert`, it might be useful to configure
how the script engines are initialized and how the script evaluators are built.
This can be done by setting a custom implementation of `ScriptEvaluatorFactory`.

In particular, this is important for modular environments (e.g. OSGi), where user might face issues
with modular class loading and [JSR 223](https://www.jcp.org/en/jsr/detail?id=223).
It also allows to use any custom script engine, not necessarily based on the
[JSR 223](https://www.jcp.org/en/jsr/detail?id=223) (e.g. Spring Expression Language).

##### 9.2.9.1. XML configuration

To specify the `ScriptEvaluatorFactory` via XML, you need to define the `hibernate.validator.script_evaluator_factory`
property.

Example 9.17: Defining the `ScriptEvaluatorFactory` via XML
```
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
        version="2.0">

    <property name="hibernate.validator.script_evaluator_factory">
        org.hibernate.validator.referenceguide.chapter09.CustomScriptEvaluatorFactory
    </property>

</validation-config>
```

In this case, the specified `ScriptEvaluatorFactory` must have a no-arg constructor.

##### 9.2.9.2. Programmatic configuration

To configure it programmatically, you need to pass an instance of `ScriptEvaluatorFactory` to the `ValidatorFactory`.
This gives more flexibility in the configuration of the `ScriptEvaluatorFactory`. [Example 9.18, “Defining the `ScriptEvaluatorFactory` programmatically”](#example-script-evaluator-factory-programmatically)
shows how this can be done.

Example 9.18: Defining the `ScriptEvaluatorFactory` programmatically
```
ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
        .configure()
        .scriptEvaluatorFactory( new CustomScriptEvaluatorFactory() )
        .buildValidatorFactory();
Validator validator = validatorFactory.getValidator();
```

##### 9.2.9.3. Custom `ScriptEvaluatorFactory` implementation examples

This section shows a couple of custom `ScriptEvaluatorFactory` implementations that can be used
in modular environments as well as one using the [Spring Expression Language](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions)
for writing constraint scripts.

Problems with modular environments and [JSR 223](https://www.jcp.org/en/jsr/detail?id=223) come from the class loading.
The class loader where the script engine is available might be different from the one of Hibernate Validator.
Thus the script engine wouldn’t be found using the default strategy.

To solve this issue, the `MultiClassLoaderScriptEvaluatorFactory` class below can be introduced:

```
/*
 * Hibernate Validator, declare and validate application constraints
 *
 * License: Apache License, Version 2.0
 * See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
 */
package org.hibernate.validator.osgi.scripting;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;

import org.hibernate.validator.spi.scripting.AbstractCachingScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEngineScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluationException;
import org.hibernate.validator.spi.scripting.ScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory;

/**
 * {@link ScriptEvaluatorFactory} that allows you to pass multiple {@link ClassLoader}s that will be used
 * to search for {@link ScriptEngine}s. Useful in environments similar to OSGi, where script engines can be
 * found only in {@link ClassLoader}s different from default one.
 *
 * @author Marko Bekhta
 */
public class MultiClassLoaderScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

    private final ClassLoader[] classLoaders;

    public MultiClassLoaderScriptEvaluatorFactory(ClassLoader... classLoaders) {
        if ( classLoaders.length == 0 ) {
            throw new IllegalArgumentException( "No class loaders were passed" );
        }
        this.classLoaders = classLoaders;
    }

    @Override
    protected ScriptEvaluator createNewScriptEvaluator(String languageName) {
        for ( ClassLoader classLoader : classLoaders ) {
            ScriptEngine engine = new ScriptEngineManager( classLoader ).getEngineByName( languageName );
            if ( engine != null ) {
                return new ScriptEngineScriptEvaluator( engine );
            }
        }
        throw new ScriptEvaluationException( "No JSR 223 script engine found for language " + languageName );
    }
}
```

and then declared with:

```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .scriptEvaluatorFactory(
                new MultiClassLoaderScriptEvaluatorFactory( GroovyScriptEngineFactory.class.getClassLoader() )
        )
        .buildValidatorFactory()
        .getValidator();
```

This way, it is possible to pass multiple `ClassLoader` instances: typically the class loaders of the wanted `ScriptEngine`s.

An alternative approach for OSGi environments can be to use the `OsgiScriptEvaluatorFactory` defined below:

```
/*
 * Hibernate Validator, declare and validate application constraints
 *
 * License: Apache License, Version 2.0
 * See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
 */
package org.hibernate.validator.osgi.scripting;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;
import javax.validation.ValidationException;

import org.hibernate.validator.spi.scripting.AbstractCachingScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEngineScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluator;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory;
import org.hibernate.validator.spi.scripting.ScriptEvaluatorNotFoundException;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;

/**
 * {@link ScriptEvaluatorFactory} suitable for OSGi environments. It is created
 * based on the {@code BundleContext} which is used to iterate through {@code Bundle}s and find all {@link ScriptEngineFactory}
 * candidates.
 *
 * @author Marko Bekhta
 */
public class OsgiScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

    private final List<ScriptEngineManager> scriptEngineManagers;

    public OsgiScriptEvaluatorFactory(BundleContext context) {
        this.scriptEngineManagers = Collections.unmodifiableList( findManagers( context ) );
    }

    @Override
    protected ScriptEvaluator createNewScriptEvaluator(String languageName) throws ScriptEvaluatorNotFoundException {
        return scriptEngineManagers.stream()
                .map( manager -> manager.getEngineByName( languageName ) )
                .filter( Objects::nonNull )
                .map( engine -> new ScriptEngineScriptEvaluator( engine ) )
                .findFirst()
                .orElseThrow( () -> new ValidationException( String.format( "Unable to find script evaluator for '%s'.", languageName ) ) );
    }

    private List<ScriptEngineManager> findManagers(BundleContext context) {
        return findFactoryCandidates( context ).stream()
                .map( className -> {
                    try {
                        return new ScriptEngineManager( Class.forName( className ).getClassLoader() );
                    }
                    catch (ClassNotFoundException e) {
                        throw new ValidationException( "Unable to instantiate '" + className + "' based engine factory manager.", e );
                    }
                } ).collect( Collectors.toList() );
    }

    /**
     * Iterates through all bundles to get the available {@link ScriptEngineFactory} classes
     *
     * @return the names of the available ScriptEngineFactory classes
     *
     * @throws IOException
     */
    private List<String> findFactoryCandidates(BundleContext context) {
        return Arrays.stream( context.getBundles() )
                .filter( Objects::nonNull )
                .filter( bundle -> !"system.bundle".equals( bundle.getSymbolicName() ) )
                .flatMap( this::toStreamOfResourcesURL )
                .filter( Objects::nonNull )
                .flatMap( url -> toListOfFactoryCandidates( url ).stream() )
                .collect( Collectors.toList() );
    }

    private Stream<URL> toStreamOfResourcesURL(Bundle bundle) {
        Enumeration<URL> entries = bundle.findEntries(
                "META-INF/services",
                "javax.script.ScriptEngineFactory",
                false
        );
        return entries != null ? Collections.list( entries ).stream() : Stream.empty();
    }

    private List<String> toListOfFactoryCandidates(URL url) {
        try ( BufferedReader reader = new BufferedReader( new InputStreamReader( url.openStream(), "UTF-8" ) ) ) {
            return reader.lines()
                    .map( String::trim )
                    .filter( line -> !line.isEmpty() )
                    .filter( line -> !line.startsWith( "#" ) )
                    .collect( Collectors.toList() );
        }
        catch (IOException e) {
            throw new ValidationException( "Unable to read the ScriptEngineFactory resource file", e );
        }
    }
}
```

and then declared with:

```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .scriptEvaluatorFactory(
                new OsgiScriptEvaluatorFactory( FrameworkUtil.getBundle( this.getClass() ).getBundleContext() )
        )
        .buildValidatorFactory()
        .getValidator();
```

It is designed specifically for OSGi environments and allows you to pass the `BundleContext` which will be used to search
for `ScriptEngineFactory` as a parameter.

As already mentioned, you can also use script engines that are not based on [JSR 223](https://www.jcp.org/en/jsr/detail?id=223).

For instance, to use the [Spring Expression Language](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions),
you can define a `SpringELScriptEvaluatorFactory` as:

```
package org.hibernate.validator.referenceguide.chapter09;

public class SpringELScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

    @Override
    public ScriptEvaluator createNewScriptEvaluator(String languageName) {
        if ( !"spring".equalsIgnoreCase( languageName ) ) {
            throw new IllegalStateException( "Only Spring EL is supported" );
        }

        return new SpringELScriptEvaluator();
    }

    private static class SpringELScriptEvaluator implements ScriptEvaluator {

        private final ExpressionParser expressionParser = new SpelExpressionParser();

        @Override
        public Object evaluate(String script, Map<String, Object> bindings) throws ScriptEvaluationException {
            try {
                Expression expression = expressionParser.parseExpression( script );
                EvaluationContext context = new StandardEvaluationContext( bindings.values().iterator().next() );
                for ( Entry<String, Object> binding : bindings.entrySet() ) {
                    context.setVariable( binding.getKey(), binding.getValue() );
                }
                return expression.getValue( context );
            }
            catch (ParseException | EvaluationException e) {
                throw new ScriptEvaluationException( "Unable to evaluate SpEL script", e );
            }
        }
    }
}
```

This factory allows to use Spring Expression Language in `ScriptAssert` and `ParameterScriptAssert`
constraints:

```
@ScriptAssert(script = "value > 0", lang = "spring")
public class Foo {

    private final int value;

    private Foo(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
```

### 9.3. Configuring a Validator

When working with a configured validator factory it can occasionally be required to apply a
different configuration to a single `Validator` instance. [Example 9.25, “Configuring a `Validator` instance via `usingContext()`”](#example-using-context) shows how this can
be achieved by calling `ValidatorFactory#usingContext()`.

Example 9.25: Configuring a `Validator` instance via `usingContext()`
```
ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

Validator validator = validatorFactory.usingContext()
        .messageInterpolator( new MyMessageInterpolator() )
        .traversableResolver( new MyTraversableResolver() )
        .getValidator();
```

## 10. Using constraint metadata

The Jakarta Bean Validation specification provides not only a validation engine, but also an API for
retrieving constraint metadata in a uniform way, no matter whether the constraints are declared
using annotations or via XML mappings. Read this chapter to learn more about this API and its
possibilities. You can find all the metadata API types in the package `javax.validation.metadata`.

The examples presented in this chapter are based on the classes and constraint declarations shown in
[Example 10.1, “Example classes”](#metadata-example-car).

Example 10.1: Example classes
```
package org.hibernate.validator.referenceguide.chapter10;

public class Person {

    public interface Basic {
    }

    @NotNull
    private String name;

    //getters and setters ...
}
```

```
package org.hibernate.validator.referenceguide.chapter10;

public interface Vehicle {

    public interface Basic {
    }

    @NotNull(groups = Vehicle.Basic.class)
    String getManufacturer();
}
```

```
package org.hibernate.validator.referenceguide.chapter10;

@ValidCar
public class Car implements Vehicle {

    public interface SeverityInfo extends Payload {
    }

    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    private Person driver;

    private String modelName;

    public Car() {
    }

    public Car(
            @NotNull String manufacturer,
            String licencePlate,
            Person driver,
            String modelName) {

        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.driver = driver;
        this.modelName = modelName;
    }

    public void driveAway(@Max(75) int speed) {
        //...
    }

    @LuggageCountMatchesPassengerCount(
            piecesOfLuggagePerPassenger = 2,
            validationAppliesTo = ConstraintTarget.PARAMETERS,
            payload = SeverityInfo.class,
            message = "There must not be more than {piecesOfLuggagePerPassenger} pieces " +
                    "of luggage per passenger."
    )
    public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
        //...
    }

    @Override
    @Size(min = 3)
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    @Valid
    @ConvertGroup(from = Default.class, to = Person.Basic.class)
    public Person getDriver() {
        return driver;
    }

    //further getters and setters...
}
```

```
package org.hibernate.validator.referenceguide.chapter10;

public class Library {

    @NotNull
    private String name;

    private List<@NotNull @Valid Book> books;

    //getters and setters ...
}
```

```
package org.hibernate.validator.referenceguide.chapter10;

public class Book {

    @NotEmpty
    private String title;

    @NotEmpty
    private String author;

    //getters and setters ...
}
```

### 10.1. `BeanDescriptor`

The entry point into the metadata API is the method `Validator#getConstraintsForClass()`, which
returns an instance of the [`BeanDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/BeanDescriptor.html) interface. Using this
descriptor, you can obtain metadata for constraints declared directly on the bean itself (class- or
property-level), but also retrieve metadata descriptors representing single properties, methods and
constructors.

[Example 10.2, “Using `BeanDescriptor`”](#metadata-example-using-beandescriptor) demonstrates how to retrieve a `BeanDescriptor` for the
`Car` class and how to use this descriptor in form of assertions.

|  | If a constraint declaration hosted by the requested class is invalid, a `ValidationException` is thrown. |
| --- | --- |

Example 10.2: Using `BeanDescriptor`
```
BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

assertTrue( carDescriptor.isBeanConstrained() );

//one class-level constraint
assertEquals( 1, carDescriptor.getConstraintDescriptors().size() );

//manufacturer, licensePlate, driver
assertEquals( 3, carDescriptor.getConstrainedProperties().size() );

//property has constraint
assertNotNull( carDescriptor.getConstraintsForProperty( "licensePlate" ) );

//property is marked with @Valid
assertNotNull( carDescriptor.getConstraintsForProperty( "driver" ) );

//constraints from getter method in interface and implementation class are returned
assertEquals(
        2,
        carDescriptor.getConstraintsForProperty( "manufacturer" )
                .getConstraintDescriptors()
                .size()
);

//property is not constrained
assertNull( carDescriptor.getConstraintsForProperty( "modelName" ) );

//driveAway(int), load(List<Person>, List<PieceOfLuggage>)
assertEquals( 2, carDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() );

//driveAway(int), getManufacturer(), getDriver(), load(List<Person>, List<PieceOfLuggage>)
assertEquals(
        4,
        carDescriptor.getConstrainedMethods( MethodType.NON_GETTER, MethodType.GETTER )
                .size()
);

//driveAway(int)
assertNotNull( carDescriptor.getConstraintsForMethod( "driveAway", int.class ) );

//getManufacturer()
assertNotNull( carDescriptor.getConstraintsForMethod( "getManufacturer" ) );

//setManufacturer() is not constrained
assertNull( carDescriptor.getConstraintsForMethod( "setManufacturer", String.class ) );

//Car(String, String, Person, String)
assertEquals( 1, carDescriptor.getConstrainedConstructors().size() );

//Car(String, String, Person, String)
assertNotNull(
        carDescriptor.getConstraintsForConstructor(
                String.class,
                String.class,
                Person.class,
                String.class
        )
);
```

You can determine whether the specified class hosts any class- or property-level constraints via
`isBeanConstrained()`. Method or constructor constraints are not considered by `isBeanConstrained()`.

The method `getConstraintDescriptors()` is common to all descriptors derived from `ElementDescriptor`
(see [Section 10.4, “`ElementDescriptor`”](#validator-metadata-api-elementdescriptor)) and returns a set of descriptors representing the
constraints directly declared on the given element. In case of `BeanDescriptor`, the bean’s class-
level constraints are returned. More details on `ConstraintDescriptor` can be found in
[Section 10.7, “`ConstraintDescriptor`”](#section-constraint-descriptor).

Via `getConstraintsForProperty()`, `getConstraintsForMethod()` and `getConstraintsForConstructor()` you
can obtain a descriptor representing one given property or executable element, identified by its
name and, in case of methods and constructors, parameter types. The different descriptor types
returned by these methods are described in the following sections.

Note that these methods consider constraints declared at super-types according to the rules for
constraint inheritance as described in [Section 2.1.5, “Constraint inheritance”](#section-constraint-inheritance). An example is the
descriptor for the `manufacturer` property, which provides access to all constraints defined on
`Vehicle#getManufacturer()` and the implementing method `Car#getManufacturer()`. `null` is returned in
case the specified element does not exist or is not constrained.

The methods `getConstrainedProperties()`, `getConstrainedMethods()` and `getConstrainedConstructors()`
return (potentially empty) sets with all constrained properties, methods and constructors,
respectively. An element is considered constrained if it has at least one constraint or is marked
for cascaded validation. When invoking `getConstrainedMethods()`, you can specify the type of the
methods to be returned (getters, non-getters or both).

### 10.2. `PropertyDescriptor`

The interface
[`PropertyDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/PropertyDescriptor.html) represents one given property of a
class. It is transparent whether constraints are declared on a field or a property getter, provided
the JavaBeans naming conventions are respected. [Example 10.3, “Using `PropertyDescriptor`”](#metadata-example-using-propertydescriptor) shows
how to use the `PropertyDescriptor` interface.

Example 10.3: Using `PropertyDescriptor`
```
PropertyDescriptor licensePlateDescriptor = carDescriptor.getConstraintsForProperty(
        "licensePlate"
);

//"licensePlate" has two constraints, is not marked with @Valid and defines no group conversions
assertEquals( "licensePlate", licensePlateDescriptor.getPropertyName() );
assertEquals( 2, licensePlateDescriptor.getConstraintDescriptors().size() );
assertTrue( licensePlateDescriptor.hasConstraints() );
assertFalse( licensePlateDescriptor.isCascaded() );
assertTrue( licensePlateDescriptor.getGroupConversions().isEmpty() );

PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

//"driver" has no constraints, is marked with @Valid and defines one group conversion
assertEquals( "driver", driverDescriptor.getPropertyName() );
assertTrue( driverDescriptor.getConstraintDescriptors().isEmpty() );
assertFalse( driverDescriptor.hasConstraints() );
assertTrue( driverDescriptor.isCascaded() );
assertEquals( 1, driverDescriptor.getGroupConversions().size() );
```

Using `getConstraintDescriptors()`, you can retrieve a set of `ConstraintDescriptors` providing more
information on the individual constraints of a given property. The method `isCascaded()` returns
`true` if the property is marked for cascaded validation (either using the `@Valid` annotation or via
XML), `false` otherwise. Any configured group conversions are returned by `getGroupConversions()`. See
[Section 10.6, “`GroupConversionDescriptor`”](#section-group-conversion-descriptor) for more details on `GroupConversionDescriptor`.

### 10.3. `MethodDescriptor` and `ConstructorDescriptor`

Constrained methods and constructors are represented by the interfaces
[`MethodDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/MethodDescriptor.html)
[`ConstructorDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/ConstructorDescriptor.html), respectively.
[Example 10.4, “Using `MethodDescriptor` and `ConstructorDescriptor`”](#metadata-example-using-methodandconstructordescriptor) demonstrates how to work with these
descriptors.

Example 10.4: Using `MethodDescriptor` and `ConstructorDescriptor`
```
//driveAway(int) has a constrained parameter and an unconstrained return value
MethodDescriptor driveAwayDescriptor = carDescriptor.getConstraintsForMethod(
        "driveAway",
        int.class
);
assertEquals( "driveAway", driveAwayDescriptor.getName() );
assertTrue( driveAwayDescriptor.hasConstrainedParameters() );
assertFalse( driveAwayDescriptor.hasConstrainedReturnValue() );

//always returns an empty set; constraints are retrievable by navigating to
//one of the sub-descriptors, e.g. for the return value
assertTrue( driveAwayDescriptor.getConstraintDescriptors().isEmpty() );

ParameterDescriptor speedDescriptor = driveAwayDescriptor.getParameterDescriptors()
        .get( 0 );

//The "speed" parameter is located at index 0, has one constraint and is not cascaded
//nor does it define group conversions
assertEquals( "speed", speedDescriptor.getName() );
assertEquals( 0, speedDescriptor.getIndex() );
assertEquals( 1, speedDescriptor.getConstraintDescriptors().size() );
assertFalse( speedDescriptor.isCascaded() );
assert speedDescriptor.getGroupConversions().isEmpty();

//getDriver() has no constrained parameters but its return value is marked for cascaded
//validation and declares one group conversion
MethodDescriptor getDriverDescriptor = carDescriptor.getConstraintsForMethod(
        "getDriver"
);
assertFalse( getDriverDescriptor.hasConstrainedParameters() );
assertTrue( getDriverDescriptor.hasConstrainedReturnValue() );

ReturnValueDescriptor returnValueDescriptor = getDriverDescriptor.getReturnValueDescriptor();
assertTrue( returnValueDescriptor.getConstraintDescriptors().isEmpty() );
assertTrue( returnValueDescriptor.isCascaded() );
assertEquals( 1, returnValueDescriptor.getGroupConversions().size() );

//load(List<Person>, List<PieceOfLuggage>) has one cross-parameter constraint
MethodDescriptor loadDescriptor = carDescriptor.getConstraintsForMethod(
        "load",
        List.class,
        List.class
);
assertTrue( loadDescriptor.hasConstrainedParameters() );
assertFalse( loadDescriptor.hasConstrainedReturnValue() );
assertEquals(
        1,
        loadDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size()
);

//Car(String, String, Person, String) has one constrained parameter
ConstructorDescriptor constructorDescriptor = carDescriptor.getConstraintsForConstructor(
        String.class,
        String.class,
        Person.class,
        String.class
);

assertEquals( "Car", constructorDescriptor.getName() );
assertFalse( constructorDescriptor.hasConstrainedReturnValue() );
assertTrue( constructorDescriptor.hasConstrainedParameters() );
assertEquals(
        1,
        constructorDescriptor.getParameterDescriptors()
                .get( 0 )
                .getConstraintDescriptors()
                .size()
);
```

`getName()` returns the name of the given method or constructor. The methods
`hasConstrainedParameters()` and `hasConstrainedReturnValue()` can be used to perform a quick check
whether an executable element has any parameter constraints (either constraints on single parameters
or cross-parameter constraints) or return value constraints.

Note that constraints are not directly exposed on `MethodDescriptor` and `ConstructorDescriptor`,
but rather on dedicated descriptors representing an executable’s parameters, its return value and
its cross-parameter constraints. To get hold of one of these descriptors, invoke
`getParameterDescriptors()`, `getReturnValueDescriptor()` or `getCrossParameterDescriptor()`,
respectively.

These descriptors provide access to the element’s constraints (`getConstraintDescriptors()`) and, in
the case of parameters and return value, to its configuration for cascaded validation (`isValid()` and
`getGroupConversions()`). For parameters, you also can retrieve the index and the name, as returned by
the currently used parameter name provider (see [Section 9.2.4, “`ParameterNameProvider`”](#section-parameter-name-provider)) via `getName()`
and `getIndex()`.

|  | Getter methods following the JavaBeans naming conventions are considered as bean properties but also as constrained methods.   That means you can retrieve the related metadata either by obtaining a `PropertyDescriptor` (e.g. `BeanDescriptor.getConstraintsForProperty("foo")`) or by examining the return value descriptor of the getter’s `MethodDescriptor` (e.g. `BeanDescriptor.getConstraintsForMethod("getFoo").getReturnValueDescriptor())`. |
| --- | --- |

### 10.4. `ElementDescriptor`

The [`ElementDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/ElementDescriptor.html)
interface is the common base class for the
individual descriptor types such as `BeanDescriptor`, `PropertyDescriptor` etc. Besides
`getConstraintDescriptors()` it provides some more methods common to all descriptors.

`hasConstraints()` allows for a quick check whether an element has any direct constraints (e.g. class-
level constraints in case of `BeanDescriptor`).

`getElementClass()` returns the Java type of the element
represented by a given descriptor. More specifically, the method returns

* the object type when invoked on `BeanDescriptor`,
* the type of a property or parameter when invoked on `PropertyDescriptor` or `ParameterDescriptor`
  respectively,
* `Object[].class` when invoked on `CrossParameterDescriptor`,
* the return type when invoked on `ConstructorDescriptor`, `MethodDescriptor` or `ReturnValueDescriptor`.
  `void.class` will be returned for methods which don’t have a return value.

[Example 10.5, “Using `ElementDescriptor methods`”](#metadata-example-using-elementdescriptor) shows how these methods are used.

Example 10.5: Using `ElementDescriptor methods`
```
PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
        "manufacturer"
);

assertTrue( manufacturerDescriptor.hasConstraints() );
assertEquals( String.class, manufacturerDescriptor.getElementClass() );

CrossParameterDescriptor loadCrossParameterDescriptor = carDescriptor.getConstraintsForMethod(
        "load",
        List.class,
        List.class
).getCrossParameterDescriptor();

assertTrue( loadCrossParameterDescriptor.hasConstraints() );
assertEquals( Object[].class, loadCrossParameterDescriptor.getElementClass() );
```

Finally, `ElementDescriptor` offers access to the `ConstraintFinder` API which allows you to query for
constraint metadata in a fine grained way. [Example 10.6, “Usage of `ConstraintFinder`”](#example-constraint-finder) shows how to retrieve a
`ConstraintFinder` instance via `findConstraints()` and use the API to query for constraint metadata.

Example 10.6: Usage of `ConstraintFinder`
```
PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
        "manufacturer"
);

//"manufacturer" constraints are declared on the getter, not the field
assertTrue(
        manufacturerDescriptor.findConstraints()
                .declaredOn( ElementType.FIELD )
                .getConstraintDescriptors()
                .isEmpty()
);

//@NotNull on Vehicle#getManufacturer() is part of another group
assertEquals(
        1,
        manufacturerDescriptor.findConstraints()
                .unorderedAndMatchingGroups( Default.class )
                .getConstraintDescriptors()
                .size()
);

//@Size on Car#getManufacturer()
assertEquals(
        1,
        manufacturerDescriptor.findConstraints()
                .lookingAt( Scope.LOCAL_ELEMENT )
                .getConstraintDescriptors()
                .size()
);

//@Size on Car#getManufacturer() and @NotNull on Vehicle#getManufacturer()
assertEquals(
        2,
        manufacturerDescriptor.findConstraints()
                .lookingAt( Scope.HIERARCHY )
                .getConstraintDescriptors()
                .size()
);

//Combining several filter options
assertEquals(
        1,
        manufacturerDescriptor.findConstraints()
                .declaredOn( ElementType.METHOD )
                .lookingAt( Scope.HIERARCHY )
                .unorderedAndMatchingGroups( Vehicle.Basic.class )
                .getConstraintDescriptors()
                .size()
);
```

Via `declaredOn()` you can search for `ConstraintDescriptors` declared on certain element types. This is
useful to find property constraints declared on either fields or getter methods.

`unorderedAndMatchingGroups()` restricts the resulting constraints to those matching the given
validation group(s).

`lookingAt()` allows to distinguish between constraints directly specified on the element
(`Scope.LOCAL_ELEMENT`) or constraints belonging to the element but hosted anywhere in the class
hierarchy (`Scope.HIERARCHY`).

You can also combine the different options as shown in the last example.

|  | Order is not respected by `unorderedAndMatchingGroups()`, but group inheritance and inheritance via sequence are. |
| --- | --- |

### 10.5. `ContainerDescriptor` and `ContainerElementTypeDescriptor`

The [`ContainerDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/ContainerDescriptor.html)
interface is the common interface for all the elements that support container element constraints and cascading
validation (`PropertyDescriptor`, `ParameterDescriptor`, `ReturnValueDescriptor`).

It has a single method `getConstrainedContainerElementTypes()` that returns a set of `ContainerElementTypeDescriptor`.

`ContainerElementTypeDescriptor` extends `ContainerDescriptor` to support nested container element constraints.

`ContainerElementTypeDescriptor` contains the information about the container, the constraints and the cascading
validation.

[Example 10.7, “Using `ContainerElementTypeDescriptor`”](#metadata-example-using-containerelementtypedescriptor) shows how to use `getConstrainedContainerElementTypes()`
to retrieve the set of `ContainerElementTypeDescriptor`.

Example 10.7: Using `ContainerElementTypeDescriptor`
```
PropertyDescriptor booksDescriptor = libraryDescriptor.getConstraintsForProperty(
        "books"
);

Set<ContainerElementTypeDescriptor> booksContainerElementTypeDescriptors =
        booksDescriptor.getConstrainedContainerElementTypes();
ContainerElementTypeDescriptor booksContainerElementTypeDescriptor =
        booksContainerElementTypeDescriptors.iterator().next();

assertTrue( booksContainerElementTypeDescriptor.hasConstraints() );
assertTrue( booksContainerElementTypeDescriptor.isCascaded() );
assertEquals(
        0,
        booksContainerElementTypeDescriptor.getTypeArgumentIndex().intValue()
);
assertEquals(
        List.class,
        booksContainerElementTypeDescriptor.getContainerClass()
);

Set<ConstraintDescriptor<?>> constraintDescriptors =
        booksContainerElementTypeDescriptor.getConstraintDescriptors();
ConstraintDescriptor<?> constraintDescriptor =
        constraintDescriptors.iterator().next();

assertEquals(
        NotNull.class,
        constraintDescriptor.getAnnotation().annotationType()
);
```

### 10.6. `GroupConversionDescriptor`

All those descriptor types that represent elements which can be subject of cascaded validation
(i.e., `PropertyDescriptor`, `ParameterDescriptor` and `ReturnValueDescriptor`) provide access to the
element’s group conversions via `getGroupConversions()`. The returned set contains a
[`GroupConversionDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation//metadata/GroupConversionDescriptor.html)
for each configured conversion, allowing to retrieve
source and target groups of the conversion. [Example 10.8, “Using `GroupConversionDescriptor`”](#metadata-example-using-groupconversiondescriptor)
shows an example.

Example 10.8: Using `GroupConversionDescriptor`
```
PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

Set<GroupConversionDescriptor> groupConversions = driverDescriptor.getGroupConversions();
assertEquals( 1, groupConversions.size() );

GroupConversionDescriptor groupConversionDescriptor = groupConversions.iterator()
        .next();
assertEquals( Default.class, groupConversionDescriptor.getFrom() );
assertEquals( Person.Basic.class, groupConversionDescriptor.getTo() );
```

### 10.7. `ConstraintDescriptor`

Last but not least, the
[`ConstraintDescriptor`](http://docs.jboss.org/hibernate/beanvalidation/spec/2.0/api/?javax/validation/metadata/ConstraintDescriptor.html)
interface describes a
single constraint together with its composing constraints. Via an instance of this interface you get
access to the constraint annotation and its parameters.

[Example 10.9, “Using `ConstraintDescriptor`”](#metadata-example-using-constraintdescriptor)
shows how to retrieve default constraint attributes (such as message template, groups etc.) as well
as custom constraint attributes (`piecesOfLuggagePerPassenger`) and other metadata such as the
constraint’s annotation type and its validators from a `ConstraintDescriptor`.

Example 10.9: Using `ConstraintDescriptor`
```
//descriptor for the @LuggageCountMatchesPassengerCount constraint on the
//load(List<Person>, List<PieceOfLuggage>) method
ConstraintDescriptor<?> constraintDescriptor = carDescriptor.getConstraintsForMethod(
        "load",
        List.class,
        List.class
).getCrossParameterDescriptor().getConstraintDescriptors().iterator().next();

//constraint type
assertEquals(
        LuggageCountMatchesPassengerCount.class,
        constraintDescriptor.getAnnotation().annotationType()
);

//standard constraint attributes
assertEquals( SeverityInfo.class, constraintDescriptor.getPayload().iterator().next() );
assertEquals(
        ConstraintTarget.PARAMETERS,
        constraintDescriptor.getValidationAppliesTo()
);
assertEquals( Default.class, constraintDescriptor.getGroups().iterator().next() );
assertEquals(
        "There must not be more than {piecesOfLuggagePerPassenger} pieces of luggage per " +
        "passenger.",
        constraintDescriptor.getMessageTemplate()
);

//custom constraint attribute
assertEquals(
        2,
        constraintDescriptor.getAttributes().get( "piecesOfLuggagePerPassenger" )
);

//no composing constraints
assertTrue( constraintDescriptor.getComposingConstraints().isEmpty() );

//validator class
assertEquals(
        Arrays.<Class<?>>asList( LuggageCountMatchesPassengerCount.Validator.class ),
        constraintDescriptor.getConstraintValidatorClasses()
);
```

## 11. Integrating with other frameworks

Hibernate Validator is intended to be used to implement multi-layered data validation, where
constraints are expressed in a single place (the annotated domain model) and checked in various
different layers of the application. For this reason there are multiple integration points with
other technologies.

### 11.1. ORM integration

Hibernate Validator integrates with both Hibernate ORM and all pure Java Persistence providers.

|  | When lazy loaded associations are supposed to be validated it is recommended to place the constraint on the getter of the association. Hibernate ORM replaces lazy loaded associations with proxy instances which get initialized/loaded when requested via the getter. If, in such a case, the constraint is placed on field level, the actual proxy instance is used which will lead to validation errors. |
| --- | --- |

#### 11.1.1. Database schema-level validation

Out of the box, Hibernate ORM will translate the constraints you have defined for
your entities into mapping metadata. For example, if a property of your entity is annotated
`@NotNull`, its columns will be declared as `not null` in the DDL schema generated by Hibernate ORM.

If, for some reason, the feature needs to be disabled, set `hibernate.validator.apply_to_ddl` to
`false`. See also [Section 2.3.1, “Jakarta Bean Validation constraints”](#validator-defineconstraints-spec) and [Section 2.3.2, “Additional constraints”](#validator-defineconstraints-hv-constraints).

You can also limit the DDL constraint generation to a subset of the defined constraints by setting
the property `org.hibernate.validator.group.ddl`. The property specifies the comma-separated, fully
specified class names of the groups a constraint has to be part of in order to be considered for DDL
schema generation.

#### 11.1.2. Hibernate ORM event-based validation

Hibernate Validator has a built-in Hibernate event listener -
[`org.hibernate.cfg.beanvalidation.BeanValidationEventListener`](https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java) -
which is part of Hibernate ORM. Whenever a `PreInsertEvent`,
`PreUpdateEvent` or `PreDeleteEvent` occurs, the listener will verify all constraints of the entity
instance and throw an exception if any constraint is violated. Per default, objects will be checked
before any inserts or updates are made by Hibernate ORM. Pre deletion events will per default not
trigger a validation. You can configure the groups to be validated per event type using the
properties `javax.persistence.validation.group.pre-persist`,
`javax.persistence.validation.group.pre-update` and `javax.persistence.validation.group.pre-remove`.
The values of these properties are the comma-separated fully specified class names of the groups
to validate. [Example 11.1, “Manual configuration of `BeanValidationEvenListener`”](#example-beanvalidationeventlistener-config) shows the default values for these
properties. In this case they could also be omitted.

On constraint violation, the event will raise a runtime `ConstraintViolationException` which contains
a set of `ConstraintViolation` instances describing each failure.

If Hibernate Validator is present in the classpath, Hibernate ORM will use it transparently.
To avoid validation even though Hibernate Validator is in the classpath, set
`javax.persistence.validation.mode` to none.

|  | If the beans are not annotated with validation annotations, there is no runtime performance cost. |
| --- | --- |

In case you need to manually set the event listeners for Hibernate ORM, use the following
configuration in *hibernate.cfg.xml*:

Example 11.1: Manual configuration of `BeanValidationEvenListener`
```
<hibernate-configuration>
    <session-factory>
        ...
        <property name="javax.persistence.validation.group.pre-persist">
            javax.validation.groups.Default
        </property>
        <property name="javax.persistence.validation.group.pre-update">
            javax.validation.groups.Default
        </property>
        <property name="javax.persistence.validation.group.pre-remove"></property>
        ...
        <event type="pre-update">
            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
        </event>
        <event type="pre-insert">
            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
        </event>
        <event type="pre-delete">
            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
        </event>
    </session-factory>
</hibernate-configuration>
```

#### 11.1.3. JPA

If you are using JPA 2 and Hibernate Validator is in the classpath, the JPA2 specification requires
that Jakarta Bean Validation gets enabled. The properties `javax.persistence.validation.group.pre-persist`,
`javax.persistence.validation.group.pre-update` and `javax.persistence.validation.group.pre-remove` as
described in [Section 11.1.2, “Hibernate ORM event-based validation”](#validator-checkconstraints-orm-hibernateevent) can in this case be configured in
*persistence.xml*. *persistence.xml* also defines a node validation-mode which can be set to `AUTO`,
`CALLBACK` or `NONE`. The default is `AUTO`.

### 11.2. JSF & Seam

When working with JSF2 or JBoss Seam and Hibernate Validator (Jakarta Bean Validation) is present in the
runtime environment, validation is triggered for every field in the application. [Example 11.2, “Usage of Jakarta Bean Validation within JSF2”](#example-jsf2)
shows an example of the `f:validateBean` tag in a JSF page. The `validationGroups` attribute is optional
and can be used to specify a comma separated list of validation groups. The default is
`javax.validation.groups.Default`. For more information refer to the Seam documentation or the JSF 2
specification.

Example 11.2: Usage of Jakarta Bean Validation within JSF2
```
<h:form>

  <f:validateBean validationGroups="javax.validation.groups.Default">

    <h:inputText value=#{model.property}/>
    <h:selectOneRadio value=#{model.radioProperty}> ... </h:selectOneRadio>
    <!-- other input components here -->

  </f:validateBean>

</h:form>
```

|  | The integration between JSF 2 and Jakarta Bean Validation is described in the "Jakarta Bean Validation Integration" chapter of [JSR-314](http://jcp.org/en/jsr/detail?id=314). It is interesting to know that JSF 2 implements a custom `MessageInterpolator` to ensure proper localization. To encourage the use of the Jakarta Bean Validation message facility, JSF 2 will per default only display the generated Bean Validation message. This can, however, be configured via the application resource bundle by providing the following configuration (`{0}` is replaced with the Jakarta Bean Validation message and `{1}` is replaced with the JSF component label):  ``` javax.faces.validator.BeanValidator.MESSAGE={1}: {0} ```    The default is:  ``` javax.faces.validator.BeanValidator.MESSAGE={0} ``` |
| --- | --- |

### 11.3. CDI

As of version 1.1, Bean Validation (and therefore Jakarta Bean Validation) is integrated with CDI
(Contexts and Dependency Injection for Jakarta EE).

This integration provides CDI managed beans for `Validator` and `ValidatorFactory` and enables
dependency injection in constraint validators as well as custom message interpolators, traversable
resolvers, constraint validator factories, parameter name providers, clock providers and value
extractors.

Furthermore, parameter and return value constraints on the methods and constructors of CDI managed
beans will automatically be validated upon invocation.

When your application runs on a Java EE container, this integration is enabled by default. When
working with CDI in a Servlet container or in a pure Java SE environment, you can use the CDI
portable extension provided by Hibernate Validator. To do so, add the portable extension to your
class path as described in [Section 1.1.2, “CDI”](#section-getting-started-cdi).

#### 11.3.1. Dependency injection

CDI’s dependency injection mechanism makes it very easy to retrieve `ValidatorFactory` and `Validator`
instances and use them in your managed beans. Just annotate instance fields of your bean with
`@javax.inject.Inject` as shown in [Example 11.3, “Retrieving validator factory and validator via `@Inject`”](#example-dependency-injection).

Example 11.3: Retrieving validator factory and validator via `@Inject`
```
package org.hibernate.validator.referenceguide.chapter11.cdi.validator;

@ApplicationScoped
public class RentalStation {

    @Inject
    private ValidatorFactory validatorFactory;

    @Inject
    private Validator validator;

    //...
}
```

The injected beans are the default validator factory and validator instances. In order to configure
them - e.g. to use a custom message interpolator - you can use the Jakarta Bean Validation XML descriptors
as discussed in [Chapter 8, *Configuring via XML*](#chapter-xml-configuration).

If you are working with several Jakarta Bean Validation providers, you can make sure that factory and
validator from Hibernate Validator are injected by annotating the injection points with the
`@HibernateValidator` qualifier which is demonstrated in [Example 11.4, “Using the `@HibernateValidator` qualifier annotation”](#example-dependency-injection-using-hv).

Example 11.4: Using the `@HibernateValidator` qualifier annotation
```
package org.hibernate.validator.referenceguide.chapter11.cdi.validator.qualifier;

@ApplicationScoped
public class RentalStation {

    @Inject
    @HibernateValidator
    private ValidatorFactory validatorFactory;

    @Inject
    @HibernateValidator
    private Validator validator;

    //...
}
```

|  | The fully-qualified name of the qualifier annotation is `org.hibernate.validator.cdi.HibernateValidator`. Be sure to not import `org.hibernate.validator.HibernateValidator` instead which is the `ValidationProvider` implementation used for selecting Hibernate Validator when working with the bootstrapping API (see [Section 9.1, “Retrieving `ValidatorFactory` and `Validator`”](#section-retrieving-validator-factory-validator)). |
| --- | --- |

Via `@Inject` you also can inject dependencies into constraint validators and other Jakarta Bean Validation
objects such as `MessageInterpolator` implementations etc.

[Example 11.5, “Constraint validator with injected bean”](#example-constraint-validator-injected-bean)
demonstrates how an injected CDI bean is used in a `ConstraintValidator` implementation to determine
whether the given constraint is valid or not. As the example shows, you also can work with the
`@PostConstruct` and `@PreDestroy` callbacks to implement any required construction and destruction
logic.

Example 11.5: Constraint validator with injected bean
```
package org.hibernate.validator.referenceguide.chapter11.cdi.injection;

public class ValidLicensePlateValidator
        implements ConstraintValidator<ValidLicensePlate, String> {

    @Inject
    private VehicleRegistry vehicleRegistry;

    @PostConstruct
    public void postConstruct() {
        //do initialization logic...
    }

    @PreDestroy
    public void preDestroy() {
        //do destruction logic...
    }

    @Override
    public void initialize(ValidLicensePlate constraintAnnotation) {
    }

    @Override
    public boolean isValid(String licensePlate, ConstraintValidatorContext constraintContext) {
        return vehicleRegistry.isValidLicensePlate( licensePlate );
    }
}
```

#### 11.3.2. Method validation

The method interception facilities of CDI allow for a very tight integration with Jakarta Bean Validation’s
method validation functionality. Just put constraint annotations to the parameters and return values
of the executables of your CDI beans and they will be validated automatically before (parameter
constraints) and after (return value constraints) a method or constructor is invoked.

Note that no explicit interceptor binding is required, instead the required method validation
interceptor will automatically be registered for all managed beans with constrained methods and
constructors.

|  | The interceptor `org.hibernate.validator.cdi.internal.interceptor.ValidationInterceptor` is registered by `org.hibernate.validator.cdi.internal.ValidationExtension`. This happens implicitly within a Java EE runtime environment or explicitly by adding the *hibernate-validator-cdi* artifact - see [Section 1.1.2, “CDI”](#section-getting-started-cdi) |
| --- | --- |

You can see an example in [Example 11.6, “CDI managed beans with method-level constraints”](#example-cdi-method-validation).

Example 11.6: CDI managed beans with method-level constraints
```
package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation;

@ApplicationScoped
public class RentalStation {

    @Valid
    public RentalStation() {
        //...
    }

    @NotNull
    @Valid
    public Car rentCar(
            @NotNull Customer customer,
            @NotNull @Future Date startDate,
            @Min(1) int durationInDays) {
        //...
        return null;
    }

    @NotNull
    List<Car> getAvailableCars() {
        //...
        return null;
    }
}
```

```
package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation;

@RequestScoped
public class RentCarRequest {

    @Inject
    private RentalStation rentalStation;

    public void rentCar(String customerId, Date startDate, int duration) {
        //causes ConstraintViolationException
        rentalStation.rentCar( null, null, -1 );
    }
}
```

Here the `RentalStation` bean hosts several method constraints. When invoking one of the `RentalStation`
methods from another bean such as `RentCarRequest`, the constraints of the invoked method are
automatically validated. If any illegal parameter values are passed as in the example, a
`ConstraintViolationException` will be thrown by the method interceptor, providing detailed
information on the violated constraints. The same is the case if the method’s return value violates
any return value constraints.

Similarly, constructor constraints are validated automatically upon invocation. In the example the
`RentalStation` object returned by the constructor will be validated since the constructor return
value is marked with `@Valid`.

##### 11.3.2.1. Validated executable types

Jakarta Bean Validation allows for a fine-grained control of the executable types which are automatically
validated. By default, constraints on constructors and non-getter methods are validated. Therefore
the `@NotNull` constraint on the method `RentalStation#getAvailableCars()` in
[Example 11.6, “CDI managed beans with method-level constraints”](#example-cdi-method-validation) does not get validated when the method is invoked.

You have the following options to configure which types of executables are validated upon
invocation:

* Configure the executable types globally via the XML descriptor *META-INF/validation.xml*;
  see [Section 8.1, “Configuring the validator factory in *validation.xml*”](#section-configuration-validation-xml) for an example
* Use the `@ValidateOnExecution` annotation on the executable or type level

If several sources of configuration are specified for a given executable, `@ValidateOnExecution` on
the executable level takes precedence over `@ValidateOnExecution` on the type level and
`@ValidateOnExecution` generally takes precedence over the globally configured types in *META-
INF/validation.xml*.

[Example 11.7, “Using `@ValidateOnExecution`”](#example-using-validateonexecution) shows how to use the `@ValidateOnExecution` annotation:

Example 11.7: Using `@ValidateOnExecution`
```
package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.configuration;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.ALL)
public class RentalStation {

    @Valid
    public RentalStation() {
        //...
    }

    @NotNull
    @Valid
    @ValidateOnExecution(type = ExecutableType.NONE)
    public Car rentCar(
            @NotNull Customer customer,
            @NotNull @Future Date startDate,
            @Min(1) int durationInDays) {
        //...
        return null;
    }

    @NotNull
    public List<Car> getAvailableCars() {
        //...
        return null;
    }
}
```

Here the method `rentCar()` won’t be validated upon invocation because it is annotated with
`@ValidateOnExecution(type = ExecutableType.NONE)`. In contrast, the constructor and the
method `getAvailableCars()` will be validated due to `@ValidateOnExecution(type =
ExecutableType.ALL)` being given on the type level. `ExecutableType.ALL` is a more compact form for
explicitly specifying all the types `CONSTRUCTORS`, `GETTER_METHODS` and `NON_GETTER_METHODS`.

|  | Executable validation can be turned off globally by specifying `<executable-validation enabled="false"/>` in *META-INF/validation.xml*. In this case, all the `@ValidateOnExecution` annotations are ignored. |
| --- | --- |

Note that when a method overrides or implements a super-type method, the configuration will be taken
from that overridden or implemented method (as given via `@ValidateOnExecution` on the method itself
or on the super-type). This protects a client of the super-type method from an unexpected alteration
of the configuration, e.g. disabling validation of an overridden executable in a sub-type.

In case a CDI managed bean overrides or implements a super-type method and this super-type method
hosts any constraints, it can happen that the validation interceptor is not properly registered with
the bean, resulting in the bean’s methods not being validated upon invocation. In this case you can
specify the executable type `IMPLICIT` on the sub-class as shown in
[Example 11.8, “Using `ExecutableType.IMPLICIT`”](#example-using-executabletype-implicit), which makes sure that all required metadata is discovered
and the validation interceptor kicks in when the methods on `ExpressRentalStation` are invoked.

Example 11.8: Using `ExecutableType.IMPLICIT`
```
package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.implicit;

@ValidateOnExecution(type = ExecutableType.ALL)
public interface RentalStation {

    @NotNull
    @Valid
    Car rentCar(
            @NotNull Customer customer,
            @NotNull @Future Date startDate,
            @Min(1) int durationInDays);

    @NotNull
    List<Car> getAvailableCars();
}
```

```
package org.hibernate.validator.referenceguide.chapter11.cdi.methodvalidation.implicit;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.IMPLICIT)
public class ExpressRentalStation implements RentalStation {

    @Override
    public Car rentCar(Customer customer, Date startDate, @Min(1) int durationInDays) {
        //...
        return null;
    }

    @Override
    public List<Car> getAvailableCars() {
        //...
        return null;
    }
}
```

### 11.4. Java EE

When your application runs on a Java EE application server such as [WildFly](http://wildfly.org/),
you also can obtain `Validator` and `ValidatorFactory` instances via `@Resource` injection in
managed objects such as EJBs etc., as shown in [Example 11.9, “Retrieving `Validator` and `ValidatorFactory` via `@Resource` injection”](#example-validator-resource-injection).

Example 11.9: Retrieving `Validator` and `ValidatorFactory` via `@Resource` injection
```
package org.hibernate.validator.referenceguide.chapter11.javaee;

public class RentalStationBean {

    @Resource
    private ValidatorFactory validatorFactory;

    @Resource
    private Validator validator;

    //...
}
```

Alternatively you can obtain a validator and a validator factory from JNDI under the names
"*java:comp/Validator*" and "*java:comp/ValidatorFactory*", respectively.

Similar to CDI-based injection via `@Inject`, these objects represent default validator and validator
factory and thus can be configured using the XML descriptor *META-INF/validation.xml* (see
[Chapter 8, *Configuring via XML*](#chapter-xml-configuration)).

When your application is CDI-enabled, the injected objects are CDI-aware as well and e.g. support
dependency injection in constraint validators.

### 11.5. JavaFX

Hibernate Validator also provides support for the unwrapping of JavaFX properties. If JavaFX is present
on the classpath, `ValueExtractor`s for JavaFX properties are automatically registered.
See [Section 7.4, “JavaFX value extractors”](#section-valueextraction-javafx) for examples and further discussion.

## 12. Hibernate Validator Specifics

In this chapter you will learn how to make use of several features provided by Hibernate Validator
in addition to the functionality defined by the Jakarta Bean Validation specification. This includes the
fail fast mode, the API for programmatic constraint configuration and the boolean composition of
constraints.

New APIs or SPIs are tagged with the `org.hibernate.validator.Incubating` annotation as long as they
are under development. This means that such elements (e.g. packages, types, methods, constants etc.)
may be incompatibly altered - or removed - in subsequent releases. Usage of incubating API/SPI members
is encouraged (so the development team can get feedback on these new features) but you should be
prepared for updating code which is using them as needed when upgrading to a new version of Hibernate
Validator.

|  | Using the features described in the following sections may result in application code which is not portable between Jakarta Bean Validation providers. |
| --- | --- |

### 12.1. Public API

Let’s start, however, with a look at the public API of Hibernate Validator. Below you can find a list of all packages belonging to this API and their purpose.
Note that when a package is part of the public API this is not necessarily true for its sub-packages.

`org.hibernate.validator`

Classes used by the Jakarta Bean Validation bootstrap mechanism (eg. validation provider, configuration class); for more details see [Chapter 9, *Bootstrapping*](#chapter-bootstrapping).

`org.hibernate.validator.cfg`, `org.hibernate.validator.cfg.context`, `org.hibernate.validator.cfg.defs`, `org.hibernate.validator.spi.cfg`

Hibernate Validator’s fluent API for constraint declaration; in `org.hibernate.validator.cfg` you will find the `ConstraintMapping` interface, in `org.hibernate.validator.cfg.defs` all constraint definitions and in `org.hibernate.validator.spi.cfg` a callback for using the API for configuring the default validator factory. Refer to [Section 12.4, “Programmatic constraint definition and declaration”](#section-programmatic-api) for the details.

`org.hibernate.validator.constraints`, `org.hibernate.validator.constraints.br`, `org.hibernate.validator.constraints.pl`

Some useful custom constraints provided by Hibernate Validator in addition to the built-in constraints defined by the Jakarta Bean Validation specification; the constraints are described in detail in [Section 2.3.2, “Additional constraints”](#validator-defineconstraints-hv-constraints).

`org.hibernate.validator.constraintvalidation`

Extended constraint validator context which allows to set custom attributes for message interpolation. [Section 12.12.1, “`HibernateConstraintValidatorContext`”](#section-hibernateconstraintvalidatorcontext) describes how to make use of that feature.

`org.hibernate.validator.group`, `org.hibernate.validator.spi.group`

The group sequence provider feature which allows you to define dynamic default group sequences in function of the validated object state; the specifics can be found in [Section 5.4, “Redefining the default group sequence”](#section-default-group-class).

`org.hibernate.validator.messageinterpolation`, `org.hibernate.validator.resourceloading`, `org.hibernate.validator.spi.resourceloading`

Classes related to constraint message interpolation; the first package contains Hibernate Validator’s default message interpolator, `ResourceBundleMessageInterpolator`. The latter two packages provide the `ResourceBundleLocator` SPI for the loading of resource bundles (see [Section 4.2.1, “`ResourceBundleLocator`”](#section-resource-bundle-locator)) and its default implementation.

`org.hibernate.validator.parameternameprovider`

A `ParameterNameProvider` based on the Paranamer library, see [Section 12.13, “Paranamer based `ParameterNameProvider`”](#section-paranamer-parameternameprovider).

`org.hibernate.validator.propertypath`

Extensions to the `javax.validation.Path` API, see [Section 12.7, “Extensions of the Path API”](#section-extensions-path-api).

`org.hibernate.validator.spi.constraintdefinition`

An SPI for registering additional constraint validators programmatically, see [Section 12.14, “Providing constraint definitions”](#section-constraint-definition-contribution).

`org.hibernate.validator.spi.messageinterpolation`

An SPI that can be used to tweak the resolution of the locale when interpolating the constraint violation messages. See [Section 12.11, “Customizing the locale resolution”](#section-locale-resolver).

`org.hibernate.validator.spi.nodenameprovider`

An SPI that can be used to alter how the names of properties will be resolved when the property path is constructed. See [Section 12.17, “Customizing the property name resolution for constraint violations”](#section-property-node-name-provider).

|  | The public packages of Hibernate Validator fall into two categories: while the actual API parts are intended to be *invoked* or *used* by clients (e.g. the API for programmatic constraint declaration or the custom constraints), the SPI (service provider interface) packages contain interfaces which are intended to be *implemented* by clients (e.g. `ResourceBundleLocator`). |
| --- | --- |

Any packages not listed in that table are internal packages of Hibernate Validator and are not
intended to be accessed by clients. The contents of these internal packages can change from release
to release without notice, thus possibly breaking any client code relying on it.

### 12.2. Fail fast mode

Using the fail fast mode, Hibernate Validator allows to return from the current validation as soon
as the first constraint violation occurs. This can be useful for the validation of large object
graphs where you are only interested in a quick check whether there is any constraint violation at
all.

[Example 12.1, “Using the fail fast validation mode”](#example-using-fail-fast) shows how to bootstrap and use a fail fast enabled validator.

Example 12.1: Using the fail fast validation mode
```
package org.hibernate.validator.referenceguide.chapter12.failfast;

public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    //getters and setters...
}
```

```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .failFast( true )
        .buildValidatorFactory()
        .getValidator();

Car car = new Car( null, false );

Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
```

Here the validated object actually fails to satisfy both the constraints declared on the `Car` class,
yet the validation call yields only one `ConstraintViolation` since the fail fast mode is enabled.

|  | There is no guarantee in which order the constraints are evaluated, i.e. it is not deterministic whether the returned violation originates from the `@NotNull` or the `@AssertTrue` constraint. If required, a deterministic evaluation order can be enforced using group sequences as described in [Section 5.3, “Defining group sequences”](#section-defining-group-sequences). |
| --- | --- |

Refer to [Section 9.2.8, “Provider-specific settings”](#section-provider-specific-settings) to learn about the different ways of enabling the
fail fast mode when bootstrapping a validator.

### 12.3. Relaxation of requirements for method validation in class hierarchies

The Jakarta Bean Validation specification defines a set of preconditions which apply when defining
constraints on methods within class hierarchies. These preconditions are defined in
[section 5.6.5](http://beanvalidation.org/2.0/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance)
of the Jakarta Bean Validation 2.0 specification. See also [Section 3.1.4, “Method constraints in inheritance hierarchies”](#section-method-constraints-inheritance-hierarchies)
in this guide.

As per specification, a Jakarta Bean Validation provider is allowed to relax these preconditions.
With Hibernate Validator you can do this in one of two ways.

First you can use the configuration properties *hibernate.validator.allow\_parameter\_constraint\_override*,
*hibernate.validator.allow\_multiple\_cascaded\_validation\_on\_result* and
*hibernate.validator.allow\_parallel\_method\_parameter\_constraint* in *validation.xml*. See example
[Example 12.2, “Configuring method validation behaviour in class hierarchies via properties”](#example-relaxing-method-validation-xml).

Example 12.2: Configuring method validation behaviour in class hierarchies via properties
```
<?xml version="1.0" encoding="UTF-8"?>
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration validation-configuration-2.0.xsd"
        version="2.0">
    <default-provider>org.hibernate.validator.HibernateValidator</default-provider>

    <property name="hibernate.validator.allow_parameter_constraint_override">true</property>
    <property name="hibernate.validator.allow_multiple_cascaded_validation_on_result">true</property>
    <property name="hibernate.validator.allow_parallel_method_parameter_constraint">true</property>
</validation-config>
```

Alternatively these settings can be applied during programmatic bootstrapping.

Example 12.3: Configuring method validation behaviour in class hierarchies
```
HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();

configuration.allowMultipleCascadedValidationOnReturnValues( true )
        .allowOverridingMethodAlterParameterConstraint( true )
        .allowParallelMethodsDefineParameterConstraints( true );
```

By default, all of these properties are false, implementing the default behavior as defined in the
Jakarta Bean Validation specification.

|  | Changing the default behaviour for method validation will result in non specification-conforming and non portable application. Make sure to understand what you are doing and that your use case really requires changes to the default behaviour. |
| --- | --- |

### 12.4. Programmatic constraint definition and declaration

As per the Jakarta Bean Validation specification, you can define and declare constraints using Java annotations and XML
based constraint mappings.

In addition, Hibernate Validator provides a fluent API which allows for the programmatic
configuration of constraints. Use cases include the dynamic addition of constraints at runtime
depending on some application state or tests where you need entities with different constraints in
different scenarios but don’t want to implement actual Java classes for each test case.

By default, constraints added via the fluent API are additive to constraints configured via the
standard configuration capabilities. But it is also possible to ignore annotation and XML configured
constraints where required.

The API is centered around the `ConstraintMapping` interface. You obtain a new mapping via
`HibernateValidatorConfiguration#createConstraintMapping()` which you then can configure in a fluent
manner as shown in [Example 12.4, “Programmatic constraint declaration”](#example-constraint-mapping).

Example 12.4: Programmatic constraint declaration
```
HibernateValidatorConfiguration configuration = Validation
        .byProvider( HibernateValidator.class )
        .configure();

ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .field( "manufacturer" )
            .constraint( new NotNullDef() )
        .field( "licensePlate" )
            .ignoreAnnotations( true )
            .constraint( new NotNullDef() )
            .constraint( new SizeDef().min( 2 ).max( 14 ) )
    .type( RentalCar.class )
        .getter( "rentalStation" )
            .constraint( new NotNullDef() );

Validator validator = configuration.addMapping( constraintMapping )
        .buildValidatorFactory()
        .getValidator();
```

Constraints can be configured on multiple classes and properties using method chaining. The
constraint definition classes `NotNullDef` and `SizeDef` are helper classes which allow to configure
constraint parameters in a type-safe fashion. Definition classes exist for all built-in constraints
in the `org.hibernate.validator.cfg.defs` package. By calling `ignoreAnnotations()` any constraints
configured via annotations or XML are ignored for the given element.

|  | Each element (type, property, method etc.) may only be configured once within all the constraint mappings used to set up one validator factory. Otherwise a `ValidationException` is raised. |
| --- | --- |

|  | It is not supported to add constraints to non-overridden supertype properties and methods by configuring a subtype. Instead you need to configure the supertype in this case. |
| --- | --- |

Having configured the mapping, you must add it back to the configuration object from which you then
can obtain a validator factory.

For custom constraints, you can either create your own definition classes extending `ConstraintDef` or
you can use `GenericConstraintDef` as seen in [Example 12.5, “Programmatic declaration of a custom constraint”](#example-generic-constraint-mapping).

Example 12.5: Programmatic declaration of a custom constraint
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .field( "licensePlate" )
            .constraint( new GenericConstraintDef<>( CheckCase.class )
                .param( "value", CaseMode.UPPER )
            );
```

Container element constraints are supported by the programmatic API, using `containerElementType()`.

[Example 12.6, “Programmatic declaration of a nested container element constraint”](#example-nested-container-element-constraints) show an example where constraints are declared on
nested container elements.

Example 12.6: Programmatic declaration of a nested container element constraint
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .field( "manufacturer" )
            .constraint( new NotNullDef() )
        .field( "licensePlate" )
            .ignoreAnnotations( true )
            .constraint( new NotNullDef() )
            .constraint( new SizeDef().min( 2 ).max( 14 ) )
        .field( "partManufacturers" )
            .containerElementType( 0 )
                .constraint( new NotNullDef() )
            .containerElementType( 1, 0 )
                .constraint( new NotNullDef() )
    .type( RentalCar.class )
        .getter( "rentalStation" )
            .constraint( new NotNullDef() );
```

As demonstrated, the parameters passed to `containerElementType()` are the path of type argument
indexes used to obtain the desired nested container element type.

By invoking `valid()` you can mark a member for cascaded validation which is equivalent to annotating
it with `@Valid`. Configure any group conversions to be applied during cascaded validation using the
`convertGroup()` method (equivalent to `@ConvertGroup`). An example can be seen in
[Example 12.7, “Marking a property for cascaded validation”](#example-cascading-constraints).

Example 12.7: Marking a property for cascaded validation
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .field( "driver" )
            .constraint( new NotNullDef() )
            .valid()
            .convertGroup( Default.class ).to( PersonDefault.class )
        .field( "partManufacturers" )
            .containerElementType( 0 )
                .valid()
            .containerElementType( 1, 0 )
                .valid()
    .type( Person.class )
        .field( "name" )
            .constraint( new NotNullDef().groups( PersonDefault.class ) );
```

You can not only configure bean constraints using the fluent API but also method and constructor
constraints. As shown in [Example 12.8, “Programmatic declaration of method and constructor constraints”](#example-method-constraint-mapping) constructors are identified by their
parameter types and methods by their name and parameter types. Having selected a method or
constructor, you can mark its parameters and/or return value for cascaded validation and add
constraints as well as cross-parameter constraints.

As shown in the example, `valid()` can be also invoked on a container element type.

Example 12.8: Programmatic declaration of method and constructor constraints
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .constructor( String.class )
            .parameter( 0 )
                .constraint( new SizeDef().min( 3 ).max( 50 ) )
            .returnValue()
                .valid()
        .method( "drive", int.class )
            .parameter( 0 )
                .constraint( new MaxDef().value( 75 ) )
        .method( "load", List.class, List.class )
            .crossParameter()
                .constraint( new GenericConstraintDef<>(
                        LuggageCountMatchesPassengerCount.class ).param(
                            "piecesOfLuggagePerPassenger", 2
                        )
                )
        .method( "getDriver" )
            .returnValue()
                .constraint( new NotNullDef() )
                .valid();
```

Last but not least you can configure the default group sequence or the default group sequence
provider of a type as shown in the following example.

Example 12.9: Configuration of default group sequence and default group sequence provider
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .defaultGroupSequence( Car.class, CarChecks.class )
    .type( RentalCar.class )
        .defaultGroupSequenceProviderClass( RentalCarGroupSequenceProvider.class );
```

### 12.5. Applying programmatic constraint declarations to the default validator factory

If you are not bootstrapping a validator factory manually
but work with the default factory as configured via *META-INF/validation.xml*
(see [Chapter 8, *Configuring via XML*](#chapter-xml-configuration)),
you can add one or more constraint mappings by creating one or several constraint mapping contributors.
To do so, implement the `ConstraintMappingContributor` contract:

Example 12.10: Custom `ConstraintMappingContributor` implementation
```
package org.hibernate.validator.referenceguide.chapter12.constraintapi;

public class MyConstraintMappingContributor implements ConstraintMappingContributor {

    @Override
    public void createConstraintMappings(ConstraintMappingBuilder builder) {
        builder.addConstraintMapping()
            .type( Marathon.class )
                .getter( "name" )
                    .constraint( new NotNullDef() )
                .field( "numberOfHelpers" )
                    .constraint( new MinDef().value( 1 ) );

        builder.addConstraintMapping()
            .type( Runner.class )
                .field( "paidEntryFee" )
                    .constraint( new AssertTrueDef() );
    }
}
```

You then need to specify the fully-qualified class name of the contributor implementation in *META-INF/validation.xml*,
using the property key `hibernate.validator.constraint_mapping_contributors`. You can specify several
contributors by separating them with a comma.

### 12.6. Advanced constraint composition features

#### 12.6.1. Validation target specification for purely composed constraints

In case you specify a purely composed constraint - i.e. a constraint which has no validator itself but is solely made
up from other, composing constraints - on a method declaration, the validation engine cannot determine whether that
constraint is to be applied as a return value constraint or as a cross-parameter constraint.

Hibernate Validator allows to resolve such ambiguities by specifying the `@SupportedValidationTarget` annotation on the
declaration of the composed constraint type as shown in [Example 12.11, “Specifying the validation target of a purely composed constraint”](#example-purely-composed-constraint-validation-target).
The `@ValidInvoiceAmount` does not declare any validator, but it is solely composed by the `@Min` and `@NotNull`
constraints. The `@SupportedValidationTarget` ensures that the constraint is applied to the method return value when
given on a method declaration.

Example 12.11: Specifying the validation target of a purely composed constraint
```
package org.hibernate.validator.referenceguide.chapter12.purelycomposed;

@Min(value = 0)
@NotNull
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
@SupportedValidationTarget(ValidationTarget.ANNOTATED_ELEMENT)
@ReportAsSingleViolation
public @interface ValidInvoiceAmount {

    String message() default "{org.hibernate.validator.referenceguide.chapter11.purelycomposed."
            + "ValidInvoiceAmount.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @OverridesAttribute(constraint = Min.class, name = "value")
    long value();
}
```

#### 12.6.2. Boolean composition of constraints

Jakarta Bean Validation specifies that the constraints of a composed constraint (see
[Section 6.4, “Constraint composition”](#section-constraint-composition)) are all combined via a logical *AND*. This means all of the
composing constraints need to return true to obtain an overall successful validation.

Hibernate Validator offers an extension to this and allows you to compose constraints via a logical
*OR* or *NOT*. To do so, you have to use the ConstraintComposition annotation and the enum
CompositionType with its values *AND*, *OR* and *ALL\_FALSE*.

[Example 12.12, “OR composition of constraints”](#example-boolean-constraint-composition) shows how to build a composed constraint `@PatternOrSize`
where only one of the composing constraints needs to be valid in order to pass the validation.
Either the validated string is all lower-cased or it is between two and three characters long.

Example 12.12: OR composition of constraints
```
package org.hibernate.validator.referenceguide.chapter12.booleancomposition;

@ConstraintComposition(OR)
@Pattern(regexp = "[a-z]")
@Size(min = 2, max = 3)
@ReportAsSingleViolation
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
public @interface PatternOrSize {
    String message() default "{org.hibernate.validator.referenceguide.chapter11." +
            "booleancomposition.PatternOrSize.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
}
```

|  | Using *ALL\_FALSE* as composition type implicitly enforces that only a single violation will get reported in case validation of the constraint composition fails. |
| --- | --- |

### 12.7. Extensions of the Path API

Hibernate Validator provides an extension to the `javax.validation.Path` API.
For nodes of `ElementKind.PROPERTY` and `ElementKind.CONTAINER_ELEMENT` it allows to obtain the value of the
represented property.
To do so, narrow down a given node to the type `org.hibernate.validator.path.PropertyNode` or
`org.hibernate.validator.path.ContainerElementNode` respectively using `Node#as()`, as
shown in the following example:

Example 12.13: Getting the value from property nodes
```
Building building = new Building();

// Assume the name of the person violates a @Size constraint
Person bob = new Person( "Bob" );
Apartment bobsApartment = new Apartment( bob );
building.getApartments().add( bobsApartment );

Set<ConstraintViolation<Building>> constraintViolations = validator.validate( building );

Path path = constraintViolations.iterator().next().getPropertyPath();
Iterator<Path.Node> nodeIterator = path.iterator();

Path.Node node = nodeIterator.next();
assertEquals( node.getName(), "apartments" );
assertSame( node.as( PropertyNode.class ).getValue(), bobsApartment );

node = nodeIterator.next();
assertEquals( node.getName(), "resident" );
assertSame( node.as( PropertyNode.class ).getValue(), bob );

node = nodeIterator.next();
assertEquals( node.getName(), "name" );
assertEquals( node.as( PropertyNode.class ).getValue(), "Bob" );
```

This is also very useful to obtain the element of `Set` properties on the property path (e.g. `apartments`
in the example) which otherwise could not be identified (unlike for `Map` and `List`, there is no key nor index
in this case).

### 12.8. Dynamic payload as part of `ConstraintViolation`

In some cases automatic processing of violations can be aided, if the constraint violation provides additional
data - a so called dynamic payload. This dynamic payload could for example contain hints to the user on how to
resolve the violation.

Dynamic payloads can be set in [custom constraints](#validator-customconstraints) using `HibernateConstraintValidatorContext`.
This is shown in example [Example 12.14, “`ConstraintValidator` implementation setting a dynamic payload”](#example-constraint-validator-setting-dynamic-payload) where the
`javax.validation.ConstraintValidatorContext` is unwrapped to `HibernateConstraintValidatorContext` in order to call
`withDynamicPayload`.

Example 12.14: `ConstraintValidator` implementation setting a dynamic payload
```
package org.hibernate.validator.referenceguide.chapter12.dynamicpayload;

import static org.hibernate.validator.internal.util.CollectionHelper.newHashMap;

public class ValidPassengerCountValidator implements ConstraintValidator<ValidPassengerCount, Car> {

    private static final Map<Integer, String> suggestedCars = newHashMap();

    static {
        suggestedCars.put( 2, "Chevrolet Corvette" );
        suggestedCars.put( 3, "Toyota Volta" );
        suggestedCars.put( 4, "Maserati GranCabrio" );
        suggestedCars.put( 5, " Mercedes-Benz E-Class" );
    }

    @Override
    public void initialize(ValidPassengerCount constraintAnnotation) {
    }

    @Override
    public boolean isValid(Car car, ConstraintValidatorContext context) {
        if ( car == null ) {
            return true;
        }

        int passengerCount = car.getPassengers().size();
        if ( car.getSeatCount() >= passengerCount ) {
            return true;
        }
        else {

            if ( suggestedCars.containsKey( passengerCount ) ) {
                HibernateConstraintValidatorContext hibernateContext = context.unwrap(
                        HibernateConstraintValidatorContext.class
                );
                hibernateContext.withDynamicPayload( suggestedCars.get( passengerCount ) );
            }
            return false;
        }
    }
}
```

On the constraint violation processing side, a `javax.validation.ConstraintViolation` can then in turn be
unwrapped to `HibernateConstraintViolation` in order to retrieve the dynamic payload for further processing.

Example 12.15: Retrieval of a `ConstraintViolation`'s dynamic payload
```
Car car = new Car( 2 );
car.addPassenger( new Person() );
car.addPassenger( new Person() );
car.addPassenger( new Person() );
Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );

ConstraintViolation<Car> constraintViolation = constraintViolations.iterator().next();
@SuppressWarnings("unchecked")
HibernateConstraintViolation<Car> hibernateConstraintViolation = constraintViolation.unwrap(
        HibernateConstraintViolation.class
);
String suggestedCar = hibernateConstraintViolation.getDynamicPayload( String.class );
assertEquals( "Toyota Volta", suggestedCar );
```

### 12.9. `ParameterMessageInterpolator`

Hibernate Validator requires per default an implementation of the Unified EL (see
[Section 1.1.1, “Unified EL”](#validator-gettingstarted-uel)) to be available. This is needed to allow the interpolation
of constraint error messages using EL expressions as defined by the Jakarta Bean Validation specification.

For environments where you cannot or do not want to provide an EL implementation, Hibernate Validator
offers a non EL based message interpolator - `org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator`.

Refer to [Section 4.2, “Custom message interpolation”](#section-custom-message-interpolation) to see how to plug in custom message interpolator
implementations.

|  | Constraint messages containing EL expressions will be returned un-interpolated by `org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator`. This also affects built-in default constraint messages which use EL expressions. At the moment, `DecimalMin` and `DecimalMax` are affected. |
| --- | --- |

### 12.10. `ResourceBundleLocator`

With `ResourceBundleLocator`, Hibernate Validator provides an additional SPI which allows to retrieve
error messages from other resource bundles than *ValidationMessages* while still using the actual
interpolation algorithm as defined by the specification. Refer to
[Section 4.2.1, “`ResourceBundleLocator`”](#section-resource-bundle-locator) to learn how to make use of that SPI.

### 12.11. Customizing the locale resolution

|  | These contracts are marked as `@Incubating` so they might be subject to change in the future. |
| --- | --- |

Hibernate Validator provides several extension points to build a custom locale resolution strategy.
The resolved locale is used when interpolating the constraint violation messages.

The default behavior of Hibernate Validator is to always use the system default locale (as obtained via `Locale.getDefault()`).
This might not be the desired behavior if, for example, you usually set your system locale to `en-US` but want your application to provide messages in French.

The following example shows how to set the Hibernate Validator default locale to `fr-FR`:

Example 12.16: Configure the default locale
```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .defaultLocale( Locale.FRANCE )
        .buildValidatorFactory()
        .getValidator();

Set<ConstraintViolation<Bean>> violations = validator.validate( new Bean() );
assertEquals( "doit avoir la valeur vrai", violations.iterator().next().getMessage() );
```

While this is already a nice improvement, in a fully internationalized application, this is not sufficient:
you need Hibernate Validator to select the locale depending on the user context.

Hibernate Validator provides the `org.hibernate.validator.spi.messageinterpolation.LocaleResolver` SPI
which allows to fine-tune the resolution of the locale.
Typically, in a JAX-RS environment, you can resolve the locale to use from the `Accept-Language` HTTP header.

In the following example, we use a hardcoded value but, for instance, in the case of a RESTEasy application,
you could extract the header from the `ResteasyContext`.

Example 12.17: Fine tune the locale used to interpolate the messages via a `LocaleResolver`
```
LocaleResolver localeResolver = new LocaleResolver() {

    @Override
    public Locale resolve(LocaleResolverContext context) {
        // get the locales supported by the client from the Accept-Language header
        String acceptLanguageHeader = "it-IT;q=0.9,en-US;q=0.7";

        List<LanguageRange> acceptedLanguages = LanguageRange.parse( acceptLanguageHeader );
        List<Locale> resolvedLocales = Locale.filter( acceptedLanguages, context.getSupportedLocales() );

        if ( resolvedLocales.size() > 0 ) {
            return resolvedLocales.get( 0 );
        }

        return context.getDefaultLocale();
    }
};

Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .defaultLocale( Locale.FRANCE )
        .locales( Locale.FRANCE, Locale.ITALY, Locale.US )
        .localeResolver( localeResolver )
        .buildValidatorFactory()
        .getValidator();

Set<ConstraintViolation<Bean>> violations = validator.validate( new Bean() );
assertEquals( "deve essere true", violations.iterator().next().getMessage() );
```

|  | When using the `LocaleResolver`, you have to define the list of supported locales via the `locales()` method. |
| --- | --- |

### 12.12. Custom contexts

The Jakarta Bean Validation specification offers at several points in its API the possibility to unwrap a
given interface to an implementor specific subtype. In the case of constraint violation creation in
`ConstraintValidator` implementations as well as message interpolation in `MessageInterpolator`
instances, there exist `unwrap()` methods for the provided context instances -
`ConstraintValidatorContext` respectively `MessageInterpolatorContext`. Hibernate Validator provides
custom extensions for both of these interfaces.

#### 12.12.1. `HibernateConstraintValidatorContext`

`HibernateConstraintValidatorContext` is a subtype of `ConstraintValidatorContext` which allows you to:

* set arbitrary parameters for interpolation via the Expression Language message interpolation
  facility using `HibernateConstraintValidatorContext#addExpressionVariable(String, Object)`
  or `HibernateConstraintValidatorContext#addMessageParameter(String, Object)`.

  Example 152. Custom `@Future` validator injecting an expression variable
  ```
  package org.hibernate.validator.referenceguide.chapter12.context;

  import java.time.Instant;

  import javax.validation.ConstraintValidator;
  import javax.validation.ConstraintValidatorContext;
  import javax.validation.constraints.Future;

  import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;

  public class MyFutureValidator implements ConstraintValidator<Future, Instant> {

      @Override
      public void initialize(Future constraintAnnotation) {
      }

      @Override
      public boolean isValid(Instant value, ConstraintValidatorContext context) {
          if ( value == null ) {
              return true;
          }

          HibernateConstraintValidatorContext hibernateContext = context.unwrap(
                  HibernateConstraintValidatorContext.class
          );

          Instant now = Instant.now( context.getClockProvider().getClock() );

          if ( !value.isAfter( now ) ) {
              hibernateContext.disableDefaultConstraintViolation();
              hibernateContext
                      .addExpressionVariable( "now", now )
                      .buildConstraintViolationWithTemplate( "Must be after ${now}" )
                      .addConstraintViolation();

              return false;
          }

          return true;
      }
  }
  ```

  Example 153. Custom `@Future` validator injecting a message parameter
  ```
  package org.hibernate.validator.referenceguide.chapter12.context;

  import java.time.Instant;

  import javax.validation.ConstraintValidator;
  import javax.validation.ConstraintValidatorContext;
  import javax.validation.constraints.Future;

  import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;

  public class MyFutureValidatorMessageParameter implements ConstraintValidator<Future, Instant> {

      @Override
      public void initialize(Future constraintAnnotation) {
      }

      @Override
      public boolean isValid(Instant value, ConstraintValidatorContext context) {
          if ( value == null ) {
              return true;
          }

          HibernateConstraintValidatorContext hibernateContext = context.unwrap(
                  HibernateConstraintValidatorContext.class
          );

          Instant now = Instant.now( context.getClockProvider().getClock() );

          if ( !value.isAfter( now ) ) {
              hibernateContext.disableDefaultConstraintViolation();
              hibernateContext
                      .addMessageParameter( "now", now )
                      .buildConstraintViolationWithTemplate( "Must be after {now}" )
                      .addConstraintViolation();

              return false;
          }

          return true;
      }
  }
  ```

  |  | Apart from the syntax, the main difference between message parameters and expression variables is that message parameters are simply interpolated whereas expression variables are interpreted using the expression language engine. In practice, it should not change anything. |
  | --- | --- |

  |  | Note that the parameters specified via `addExpressionVariable(String, Object)` and `addMessageParameter(String, Object)` are global and apply to all constraint violations created by this `isValid()` invocation. This includes the default constraint violation, but also all violations created by the `ConstraintViolationBuilder`. You can, however, update the parameters between invocations of `ConstraintViolationBuilder#addConstraintViolation()`. |
  | --- | --- |
* set an arbitrary dynamic payload - see [Section 12.8, “Dynamic payload as part of `ConstraintViolation`”](#section-dynamic-payload)

#### 12.12.2. `HibernateMessageInterpolatorContext`

Hibernate Validator also offers a custom extension of `MessageInterpolatorContext`, namely
`HibernateMessageInterpolatorContext` (see [Example 12.18, “`HibernateMessageInterpolatorContext`”](#example-custom-message-interpolator-context)). This
subtype was introduced to allow a better integration of Hibernate Validator into Glassfish. The
root bean type was in this case needed to determine the right class loader for the message resource
bundle. If you have any other use cases, let us know.

Example 12.18: `HibernateMessageInterpolatorContext`
```
 * @author Gunnar Morling
 * @author Guillaume Smet
 * @since 5.0
 */
public interface HibernateMessageInterpolatorContext extends MessageInterpolator.Context {

    /**
     * Returns the currently validated root bean type.
     *
```

### 12.13. Paranamer based `ParameterNameProvider`

Hibernate Validator comes with a `ParameterNameProvider` implementation which leverages the
[Paranamer](http://paranamer.codehaus.org/) library.

This library provides several ways for obtaining parameter names at runtime, e.g. based on debug
symbols created by the Java compiler, constants with the parameter names woven into the bytecode in
a post-compile step or annotations such as the `@Named` annotation from JSR 330.

In order to use `ParanamerParameterNameProvider`, either pass an instance when bootstrapping a
validator as shown in [Example 9.10, “Using a custom `ParameterNameProvider`”](#example-using-custom-parameter-name-provider) or specify
`org.hibernate.validator.parameternameprovider.ParanamerParameterNameProvider` as value for the
`<parameter-name-provider>` element in the *META-INF/validation.xml* file.

|  | When using this parameter name provider, you need to add the Paranamer library to your classpath. It is available in the Maven Central repository with the group id `com.thoughtworks.paranamer` and the artifact id `paranamer`. |
| --- | --- |

By default `ParanamerParameterNameProvider` retrieves parameter names from constants added to the byte
code at build time (via `DefaultParanamer`) and debug symbols (via `BytecodeReadingParanamer`).
Alternatively you can specify a `Paranamer` implementation of your choice when creating a
`ParanamerParameterNameProvider` instance.

### 12.14. Providing constraint definitions

Jakarta Bean Validation allows to (re-)define constraint definitions via XML in its constraint mapping
files. See [Section 8.2, “Mapping constraints via `constraint-mappings`”](#section-mapping-xml-constraints) for more information and [Example 8.2, “Bean constraints configured via XML”](#example-constraints-car)
for an example. While this approach is sufficient for many use cases, it has its shortcomings
in others. Imagine for example a constraint library wanting to contribute constraint
definitions for custom types. This library could provide a mapping file with their library, but this
file still would need to be referenced by the user of the library. Luckily there are better ways.

|  | The following concepts are considered experimental at this time. Let us know whether you find them useful and whether they meet your needs. |
| --- | --- |

#### 12.14.1. Constraint definitions via `ServiceLoader`

Hibernate Validator allows to utilize Java’s
[ServiceLoader](http://docs.oracle.com/javase/8/docs/api/?java/util/ServiceLoader.html)
mechanism to register additional constraint definitions. All you have to do is to add the file
*javax.validation.ConstraintValidator* to *META-INF/services*. In this service file you list the
fully qualified classnames of your constraint validator classes (one per line). Hibernate Validator
will automatically infer the constraint types they apply to.
See [Constraint definition via service file](#example-using-service-file-for-constraint-definitions)
for an example.

Example 12.19: *META-INF/services/javax.validation.ConstraintValidator*
```
# Assuming a custom constraint annotation @org.mycompany.CheckCase
org.mycompany.CheckCaseValidator
```

To contribute default messages for your custom constraints, place a file *ContributorValidationMessages.properties*
and/or its locale-specific specializations at the root of your JAR. Hibernate Validator will consider the
entries from all the bundles with this name found on the classpath in addition to those given in *ValidationMessages.properties*.

This mechanism is also helpful when creating large multi-module applications: instead of putting all the constraint
messages into one single bundle, you can have one resource bundle per module containing only those messages of that module.

|  | We highly recommend the reading of [this blog post by Marko Bekhta](http://in.relation.to/2017/03/02/adding-custom-constraint-definitions-via-the-java-service-loader/), guiding you step by step through the process of creating an independent JAR that contains your custom constraints and declares them via the `ServiceLoader`. |
| --- | --- |

#### 12.14.2. Adding constraint definitions programmatically

While the service loader approach works in many scenarios, but not in all (think for example
OSGi where service files are not visible), there is yet another way of contributing constraint
definitions. You can use the programmatic constraint declaration API - see
[Example 12.20, “Adding constraint definitions through the programmatic API”](#example-using-constraint-definition-api).

Example 12.20: Adding constraint definitions through the programmatic API
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
        .constraintDefinition( ValidPassengerCount.class )
        .validatedBy( ValidPassengerCountValidator.class );
```

If your validator implementation is rather simple (i.e. no initialization from the annotation is needed,
and `ConstraintValidatorContext` is not used), you also can use this alternative API to specify the constraint logic using a Lambda expression or method reference:

Example 12.21: Adding constraint definition with a Lambda expression
```
ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
        .constraintDefinition( ValidPassengerCount.class )
            .validateType( Bus.class )
                .with( b -> b.getSeatCount() >= b.getPassengers().size() );
```

Instead of directly adding a constraint mapping to the configuration object, you may use a `ConstraintMappingContributor`
as detailed in [Section 12.5, “Applying programmatic constraint declarations to the default validator factory”](#section-programmatic-api-contributor). This can be useful when
configuring the default validator factory using *META-INF/validation.xml* (see
[Chapter 8, *Configuring via XML*](#chapter-xml-configuration)).

|  | One use case for registering constraint definitions through the programmatic API is the ability to specify an alternative constraint validator for the `@URL` constraint. Historically, Hibernate Validator’s default constraint validator for this constraint uses the `java.net.URL` constructor to validate an URL. However, there is also a purely regular expression based version available which can be configured using a `ConstraintDefinitionContributor`:  Using the programmatic constraint declaration API to register a regular expression based constraint definition for `@URL` ``` ConstraintMapping constraintMapping = configuration.createConstraintMapping();  constraintMapping         .constraintDefinition( URL.class )         .includeExistingValidators( false )         .validatedBy( RegexpURLValidator.class ); ``` |
| --- | --- |

### 12.15. Customizing class-loading

There are several cases in which Hibernate Validator needs to load resources or classes given by name:

* XML descriptors (*META-INF/validation.xml* as well as XML constraint mappings)
* classes specified by name in XML descriptors (e.g. custom message interpolators etc.)
* the *ValidationMessages* resource bundle
* the `ExpressionFactory` implementation used for expression based message interpolation

By default, Hibernate Validator tries to load these resources via the current thread context class loader.
If that’s not successful, Hibernate Validator’s own class loader will be tried as a fallback.

For cases where this strategy is not appropriate (e.g. modularized environments such as OSGi),
you may provide a specific class loader for loading these resources when bootstrapping the validator factory:

Example 12.22: Providing a class loader for loading external resources and classes
```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .externalClassLoader( classLoader )
        .buildValidatorFactory()
        .getValidator();
```

In the case of OSGi, you could e.g. pass the loader of a class from the bundle bootstrapping Hibernate Validator
or a custom class loader implementation which delegates to `Bundle#loadClass()` etc.

|  | Call `ValidatorFactory#close()` if a given validator factory instance is not needed any longer. Failure to do so may result in a class loader leak in cases where applications/bundles are re-deployed and a non-closed validator factory still is referenced by application code. |
| --- | --- |

### 12.16. Customizing the getter property selection strategy

When a bean is validated by Hibernate Validator, its properties get validated. A property can either
be a field or a getter.
By default, Hibernate Validator respects the JavaBeans specification and considers a method as a getter as soon
as one of the conditions below is true:

* the method name starts with `get`, it has a non-void return type and has no parameters;
* the method name starts with `is`, has a return type of `boolean` and has no parameters;
* the method name starts with `has`, has a return type of `boolean` and has no parameters (this rule
  is specific to Hibernate Validator and is not mandated by the JavaBeans specification)

While these rules are usually appropriate when following the classic JavaBeans convention, it might happen,
especially with code generators, that the JavaBeans naming convention is not followed and that the getters'
names are following a different convention.

In this case, the strategy for detecting getters should be redefined in order to fully validate the object.

A classic example of this requirement is when the classes follow a fluent naming convention,
as illustrated in [Example 12.23, “A class that uses non-standard getters”](#example-using-fluent-api-pattern).

Example 12.23: A class that uses non-standard getters
```
package org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy;

public class User {

    private String firstName;
    private String lastName;
    private String email;

    // [...]

    @NotEmpty
    public String firstName() {
        return firstName;
    }

    @NotEmpty
    public String lastName() {
        return lastName;
    }

    @Email
    public String email() {
        return email;
    }
}
```

If such object gets validated, no validation will be performed on the getters as they are not detected
by the standard strategy.

Example 12.24: Validating a class with non-standard getters using the default getter property selection strategy
```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .buildValidatorFactory()
        .getValidator();

User user = new User( "", "", "not an email" );

Set<ConstraintViolation<User>> constraintViolations = validator.validate( user );

// as User has non-standard getters no violations are triggered
assertEquals( 0, constraintViolations.size() );
```

To make Hibernate Validator treat such methods as properties, a custom `GetterPropertySelectionStrategy`
should be configured.
In this particular case, a possible implementation of the strategy would be:

Example 12.25: Custom `GetterPropertySelectionStrategy` implementation
```
package org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy;

public class FluentGetterPropertySelectionStrategy implements GetterPropertySelectionStrategy {

    private final Set<String> methodNamesToIgnore;

    public FluentGetterPropertySelectionStrategy() {
        // we will ignore all the method names coming from Object
        this.methodNamesToIgnore = Arrays.stream( Object.class.getDeclaredMethods() )
                .map( Method::getName )
                .collect( Collectors.toSet() );
    }

    @Override
    public Optional<String> getProperty(ConstrainableExecutable executable) {
        if ( methodNamesToIgnore.contains( executable.getName() )
                || executable.getReturnType() == void.class
                || executable.getParameterTypes().length > 0 ) {
            return Optional.empty();
        }

        return Optional.of( executable.getName() );
    }

    @Override
    public Set<String> getGetterMethodNameCandidates(String propertyName) {
        // As method name == property name, there always is just one possible name for a method
        return Collections.singleton( propertyName );
    }
}
```

There are multiple ways to configure Hibernate Validator to use this strategy. It can either be done
programmatically (see [Example 12.26, “Configuring a custom `GetterPropertySelectionStrategy` programmatically”](#custom-getter-strategy-programmatically)) or by using the
`hibernate.validator.getter_property_selection_strategy` property in the XML configuration
(see [Example 12.27, “Configuring a custom `GetterPropertySelectionStrategy` using an XML property”](#custom-getter-strategy-xml)).

Example 12.26: Configuring a custom `GetterPropertySelectionStrategy` programmatically
```
Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        // Setting a custom getter property selection strategy
        .getterPropertySelectionStrategy( new FluentGetterPropertySelectionStrategy() )
        .buildValidatorFactory()
        .getValidator();

User user = new User( "", "", "not an email" );

Set<ConstraintViolation<User>> constraintViolations = validator.validate( user );

assertEquals( 3, constraintViolations.size() );
```

Example 12.27: Configuring a custom `GetterPropertySelectionStrategy` using an XML property
```
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
        version="2.0">

    <property name="hibernate.validator.getter_property_selection_strategy">
        org.hibernate.validator.referenceguide.chapter12.getterselectionstrategy.NoPrefixGetterPropertySelectionStrategy
    </property>

</validation-config>
```

|  | It is important to mention that in cases where programmatic constraints are added using `HibernateValidatorConfiguration#addMapping(ConstraintMapping)`, adding mappings should always be done after the required getter property selection strategy is configured. Otherwise, the default strategy will be used for the mappings added before defining the strategy. |
| --- | --- |

### 12.17. Customizing the property name resolution for constraint violations

Imagine that we have a simple data class that has `@NotNull` constraints on some fields:

Example 12.28: Person data class
```
public class Person {
    @NotNull
    @JsonProperty("first_name")
    private final String firstName;

    @JsonProperty("last_name")
    private final String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```

This class can be serialized to JSON by using the [Jackson](https://github.com/FasterXML/jackson) library:

Example 12.29: Serializing Person object to JSON
```
public class PersonSerializationTest {
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    public void personIsSerialized() throws JsonProcessingException {
        Person person = new Person( "Clark", "Kent" );

        String serializedPerson = objectMapper.writeValueAsString( person );

        assertEquals( "{\"first_name\":\"Clark\",\"last_name\":\"Kent\"}", serializedPerson );
    }
}
```

As we can see, the object is serialized to:

Example 12.30: Person as json
```
{
  "first_name": "Clark",
  "last_name": "Kent"
}
```

Notice how the names of the properties differ. In the Java object, we have `firstName` and `lastName`, whereas in the JSON output, we have
`first_name` and `last_name`.
We customized this behavior through `@JsonProperty` annotations.

Now imagine that we use this class in a REST environment, where a user can send [a `Person` instance as JSON](#example-person-json) in the request body.
It would be nice, when indicating on which field the validation failed, to indicate the name they use in their JSON request, `first_name`,
and not the name we use internally in our Java code, `firstName`.

The `org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider` contract allows us to do this.
By implementing it, we can define how the name of a property will be resolved during validation.
In our case, we want to read the value from the Jackson configuration.

One example of how to do this is to leverage the Jackson API:

Example 12.31: JacksonPropertyNodeNameProvider implementation
```
import org.hibernate.validator.spi.nodenameprovider.JavaBeanProperty;
import org.hibernate.validator.spi.nodenameprovider.Property;
import org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider;

import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;

public class JacksonPropertyNodeNameProvider implements PropertyNodeNameProvider {
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public String getName(Property property) {
        if ( property instanceof JavaBeanProperty ) {
            return getJavaBeanPropertyName( (JavaBeanProperty) property );
        }

        return getDefaultName( property );
    }

    private String getJavaBeanPropertyName(JavaBeanProperty property) {
        JavaType type = objectMapper.constructType( property.getDeclaringClass() );
        BeanDescription desc = objectMapper.getSerializationConfig().introspect( type );

        return desc.findProperties()
                .stream()
                .filter( prop -> prop.getInternalName().equals( property.getName() ) )
                .map( BeanPropertyDefinition::getName )
                .findFirst()
                .orElse( property.getName() );
    }

    private String getDefaultName(Property property) {
        return property.getName();
    }
}
```

And when doing the validation:

Example 12.32: JacksonPropertyNodeNameProvider usage
```
public class JacksonPropertyNodeNameProviderTest {
    @Test
    public void nameIsReadFromJacksonAnnotationOnField() {
        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
                .configure()
                .propertyNodeNameProvider( new JacksonPropertyNodeNameProvider() )
                .buildValidatorFactory();

        Validator validator = validatorFactory.getValidator();

        Person clarkKent = new Person( null, "Kent" );

        Set<ConstraintViolation<Person>> violations = validator.validate( clarkKent );
        ConstraintViolation<Person> violation = violations.iterator().next();

        assertEquals( violation.getPropertyPath().toString(), "first_name" );
    }
```

We can see that the property path now returns `first_name`.

Note that this also works when the annotations are on a getter:

Example 12.33: Annotation on a getter
```
@Test
public void nameIsReadFromJacksonAnnotationOnGetter() {
    ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
            .configure()
            .propertyNodeNameProvider( new JacksonPropertyNodeNameProvider() )
            .buildValidatorFactory();

    Validator validator = validatorFactory.getValidator();

    Person clarkKent = new Person( null, "Kent" );

    Set<ConstraintViolation<Person>> violations = validator.validate( clarkKent );
    ConstraintViolation<Person> violation = violations.iterator().next();

    assertEquals( violation.getPropertyPath().toString(), "first_name" );
}

public class Person {
    private final String firstName;

    @JsonProperty("last_name")
    private final String lastName;

    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @NotNull
    @JsonProperty("first_name")
    public String getFirstName() {
        return firstName;
    }
}
```

This is just one use case of why we would like to change how the property names are resolved.

`org.hibernate.validator.spi.nodenameprovider.PropertyNodeNameProvider` can be implemented to provide a property name in
whatever way you see fit (reading from annotations, for instance).

There are two more interfaces that are worth mentioning:

* `org.hibernate.validator.spi.nodenameprovider.Property` is a base interface that holds metadata about a property. It
  has a single `String getName()` method that can be used to get the "original" name of a property. This interface
  should be used as a default way of resolving the name (see how it is used in [Example 12.31, “JacksonPropertyNodeNameProvider implementation”](#example-jackson-property-node-name-provider)).
* `org.hibernate.validator.spi.nodenameprovider.JavaBeanProperty` is an interface that holds metadata about a bean property. It
  extends `org.hibernate.validator.spi.nodenameprovider.Property` and provide some additional methods like `Class<?> getDeclaringClass()`
  which returns the class that is the owner of the property.

## 13. Annotation Processor

Have you ever caught yourself by unintentionally doing things like

* specifying constraint annotations at unsupported data types (e.g. by annotating a String with `@Past`)
* annotating the setter of a JavaBeans property (instead of the getter method)
* annotating static fields/methods with constraint annotations (which is not supported)?

Then the Hibernate Validator Annotation Processor is the right thing for you. It helps preventing
such mistakes by plugging into the build process and raising compilation errors whenever constraint
annotations are incorrectly used.

|  | You can find the Hibernate Validator Annotation Processor as part of the distribution bundle on [Sourceforge](http://sourceforge.net/projects/hibernate/files/hibernate-validator) or in the usual Maven repositories such as Maven Central under the GAV `org.hibernate.validator:hibernate-validator-annotation-processor:6.1.7.Final`. |
| --- | --- |

### 13.1. Prerequisites

The Hibernate Validator Annotation Processor is based on the "Pluggable Annotation Processing API"
as defined by [JSR 269](http://jcp.org/en/jsr/detail?id=269) which is part of the Java
Platform.

### 13.2. Features

As of Hibernate Validator 6.1.7.Final the Hibernate Validator Annotation Processor checks that:

* constraint annotations are allowed for the type of the annotated element
* only non-static fields or methods are annotated with constraint annotations
* only non-primitive fields or methods are annotated with `@Valid`
* only such methods are annotated with constraint annotations which are valid JavaBeans
  getter methods (optionally, see below)
* only such annotation types are annotated with constraint annotations which are constraint
  annotations themselves
* definition of dynamic default group sequence with `@GroupSequenceProvider` is valid
* annotation parameter values are meaningful and valid
* method parameter constraints in inheritance hierarchies respect the inheritance rules
* method return value constraints in inheritance hierarchies respect the inheritance rules

### 13.3. Options

The behavior of the Hibernate Validator Annotation Processor can be controlled using the following
[processor options](http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html#BHCHACIB):

`diagnosticKind`

Controls how constraint problems are reported. Must be the
string representation of one of the values from the enum `javax.tools.Diagnostic.Kind`,
e.g. `WARNING`. A value of `ERROR` will cause compilation to halt whenever the AP detects
a constraint problem. Defaults to `ERROR`.

`methodConstraintsSupported`

Controls whether constraints are allowed at methods of any
kind. Must be set to `true` when working with method level constraints as supported by
Hibernate Validator. Can be set to `false` to allow constraints only at
JavaBeans getter methods as defined by the Jakarta Bean Validation API. Defaults to `true`.

`verbose`

Controls whether detailed processing information shall be
displayed or not, useful for debugging purposes. Must be either
`true` or `false`. Defaults to `false`.

### 13.4. Using the Annotation Processor

This section shows in detail how to integrate the Hibernate Validator Annotation Processor into
command line builds (Maven, Ant, javac) as well as IDE-based builds (Eclipse, IntelliJ IDEA,
NetBeans).

#### 13.4.1. Command line builds

##### 13.4.1.1. Maven

For using the Hibernate Validator annotation processor with Maven, set it up via the `annotationProcessorPaths` option like this:

Example 13.1: Using the HV Annotation Processor with Maven
```
<project>
    [...]
    <build>
        [...]
        <plugins>
            [...]
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.6.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.hibernate.validator</groupId>
                            <artifactId>hibernate-validator-annotation-processor</artifactId>
                            <version>6.1.7.Final</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            [...]
        </plugins>
        [...]
    </build>
    [...]
</project>
```

##### 13.4.1.2. Gradle

When using [Gradle](https://gradle.org) it is enough to reference the annotation processor as an `annotationProcessor` dependency.

Example 13.2: Using the annotation processor with Gradle
```
dependencies {
    annotationProcessor group: 'org.hibernate.validator', name: 'hibernate-validator-annotation-processor', version: '6.1.7.Final'

    // any other dependencies ...
}
```

##### 13.4.1.3. Apache Ant

Similar to directly working with javac, the annotation processor can be added as as compiler
argument when invoking the [javac task](http://ant.apache.org/manual/CoreTasks/javac.html)
for [Apache Ant](http://ant.apache.org/):

Example 13.3: Using the annotation processor with Ant
```
<javac srcdir="src/main"
       destdir="build/classes"
       classpath="/path/to/validation-api-2.0.2.jar">
       <compilerarg value="-processorpath" />
       <compilerarg value="/path/to/hibernate-validator-annotation-processor-6.1.7.Final.jar"/>
</javac>
```

##### 13.4.1.4. javac

When compiling on the command line using
[javac](http://docs.oracle.com/javase/8/docs/technotes/guides/javac/index.html), specify the JAR
*hibernate-validator-annotation-processor-6.1.7.Final.jar* using the "processorpath" option as shown in
the following listing. The processor will be detected automatically by the compiler and invoked
during compilation.

Example 13.4: Using the annotation processor with javac
```
javac src/main/java/org/hibernate/validator/ap/demo/Car.java \
   -cp /path/to/validation-api-2.0.2.jar \
   -processorpath /path/to/hibernate-validator-annotation-processor-6.1.7.Final.jar
```

#### 13.4.2. IDE builds

##### 13.4.2.1. Eclipse

The annotation processor will automatically be set up for Maven projects configured as described above,
provided you have the [M2E Eclipse plug-in](https://www.eclipse.org/m2e/) installed.

For plain Eclipse projects follow these steps to set up the annotation processor:

* Right-click your project, choose "Properties"
* Go to "Java Compiler" and make sure, that "Compiler compliance level" is set to "1.8".
  Otherwise the processor won’t be activated
* Go to "Java Compiler - Annotation Processing" and choose "Enable annotation processing"
* Go to "Java Compiler - Annotation Processing - Factory Path" and add the JAR
  hibernate-validator-annotation-processor-6.1.7.Final.jar
* Confirm the workspace rebuild

You now should see any annotation problems as regular error markers within the editor and in the
"Problem" view:

![annotation processor eclipse](images/annotation_processor_eclipse.png)

##### 13.4.2.2. IntelliJ IDEA

The following steps must be followed to use the annotation processor within
[IntelliJ IDEA](http://www.jetbrains.com/idea/) (version 9 and above):

* Go to "File", then "Settings",
* Expand the node "Compiler", then "Annotation Processors"
* Choose "Enable annotation processing" and enter the following as "Processor path":
  /path/to/hibernate-validator-annotation-processor-6.1.7.Final.jar
* Add the processor’s fully qualified name org.hibernate.validator.ap.ConstraintValidationProcessor
  to the "Annotation Processors" list
* If applicable add you module to the "Processed Modules" list

Rebuilding your project then should show any erroneous constraint annotations:

![annotation processor intellij](images/annotation_processor_intellij.png)

##### 13.4.2.3. NetBeans

The [NetBeans](http://www.netbeans.org/) IDE supports using
annotation processors within the IDE build. To do so, do the following:

* Right-click your project, choose "Properties"
* Go to "Libraries", tab "Processor", and add the JAR hibernate-validator-annotation-processor-6.1.7.Final.jar
* Go to "Build - Compiling", select "Enable Annotation Processing" and "Enable Annotation Processing
  in Editor". Add the annotation processor by specifying its fully qualified name
  org.hibernate.validator.ap.ConstraintValidationProcessor

Any constraint annotation problems will then be marked directly within the editor:

![annotation processor netbeans](images/annotation_processor_netbeans.png)

### 13.5. Known issues

The following known issues exist as of July 2017:

* Container element constraints are not supported for now.
* Constraints applied to a container but in reality applied to the container elements (be it via
  the `Unwrapping.Unwrap` payload or via a value extractor marked with `@UnwrapByDefault`) are not supported
  correctly.
* [HV-308](https://hibernate.atlassian.net/browse/HV-308): Additional validators
  registered for a constraint
  [using XML](http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#chapter-xml-configuration) are
  not evaluated by the annotation processor.
* Sometimes custom constraints can’t be
  [properly evaluated](https://hibernate.atlassian.net/browse/HV-293) when
  using the processor within Eclipse. Cleaning the project can help in these situations. This seems to
  be an issue with the Eclipse JSR 269 API implementation, but further investigation is required here.
* When using the processor within Eclipse, the check of dynamic default group sequence definitions
  doesn’t work. After further investigation, it seems to be an issue with the Eclipse JSR 269 API
  implementation.

## 14. Further reading

Last but not least, a few pointers to further information.

A great source for examples is the Jakarta Bean Validation TCK which is available for anonymous access on
[GitHub](https://github.com/beanvalidation/beanvalidation-tck/). In particular the TCK’s
[tests](https://github.com/beanvalidation/beanvalidation-tck/tree/master/tests) might be
of interest. [The Jakarta Bean Validation](http://beanvalidation.org/2.0/spec/) specification itself
is also a great way to deepen your understanding of Jakarta Bean Validation and Hibernate Validator.

If you have any further questions about Hibernate Validator or want to share some of your use cases,
have a look at the [Hibernate Validator
Wiki](http://community.jboss.org/en/hibernate/validator), the [Hibernate Validator Forum](https://discourse.hibernate.org/c/hibernate-validator) and the
[Hibernate Validator tag on Stack Overflow](https://stackoverflow.com/questions/tagged/hibernate-validator).

In case you would like to report a bug use
[Hibernate’s Jira](https://hibernate.atlassian.net/projects/HV/) instance.
Feedback is always welcome!

Last updated 2020-12-16 15:41:22 UTC



=== Content from beanvalidation.org_172d9317_20250110_195958.html ===

# Jakarta Bean Validation specification

Gunnar Morling

version 2.0,
2019-08-05

Final

Table of Contents

* [Final license](#_final_license)
  + [Eclipse Foundation Specification License - v1.0](#_eclipse_foundation_specification_license_v1_0)
* [1. Introduction](#introduction)
  + [1.1. Expert group](#introduction-expertgroup)
  + [1.2. Specification goals](#introduction-goals)
  + [1.3. Required Java version](#introduction-requirements)
  + [1.4. How this document is organized](#introduction-documentorganization)
  + [1.5. How to comment](#introduction-commentingprocess)
* [2. What’s new](#whatsnew)
  + [2.1. What’s new in 2.0](#whatsnew-20)
  + [2.2. What’s new in 1.1](#whatsnew-11)
    - [2.2.1. Openness](#whatsnew-11-openness)
    - [2.2.2. Dependency injection](#whatsnew-11-dependencyinjection)
    - [2.2.3. Method validation](#whatsnew-11-methodvalidation)
    - [2.2.4. Integration with CDI](#whatsnew-11-contextdependencyinjection)
    - [2.2.5. Group conversion](#whatsnew-11-groupconversion)
    - [2.2.6. Message interpolation via the unified expression language](#whatsnew-11-expressionlanguage)
    - [2.2.7. Others](#whatsnew-11-others)
* [3. Constraint definition](#constraintsdefinitionimplementation)
  + [3.1. Constraint annotation](#constraintsdefinitionimplementation-constraintdefinition)
    - [3.1.1. Constraint definition properties](#constraintsdefinitionimplementation-constraintdefinition-properties)
    - [3.1.2. Examples](#constraintsdefinitionimplementation-constraintdefinition-examples)
  + [3.2. Applying multiple constraints of the same type](#constraintsdefinitionimplementation-multipleconstraints)
  + [3.3. Constraint composition](#constraintsdefinitionimplementation-constraintcomposition)
  + [3.4. Constraint validation implementation](#constraintsdefinitionimplementation-validationimplementation)
    - [3.4.1. Implementation of temporal constraint validators](#constraintsdefinitionimplementation-validationimplementation-temporalvalidators)
    - [3.4.2. Examples](#constraintsdefinitionimplementation-validationimplementation-example)
  + [3.5. The ConstraintValidatorFactory](#constraintsdefinitionimplementation-constraintfactory)
* [4. Value extractor definition](#valueextractordefinition)
  + [4.1. @ExtractedValue](#valueextractordefinition-extractedvalue)
  + [4.2. @UnwrapByDefault](#valueextractordefinition-unwrapbydefault)
  + [4.3. Built-in value extractors](#valueextractordefinition-builtinvalueextractors)
  + [4.4. Examples](#valueextractordefinition-examples)
* [5. Constraint declaration and validation process](#constraintdeclarationvalidationprocess)
  + [5.1. Requirements on classes to be validated](#constraintdeclarationvalidationprocess-requirements)
    - [5.1.1. Object validation](#constraintdeclarationvalidationprocess-requirements-objectvalidation)
    - [5.1.2. Field and property validation](#constraintdeclarationvalidationprocess-requirements-propertyvalidation)
    - [5.1.3. Graph validation](#constraintdeclarationvalidationprocess-requirements-graphvalidation)
  + [5.2. Constraint declaration](#constraintdeclarationvalidationprocess-constraintdeclaration)
  + [5.3. Inheritance (interface and superclass)](#constraintdeclarationvalidationprocess-inheritance)
  + [5.4. Group and group sequence](#constraintdeclarationvalidationprocess-groupsequence)
    - [5.4.1. Group inheritance](#constraintdeclarationvalidationprocess-groupsequence-groupinheritance)
    - [5.4.2. Group sequence](#constraintdeclarationvalidationprocess-groupsequence-groupsequence)
    - [5.4.3. Redefining the Default group for a class](#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup)
    - [5.4.4. Implicit grouping](#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping)
    - [5.4.5. Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion)
    - [5.4.6. Formal group definitions](#constraintdeclarationvalidationprocess-groupsequence-formaldefinition)
  + [5.5. Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints)
    - [5.5.1. Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)
  + [5.6. Method and constructor constraints](#constraintdeclarationvalidationprocess-methodlevelconstraints)
    - [5.6.1. Requirements on methods to be validated](#constraintdeclarationvalidationprocess-methodlevelconstraints-requirements)
    - [5.6.2. Declaring parameter constraints](#constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints)
    - [5.6.3. Declaring return value constraints](#constraintdeclarationvalidationprocess-methodlevelconstraints-returnvalueconstraints)
    - [5.6.4. Marking parameters and return values for cascaded validation](#constraintdeclarationvalidationprocess-methodlevelconstraints-cascadedvalidation)
    - [5.6.5. Method constraints in inheritance hierarchies](#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance)
  + [5.7. Validation routine](#constraintdeclarationvalidationprocess-validationroutine)
    - [5.7.1. Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)
    - [5.7.2. Method and constructor validation](#constraintdeclarationvalidationprocess-validationroutine-methodconstructorvalidation)
    - [5.7.3. Traversable property](#constraintdeclarationvalidationprocess-validationroutine-traversable)
    - [5.7.4. ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution)
    - [5.7.5. ValueExtractor resolution](#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution)
  + [5.8. Examples](#constraintdeclarationvalidationprocess-examples)
* [6. Validation APIs](#validationapi)
  + [6.1. Validator API](#validationapi-validatorapi)
    - [6.1.1. Validation methods](#validationapi-validatorapi-validationmethods)
    - [6.1.2. Methods for validating method and constructor constraints](#validationapi-validatorapi-methodlevelvalidationmethods)
    - [6.1.3. groups](#validationapi-validatorapi-groups)
  + [6.2. ConstraintViolation](#validationapi-constraintviolation)
    - [6.2.1. Examples](#validationapi-constraintviolation-examples)
    - [6.2.2. Examples for method and constructor constraint violations](#validationapi-constraintviolation-examplesexecutables)
  + [6.3. Message interpolation](#validationapi-message)
    - [6.3.1. Default message interpolation](#validationapi-message-defaultmessageinterpolation)
    - [6.3.2. Custom message interpolation](#validationapi-message-customresolution)
    - [6.3.3. Examples](#validationapi-message-examples)
  + [6.4. Triggering method validation](#validationapi-triggeringmethodvalidation)
  + [6.5. Bootstrapping](#validationapi-bootstrapping)
    - [6.5.1. Examples](#validationapi-bootstrapping-examples)
    - [6.5.2. ValidatorFactory](#validationapi-bootstrapping-validatorfactory)
    - [6.5.3. Configuration](#validationapi-bootstrapping-configuration)
    - [6.5.4. ValidationProvider and ValidationProviderResolver](#validationapi-bootstrapping-validationprovider)
    - [6.5.5. Validation](#validationapi-bootstrapping-validation)
    - [6.5.6. XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)
    - [6.5.7. Bootstrapping considerations](#validationapi-bootstrapping-usageandcontainerexpectation)
* [7. Constraint metadata request APIs](#constraintmetadata)
  + [7.1. Validator](#constraintmetadata-validator)
  + [7.2. ElementDescriptor](#constraintmetadata-elementdescriptor)
  + [7.3. BeanDescriptor](#constraintmetadata-beandescriptor)
  + [7.4. CascadableDescriptor](#constraintmetadata-cascadabledescriptor)
  + [7.5. GroupConversionDescriptor](#constraintmetadata-groupconversiondescriptor)
  + [7.6. PropertyDescriptor](#constraintmetadata-propertydescriptor)
  + [7.7. ExecutableDescriptor, MethodDescriptor and ConstructorDescriptor](#constraintmetadata-executabledescriptor)
  + [7.8. ParameterDescriptor](#constraintmetadata-parameterdescriptor)
  + [7.9. CrossParameterDescriptor](#constraintmetadata-crossparameterdescriptor)
  + [7.10. ReturnValueDescriptor](#constraintmetadata-returnvaluedescriptor)
  + [7.11. ContainerDescriptor and ContainerElementTypeDescriptor](#constraintmetadata-containerdescriptor)
  + [7.12. ConstraintDescriptor](#constraintmetadata-constraintdescriptor)
  + [7.13. Example](#constraintmetadata-example)
* [8. Built-in Constraint definitions](#builtinconstraints)
  + [8.1. `@Null` constraint](#builtinconstraints-null)
  + [8.2. `@NotNull` constraint](#builtinconstraints-notnull)
  + [8.3. `@AssertTrue` constraint](#builtinconstraints-asserttrue)
  + [8.4. `@AssertFalse` constraint](#builtinconstraints-assertfalse)
  + [8.5. `@Min` constraint](#builtinconstraints-min)
  + [8.6. `@Max` constraint](#builtinconstraints-max)
  + [8.7. `@DecimalMin` constraint](#builtinconstraints-decimalmin)
  + [8.8. `@DecimalMax` constraint](#builtinconstraints-decimalmax)
  + [8.9. `@Negative` constraint](#builtinconstraints-negative)
  + [8.10. `@NegativeOrZero` constraint](#builtinconstraints-negativeorzero)
  + [8.11. `@Positive` constraint](#builtinconstraints-positive)
  + [8.12. `@PositiveOrZero` constraint](#builtinconstraints-positiveorzero)
  + [8.13. `@Size` constraint](#builtinconstraints-size)
  + [8.14. `@Digits` constraint](#builtinconstraints-digits)
  + [8.15. `@Past` constraint](#builtinconstraints-past)
  + [8.16. `@PastOrPresent` constraint](#builtinconstraints-pastorpresent)
  + [8.17. `@Future` constraint](#builtinconstraints-future)
  + [8.18. `@FutureOrPresent` constraint](#builtinconstraints-futureorpresent)
  + [8.19. `@Pattern` constraint](#builtinconstraints-pattern)
  + [8.20. `@NotEmpty` constraint](#builtinconstraints-notempty)
  + [8.21. `@NotBlank` constraint](#builtinconstraints-notblank)
  + [8.22. `@Email` constraint](#builtinconstraints-email)
* [9. XML deployment descriptor](#xml)
  + [9.1. Constraint definition and declaration](#xml-mapping)
    - [9.1.1. Constraint declaration in XML](#xml-mapping-constraintdeclarationinxml)
    - [9.1.2. Overriding constraint definitions in XML](#xml-mapping-constraintdefinition)
    - [9.1.3. Converting the string representation of a value](#xml-mapping-typeconversion)
    - [9.1.4. XML Schema](#xml-mapping-xsd)
  + [9.2. Configuration schema](#xml-config-xsd)
* [10. Exception model](#exception)
  + [10.1. Error report: `ConstraintViolationException`](#exception-errorreport)
  + [10.2. Constraint definition: `ConstraintDefinitionException`](#exception-constraintdefinition)
  + [10.3. Constraint declaration: `ConstraintDeclarationException` and `UnexpectedTypeException`](#exception-constraintdeclaration)
  + [10.4. Group definition: `GroupDefinitionException`](#exception-groupdefinition)
  + [10.5. Value extractor definition: `ValueExtractorDefinitionException`](#exception-valueextractordefinition)
  + [10.6. Value extractor declaration: `ValueExtractorDeclarationException`](#exception-valueextractordeclaration)
  + [10.7. No Jakarta Bean Validation Provider detected: `NoProviderFoundException`](#exception-noprovider)
* [11. Integration](#integration)
  + [11.1. General requirements](#integration-general)
    - [11.1.1. Objects lifecycle](#integration-general-objectslifecycle)
    - [11.1.2. Method and constructor validation](#integration-general-executable)
  + [11.2. Jakarta EE](#integration-jakartaee)
  + [11.3. Jakarta Context and Dependency Injection integration](#integration-dependencyinjection)
    - [11.3.1. `ValidatorFactory` and `Validator`](#integration-dependencyinjection-validatorfactory)
    - [11.3.2. `ConstraintValidatorFactory`, `MessageInterpolator`, `ParameterNameProvider`, `ClockProvider`, `TraversableResolver` and `ValueExtractor`](#integration-dependencyinjection-customconfiguration)
    - [11.3.3. Method and constructor validation](#integration-dependencyinjection-methodconstructorvalidation)
  + [11.4. Jakarta Persistence 2.0 integration](#integration-persistence)
  + [11.5. Jakarta Server Faces 2.0 integration](#integration-faces)
  + [11.6. Jakarta RESTful Web Services 2 integration](#integration-restfulws)
* [Appendix A: Terminology](#terminology)
* [Appendix B: Standard ResourceBundle messages](#standard-resolver-messages)
* [Appendix C: Jakarta Persistence 2.0 and schema generation](#appendix-persistence)
* [Appendix D: Module name](#appendix-module-name)
* [Appendix E: Changelog](#changelog)

```
Specification: Jakarta Bean Validation

Version: 2.0

Status: Final

Release: 2019-08-05
```

## Final license

Copyright 2019 Eclipse Foundation.

This specification is licensed under the Eclipse Foundation Specification License 1.0; this specification is based on material that is licensed under the Apache License, version 2.0.

### Eclipse Foundation Specification License - v1.0

(Copy of the EFSL license [here](https://www.eclipse.org/legal/efsl.php))

By using and/or copying this document, or the Eclipse Foundation document from which this statement is linked, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions:

Permission to copy, and distribute the contents of this document, or the Eclipse Foundation document from which this statement is linked, in any medium for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the document, or portions thereof, that you use:

* link or URL to the original Eclipse Foundation document.
* All existing copyright notices, or if one does not exist, a notice (hypertext is preferred, but a textual representation is permitted) of the form: "Copyright © [$date-of-document] “Eclipse Foundation, Inc. [[url to this license]](#url to this license) "

Inclusion of the full text of this NOTICE must be provided. We request that authorship attribution be provided in any software, documents, or other items or products that you create pursuant to the implementation of the contents of this document, or any portion thereof.

No right to create modifications or derivatives of Eclipse Foundation documents is granted pursuant to this license, except anyone may prepare and distribute derivative works and portions of this document in software that implements the specification, in supporting materials accompanying such software, and in documentation of such software, PROVIDED that all such works include the notice below. HOWEVER, the publication of derivative works of this document for use as a technical specification is expressly prohibited.

The notice is:

Copyright © 2019 Eclipse Foundation. This software or document includes material copied from or derived from Jakarta Bean Validation <https://projects.eclipse.org/projects/ee4j.bean-validation>

Disclaimers

THIS DOCUMENT IS PROVIDED "AS IS," AND THE COPYRIGHT HOLDERS AND THE ECLIPSE FOUNDATION MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.

THE COPYRIGHT HOLDERS AND THE ECLIPSE FOUNDATION WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.

The name and trademarks of the copyright holders or the Eclipse Foundation may NOT be used in advertising or publicity pertaining to this document or its contents without specific, written prior permission. Title to copyright in this document will at all times remain with copyright holders.

## 1. Introduction

This document is the specification of the Jakarta Bean Validation in Jakarta EE and Java SE. The technical objective of this work is to provide an object level constraint declaration and validation facility for the Java application developer, as well as a constraint metadata repository and query API.

It also offers method and constructor validation facilities to ensure constraints on their parameters and return values.

### 1.1. Expert group

This work has been conducted as part of the Jakarta Bean Validation under the [Jakarta EE Specification Process](https://jakarta.ee/about/jesp/) and formerly JSR 380, 349 and 303 under the Java Community Process Program.
This specification is the result of the collaborative work of the members of the Expert Groups and the community at large.

The following persons have actively contributed to Bean Validation 2.0 as members of the JSR 380 expert group and the community at large in alphabetical order:

* Matt Benson
* Emmanuel Bernard (Red Hat, Inc.)
* Linda DeMichiel (Oracle)
* Hendrik Ebbers (Canoo AG)
* Hardy Ferentschik (Red Hat, Inc.)
* Christian Kaltepoth (ingenit GmbH & Co. KG)
* Werner Keil
* Marco Molteni (Genidea Sagl)
* Gunnar Morling (Red Hat, Inc.) - Specification Lead
* Michael Nascimento Santos
* Otavio Santana
* Guillaume Smet (Red Hat, Inc.)
* Tsuyoshi Yoshitomi (Fujitsu Limited)

The following persons have actively contributed to Bean Validation 1.1 as members of the JSR 349 expert group and the community at large in alphabetical order:

* Matt Benson
* Paul Benedict
* Emmanuel Bernard (Red Hat, Inc.) - Specification Lead
* Edward Burns (Oracle)
* Peter Davis
* Linda DeMichiel (Oracle)
* Hardy Ferentschik (Red Hat, Inc.)
* Antonio Goncalves
* Cemalettin Koç
* Rich Midwinter
* Gunnar Morling (individual then Red Hat, Inc.)
* Pete Muir (Red Hat, Inc.)
* Michael Nascimento Santos
* Gerhard Petracek
* Kevin Pollet (SERLI)
* Jagadish Prasath Ramu (Oracle)
* Bill Shannon (Oracle)
* Sebastian Thomschke

Former expert group members of JSR-303 in alphabetical order are:

* Geert Bevin
* Emmanuel Bernard (Red Hat, Inc.) - Specification Lead
* Uri Boness
* Erik Brakkee (Ericsson AB)
* Ed Burns (Sun Microsystems, Inc.)
* Jason Carreira
* Robert Clevenger (Oracle - retired)
* Linda DeMichiel (Sun Microsystems, Inc.)
* Tim Fennel
* Bharath Ganesh (Pramati Technologies)
* Romain Guy (Google Inc.)
* Robert Harrop
* Jacob J. Hookom
* Bob Lee (Google Inc.)
* Craig R. McClanahan (Sun Microsystems, Inc.)
* Niall K. Pemberton
* Steve Peterson
* Dhanji R. Prasanna (Google Inc., formerly individual)
* Gerhard Petracek
* Matt Raible
* Michael Nascimento Santos
* Sebastian Thomschke
* Jon Wetherbee (Oracle)

### 1.2. Specification goals

Validating data is a common task that occurs throughout an application, from the presentation layer to the persistence layer. Often the same validation logic is implemented in each layer, proving to be time consuming and error-prone. To avoid duplication of these validations in each layer, developers often bundle validation logic directly into the domain model, cluttering domain classes with validation code that is, in fact, metadata about the class itself.

This specification defines a metadata model and API for JavaBean validation. The default metadata source is annotations, with the ability to override and extend the metadata through the use of XML validation descriptors.

The validation API developed by this specification is not intended for use in any one tier or programming model. It is specifically not tied to either the web tier or the persistence tier, and is available for both server-side application programming, as well as rich client Swing application developers. This API is seen as a general extension to the JavaBeans object model, and as such is expected to be used as a core component in other specifications. Ease of use and flexibility have influenced the design of this specification.

As of version 1.1, Jakarta Bean Validation constraints can also be applied to the parameters and return values of methods of arbitrary Java types. Thus the Jakarta Bean Validation API can be used to describe and validate the contract (comprising pre- and postconditions) applying to a given method ("Programming by Contract", PbC). Note that it is *not* the goal of this specification to develop a fully-fledged PbC solution but rather an easy-to-use facility satisfying the most common needs related to applying constraints to method parameters and return values, based on the proven concepts of the Jakarta Bean Validation API.

### 1.3. Required Java version

The specification uses Java 8 language features. There is no requirement that implementations be compatible with Java language versions prior to 8.

### 1.4. How this document is organized

This document describes each aspect of the Jakarta Bean Validation specification in a separate chapter. One should remember that the specification is a consistent whole.

[Constraint definition](#constraintsdefinitionimplementation) describes how constraints are defined.

[Value extractor definition](#valueextractordefinition) describes how extractors for the values of container types are defined.

[Constraint declaration and validation process](#constraintdeclarationvalidationprocess) describes how a JavaBean class is decorated with annotations to describe constraints.

[Validation APIs](#validationapi) describes how to programmatically validate a JavaBean.

[Constraint metadata request APIs](#constraintmetadata) describes how the metadata query API works.

[Built-in Constraint definitions](#builtinconstraints) list all the built-in constraints.

[XML deployment descriptor](#xml) describes the XML deployment descriptors for the configuration and the mapping.

[Exception model](#exception) describes the exception model and hierarchy used by Jakarta Bean Validation.

[Integration](#integration) describes the different integration points of Jakarta Bean Validation with other technologies. In some cases one has to refer to the respective specifications for the up-to-date integration rules.

In [Terminology](#terminology), key concepts are summarized. Some reviewers have found that reading the terminology section first helps to better understand the specification.

The changelog can be found at [Changelog](#changelog).

### 1.5. How to comment

The expert group is eager to receive feedback from readers. Feel free to contact us. You can get all the details at <http://beanvalidation.org/contribute/>.

## 2. What’s new

| Note | Names used under the JCP for specifications are preserved in the What’s new section for versions released prior to the move to Jakarta EE in order to preserve historical accuracy. |
| --- | --- |

### 2.1. What’s new in 2.0

The main contribution of Bean Validation 2.0 is leveraging the new language features and API additions of Java 8 for the purposes of validation.
Java 8 or later is required to use Bean Validation 2.0.

The changes include:

* Support for validating container elements by annotating type arguments of parameterized types, e.g. `List<@Positive Integer> positiveNumbers` (see [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints));
  this also includes:

  + More flexible cascaded validation of collection types; e.g. values *and* keys of maps can be validated now: `Map<@Valid CustomerType, @Valid Customer> customersByType`
  + Support for `java.util.Optional`
  + Support for the property types declared by JavaFX
  + Support for custom container types by plugging in additional value extractors (see [Value extractor definition](#valueextractordefinition))
* Support for the new date/time data types for `@Past` and `@Future` (see [Built-in Constraint definitions](#builtinconstraints));
  fine-grained control over the current time and time zone used for validation (see [Implementation of temporal constraint validators](#constraintsdefinitionimplementation-validationimplementation-temporalvalidators))
* New built-in constraints: `@Email`, `@NotEmpty`, `@NotBlank`, `@Positive`, `@PositiveOrZero`, `@Negative`, `@NegativeOrZero`, `@PastOrPresent` and `@FutureOrPresent` (see [Built-in Constraint definitions](#builtinconstraints))
* All built-in constraints are marked as repeatable now
* Parameter names are retrieved using reflection (see [Naming parameters](#constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters))
* `ConstraintValidator#initialize()` is a default method (see [Constraint validation implementation](#constraintsdefinitionimplementation-validationimplementation))
* The namespace for Bean Validation XML descriptors has been changed to `<http://xmlns.jcp.org/xml/ns/validation/configuration>` for `META-INF/validation.xml` and `<http://xmlns.jcp.org/xml/ns/validation/mapping>` for constraint mapping files (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration))

### 2.2. What’s new in 1.1

Bean Validation 1.1 improves and builds upon Bean Validation 1.0. The expert group and the community have been working on a few specific areas.

#### 2.2.1. Openness

All of Bean Validation 1.1 work has been done in the open and in an open source way. Source code for the API, reference implementation, test compatibility kit as well as the specification and the website sources are available in the open. All discussions are done in the open in the publicly available development mailing list. Road map and proposals are also published on the website.

You can find all the details (mailing lists, source repositories etc.) at <http://beanvalidation.org>.

#### 2.2.2. Dependency injection

Bean Validation uses a few components `MessageInterpolator`, `TraversableResolver`, `ParameterNameProvider`, `ConstraintValidatorFactory` and `ConstraintValidator`. Bean Validation 1.1 standardizes how these objects are managed by a container and how these objects can benefit from container services. In particular, CDI support within Java EE is being defined.

#### 2.2.3. Method validation

Bean Validation 1.1 allows to put constraints to the parameters and return values of arbitrary methods and constructors. That way the Bean Validation API can be used to describe and validate the contract applying to a given method or constructor, that is:

* the preconditions that must be met by the caller before the method or constructor may be invoked and
* the postconditions that are guaranteed to the caller after a method or constructor invocation returns.

This enables a programming style known as "Programming by Contract" (PbC). Compared to traditional means of checking the sanity of argument and return values this approach has several advantages:

* These checks are expressed declaratively and don’t have to be performed manually, which results in less code to write, read and maintain.
* The pre- and postconditions applying for a method or constructor don’t have to be expressed again in the documentation, since any of its annotations will automatically be included in the generated JavaDoc. This reduces redundancies, thus avoiding efforts and inconsistencies between implementation and documentation.

#### 2.2.4. Integration with CDI

The integration points with CDI have been increased and reworked. This opens up for a more natural and standard integration both in Java EE and Java SE and encompass dependency injection, component lifecycle management and interception for method validation.

#### 2.2.5. Group conversion

The specification offers a way to alter the targeted group when validation cascading is happening. This feature is particularly useful to reuse a given object (graph) and to avoid leaking groups between various object subgraphs. It also makes for more readable constraints.

#### 2.2.6. Message interpolation via the unified expression language

Constraint violation messages can now use EL expressions for a much more flexible rendering and string formatting. In particular a formatter object is injected in the EL context to convert numbers, dates etc. into the locale specific string representation. Likewise, the validated value is also available in the EL context.

#### 2.2.7. Others

Many more minor changes have been done. Check out the change log for more details at [Changelog](#changelog).

## 3. Constraint definition

Constraints are defined by the combination of a constraint annotation and a list of constraint validation implementations. The constraint annotation is applied on types, fields, methods, constructors, parameters, container elements or other constraint annotations in case of composition.

Unless stated otherwise the default package name for the Jakarta Bean Validation APIs is `javax.validation`.

### 3.1. Constraint annotation

A constraint on a JavaBean is expressed through one or more annotations. An annotation is considered a constraint definition if its retention policy contains `RUNTIME` and if the annotation itself is annotated with `javax.validation.Constraint` .

Listing 3.1: `@Constraint` annotation
```
/**
 * Marks an annotation as being a Jakarta Bean Validation constraint.
 * <p>
 * A given constraint annotation must be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 * <p>
 * Each constraint annotation must host the following attributes:
 * <ul>
 *     <li>{@code String message() default [...];} which should default to an error
 *     message key made of the fully-qualified class name of the constraint followed by
 *     {@code .message}. For example {@code "{com.acme.constraints.NotSafe.message}"}</li>
 *     <li>{@code Class<?>[] groups() default {};} for user to customize the targeted
 *     groups</li>
 *     <li>{@code Class<? extends Payload>[] payload() default {};} for
 *     extensibility purposes</li>
 * </ul>
 * <p>
 * When building a constraint that is both generic and cross-parameter, the constraint
 * annotation must host the {@code validationAppliesTo()} property.
 * A constraint is generic if it targets the annotated element and is cross-parameter if
 * it targets the array of parameters of a method or constructor.
 * <pre>
 *     ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
 * </pre>
 * This property allows the constraint user to choose whether the constraint
 * targets the return type of the executable or its array of parameters.
 *
 * A constraint is both generic and cross-parameter if
 * <ul>
 *     <li>two kinds of {@code ConstraintValidator}s are attached to the
 *     constraint, one targeting {@link ValidationTarget#ANNOTATED_ELEMENT}
 *     and one targeting {@link ValidationTarget#PARAMETERS},</li>
 *     <li>or if a {@code ConstraintValidator} targets both
 *     {@code ANNOTATED_ELEMENT} and {@code PARAMETERS}.</li>
 * </ul>
 *
 * Such dual constraints are rare. See {@link SupportedValidationTarget} for more info.
 * <p>
 * Here is an example of constraint definition:
 * <pre>
 * &#64;Documented
 * &#64;Constraint(validatedBy = OrderNumberValidator.class)
 * &#64;Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
 * &#64;Retention(RUNTIME)
 * public &#64;interface OrderNumber {
 *     String message() default "{com.acme.constraint.OrderNumber.message}";
 *     Class&lt;?&gt;[] groups() default {};
 *     Class&lt;? extends Payload&gt;[] payload() default {};
 * }
 * </pre>
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {

    /**
     * {@link ConstraintValidator} classes implementing the constraint. The given classes
     * must reference distinct target types for a given {@link ValidationTarget}. If two
     * {@code ConstraintValidator}s refer to the same type, an exception will occur.
     * <p>
     * At most one {@code ConstraintValidator} targeting the array of parameters of
     * methods or constructors (aka cross-parameter) is accepted. If two or more
     * are present, an exception will occur.
     *
     * @return array of {@code ConstraintValidator} classes implementing the constraint
     */
    Class<? extends ConstraintValidator<?, ?>>[] validatedBy();
}
```

A constraint is said to be generic if it has at least one constraint validator targeting the element annotated i.e. targeting the (returned) element annotated by the constraint (a bean, a field, a getter, a method/constructor return value or a method/constructor parameter). A constraint is said to be cross-parameter if it has one constraint validator targeting the array of parameters of a method or constructor (to validate the consistency of several method/constructor parameters). A Jakarta Bean Validation constraint is most of the time either a generic constraint or a cross-parameter constraint. In rare situations, a constraint can be both.

Generic constraint annotations can target any of the following `ElementType`s:

* `FIELD` for constrained attributes
* `METHOD` for constrained getters and constrained method return values
* `CONSTRUCTOR` for constrained constructor return values
* `PARAMETER` for constrained method and constructor parameters
* `TYPE` for constrained beans
* `ANNOTATION_TYPE` for constraints composing other constraints
* `TYPE_USE` for container element constraints

Cross-parameter constraint annotations can target any of the following `ElementType`s:

* `METHOD`
* `CONSTRUCTOR`
* `ANNOTATION_TYPE` for cross-parameter constraints composing other cross-parameter constraints

A constraint annotation that is both can target the union of the generic and cross-parameter constraint annotations targets.

While other `ElementType`s are not forbidden, the provider does not have to recognize and process constraints placed on such types.

Since a given constraint definition applies to one or more specific Java types, the JavaDoc for the constraint annotation should clearly state which types are supported. Applying a constraint annotation to an incompatible type will raise an `UnexpectedTypeException`. Care should be taken on defining the list of `ConstraintValidator`s. The type resolution algorithm (see [ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution)) could lead to exceptions if the `ConstraintValidator` list leads to ambiguities.

At most one `ConstraintValidator` supporting cross-parameter validation must be present for a given constraint. A `ConstraintDefinitionException` is raised otherwise. The JavaDoc should clearly state if the constraint is a generic and / or a cross-parameter constraint.

If a constraint definition is not valid, a `ConstraintDefinitionException` is raised either at validation time or when the metadata is requested. Invalid constraint definitions causes are multiple but include missing or illegal `message` or `groups` elements (see [Constraint definition properties](#constraintsdefinitionimplementation-constraintdefinition-properties)).

| Note | Jakarta Bean Validation defines rules for applying constraint annotations in inheritance hierarchies, described in [Inheritance (interface and superclass)](#constraintdeclarationvalidationprocess-inheritance) and [Method constraints in inheritance hierarchies](#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance). It is therefore not recommended to specify the meta annotation `java.lang.annotation.Inherited` at constraint annotation types, as it is not relevant in the context of Jakarta Bean Validation and would conflict with the proposed rules. |
| --- | --- |

#### 3.1.1. Constraint definition properties

A constraint definition may have attributes that are specified at the time the constraint is applied to a JavaBean. The properties are mapped as annotation elements. The annotation element names `message`, `groups`, `validationAppliesTo` and `payload` are considered reserved names; annotation elements starting with `valid` are not allowed ; a constraint may use any other element name for its attributes.

##### 3.1.1.1. message

Every constraint annotation must define a `message` element of type `String`.

```
String message() default "{com.acme.constraint.MyConstraint.message}";
```

The `message` element value is used to create the error message. See [Message interpolation](#validationapi-message) for a detailed explanation. It is recommended to default `message` values to resource bundle keys to enable internationalization. It is also recommended to use the following convention: the resource bundle key should be the fully qualified class name of the constraint annotation concatenated to `.message` as shown in the previous program listing.

Built-in Jakarta Bean Validation constraints follow this convention.

##### 3.1.1.2. groups

Every constraint annotation must define a `groups` element that specifies the processing groups with which the constraint declaration is associated. The type of the `groups` parameter is `Class<?>[]`.

```
Class<?>[] groups() default {};
```

The default value must be an empty array.

If no group is specified when declaring the constraint on an element, the `Default` group is considered declared.

See [groups](#validationapi-validatorapi-groups) for more information.

Groups are typically used to control the order in which constraints are evaluated, or to perform validation of the partial state of a JavaBean.

##### 3.1.1.3. payload

Constraint annotations must define a `payload` element that specifies the payload with which the constraint declaration is associated. The type of the `payload` parameter is `Payload[]`.

```
Class<? extends Payload>[] payload() default {};
```

The default value must be an empty array.

Each attachable payload extends `Payload`.

Listing 3.2: `Payload` interface
```
/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * <p>
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 * </p>
 * With the exception of the {@link Unwrapping} payload types, the use of payloads is not
 * considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}
```

Payloads are typically used by validation clients to associate some metadata information with a given constraint declaration.
Describing payloads as interface extensions as opposed to a string-based approach allows an easier and more type-safe approach.
Payloads are typically non-portable.
An exception are the `Unwrapping.Skip` and `Unwrapping.Unwrap` payload types which are defined by this specification (see [Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)).

One use case for payload shown in [Use of payload to associate severity to a constraint](#example-payload) is to associate a severity to a constraint. This severity can be exploited by a presentation framework to adjust how a constraint failure is displayed.

Example 3.1: Use of payload to associate severity to a constraint
```
package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() { [...] }

    @NotNull(message="the city is mandatory", payload=Severity.Error.class)
    String getCity() { [...] }
}
```

The `payload` information can be retrieved from error reports via the `ConstraintDescriptor` either accessed through the `ConstraintViolation` objects (see [ConstraintViolation](#validationapi-constraintviolation)) or through the metadata API (see [ConstraintDescriptor](#constraintmetadata-constraintdescriptor)).

##### 3.1.1.4. validationAppliesTo

`validationAppliesTo` is used at constraint declaration time to clarify what the constraint targets (i.e. the annotated element, the method return value or the method parameters).

The element `validationAppliesTo` must only be present for constraints that are both generic and cross-parameter, it is mandatory in this situation. A `ConstraintDefinitionException` is raised if these rules are violated.

The type of the `validationAppliesTo` parameter is `ConstraintTarget`. The default value must be `ConstraintTarget.IMPLICIT`.

Listing 3.3: validationAppliesTo and ConstraintTarget
```
ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
```

```
/**
 * Defines the constraint target.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ConstraintTarget {

    /**
     * Discover the type when no ambiguity is present
     * <ul>
     *     <li>if neither on a method nor a constructor, it implies the annotated element
     *     (type, field etc),</li>
     *     <li>if on a method or constructor with no parameter, it implies
     *     {@code RETURN_VALUE},</li>
     *     <li>if on a method with no return value ({@code void}), it implies
     *     {@code PARAMETERS}.</li>
     * </ul>
     * Otherwise, {@code IMPLICIT} is not accepted and either {@code RETURN_VALUE} or
     * {@code PARAMETERS} is required. This is the case for constructors with parameters
     * and methods with parameters and return value.
     */
    IMPLICIT,

    /**
     * Constraint applies to the return value of a method or a constructor.
     */
    RETURN_VALUE,

    /**
     * Constraint applies to the parameters of a method or a constructor
     */
    PARAMETERS
}
```

If a `ConstraintTarget` is used in an illegal situation, a `ConstraintDeclarationException` is raised either at validation time or when the metadata is requested. Examples of illegal situations are:

* using `IMPLICIT` in a situation that cannot be inferred (see the JavaDoc for the detailed rules),
* using `PARAMETERS` on a constructor or method that has no parameter,
* using `RETURN_VALUE` on a method with no return value,
* using `PARAMETERS` or `RETURN_VALUE` on a type - class or interface - or on a field.

Constraint users are encouraged to explicitly set the `ConstraintTarget` target when using a constraint supporting both on a method or constructor as it improves readability.

##### 3.1.1.5. Constraint specific parameter

The constraint annotation definitions may define additional elements to parameterize the constraint. For example, a constraint that validates the length of a string can use an annotation element named `length` to specify the maximum length at the time the constraint is declared.

#### 3.1.2. Examples

Example 3.2: Simple constraint definition
```
//assuming OrderNumberValidator is a generic constraint validator

package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface OrderNumber {

    String message() default "{com.acme.constraint.OrderNumber.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

[Simple constraint definition](#example-definition-notnull) marks a `String` as a well-formed order number. The constraint validator is implemented by `OrderNumberValidator`.

Example 3.3: Simple cross-parameter constraint definition
```
//assuming DateParametersConsistentValidator is a cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters of a method are in the
 * correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {

    String message() default "{com.acme.constraint.DateParametersConsistent.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

[Simple cross-parameter constraint definition](#example-definition-crossparameter) shows a cross-parameter constraint which ensures that two date parameters of a method are in the correct order. The constraint validator is implemented by `DateParametersConsistentValidator`.

Example 3.4: Constraint that is both generic and cross parameter
```
//assuming ELAssertValidator is both a generic and cross-parameter
//constraint validator

package com.acme.constraint;

/**
 * Jakarta Expresson Language expression to be validated. This constraint accepts any type and can
 * validate both the annotated type or apply restrictions across parameters.
 */
@Documented
@Constraint(validatedBy = ELAssertValidator.class)
@Target({ METHOD, FIELD, TYPE, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface ELAssert {

    String message() default "{com.acme.constraint.ELAssert.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

    String expression();
}
```

```
@ELAssert(
    message="Please check that your passwords match and try again.",
    expression="param[1]==param[2]",
    validationAppliesTo=ConstraintType.PARAMETERS
)
public User createUser(String email, String password, String repeatPassword) { [...] }
```

[Constraint that is both generic and cross parameter](#example-definition-genericandcrossparameter) shows a constraint that can be applied both on the annotated element and across parameters of a method or a constructor. Note in this case the presence of `validationAppliesTo`.

Example 3.5: Constraint definition with default parameter
```
package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear. Adjustable to the age of the person. Accepts
 * Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface Audible {

    Age age() default Age.YOUNG;

    String message() default "{com.acme.constraint.Audible.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING,
        OLD
    }
}
```

[Constraint definition with default parameter](#example-definition-length) ensures that a given frequency is within the scope of human ears. The constraint definition includes an optional parameter that may be specified when the constraint is applied.

Example 3.6: Constraint definition with mandatory parameter
```
package com.acme.constraint;

/**
 * Defines the list of values accepted. Accepts int or Integer objects.
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface Acceptable {

    int[] value();

    String message() default "{com.acme.constraint.Acceptable.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

[Constraint definition with mandatory parameter](#example-definition-mandatory) defines a list of acceptable values expressed as an array: the `value` property must be specified when the constraint is applied.

### 3.2. Applying multiple constraints of the same type

It is often useful to declare the same constraint more than once to the same target, with different properties. A common example is the `@Pattern` constraint, which validates that its target matches a specified regular expression. Other constraints have this requirement as well. The same constraint type can belong to different groups and have specific error messages depending on the targeted group.

To support this requirement, the Jakarta Bean Validation provider treats regular annotations (annotations not annotated by `@Constraint`) whose `value` element has a return type of an array of constraint annotations in a special way. Each element in the `value` array are processed by the Jakarta Bean Validation implementation as regular constraint annotations. This means that each constraint specified in the `value` element is applied to the target. The annotation must have retention `RUNTIME` and can be applied on a type, field, property, executable parameter, executable return value, executable cross-parameter or another annotation. It is recommended to use the same set of targets as the initial constraint.

Note to constraint designers: each constraint annotation should be coupled with its corresponding multi-valued annotation. The specification recommends, though does not mandate, the definition of an inner annotation named `List`.
Each constraint annotation type should be meta-annotated with `java.lang.annotation.Repeatable`, referencing the corresponding `List` annotation.
This marks the constraint annotation type as repeatable and lets users specify the constraint several times without explicitly using the `List` annotation.
All built-in annotations follow this pattern.

Example 3.7: Multi-valued constraint definition
```
/**
 * Validate a zip code for a given country
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }
}
```

Example 3.8: Multi-valued constraint declaration
```
public class Address {
    @ZipCode(countryCode = "fr", groups = Default.class, message = "zip code is not valid")
    @ZipCode(
        countryCode = "fr",
        groups = SuperUser.class,
        message = "zip code invalid. Requires overriding before saving."
    )
    private String zipCode;
}
```

In this example, both constraints apply to the `zipCode` field but with different groups and with different error messages.
It is also possible to specify a constraint several times by explicitly using the `@List` annotation
(though simply repeating the annotation is the preferred idiom as of Jakarta Bean Validation 2.0 and Java 8):

Example 3.9: Multi-valued constraint declaration using explicit `@List` annotation (discouraged)
```
public class Address {
    @ZipCode.List( {
        @ZipCode(countryCode="fr", groups=Default.class,
            message = "zip code is not valid"),
        @ZipCode(countryCode="fr", groups=SuperUser.class,
            message = "zip code invalid. Requires overriding before saving.")
    } )
    private String zipCode;
}
```

Using two different multi-constraint annotations for the same underlying constraint type on the same target (i.e. class or property) is not considered portable and is discouraged.

### 3.3. Constraint composition

This specification allows you to compose constraints to create higher level constraints.

Constraint composition is useful in several ways:

* Avoid duplication and facilitate reuse of more primitive constraints.
* Expose primitive constraints as part of a composed constraint in the metadata API and enhance tool awareness.

Composition is done by annotating a constraint annotation with the composing constraint annotations.

Example 3.10: Composition is done by annotating the composed constraint
```
@Pattern(regexp = "[0-9]*")
@Size(min = 5, max = 5)
@Constraint(validatedBy = FrenchZipCodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface FrenchZipCode {

    String message() default "Wrong zip code";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipCode[] value();
    }
}
```

Annotating an element with `@FrenchZipCode` (the composed annotation) is equivalent to annotating it with `@Pattern(regexp="[0-9]*")`, `@Size(min=5, max=5)` (the composing annotations) and `@FrenchZipCode`. More formally, each constraint annotation hosted on a constraint annotation is applied to the target element and this is done recursively. Note that the main annotation and its constraint validation implementation is also applied. By default, each failing constraint generates an error report. Groups from the main constraint annotation are inherited by the composing annotations. Any `groups` definition on a composing annotation is ignored. Payload from the main constraint annotation is inherited by the composing annotations. Any `payload` definition on a composing annotation is ignored. The constraint target from the main constraint annotation is inherited by the composing annotations. Any `validationAppliesTo` definition on a composing annotation is ignored.

The type upon which composed constraint is placed must be compatible with all constraints (composing and composed). A constraint designer should ensure that such a type exists and lists in the JavaDoc all the compatible types.

All composed and composing constraints must have a constraint type in common. In particular, it is not legal to mix a pure generic constraint and a pure cross-parameter constraint.

It is possible to ensure that composing annotations do not raise individual error reports. In this scenario, if one or more composing annotations are invalid, the main constraint is automatically considered invalid and the corresponding error report is generated. To mark a constraint as raising a single constraint error report if either the composed or one of the composing constraints fail, use the `@ReportAsSingleViolation` annotation.

Example 3.11: If any of the composing constraints fail, the error report corresponding to `@FrenchZipCode` is raised and none other.
```
@Pattern(regexp = "[0-9]*")
@Size(min = 5, max = 5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipCodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface FrenchZipCode {

    String message() default "Wrong zip code";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipCode[] value();
    }
}
```

The definition of `@ReportAsSingleViolation` is as follows.

Listing 3.4: `@ReportAsSingleViolation` annotation
```
/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 * <p>
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ReportAsSingleViolation {
}
```

More specifically, if a composed constraint is marked as `@ReportAsSingleViolation`, the evaluation of the composing constraints stops at the first failing constraint and the error report corresponding to the composed constraint is generated and returned.

Composing annotations can define the value of `message` and custom attributes (excluding `groups`, `payload` and `validationAppliesTo`) but these are fixed in the composed constraint definition.

Example 3.12: Composing annotations can use attributes. They are fixed for a given main annotation. All `@FrenchZipCode` constraints have a `@Size` restricted to 5.
```
@Pattern(regexp = "[0-9]*")
@Size(min = 5, max = 5)
@Constraint(validatedBy = FrenchZipCodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface FrenchZipCode {

    String message() default "Wrong zip code";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipCode[] value();
    }
}
```

It is possible to override attributes and messages defined on a composing annotation.
An attribute from the main annotation is used to override one or more attributes of the composing annotations.
Such an attribute is annotated with one or more `@OverridesAttribute` annotations.

Example 3.13: Attributes from composing annotations can be overridden by attributes from the composed annotation
```
@Pattern(regexp = "[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipCodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface FrenchZipCode {

    String message() default "Wrong zip code";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @OverridesAttribute(constraint = Size.class, name = "min")
    @OverridesAttribute(constraint = Size.class, name = "max")
    int size() default 5;

    @OverridesAttribute(constraint = Size.class, name = "message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipCode.zipCode.size}";

    @OverridesAttribute(constraint = Pattern.class, name = "message")
    String numberMessage() default "{com.acme.constraint.FrenchZipCode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        FrenchZipCode[] value();
    }
}
```

The value of the composed constraint attribute annotated with `@OverridesAttribute` (`@FrenchZipCode.sizeMessage`) is applied to the composing constraint attribute named after `@OverridesAttribute.name` and hosted on the composing constraint of type `@OverridesAttribute.constraint` (`@Size.message`). Similarly, `@FrenchZipCode.numberMessage` value is mapped to `@Pattern.message`.

If left undefined, the default value for `@OverridesAttribute.name` is the name of the composed constraint attribute hosting the `@OverridesAttribute` annotation.

The types of the overridden and overriding attributes must be identical.

| Note | A composing constraint can itself be a composed constraint. In this case, attribute values are overridden recursively according to the described rules. Note however, that a forwarding rule (as defined by `@OverridesAttribute`) is only applied to the direct composing constraints. |
| --- | --- |

Using [Attributes from composing annotations can be overridden by attributes from the composed annotation](#example-composing-overridden),

```
@FrenchZipCode(size=9, sizeMessage="Zip code should be of size {max}")
```

is equivalent to

```
@FrenchZipCode
```

if `@FrenchZipCode` is defined as

```
@Pattern(regexp = "[0-9]*")
@Size(min = 9, max = 9, message = "Zip code should be of size {max}")
@Constraint(validatedBy = FrenchZipCodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface FrenchZipCode {

    String message() default "Wrong zip code";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        FrenchZipCode[] value();
    }
}
```

If a constraint is used more than once as a composing constraint, the multi value constraints model as described in [Applying multiple constraints of the same type](#constraintsdefinitionimplementation-multipleconstraints) is used.

To select a specific composing constraint, `OverridesAttribute.constraintIndex` is used.
If the composing constraints are directly given on the composed constraint (i.e. via the repeatable annotation feature), `constraintIndex` refers to the left-to-right order of the constraints of this type in which they are given on the composed constraint.
If the composing constraints are specified using their corresponding `List` annotation, `constraintIndex` refers to the index within the `value` array.

A composing constraint must not be given directly on the composed constraint and using the corresponding `List` annotation at the same time.
A `ConstraintDeclarationException` will be raised in this case.

If `index` is undefined, the single constraint declaration is targeted.

Example 3.14: Use of constraintIndex in @OverridesAttribute
```
@Documented
@Constraint(validatedBy = {})
@Pattern(regexp = "[A-Z0-9._%+-][[email protected]](/cdn-cgi/l/email-protection)[A-Z0-9.-]+\\.[A-Z]{2,4}") // email
@Pattern(regexp = ".*?emmanuel.*?") // emmanuel
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {

    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint = Pattern.class, name = "message", constraintIndex = 1)
    String emmanuelMessage() default "Not Emmanuel";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        EmmanuelsEmail[] value();
    }
}
```

`@OverridesAttribute` definition is as follows:

Listing 3.5: `@OverridesAttribute` annotation
```
/**
 * Marks an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Documented
@Retention(RUNTIME)
@Target({ METHOD })
@Repeatable(List.class)
public @interface OverridesAttribute {

    /**
     * @return constraint type the attribute is overriding
     */
    Class<? extends Annotation> constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting {@code @OverridesAttribute}.
     *
     * @return name of constraint attribute overridden
     */
    String name() default "";

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * <p>
     * The index represents the index of the constraint in the
     * {@code value()} array.
     * <p>
     * By default, no index is defined and the single constraint declaration
     * is targeted.
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several {@link OverridesAttribute} annotations on the same element
     *
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {

        OverridesAttribute[] value();
    }
}
```

The following elements uniquely identify an overridden constraint attribute:

* `@OverridesAttribute.constraint`
* `@OverridesAttribute.name`
* `@OverridesAttribute.constraintIndex`

If the composition is invalid, e.g.

* infinitely recursive composition
* wrong attribute overriding
* a single attribute mapped to more than one source attribute
* a composing and composed constraint marked as different constraint types (i.e., generic and cross-parameter)
* etc.

a `ConstraintDefinitionException` is raised either at validation time or when the metadata is requested.

Constraint designers are encouraged to make use of composition (recursively or not) based on the built-in constraints defined by the specification. The composing constraints are exposed through the Jakarta Bean Validation metadata API ([ConstraintDescriptor](#constraintmetadata-constraintdescriptor)). This metadata is particularly useful for third-party metadata consumers like persistence frameworks generating database schemas (such as Jakarta Persistence) or presentation frameworks.

### 3.4. Constraint validation implementation

A constraint validation implementation performs the validation of a given constraint annotation for a given type. The implementation classes are specified by the `validatedBy` element of the `@Constraint` annotation that decorates the constraint definition. The constraint validation implementation implements the `ConstraintValidator` interface.

Listing 3.6: `ConstraintValidator` interface
```
/**
 * Defines the logic to validate a given constraint {@code A}
 * for a given object type {@code T}.
 * <p>
 * Implementations must comply to the following restriction:
 * <ul>
 *     <li>{@code T} must resolve to a non parameterized type</li>
 *     <li>or generic parameters of {@code T} must be unbounded
 *     wildcard types</li>
 * </ul>
 * <p>
 * The annotation {@link SupportedValidationTarget} can be put on a
 * {@code ConstraintValidator} implementation to mark it as supporting
 * cross-parameter constraints. Check out {@link SupportedValidationTarget}
 * and {@link Constraint} for more information.
 *
 * @param <A> the annotation type handled by an implementation
 * @param <T> the target type supported by an implementation
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator<A extends Annotation, T> {

    /**
     * Initializes the validator in preparation for
     * {@link #isValid(Object, ConstraintValidatorContext)} calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * <p>
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     * <p>
     * The default implementation is a no-op.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    default void initialize(A constraintAnnotation) {
    }

    /**
     * Implements the validation logic.
     * The state of {@code value} must not be altered.
     * <p>
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return {@code false} if {@code value} does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}
```

Some restrictions apply on the generic type `T` (used in the `isValid()` method). `T` must

* resolve to a non parameterized type (i.e. because the type is not using generics or because the raw type is used instead of the generic version)
* or generic parameters of `T` must be unbounded wildcard types (i.e. `<?>`).

| Note | This restriction is not a theoretical limitation and a future version of the specification might allow it. |
| --- | --- |

By default, a `ConstraintValidator` targets the (returned) element annotated by the constraint. You can make a `ConstraintValidator` target the array of parameters of a method or constructor (aka cross-parameter) by annotating the validator implementation with `@SupportedValidationTarget`.

Listing 3.7: `@SupportedValidationTarget` annotation and `ValidationTarget` enum
```
package javax.validation.constraintvalidation;

/**
 * Defines the target(s) a {@link ConstraintValidator} can validate.
 * <p>
 * A {@code ConstraintValidator} can target the (returned) element
 * annotated by the constraint, the array of parameters of a method
 * or constructor (aka cross-parameter) or both.
 * <p>
 * If {@code @SupportedValidationTarget} is not present, the
 * {@code ConstraintValidator} targets the (returned) element annotated
 * by the constraint.
 * <p>
 * A {@code ConstraintValidator} targeting cross-parameter must accept
 * {@code Object[]} (or {@code Object}) as the type of object it validates.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Documented
@Target({ TYPE })
@Retention(RUNTIME)
public @interface SupportedValidationTarget {

    ValidationTarget[] value();
}
```

```
package javax.validation.constraintvalidation;

/**
 * List of possible targets for a {@link ConstraintValidator}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ValidationTarget {

    /**
     * (Returned) element annotated by the constraint.
     */
    ANNOTATED_ELEMENT,

    /**
     * Array of parameters of the annotated method or constructor (aka cross-parameter).
     */
    PARAMETERS
}
```

A `ConstraintValidator` implementation can target both annotated elements and array of parameters.

If a `ConstraintValidator` targets array of parameters (cross-parameter), `T` must resolve to `Object[]` (or `Object`) in order to have the array of parameter values passed to the `isValid()` method. A `ConstraintDefinitionException` is raised otherwise.

Example 3.15: Example of cross parameter ConstraintValidator
```
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ScriptAssertValidator implements ConstraintValidator<ScriptAssert,Object[]> {
    @Override
    public void initialize(ScriptAssert constraintAnnotation) {
        [...]
    }

    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        [...]
    }
}
```

[Valid ConstraintValidator definitions](#example-constraintsdefinitionimplementation-validationimplementation-validdef) shows some examples of valid definitions.

Example 3.16: Valid ConstraintValidator definitions
```
//String is not making use of generics
public class SizeValidatorForString implements ConstraintValidator<Size, String> {
    [...]
}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection> {
    [...]
}

//Collection uses generics and unbounded wildcard type
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection<?>> {
    [...]
}

//Validator for cross-parameter constraint
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator
    implements ConstraintValidator<DateParametersConsistent, Object[]> {
    [...]
}

//Validator for both annotated elements and executable parameters
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator<ELScript, Object> {
    [...]
}
```

And some invalid definitions in [Invalid ConstraintValidator definitions](#example-constraintsdefinitionimplementation-validationimplementation-invaliddef).

Example 3.17: Invalid ConstraintValidator definitions
```
//parameterized type
public class SizeValidatorForString implements ConstraintValidator<Size, Collection<String>> {
    [...]
}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection<? extends Address>> {
    [...]
}

//cross-parameter validator accepting the wrong type
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class NumberPositiveValidator implements ConstraintValidator<NumberPositive, Number> {
    [...]
}
```

The lifecycle of a constraint validation implementation instance is undefined. Jakarta Bean Validation providers are allowed to cache `ConstraintValidator` instances retrieved from the `ConstraintValidatorFactory`.

The `initialize()` method is called by the Jakarta Bean Validation provider prior to any use of the constraint implementation.
As of Jakarta Bean Validation 2.0, `initialize()` has an empty default implementation,
allowing to omit the implementation from validators that don’t need to access any constraint attributes.

The `isValid()` method is evaluated by the Jakarta Bean Validation provider each time a given value is validated. It returns `false` if the value is not valid, `true` otherwise. `isValid()` implementations must be thread-safe.

If the property is of an unanticipated type, an `UnexpectedTypeException` is raised. `ConstraintValidator` implementations raise this exception themselves if they receive an unsupported type. However, constraint designers are encouraged to make use of specialized `ConstraintValidator` implementations and delegate the type resolution to the Jakarta Bean Validation provider (see the type matching algorithm described in [ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution)).

If an exception occurs either in the `initialize()` or `isValid()` method, the runtime exception is wrapped into a `ValidationException` by the Jakarta Bean Validation engine.

The constraint validation implementation is not allowed to change the state of the value passed to `isValid()`.

| Note | While not mandatory, it is considered a good practice to split the core constraint validation from the not null constraint validation (for example, an `@Email` constraint will return `true` on a null object, i.e. will not take care of the `@NotNull` validation).   `null` can have multiple meanings but is commonly used to express that a value does not make sense, is not available or is simply unknown. Those constraints on the value are orthogonal in most cases to other constraints. For example a String, if present, must be an email but can be null. Separating both concerns is a good practice. |
| --- | --- |

The `ConstraintValidatorContext` object passed to the `isValid()` method carries information and operations available in the context the constraint is validated to.

Listing 3.8: `ConstraintValidatorContext` interface
```
/**
 * Provides contextual data and operation when applying a given constraint validator.
 *
 * At least one {@link ConstraintViolation} must be defined (either the default one,
 * of if the default {@code ConstraintViolation} is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 * @author Guillaume Smet
 */
public interface ConstraintValidatorContext {

    /**
     * Disables the default {@link ConstraintViolation} object generation (which
     * is using the message template declared on the constraint).
     * <p>
     * Useful to set a different violation message or generate a {@code ConstraintViolation}
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current un-interpolated default message
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Returns the provider for obtaining the current time in the form of a {@link Clock},
     * e.g. when validating the {@code Future} and {@code Past} constraints.
     *
     * @return the provider for obtaining the current time, never {@code null}. If no
     * specific provider has been configured during bootstrap, a default implementation using
     * the current system time and the current default time zone as returned by
     * {@link Clock#systemDefaultZone()} will be returned.
     *
     * @since 2.0
     */
    ClockProvider getClockProvider();

    /**
     * Returns a constraint violation builder building a violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * <p>
     * To create the {@link ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated nested interfaces
     * an {@code IllegalStateException} is raised.
     * <p>
     * If {@link ConstraintValidator#isValid(Object, ConstraintValidatorContext)} returns
     * {@code false}, a {@code ConstraintViolation} object will be built per constraint
     * violation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * <p>
     * {@code ConstraintViolation} objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overridden.
     * <p>
     * To create a different {@code ConstraintViolation}, a new constraint violation builder
     * has to be retrieved from {@code ConstraintValidatorContext}
     *
     * Here are a few usage examples:
     * <pre>
     * //assuming the following domain model
     * public class User {
     *     public Map&lt;String,Address&gt; getAddresses() { ... }
     * }
     *
     * public class Address {
     *     public String getStreet() { ... }
     *     public Country getCountry() { ... }
     * }
     *
     * public class Country {
     *     public String getName() { ... }
     * }
     *
     * //From a property-level constraint on User.addresses
     * //Build a constraint violation on the default path - i.e. the "addresses" property
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on Address
     * //Build a constraint violation on the default path + "street"
     * //i.e. the street property of Address
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "street" )
     *             .addConstraintViolation();
     *
     * //From a property-level constraint on  User.addresses
     * //Build a constraint violation on the default path + the bean stored
     * //under the "home" key in the map
     * context.buildConstraintViolationWithTemplate( "Incorrect home address" )
     *             .addBeanNode()
     *                 .inContainer( Map.class, 1 )
     *                 .inIterable().atKey( "home" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].country.name
     * //i.e. property "country.name" on the object stored under "home" in the map
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *             .addPropertyNode( "addresses" )
     *             .addPropertyNode( "country" )
     *                 .inContainer( Map.class, 1 )
     *                 .inIterable().atKey( "home" )
     *             .addPropertyNode( "name" )
     *             .addConstraintViolation();
     *
     * //From a class level constraint on User
     * //Build a constraint violation on the default path + addresses["home"].&lt;map key&gt;
     * //i.e. a container element constraint violation for the map key
     * context.buildConstraintViolationWithTemplate( "the map key is invalid" )
     *             .addPropertyNode( "addresses" )
     *             .addContainerElementNode( "&lt;map key&gt;", Map.class, 0 )
     *                 .inIterable().atKey( "invalid" )
     *             .addConstraintViolation();
     * </pre>
     * <p>
     * Cross-parameter constraints on a method can create a node specific
     * to a particular parameter if required. Let's explore a few examples:
     * <pre>
     * //Cross-parameter constraint on method
     * //createUser(String password, String passwordRepeat)
     * //Build a constraint violation on the default path + "passwordRepeat"
     * context.buildConstraintViolationWithTemplate("Passwords do not match")
     *             .addParameterNode(1)
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses,
     * //        Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"]
     * //i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both and does not match")
     *             .addParameterNode(1)
     *             .addBeanNode()
     *                 .inContainer( Map.class, 1 )
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     *
     * //Cross-parameter constraint on a method
     * //mergeAddresses(Map&lt;String,Address&gt; addresses,
     * //        Map&lt;String,Address&gt; otherAddresses)
     * //Build a constraint violation on the default path + "otherAddresses["home"].city
     * //i.e. on the "city" property of the Address bean hosted in
     * //the "home" key of the "otherAddresses" map
     * context.buildConstraintViolationWithTemplate(
     *         "Map entry home present in both but city does not match")
     *             .addParameterNode(1)
     *             .addPropertyNode("city")
     *                 .inContainer( Map.class, 1 )
     *                 .inIterable().atKey("home")
     *             .addConstraintViolation();
     * </pre>
     *
     * @param messageTemplate new un-interpolated constraint message
     * @return returns a constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Jakarta Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @param <T> the type of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    <T> T unwrap(Class<T> type);

    /**
     * {@link ConstraintViolation} builder allowing to optionally associate
     * the violation report to a sub path.
     * <p>
     * To create the {@code ConstraintViolation}, one must call either one of
     * the {@code addConstraintViolation()} methods available in one of the
     * interfaces of the fluent API.
     * <p>
     * If another method is called after {@code addConstraintViolation()} on
     * {@code ConstraintViolationBuilder} or any of its associated objects
     * an {@code IllegalStateException} is raised.
     */
    interface ConstraintViolationBuilder {

        /**
         * Adds a node to the path the {@link ConstraintViolation} will be associated to.
         * <p>
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)},
         *             {@link #addBeanNode()} and {@link #addParameterNode(int)}
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Adds a property node to the path the {@link ConstraintViolation}
         * will be associated to.
         * <p>
         * {@code name} describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node {@code name}
         * @throws IllegalArgumentException if the name is null
         *
         * @since 1.1
         */
        NodeBuilderCustomizableContext addPropertyNode(String name);

        /**
         * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
         * will be associated to.
         * Note that bean nodes are always leaf nodes.
         *
         * @return a builder representing the bean node
         *
         * @since 1.1
         */
        LeafNodeBuilderCustomizableContext addBeanNode();

        /**
         * Adds a container element node to the path the {@link ConstraintViolation}
         * will be associated to.
         *
         * @param name the node name
         * @param containerType the type of the container
         * @param typeArgumentIndex the index of the type argument
         * @return a builder representing the container element node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 2.0
         */
        ContainerElementNodeBuilderCustomizableContext addContainerElementNode(String name,
                Class<?> containerType, Integer typeArgumentIndex);

        /**
         * Adds a method parameter node to the path the {@link ConstraintViolation}
         * will be associated to.
         * The parameter index must be valid (i.e. within the boundaries of the method
         * parameter indexes). May only be called from within cross-parameter validators.
         *
         * @param index the parameter index
         * @return a builder representing the index-th parameter node
         * @throws IllegalArgumentException if the index is not valid
         *
         * @since 1.1
         */
        NodeBuilderDefinedContext addParameterNode(int index);

        /**
         * Adds the new {@link ConstraintViolation} to be generated if the
         * constraint validator marks the value as invalid.
         * <p>
         * Methods of this {@code ConstraintViolationBuilder} instance and its nested
         * objects throw {@code IllegalStateException} from now on.
         *
         * @return the {@code ConstraintValidatorContext} instance the
         *         {@code ConstraintViolationBuilder} comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderDefinedContext {

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an iterable, e.g. array, {@code Iterable} or a
             * {@code Map}.
             *
             * @return a builder representing iterable details
             */
            LeafNodeContextBuilder inIterable();

            /**
             * Marks the node as being in a container such as a {@code List}, {@code Map} or
             * {@code Optional}.
             *
             * @param containerClass the type of the container
             * @param typeArgumentIndex type index of the concerned type argument
             * @return a builder representing the current node
             * @throws IllegalArgumentException if the index is not valid
             *
             * @since 2.0
             */
            LeafNodeBuilderCustomizableContext inContainer(Class<?> containerClass,
                                                           Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an iterable, e.g. array, {@code Iterable} or {@code Map}.
         * <p>
         * If the iterable is an indexed collection or a map,
         * the index or the key should be set.
         * <p>
         * The node is a leaf node (i.e. no subnode can be added).
         *
         * @since 1.1
         */
        interface LeafNodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            LeafNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderDefinedContext {

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             * <p>
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p>
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             *
             * @since 2.0
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an iterable, e.g. array, {@code Iterable} or a
             * {@code Map}.
             *
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Marks the node as being in a container such as a {@code List}, {@code Map} or
             * {@code Optional}.
             *
             * @param containerClass the type of the container
             * @param typeArgumentIndex type index of the concerned type argument
             * @return a builder representing the current node
             * @throws IllegalArgumentException if the index is not valid
             *
             * @since 2.0
             */
            NodeBuilderCustomizableContext inContainer(Class<?> containerClass,
                                                       Integer typeArgumentIndex);

            /**
             * Adds a node to the path the {@link ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             *
             * @since 2.0
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a node which is
         * in an iterable, e.g. array, {@code Iterable} or {@code Map}.
         * <p>
         * If the iterable is an indexed collection or a map,
         * the index or the key should be set.
         * <p>
         * The node is not necessarily a leaf node (i.e. subnodes can
         * be added).
         */
        interface NodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array.
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds a node to the path the {@code ConstraintViolation} will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @deprecated since 1.1 - replaced by {@link #addPropertyNode(String)}
             *             and {@link #addBeanNode()}
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             *
             * @since 1.1
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p>
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             *
             * @since 1.1
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             *
             * @since 2.0
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a container element node whose context is known
         * (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         *
         * @since 2.0
         */
        interface ContainerElementNodeBuilderDefinedContext {

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p>
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator marks the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *           {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents a container element node whose context is
         * configurable (i.e. index, key and isInIterable)
         * and that is not necessarily a leaf node (i.e. subnodes can
         * be added).
         *
         * @since 2.0
         */
        interface ContainerElementNodeBuilderCustomizableContext {

            /**
             * Marks the node as being in an iterable, e.g. array, {@code Iterable} or a
             * {@code Map}.
             *
             * @return a builder representing iterable details
             */
            ContainerElementNodeContextBuilder inIterable();

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p>
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represents refinement choices for a container element node.
         * <p>
         * If the container is an indexed collection or a map,
         * the index or the key should be set.
         * <p>
         * The node is not necessarily a leaf node (i.e. subnodes can
         * be added).
         *
         * @since 2.0
         */
        interface ContainerElementNodeContextBuilder {

            /**
             * Defines the key the object is into the {@code Map}.
             *
             * @param key map key
             * @return a builder representing the current node
             */
            ContainerElementNodeBuilderDefinedContext atKey(Object key);

            /**
             * Defines the index the object is into the {@code List} or array.
             *
             * @param index index
             * @return a builder representing the current node
             */
            ContainerElementNodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Adds a property node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * {@code name} describes a single property. In particular,
             * dot (.) is not allowed.
             *
             * @param name property name
             * @return a builder representing node {@code name}
             * @throws IllegalArgumentException if the name is null
             */
            NodeBuilderCustomizableContext addPropertyNode(String name);

            /**
             * Adds a bean node (class-level) to the path the {@link ConstraintViolation}
             * will be associated to.
             * <p>
             * Note that bean nodes are always leaf nodes.
             *
             * @return a builder representing the bean node
             */
            LeafNodeBuilderCustomizableContext addBeanNode();

            /**
             * Adds a container element node to the path the {@link ConstraintViolation}
             * will be associated to.
             *
             * @param name the node name
             * @param containerType the type of the container
             * @param typeArgumentIndex the index of the type argument
             * @return a builder representing the container element node
             * @throws IllegalArgumentException if the index is not valid
             */
            ContainerElementNodeBuilderCustomizableContext addContainerElementNode(
                    String name, Class<?> containerType, Integer typeArgumentIndex);

            /**
             * Adds the new {@link ConstraintViolation} to be generated if the
             * constraint validator mark the value as invalid.
             * <p>
             * Methods of the {@code ConstraintViolationBuilder} instance this object
             * comes from and the constraint violation builder nested
             * objects throw {@code IllegalStateException} after this call.
             *
             * @return {@code ConstraintValidatorContext} instance the
             *         {@code ConstraintViolationBuilder} comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}
```

The `ConstraintValidatorContext` interface provides access to contextual information useful for the validation of specific constraints (e.g. `getClockProvider()`, see [Implementation of temporal constraint validators](#constraintsdefinitionimplementation-validationimplementation-temporalvalidators) ).

It also allows redefinition of the default constraint message generated when a constraint is not valid. By default, each invalid constraint leads to the generation of one error object represented by a `ConstraintViolation` object.
This object is built from the default constraint message template as defined by the constraint declaration and the context in which the constraint declaration is placed (bean, property, executable parameter, cross-parameter, executable return value or container element).

The `ConstraintValidatorContext` methods let the constraint implementation disable the default `ConstraintViolation` generation and create one or more custom ones. The non-interpolated message passed as a parameter is used to build the `ConstraintViolation` message (the message interpolation operation is applied to it).

By default, the `Path` exposed on the `ConstraintViolation` represents the path to the bean, property, parameter, cross-parameter, return value or container element hosting the constraint (see [ConstraintViolation](#validationapi-constraintviolation) for more information). You can point it to a subpath of this default path by using the constraint violation builder fluent API.

[Using the fluent API to build custom constraint violations](#example-constraintsdefinitionimplementation-validationimplementation-errorbuilder) shows a few examples.

Example 3.18: Using the fluent API to build custom constraint violations
```
//assuming the following domain model
public class User {
    public Map<String,Address> getAddresses() { [...] }
}

public class Address {
    public String getStreet() { [...] }
    public Country getCountry() { [...] }
}

public class Country {
   public String getName() { [...] }
}

//From a property-level constraint on User.addresses
//Build a constraint violation on the default path - i.e. the "addresses" property
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//From a class level constraint on Address
//Build a constraint violation on the default path + "street"
//i.e. the street property of Address
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "street" )
            .addConstraintViolation();

//From a property-level constraint on  User.addresses
//Build a constraint violation on the default path + the bean stored
//under the "home" key in the map
context.buildConstraintViolationWithTemplate( "Incorrect home address" )
            .addBeanNode()
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].country.name
//i.e. property "country.name" on the object stored under "home" in the map
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addPropertyNode( "addresses" )
            .addPropertyNode( "country" )
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addPropertyNode( "name" )
            .addConstraintViolation();

//From a class level constraint on User
//Build a constraint violation on the default path + addresses["home"].<map key>
//i.e. a container element constraint violation for the map key
context.buildConstraintViolationWithTemplate( "the map key is invalid" )
            .addPropertyNode( "addresses" )
            .addContainerElementNode( "<map key>", Map.class, 0 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//To create a subnode representing a method parameter from a cross-parameter constraint violation

//Cross-parameter constraint on method createUser(String password, String passwordRepeat)
//Build a constraint violation on the default path + "passwordRepeat"
context.buildConstraintViolationWithTemplate("Passwords do not match")
            .addParameterNode( 1 )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"]
//i.e. the Address bean hosted in the "home" key of the "otherAddresses" map parameter
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both and does not match" )
            .addParameterNode( 1 )
            .addBeanNode()
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();

//Cross-parameter constraint on a method
//mergeAddresses(Map<String,Address> addresses, Map<String,Address> otherAddresses)
//Build a constraint violation on the default path + "otherAddresses["home"].city
//i.e. on the "city" property of the Address bean hosted in
//the "home" key of the "otherAddresses" map
context.buildConstraintViolationWithTemplate(
        "Map entry home present in both but city does not match" )
            .addParameterNode( 1 )
            .addPropertyNode( "city" )
                .inContainer( Map.class, 1 )
                .inIterable().atKey( "home" )
            .addConstraintViolation();
```

If `disableDefaultConstraintViolation()` is called, no custom error is added (using the error builder) and if the constraint is not valid, a `ValidationException` is raised.

#### 3.4.1. Implementation of temporal constraint validators

Constraint validators for temporal constraints (either the built-in constraints `@Past`, `@PastOrPresent`, `@Future` and `@FutureOrPresent` or custom temporal constraints) can obtain the current instant from the `ClockProvider` object exposed by `ConstraintValidatorContext#getClockProvider()`.

Listing 3.9: `ClockProvider` interface
```
/**
 * Contract for obtaining the {@link Clock} used as the reference for {@code now} when
 * validating the {@code @Future} and {@code @Past} constraints.
 * <p>
 * The default implementation will return the current system time. Plugging in custom
 * implementations may be useful for instance in batch applications which need to run with a
 * specific logical date, e.g. with yesterday's date when re-running a failed batch job
 * execution.
 * <p>
 * Implementations must be safe for access from several threads at the same time.
 *
 * @author Gunnar Morling
 * @author Guillaume Smet
 * @since 2.0
 */
public interface ClockProvider {

    /**
     * Returns the clock which serves as the reference for {@code now}.
     *
     * @return the clock which serves as the reference for {@code now}; must not be
     * {@code null}
     */
    Clock getClock();
}
```

The `getClock()` method returns a `java.time.Clock` object which represents the current instant, date and time using a time zone.
A conforming Jakarta Bean Validation implementation provides a default clock provider which returns a clock representing the current system time and default time zone.
It is recommended that implementations call `Clock#systemDefaultZone()` to obtain the clock.

When bootstrapping a validator factory or validator, an alternative clock provider can be registered (see [Bootstrapping](#validationapi-bootstrapping)).
This can for instance be useful for testing, for applying the time zone of the currently logged in user in a multi-user, multi time zone application or for running batch applications with a logical date and time different from the actual current date and time.

#### 3.4.2. Examples

Example 3.19: ConstraintValidator implementation
```
/**
 * Check that a String begins with one of the given prefixes.
 */
public class BeginsWithValidator implements ConstraintValidator<BeginsWith, String> {

    private Set<String> allowedPrefixes;

    /**
     * Configure the constraint validator based on the elements specified at the time it was
     * defined.
     *
     * @param constraint the constraint definition
     */
    @Override
    public void initialize(BeginsWith constraint) {
        allowedPrefixes = Arrays.stream( constraint.value() )
                .collect( collectingAndThen( toSet(), Collections::unmodifiableSet ) );
    }

    /**
     * Validate a specified value. returns false if the specified value does not conform to
     * the definition.
     */
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null )
            return true;

        return allowedPrefixes.stream()
                .anyMatch( value::startsWith );
    }
}
```

This `ConstraintValidator` checks that a String begins with one of the accepted prefixes.
It also demonstrates an interesting best practice: return `true` on a null parameter.

The following listing shows a validator implementing the validation logic for a cross-parameter constraint.

Example 3.20: Cross-parameter validator implementation
```
/**
 * Check that two date parameters of a method are in the expected order. Expects the 2nd and
 * 3rd parameter of the validated method to be of type java.util.Date.
 */
@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class DateParametersConsistentValidator implements
        ConstraintValidator<DateParametersConsistent, Object[]> {

    /**
     * Validate a specified value. returns false if the specified value does not conform to
     * the definition
     */
    @Override
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalArgumentException( "Unexpected method signature" );
        }
        // one or both limits are unbounded => always consistent
        if ( value[1] == null || value[2] == null ) {
            return true;
        }
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}
```

The following listing shows a validator implementing the validation logic for a constraint that is both generic and cross-parameter.

Example 3.21: Generic and cross-parameter validator implementation
```
/**
 * Checks that an object passes the Jakarta Expression Language expression
 * provided by the constraint.
 */
@SupportedValidationTarget({ValidationTarget.ANNOTATED_ELEMENT, ValidationTarget.PARAMETERS})
public class ELScriptValidator implements ConstraintValidator<ELScript, Object> {

    public void initialize(ELScript constraint) {
        [...]
    }

    public boolean isValid(Object value, ConstraintValidatorContext context) {
        [...]
    }
}
```

The next example shows how to use `ConstraintValidatorContext`.

Example 3.22: Use of ConstraintValidatorContext
```
/**
 * Check that a String begins with "SN-" and has a specified length.
 * <p>
 * Error messages are using either key:
 * <ul>
 *   <li>com.acme.constraint.SerialNumber.wrongprefix if the string doesn't begin with
 *   "SN-"</li>
 *   <li>com.acme.constraint.SerialNumber.wronglength if the string doesn't have the
 *   specified length</li>
 * </ul>
 */
public class SerialNumberValidator implements ConstraintValidator<SerialNumber, String> {

    private int length;

    /**
     * Configure the constraint validator based on the elements specified at the time it was
     * defined.
     *
     * @param constraint the constraint definition
     */
    @Override
    public void initialize(SerialNumber constraint) {
        this.length = constraint.length();
    }

    /**
     * Validate a specified value. returns false if the specified value does not conform to
     * the definition.
     */
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null )
            return true;

        context.disableDefaultConstraintViolation();

        if ( !value.startsWith( "SN-" ) ) {
            String wrongPrefix = "{com.acme.constraint.SerialNumber.wrongprefix}";
            context.buildConstraintViolationWithTemplate( wrongPrefix )
                    .addConstraintViolation();
            return false;
        }
        if ( value.length() != length ) {
            String wrongLength = "{com.acme.constraint.SerialNumber.wronglength}";
            context.buildConstraintViolationWithTemplate( wrongLength )
                    .addConstraintViolation();
            return false;
        }
        return true;
    }
}
```

The default error message is disabled and replaced by a specific error message depending on the type of constraint violation detected.
In this case, only one error report is returned at a given time but a constraint validation implementation can return several error reports.

The following example shows how to obtain the current date and time via the `ClockProvider` when validating a temporal constraint such as `@Past`:

Example 3.23: Validation of a temporal constraint
```
/**
 * Validates that the given {@link ZonedDateTime} is in the past.
 */
public class PastValidatorForZonedDateTime implements ConstraintValidator<Past, ZonedDateTime> {

    @Override
    public boolean isValid(ZonedDateTime value, ConstraintValidatorContext context) {
        if ( value == null ) {
            return true;
        }

        ZonedDateTime now = ZonedDateTime.now( context.getClockProvider().getClock() );

        return value.isBefore( now );
    }
}
```

### 3.5. The ConstraintValidatorFactory

Constraint validation implementation instances are created by a `ConstraintValidatorFactory`.

The lifecycle of `ConstraintValidator` instances is fully dependent of the Jakarta Bean Validation provider and piloted by the `ConstraintValidatorFactory` methods. Therefore, `ConstraintValidatorFactory` implementations (such as dependency injection frameworks) must consider these instances as belonging to a dependent scope. Jakarta Bean Validation providers must release each instance retrieved. The `ConstraintValidatorFactory` instance that has created a `ConstraintValidator` instance must be the one that releases it. In other words, passing an instance of `ConstraintValidator` to a `ConstraintValidatorFactory` that has not created it is an error.

| Note | `ConstraintValidator` instances created by the `ValidatorFactory` -level `ConstraintValidatorFactory` can be released when the `ValidatorFactory` is being closed. |
| --- | --- |

Listing 3.10: `ConstraintValidatorFactory` interface
```
/**
 * Instantiates a {@link ConstraintValidator} instance based off its class.
 * The {@code ConstraintValidatorFactory} is <b>not</b> responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate
     * @param <T> The type of the constraint validator to instantiate
     *
     * @return A new constraint validator instance of the specified class
     */
    <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key);

    /**
     * Signals {@code ConstraintValidatorFactory} that the instance is no longer
     * being used by the Jakarta Bean Validation provider.
     *
     * @param instance validator being released
     *
     * @since 1.1
     */
    void releaseInstance(ConstraintValidator<?, ?> instance);
}
```

The default `ConstraintValidatorFactory` provided by the Jakarta Bean Validation provider implementation uses the public no-arg constructor of the `ConstraintValidator` class. A custom `ConstraintValidatorFactory` can be provided; for example it may benefit from dependency injection control in constraint implementations (see [Bootstrapping considerations](#validationapi-bootstrapping-usageandcontainerexpectation)). Any constraint implementation relying on `ConstraintValidatorFactory` behaviors specific to an implementation (dependency injection, no no-arg constructor and so on) is not portable, hence great care should be given before walking that path. Make sure to configure the Jakarta Bean Validation provider to honor any specific needs your `ConstraintValidator` has. As constraint designer and writer, make sure to document any specific non compliant requirements.

`ConstraintValidatorFactory` should not cache instances as the state of each instance can be altered in the `initialize()` method.

If an exception occurs in the factory while retrieving the `ConstraintValidator` instance, the runtime exception is wrapped in a `ValidationException`. If the instance returned by the factory is null, a `ValidationException` is raised.

## 4. Value extractor definition

Validation of container element constraints (see [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints)) as well as cascaded validation of generic container types (see [Graph validation](#constraintdeclarationvalidationprocess-requirements-graphvalidation)) requires access to the value(s) stored in the container.
The retrieval of values stored in a container is handled via implementations of the `ValueExtractor` interface:

Listing 4.1: `ValueExtractor` interface
```
package javax.validation.valueextraction;

/**
 * Defines the logic used to extract the values from a container object of type {@code T}.
 * <p>
 * A value extractor for a generic type such as {@link Optional}, {@link List} or {@link Map}
 * is tied to one specific type parameter of {@code T}. The {@link ExtractedValue} annotation
 * is used to mark that type parameter. A value extractor for a non-generic type such as
 * {@link OptionalInt} needs to declare the type of the wrapped element(s) using
 * {@link ExtractedValue#type()}.
 * <p>
 * The extracted values are passed to the corresponding method of the {@link ValueReceiver}.
 * <p>
 * A typical value extractor implementation for {@code List} may look like this:
 *
 * <pre>
 * public class ListValueExtractor implements
 *         ValueExtractor&lt;List&lt;&#064;ExtractedValue ?&gt;&gt; {
 *
 *     &#064;Override
 *     public void extractValues(List&lt;?&gt; originalValue, ValueReceiver receiver) {
 *         for ( int i = 0; i &lt; originalValue.size(); i++ ) {
 *             receiver.indexedValue( "&lt;list element&gt;", i, originalValue.get( i ) );
 *         }
 *     }
 * }
 * </pre>
 *
 * @param <T> the container type handled by a specific implementation
 *
 * @author Gunnar Morling
 * @author Guillaume Smet
 * @see ExtractedValue
 * @see UnwrapByDefault
 * @since 2.0
 */
public interface ValueExtractor<T> {

    /**
     * Extracts the values to validate from the original object.
     *
     * @param originalValue the original value from which to extract the values, never
     * {@code null}
     * @param receiver the corresponding {@code ValueReceiver}
     */
    void extractValues(T originalValue, ValueReceiver receiver);

    /**
     * Provides a set of methods receiving value extracted by the {@link ValueExtractor}.
     * <p>
     * The value has to be passed to the method corresponding best to the type of the
     * original value.
     *
     * @since 2.0
     */
    interface ValueReceiver {

        /**
         * Receives the value extracted from an object.
         *
         * @param nodeName the name of the node representing the container element. If not
         * {@code null}, the name will be used when adding a container element node to the
         * {@link Path}
         * @param object the value to validate
         */
        void value(String nodeName, Object object);

        /**
         * Receives the value extracted from an iterable object that is not indexed (e.g.
         * a {@link Iterable}, {@link Set} or a {@link Map}).
         *
         * @param nodeName the name of the node representing the container element. If not
         * {@code null}, the name will be used when adding a container element node to the
         * {@link Path}
         * @param object the value to validate
         */
        void iterableValue(String nodeName, Object object);

        /**
         * Receives the value extracted from an indexed object (e.g. a {@link List}).
         *
         * @param nodeName the name of the node representing the container element. If not
         * {@code null}, the name will be used when adding a container element node to the
         * {@link Path}
         * @param i the index of the value in the original object
         * @param object the value to validate
         */
        void indexedValue(String nodeName, int i, Object object);

        /**
         * Receives the value extracted from a keyed object (e.g. a {@link Map}).
         *
         * @param nodeName the name of the node representing the container element. If not
         * {@code null}, the name will be used when adding a container element node to the
         * {@link Path}
         * @param key the key of the value in the original object
         * @param object the value to validate
         */
        void keyedValue(String nodeName, Object key, Object object);
    }
}
```

The validation engine passes the container instance and a value receiver object to the `extractValues()` method.
The value extractor is only invoked if the container is not `null`.
Value extractor implementations must invoke one of the `ValueReceiver` methods for each element contained in the container, passing the element value and, optionally, a node name.
When calling

* `value()`, the given value will be passed to the validation engine;
* `iterableValue()`, the given value will be passed to the validation engine and the corresponding property path node (see [ConstraintViolation](#validationapi-constraintviolation)) will be marked as iterable, i.e. `Node#isInIterable()` returns `true`;
* `indexedValue()`, the given value will be passed to the validation engine and the corresponding property path node will be marked as iterable and it will have set the given index, i.e. `Node#getIndex()` returns the given index value;
* `keyedValue()`, the given value will be passed to the validation engine and the corresponding property path node will be marked as iterable and it will have set the given key, i.e. `Node#getKey()` returns the given key value.

When passing a non-null node name to any of the receiver methods, this node name will be used when adding a node of kind `CONTAINER_ELEMENT` to the property path (see [ConstraintViolation](#validationapi-constraintviolation) for the property path construction rules).
If null is passed as node name, no node will be appended to the property path.
The resulting property path will then be the same as if the constraint had been given on the container instead of a container element.
That is desirable for single-element wrapper types such as `Optional`, `OptionalInt` etc.

If an exception occurs during invocation of the `extractValues()` method, this exception is wrapped into a `ValidationException` by the Jakarta Bean Validation engine.

The container value passed to a value extractor is retrieved from the element that hosts the type argument carrying the constraint or `@Valid` annotation:

```
public class Orders {

    private Map<String, @Valid @RetailOrder Order> ordersByName;

    public Map<@NotNull String, Order> getOrdersByName() {
        return ordersByName;
    }

    [...]
}
```

When validating the `@NotNull` constraint, the map as returned by the getter will be passed to the map key extractor in order to obtain the map keys.
When validating the `@RetailOrder` constraint and performing cascaded validation,
the map as obtained directly from the field will be passed to the map value extractor in order to obtain the map values.

### 4.1. @ExtractedValue

The `@ExtractedValue` annotation is used to denote the element extracted by a given value extractor:

Listing 4.2: `@ExtractedValue` annotation
```
package javax.validation.valueextraction;

/**
 * Marks the type parameter of a generic container type to which a {@link ValueExtractor} is
 * tied or specifies the type of the wrapped element(s) of non-generic container types.
 * <p>
 * Must be given exactly once for a value extractor type.
 *
 * @author Gunnar Morling
 * @author Guillaume Smet
 *
 * @see ValueExtractor
 * @since 2.0
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE_USE)
@Documented
public @interface ExtractedValue {

    /**
     * The type of the value extracted by the {@link ValueExtractor}. If not set, the type
     * will be automatically inferred from the type argument of the parameterized type.
     * <p>
     * Used to define value extractors for non-generic wrapper types e.g.
     * {@link OptionalInt}.
     * <p>
     * May not be used when {@code ExtractedValue} is defined on the type parameter of
     * a generic container type. A {@code ValueExtractorDefinitionException} will be thrown
     * in this case.
     *
     * @return the type of the value extracted by the value extractor
     */
    Class<?> type() default void.class;
}
```

The `@ExtractedValue` annotation must be specified exactly once for a value extractor type.

For generic container types (e.g. `java.util.List`), `@ExtractedValue` is to be specified on a type argument of the container type as used in the extractor definition.
Only unbounded wildcard type arguments are supported as target for `@ExtractedValue` in this case.

| Note | This implies that only one extractor is supported for a given generic type. I.e. there can be an extractor for `List<?>`, but not one for `List<String>` and one for `List<Integer>`. |
| --- | --- |

For non-generic container types (e.g. `java.util.OptionalInt`), `@ExtractedValue` is to be specified on the container type as used in the extractor definition.
The type of the wrapped element(s) must be specified using `@ExtractedValue#type()` in this case.

In case an illegal value extractor definition is detected, a `ValueExtractorDefinitionException` is raised.

### 4.2. @UnwrapByDefault

Value extractor definitions can be marked with the `@UnwrapByDefault` annotation.
This causes constraints to be automatically applied to the wrapped value(s) if a constraint is found for an element of a type handled by that extractor (see [Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)):

Listing 4.3: `@UnwrapByDefault` annotation
```
package javax.validation.valueextraction;

/**
 * Marks a {@link ValueExtractor} definition so that it is applied automatically when
 * detecting constraints declared on the container type supported by the extractor, causing
 * the constraints to be applied to the container's elements instead of the container.
 * <p>
 * If needed, this behavior can be changed per constraint using {@link Unwrapping.Skip},
 * causing the constraints to be applied to the container itself:
 *
 * <pre>
 * &#064;SomeConstraint(payload = Unwrapping.Skip.class)
 * SomeContainerType container;
 * </pre>
 *
 * @author Guillaume Smet
 * @since 2.0
 */
@Target({ TYPE })
@Retention(RUNTIME)
@Documented
public @interface UnwrapByDefault {

}
```

### 4.3. Built-in value extractors

Compatible implementations provide value extractors for the following types out of the box:

* `java.util.Iterable`; `iterableValue()` must be invoked for each contained element, passing the string literal `<iterable element>` as node name
* `java.util.List`; `indexedValue()` must be invoked for each contained element, passing the string literal `<list element>` as node name
* `java.util.Map`; both map keys and map values are to be supported;
  `keyedValue()` must be invoked by the map key extractor for each contained key, passing the string literal `<map key>` as node name;
  `keyedValue()` must be invoked by the map value extractor for each contained value, passing the string literal `<map value>` as node name
* `java.util.Optional`; `value()` must be invoked, passing `null` as node name and passing the contained object as value or `null` if none is present
* `java.util.OptionalInt`, `java.util.OptionalLong` and `java.util.OptionalDouble`; the extracted value types must be `java.lang.Integer`, `java.lang.Long` and `java.lang.Double`, respectively. `value()` must be invoked, passing `null` as node name and passing the contained number as value or `null` if none is present. The extractors must be marked with `@UnwrapByDefault`.

In environments where [JavaFX](https://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-overview.htm#JFXST784) is present, compatible implementations additionally provide extractors for the following types out of the box:

* `javafx.beans.observable.ObservableValue`; `value()` must be invoked with the observable value, passing `null` as node name; the extractor must be marked with `@UnwrapByDefault`
* `javafx.beans.property.ReadOnlyListProperty` and `javafx.beans.property.ListProperty`; `indexedValue()` must be invoked for each contained element, passing the string literal `<list element>` as node name
* `javafx.beans.property.ReadOnlySetProperty` and `javafx.beans.property.SetProperty`; `iterableValue()` must be invoked for each contained element, passing the string literal `<iterable element>` as node name
* `javafx.beans.property.ReadOnlyMapProperty` and `javafx.beans.property.MapProperty`; both map keys and map values are to be supported;
  `keyedValue()` must be invoked by the map key extractor for each contained key, passing the string literal `<map key>` as node name;
  `keyedValue()` must be invoked by the map value extractor for each contained value, passing the string literal `<map value>` as node name

Additional value extractors (amending or overriding the set of built-in extractors) can be registered when bootstrapping the validation engine (see [Registering ValueExtractor implementations](#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-registering)).

### 4.4. Examples

A value extractor for the elements of `java.util.List`:

```
class ListValueExtractor implements ValueExtractor<List<@ExtractedValue ?>> {

    @Override
    public void extractValues(List<?> originalValue, ValueReceiver receiver) {
        for ( int i = 0; i < originalValue.size(); i++ ) {
            receiver.indexedValue( "<list element>", i, originalValue.get( i ) );
        }
    }
}
```

This extractor passes each element contained in the given list to the receiver object,
using the literal `<list element>` as a node name.

A value extractor for `java.util.Optional`:

```
public class OptionalValueExtractor implements ValueExtractor<Optional<@ExtractedValue ?>> {

    @Override
    public void extractValues(Optional<?> originalValue, ValueReceiver receiver) {
        receiver.value( null, originalValue.orElse( null ) );
    }
}
```

This extractor passes the element wrapped by the given `Optional` to the receiver object, if present.
`null` is passed as a node name, causing no node to be appended to the resulting property path.
I.e. when the `@Size` constraint in `Optional<@Size(min=1) String> getName() { …​ }` is violated,
the resulting property path will be the same as if a constraint hosted on the `getName` getter itself was violated.

A value extractor for `java.util.OptionalInt`:

```
@UnwrapByDefault
public class OptionalIntValueExtractor implements ValueExtractor<@ExtractedValue(type = Integer.class) OptionalInt> {

    @Override
    public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
        receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
    }
}
```

This extractor passes the `int` value wrapped by the given `OptionalInt` to the receiver object, if present.
`null` is passed as a node name, causing no node to be appended to the resulting property path.
As the extractor is marked with `@UnwrapByDefault`,
any constraint declared on an element of type `OptionalInt` will implicitly be applied to the wrapped `int` value instead of the `OptionalInt` itself.
As `OptionalInt` is a non-generic type (i.e. it has no type parameters), `@ExtractedValue` is given on the container type as used within the value extractor definition,
specifying the type of the wrapped element via `type()`.

The following extractor definition is illegal as it specifies `@ExtractedValue` more than once:

```
public class IllegalMapExtractor implements ValueExtractor<Map<@ExtractedValue ?, @ExtractedValue ?>> { ... }
```

The following extractor definition is unsupported as it specifies `@ExtractedValue` on a non-wildcard type argument:

```
public class StringListValueExtractor implements ValueExtractor<List<@ExtractedValue String>> { ... }
```

## 5. Constraint declaration and validation process

The Jakarta Bean Validation specification defines a framework for declaring constraints on JavaBean classes, fields and properties. Constraints are declared on types and evaluated against instances or graphs of instances.

Jakarta Bean Validation also offers a way to declare constructor and method constraints where parameters and return values are the constrained elements. We will discuss method constraints declaration in detail in [Method and constructor constraints](#constraintdeclarationvalidationprocess-methodlevelconstraints).

Furthermore, constraints can be applied to the elements of generic container types such as `Map`, `List` or `Optional` or of non-generic container types such as `OptionalInt`.
Container element constraints are discussed in detail in [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints).

### 5.1. Requirements on classes to be validated

Objects hosting constraints and expecting to be validated by Jakarta Bean Validation providers must fulfill the following requirements:

* Properties to be validated must follow the method signature conventions for JavaBeans read properties, as defined by the [JavaBeans specification](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/). These properties are commonly referred as getters.
* Static fields and static methods are excluded from validation.
* Constraints can be applied to interfaces and superclasses.

| Note | What is a getter?  The JavaBeans specification specifies that a getter is a method whose   * name starts with `get` and has a return type but no parameter * name starts with `is`, has no parameter and is returning `boolean` |
| --- | --- |

The target of an annotation definition can be a

* type
* field or property
* constructor or method return value
* constructor or method parameter
* constructor or method cross-parameter
* container element

provided that:

* the constraint definition supports the specified target (`java.lang.annotation.Target`)
* one of the `ConstraintValidator`s declared on the constraint supports the declared type of the target or in the case of cross-parameter, one cross-parameter `ConstraintValidator` is present (see [ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution) to learn about `ConstraintValidator` resolution)
* in the case of container element constraints, a corresponding value extractor exists (see [ValueExtractor resolution](#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution) for the details of value extractor resolution)

#### 5.1.1. Object validation

Constraint declarations can be applied to a class or an interface. Applying a constraint to a class or interface expresses a validation over the state of the class or the class implementing the interface.

#### 5.1.2. Field and property validation

Constraint declarations can be applied on both fields and properties for the same object type. The same constraint should however not be duplicated between a field and its associated property (the constraint validation would be applied twice). It is recommended for objects holding constraint declarations to adhere to a single state access strategy (either annotated fields or properties).

| Note | Jakarta Persistence and Jakarta Bean Validation  For maximum portability, persistent properties hosting Jakarta Bean Validation constraints should use the same access strategy used in Jakarta Persistence. In other words, place your Jakarta Bean Validation constraint annotations on the same element (field or getter) as your Jakarta Persistence annotations. |
| --- | --- |

When a field is annotated with a constraint declaration, field access strategy is used to access the state validated by such constraint.

When a property is annotated with a constraint declaration, property access strategy is used to access the state validated by such constraint.

When using field access strategy, the Jakarta Bean Validation provider accesses the instance variable directly. When using the property access strategy, the Jakarta Bean Validation provider accesses the state via the property accessor method. It is required that the class follows the method signature conventions for JavaBeans read properties (as defined by the JavaBeans `Introspector` class) for constrained properties when constrained properties are used. In this case, for every constraint property of type `T`, there is a getter method named `get<Property-name>`. The method must have no parameters. For `boolean` properties, `is<Property-name>` is an alternative name for the getter method. Specifically, if `getX` is the name of the getter method, where `X` is a string, the name of the persistent property is defined by the result of `java.beans.Introspector.decapitalize(X)`.

The fields or methods visibility are not constrained.

#### 5.1.3. Graph validation

In addition to supporting instance validation, validation of graphs of objects is also supported. The result of a graph validation is returned as a unified set of constraint violations. `@Valid` is used to express validation traversal of an association.

Listing 5.1: `@Valid` annotation
```
/**
 * Marks a property, method parameter or method return type for validation cascading.
 * <p>
 * Constraints defined on the object and its properties are be validated when the
 * property, method parameter or method return type is validated.
 * <p>
 * This behavior is applied recursively.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
public @interface Valid {
}
```

Consider the situation where bean `X` contains a field of type `Y`. By annotating field `Y` with the `@Valid` annotation, the Validator will validate `Y` (and its properties) when `X` is validated. The exact type `Z` of the value contained in the field declared of type `Y` (subclass, implementation) is determined at runtime. The constraint definitions of `Z` are used. This ensures proper polymorphic behavior for associations marked with `@Valid`.

Collection-valued, array-valued and generally `Iterable` fields and properties may also be decorated with the `@Valid` annotation. This causes the contents of the iterator to be validated. Any object implementing `java.lang.Iterable` is supported. This includes specifically:

* arrays of objects
* `java.util.Collection`
* `java.util.Set`
* `java.util.List`
* `java.util.Map` (special treatment see below)

Each object provided by the iterator is validated. For `Map`, the value (retrieved by `getValue`) of each `Map.Entry` is validated (the key is not validated).

Like regular references, its type is determined at runtime and the constraint definitions for this particular type are used.

As of Jakarta Bean Validation 2.0, `@Valid` can be applied to the elements of any generic container by putting it to the type argument(s) when using such container (e.g. `MultiMap<String, @Valid Address> addressesByType`),
provided a value extractor implementation (see [Value extractor definition](#valueextractordefinition)) for that container type and the targeted type argument is present.
There are built-in value extractors for the generic collection types listed above.
In addition, there is a built-in extractor for the key objects of maps.
See [Built-in value extractors](#valueextractordefinition-builtinvalueextractors) for the complete list of built-in value extractors.

`@Valid` also allows the validation of the elements of nested generic containers. `@Valid` must be put to a type argument of that nested container type in order to trigger validation of the elements of all the nested containers.

For a given container, the `@Valid` annotation should either be put to the container itself *or* to the type argument(s) of the container,
but not both (in order to prevent the container elements from being validated twice).

The `@Valid` annotation is applied recursively. A conforming implementation avoids infinite loops according to the rules described in [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation).

It is not supported to put `@Valid` to the type parameters of generic types or methods.
It is also not supported to put `@Valid` to type arguments within the `extends` or `implements` clauses of type definitions.
A future revision of this specification might define support for such usages of `@Valid`.

##### 5.1.3.1. Examples

Example 5.1: Making elements of a list subject to graph validation
```
public class User {

    // preferred style as of Jakarta Bean Validation 2.0
    private List<@Valid PhoneNumber> phoneNumbers;

    // traditional style; continues to be supported
    @Valid
    private List<PhoneNumber> phoneNumbers;

    // discouraged; either the container or the type argument(s) should be
    // annotated with @Valid, but not both
    @Valid
    private List<@Valid PhoneNumber> phoneNumbers;
}
```

Example 5.2: Making values of a map subject to graph validation
```
public class User {

    // preferred style as of Jakarta Bean Validation 2.0
    private Map<AddressType, @Valid Address> addressesByType;

    // traditional style; continues to be supported
    @Valid
    private Map<AddressType, Address> addressesByType;

    // discouraged; either the map or the map value type argument should be
    // annotated with @Valid, but not both
    @Valid
    private Map<AddressType, @Valid Address> addressesByType;
}
```

Example 5.3: Making keys and values of a map subject to graph validation
```
public class User {

    private Map<@Valid AddressType, @Valid Address> addressesByType;
}
```

Example 5.4: Making elements of a nested list subject to graph validation
```
public class User {
    private Map<String, List<@Valid Address>> addressesByType;
}
```

In this example, all `Address` objects contained in the lists of the `addressesByType` map will be validated.
Two value extractors are invoked for this:

* the extractor for `Map` values will be invoked to obtain all map values (lists of `Address`)
* for each extracted list of addresses, the extractor for `List` elements will be invoked, providing the `Address` objects from each list in the map

Example 5.5: Making keys and values of a nested map subject to graph validation
```
public class User {
    private Map<String, Map<@Valid AddressType, @Valid Address>> addressesByUserAndType;
}
```

In this example, all `AddressType` objects and all `Address` objects contained in the maps of the `addressesByUserAndType` map will be validated.
The following value extractors are invoked for this:

* the extractor for `Map` values will be invoked to obtain all map values (maps of addresses by address type)
* for each extracted map, the extractor for `Map` keys will be invoked, providing the `AddressType` objects from each of the nested maps
* for each extracted map, the extractor for `Map` values will be invoked, providing the `Address` objects from each of the nested maps

### 5.2. Constraint declaration

Constraint declarations are placed on classes or interfaces primarily through annotations. A constraint annotation (see [Constraint annotation](#constraintsdefinitionimplementation-constraintdefinition)), can be applied to a type, on any of the type’s fields or on any of the JavaBeans-compliant properties.

When a constraint is defined on a class, the class instance being validated is passed to the `ConstraintValidator`. When a constraint is defined on a field, the value of the field is passed to the `ConstraintValidator`. When a constraint is defined on a getter, the result of the getter invocation is passed to the `ConstraintValidator`.

[Method and constructor constraints](#constraintdeclarationvalidationprocess-methodlevelconstraints) discusses in detail constraints on methods and constructors.

Constraints can also be applied to the elements of container types, e.g. to the elements of a `List`-typed property or to the value wrapped by an `Optional` object returned by a method.
Container element constraints are discussed in [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints).

### 5.3. Inheritance (interface and superclass)

A constraint declaration can be placed on an interface. For a given class, constraint declarations held on superclasses as well as interfaces are evaluated by the Jakarta Bean Validation provider. Rules are formally described in [Formal group definitions](#constraintdeclarationvalidationprocess-groupsequence-formaldefinition).

The effect of constraint declarations is cumulative. Constraints declared on a superclass getter will be validated along with any constraints defined on an overridden version of the getter according to the Java Language Specification visibility rules.

### 5.4. Group and group sequence

A group defines a subset of constraints. Instead of validating all constraints for a given object graph, only a subset is validated. This subset is defined by the group or groups targeted. Each constraint declaration defines the list of groups it belongs to. If no group is explicitly declared, a constraint belongs to the `Default` group.

Groups are represented by interfaces.

Example 5.6: Definition of groups
```
/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * Customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}
```

A constraint can belong to one or more groups.

Example 5.7: Assign groups to constraints
```
/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}
```

During the validation call, one or more groups are validated. All the constraints belonging to this set of groups is evaluated on the object graph. In [Assign groups to constraints](#example-assigngrouptoconstraints), `@NotNull` is checked on `defaultCreditCard` when either the `Billable` or `BuyInOneClick` group is validated. `@NotNull` on `firstname` and `lastname` are validated when the `Default` group is validated. Reminder: constraints held on superclasses and interfaces are considered.

`Default` is a group predefined by the specification.

Listing 5.2: `Default` group
```
package javax.validation.groups;

/**
 * Default Jakarta Bean Validation group.
 * <p>
 * Unless a list of groups is explicitly defined:
 * <ul>
 *     <li>constraints belong to the {@code Default} group</li>
 *     <li>validation applies to the {@code Default} group</li>
 * </ul>
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}
```

#### 5.4.1. Group inheritance

In some situations, a group is a superset of one or more groups. This can be described by Jakarta Bean Validation. A group may inherit one or more groups by using interface inheritance.

Example 5.8: Groups can inherit other groups
```
/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}
```

For a given interface `Z`, constraints marked as belonging to the group `Z` (i.e. where the annotation element `groups` contains the interface `Z`) or any of the super interfaces of `Z` (inherited groups) are considered part of the group `Z`.

In the following example:

Example 5.9: Use of a inherited group
```
/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}
```

validating the group `BuyInOneClick` will lead to the following constraints checking:

* `@NotNull` on `firstname` and `lastname`
* `@NotNull` on `defaultCreditCard`

because `Default` and `Billable` are superinterfaces of `BuyInOneClick`.

#### 5.4.2. Group sequence

By default, constraints are evaluated in no particular order regardless of which groups they belong to. It is however useful in some situations to control the order of constraints evaluation. There are often scenarios where a preliminary set of constraints should be evaluated prior to other constraints. Here are two examples:

* The second group depends on a stable state to run properly. This stable state is verified by the first group.
* The second group is a heavy consumer of time, CPU or memory and its evaluation should be avoided if possible.

To implement such ordering, a group can be defined as a sequence of other groups. Each group in a group sequence must be processed sequentially in the order defined by `@GroupSequence.value` when the group defined as a sequence is requested. Note that a group member of a sequence can itself be composed of several groups via inheritance or sequence definition. In this case, each composed group must respect the sequence order as well.

Processing a group is defined in [Validation routine](#constraintdeclarationvalidationprocess-validationroutine) ; if one of the groups processed in the sequence generates one or more constraint violations, the groups following in the sequence must not be processed. This ensures that a set of constraints is evaluated only if another set of constraints is valid.

Groups defining a sequence and groups composing a sequence must not be involved in a cyclic dependency:

* either directly or indirectly
* either through cascaded sequence definitions or group inheritance

If a group containing such a circularity is evaluated, a `GroupDefinitionException` is raised.

Groups defining a sequence should not directly inherit other groups. In other words, the interface hosting the group sequence should not have any super interface.

Groups defining a sequence should not be used directly in constraint declarations. In other words, the interface hosting the group sequence should not be used in a constraint declaration.

To define a group as a sequence, the interface must be annotated with the `@GroupSequence` annotation.

Listing 5.3: `@GroupSequence` annotation
```
/**
 * Defines group sequence.
 * <p>
 * The interface hosting {@code @GroupSequence} is representing
 * the group sequence.
 * When hosted on a class, represents the {@link Default} group
 * for that class.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ TYPE })
@Retention(RUNTIME)
@Documented
public @interface GroupSequence {

    Class<?>[] value();
}
```

Here is a usage example:

Example 5.10: Make use of group sequence
```
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipCode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}
```

In [Make use of group sequence](#example-groupsequence), when the `Address.Complete` group is validated, all constraints belonging to the `Default` group are validated. If any of them fail, the validation skips the `HighLevelCoherence` group. If all `Default` constraints pass, `HighLevelCoherence` constraints are evaluated.

| Note | A given constraint can belong to two or more groups ordered by a sequence. In this case, the constraint is evaluated as part of the first group and ignored in the subsequent group(s). See [Validation routine](#constraintdeclarationvalidationprocess-validationroutine) for more information. |
| --- | --- |

#### 5.4.3. Redefining the Default group for a class

In [Make use of group sequence](#example-groupsequence), validating the `Default` group does not validate `HighLevelCoherence` constraints. To ensure a complete validation, a user must use the `Complete` group. This breaks some of the encapsulation you could expect. You can work around this by redefining what the `Default` group means for a given class. To redefine `Default` for a class, place a `@GroupSequence` annotation on the class; this sequence expresses the sequence of groups that does substitute `Default` for this class.

Example 5.11: Redefining Default group for Address
```
@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipCode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}
```

In [Redefining Default group for Address](#example-overridedefaultgroup), when an address object is validated for the group `Default`, all constraints belonging to the group `Default` and hosted on `Address` are evaluated. If none fails, all `HighLevelCoherence` constraints present on `Address` are evaluated. In other words, when validating the `Default` group for `Address`, the group sequence defined on the `Address` class is used.

Since sequences cannot have circular dependencies, using `Default` in the declaration of a sequence is not an option. Constraints hosted on a class `A` and belonging to the `Default` group (by default or explicitly) implicitly belong to the group `A`.

A sequence defined on a class `A` (i.e. redefining the `Default` groups for the class) must contain the group `A`. In other words, the default constraints hosted on a class must be part of the sequence definition. If a `@GroupSequence` redefining the `Default` group for a class `A` does not contain the group `A`, a `GroupDefinitionException` is raised when the class is validated or when its metadata is requested.

#### 5.4.4. Implicit grouping

It is possible to implicitly group several constraints in the same group without explicitly listing such a group in the constraint declaration. Every constraint hosted on an interface `Z` and part of the `Default` group (implicitly or explicitly) belongs to the group `Z`. This is useful to validate the partial state of an object based on a role represented by an interface.

Example 5.12: Example of interface / group hosting constraints
```
/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}
```

When an `Order` object is validated on the `Default` group, the following constraints are validated: `@NotNull` on `getCreationDate`, `getLastUpdate`, `getLastModifier`, `getLastReader`, `getOrderNumber` and `@Size` on `getOrderNumber` as all belong to the `Default` group.

When an `Order` object is validated on the `Auditable` group, the following constraints are validated: `@NotNull` on `getCreationDate`, `getLastUpdate`, `getLastModifier`, `getLastReader`. Only the constraints present on `Auditable` (and any of its super interfaces) and belonging to the `Default` group are validated when the group `Auditable` is requested. It allows the caller to validate that a given object can be safely audited even if the object state itself is not valid.

#### 5.4.5. Group conversion

When performing cascading validation, it is possible to use a different group than the one originally requested using the group conversion feature. Group conversions are declared by using the `@ConvertGroup` annotation.

Listing 5.4: @ConvertGroup annotation
```
package javax.validation.groups;

/**
 * Converts group {@code from} to group {@code to} during cascading.
 * <p>
 * Can be used everywhere {@link Valid} is used and must be on an element
 * annotated with {@code Valid}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
public @interface ConvertGroup {

    /**
     * The source group of this conversion.
     * @return the source group of this conversion
     */
    Class<?> from() default Default.class;

    /**
     * The target group of this conversion.
     * @return the target group of this conversion
     */
    Class<?> to();

    /**
     * Defines several {@link ConvertGroup} annotations
     * on the same element.
     */
    @Target({ METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {

        ConvertGroup[] value();
    }
}
```

`@ConvertGroup` and `@ConvertGroup.List` can be used everywhere `@Valid` can be used (associations, method/constructor parameters and return value). If these annotations are used without `@Valid`, a `ConstraintDeclarationException` is raised.

When an element is annotated with `@Valid`, validation is propagated. Groups are passed as is to the nested elements unless the `@ConvertGroup` annotation is used.

If the group expected to be passed to the nested element validation is defined as the `from` attribute of a `@ConvertGroup` annotation, the group used to effectively validate the nested element is the corresponding group defined in the `to` attribute.

If no value for the `from` attribute is specified, `Default.class` will be used as the source group of the conversion.

Rules are not executed recursively. If a rule is found matching, subsequent rules are no longer evaluated. In particular, if a set of `@ConvertGroup` declaration chains group `A` to `B` and `B` to `C`, the group `A` will be converted to `B` and not to `C`. This both makes rules clearer and let you switch two groups.

It is not legal to have more than one conversion rule containing the same `from` value. In this case, a `ConstraintDeclarationException` is raised.

Like regular constraint declarations, the `from` attribute cannot refer to a group sequence. A `ConstraintDeclarationException` is raised in this situation. The `to` attribute can. The group sequence will then be expanded before validating the associated object.

| Note | When validation is done, group sequences are expanded before validating the object and its cascaded objects with the expected groups. Group conversion on an associated object happens on the already expanded groups.   The group referred to in `@ConvertGroup.from` works on expanded groups (i.e., after the group sequence has been expanded), not necessarily groups passed to the various `validate` methods.   The group referred to in `@ConvertGroup.to` will be expanded before validating the cascaded object just like a call to the various `validate` method would have done. |
| --- | --- |

| Note | Like most Jakarta Bean Validation error cases, an illegal set of rules can be discovered statically (at compile time). For example, an annotation processor could detect such errors. |
| --- | --- |

| Note | Group circularity in a group conversion are not problematic because:   * only one rule is applied for a given cascade (rules are not applied recursively) * validation cascading is stopped when the same instance / property is validated with the same group in a given path (existing rule) |
| --- | --- |

`@ConvertGroup` and `@ConvertGroup.List` can only be placed where `@Valid` is present to ensure proper respect of the Liskov substitution principle: if rules were to be defined on an overriding method of a method marked as cascading validation, the rules could end up altering the list of constraints validated by the super type and thus violating the Liskov substitution principle.

Likewise, if a sub type overrides/implements a method originally defined in several parallel types of the hierarchy (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class) and if that method’s return value has been marked for cascading validation in one of the parallel types, no group conversion rule may be declared for that method’s return value in the parallel types of the hierarchy. This again is to avoid an unexpected altering of the post conditions to be guaranteed to the caller.

If any of these rules is violated, a `ConstraintDeclarationException` is raised by default as defined in [Method constraints in inheritance hierarchies](#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance).

Group conversion is quite useful to facilitate object graph reuse without spreading the validation group definitions across several layers. Let’s look at an example.

##### 5.4.5.1. Group conversion examples

In this example we will reuse the `Address` group split and match it to the `User` group split.

Example 5.13: Example of group conversion
```
public interface Complete extends Default {}
public interface BasicPostal {}
public interface FullPostal extends BasicPostal {}

public class Address {
    @NotNull(groups=BasicPostal.class)
    String street1;

    String street2;

    @ZipCode(groups=BasicPostal.class)
    String zipCode;

    @CodeChecker(groups=FullPostal.class)
    String doorCode;
}

public class User {
    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    @ConvertGroup(from=Complete.class, to=FullPostal.class)
    Set<Address> getAddresses() { [...] }
}
```

When validating an instance of `User` with the `Default` group, the associated addresses are validated with the `BasicPostal` group. When validating an instance of `User` with the `Complete` group, the associated addresses are validated with the `FullPostal` group.

Group conversions can also be applied during container element validation:

Example 5.14: Example of container element validation with group conversion
```
public class User {
    Set<
        @Valid
        @ConvertGroup(from=Default.class, to=BasicPostal.class)
        @ConvertGroup(from=Complete.class, to=FullPostal.class)
        Address
    > getAddresses() { [...] }
}
```

The following example shows an illegal declaration of a group conversion rule on a method’s return value:

Example 5.15: Example of an illegal group conversion
```
public interface BasicPostal {}

public class Order { [...] }

public interface RetailOrderService {

    @Valid
    Order placeOrder(String itemNo, int quantity);
}

public interface B2BOrderService {

    @Valid
    @ConvertGroup(from=Default.class, to=BasicPostal.class)
    Order placeOrder(String itemNo, int quantity);
}

public class OrderService implements RetailOrderService, B2BOrderService {

    @Override
    public Order placeOrder(String itemNo, int quantity) {
        [...]
    }
}
```

Here the class `OrderService` implements the two unrelated interfaces `RetailOrderService` and `B2BOrderService`, which both define a method `placeOrder()`, marking the return value as cascaded.

The group conversion declared in `B2BOrderService` is illegal as per the rules defined in the previous section, since the set of applied validation groups might be altered unexpectedly for a client of the `RetailOrderService` interface.

#### 5.4.6. Formal group definitions

The formal rules defining groups are as followed. *Text in italic are comments about the rules.*

For every class `X`:

1. For each superclass `Y` of `X`, the group `Y` contains all constraints of the group `Y` of `Y`
   *this rule prepares formal concepts for recursive discovery*

2. The group `X` contains the following constraints:
   group `X` is a group used on sequences redefining the default group on a class (see [Redefining the Default group for a class](#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup))

   1. every constraint declared by the class `X` which does not declare a group or does declare the group `Default` explicitly.
      *all Default constraints hosted on X*
   2. every constraint declared by any interface implemented by `X` and not annotated `@GroupSequence` which does not explicitly declare a group or does declare the group `Default` explicitly.
      *all Default constraints hosted on interfaces of X: constraints are inherited by the class hierarchy. Interfaces marked as @GroupSequence are ignored.*
   3. if `X` has a direct superclass `Y`, every constraint in the group `Y`
      *all Default constraints hosted on the superclasses of X: constraints are inherited by the class hierarchy*

3. If `X` has no `@GroupSequence` annotation, the group `Default` contains the following constraints:
   *this rule defines which constraints are evaluated when validating Default on X.*

   1. every constraint in the group `X`
   2. if `X` has a direct superclass `Y`, every constraint in the group `Default` of `Y`
      *this rule is necessary in case Y redefines the group Default*

4. If `X` does have a `@GroupSequence` annotation, the group `Default` contains every constraint belonging to every group declared by the `@GroupSequence` annotation.
   *this rule describes how a class can redefine the group Default for itself (see [Redefining the Default group for a class](#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup))*

   * the `@GroupSequence` annotation must declare the group `X`

5. For every interface `Z`, the group `Z` contains the following constraints:
   *this rule defines how non Default groups are defined*

   1. every constraint declared by the interface `Z` which does not explicitly declare a group or does declare the group `Default` explicitly.
      *all Default constraints hosted on Z: this rule formally defines implicit grouping per interface (see [Implicit grouping](#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping))*
   2. every constraint (which does not explicitly declare a group) declared by any superinterface not annotated `@GroupSequence` of the interface `Z`
      *all Default constraints hosted on interfaces of Z: groups can be inherited (see [Group inheritance](#constraintdeclarationvalidationprocess-groupsequence-groupinheritance))*
   3. every constraint declared by the class `X` which explicitly declares the group `Z`
      *every constraint hosted by X and marked as belonging to the group Z*
   4. every constraint declared by any interface implemented by `X` and not annotated `@GroupSequence` which explicitly declares the group `Z`
      *every constraint hosted by any interface of X and marked as belonging to the group Z*
   5. if `X` has a direct superclass `Y`, every constraint in the group `Z` of `Y`
      *every constraint hosted by any superclass of X and marked as belonging to the group Z*

6. For every interface `Z` annotated `@GroupSequence`, the group `Z` contains every constraint belonging to every group declared by the `@GroupSequence` annotation.
   *defines the composition side of group sequence but does not define the ordering behavior of sequence (see [Group sequence](#constraintdeclarationvalidationprocess-groupsequence-groupsequence))*

When a given group `G` (represented by an interface `G`) is requested for the validation of a class `X`:

* constraints belonging to the group `G` are evaluated
* if the interface `G` is not annotated `@GroupSequence`, every group represented by the super interface of `G` are requested for validation
* if the interface `G` is annotated with `@GroupSequence`, every group represented by the interfaces declared by the `@GroupSequence` annotation are requested for validation

  + the validation of groups declared to the `@GroupSequence` must happen in the sequencing order declared by `@GroupSequence`: the sequencing order is propagated to the groups composing the sequenced group (via inheritance or group sequence)
  + if a group validation triggers the failure of one or more constraints, groups following in the sequence must not be evaluated.
* if the group `G` represents the `Default` group of `X` overridden by `@GroupSequence`, operations are equivalent

When the `Default` group of a given class `X` is overridden via `@GroupSequence`, its validation is as followed:

* every group represented by the interfaces declared by the `@GroupSequence` annotation are requested for validation

  + the validation of groups declared to the `@GroupSequence` must happen in the sequencing order declared by `@GroupSequence`: the sequencing order is propagated to the groups composing the sequenced group (via inheritance or group sequence)
  + if a group validation triggers the failure of one or more constraints, groups following in the sequence must not be evaluated.

Unless defined by a `@GroupSequence`, evaluation ordering is not constrained. In particular, several groups can be validated in the same pass. If a group definition leads to a circular sequencing order between groups, a `GroupDefinitionException` is raised.

| Note | A group `G` sequenced (directly or indirectly) to be executed before itself is not considered a circular reference. |
| --- | --- |

### 5.5. Container element constraints

Constraints can be applied to the elements of generic containers, e.g. `List`, `Map` or `Optional`.
This is done by putting constraint annotations to the type arguments of such containers.

Container element constraints can be used within the following declarations:

* fields,
* properties,
* method or constructor parameters or
* method return values.

Example 5.16: Container element constraints
```
private List<@Email String> emails;

public Optional<@Email String> getEmail() {
    [...]
}

public Map<@NotNull String, @ValidAddress Address> getAddressesByType() {
    [...]
}

public List<@NotBlank String> getMatchingRecords(List<@NotNull @Size(max=20) String> searchTerms) {
    [...]
}
```

When a field, property, executable parameter or method return value which is of a container type gets validated, then all values contained in the container will be validated provided that their container element type is constrained.
Any container element constraints of that element will be validated alongside any other constraints hosted by that element.
For container element constraints, the same rules for validation groups and group sequences apply as for any other constraint on the same element.

When a container element is constrained, the validation engine invokes a value extractor (see [Value extractor definition](#valueextractordefinition))
which retrieves the value(s) from the container so they can be validated.
This may be a single value - e.g. in the case of `Optional` which wraps exactly one value if the `Optional` is not empty -
or multiple values in the case of collection types.

Container element constraints can be applied to nested container types:

Example 5.17: Container element constraints on nested containers
```
private Map<String, @NotEmpty List<@ValidAddress Address>> addressesByType;
```

In such case multiple value extractors will be invoked.

In the example above,

* the extractor for `Map` values will be invoked to obtain all map values (lists of `Address`)
* for each extracted list of addresses, the `@NotEmpty` constraint will be validated and the extractor for `List` elements will be invoked, providing the `Address` objects from each list in the map
* the `@ValidAddress` constraint will be applied to all elements of all lists stored in the map

It is not supported to declare container element constraints on the type parameters of generic types or methods.
It is also not supported to declare container element constraints on type arguments within the `extends` or `implements` clauses of type definitions.
I.e. the following usages are unsupported:

Example 5.18: Unsupported usage of container element constraints on generic types and methods
```
public class NonNullList<@NotNull T> {
    [...]
}

public class ContainerFactory {
    <@NotNull T> Container<T> instantiateContainer(T wrapped) { [...] }
}

public class NonNullSet<T> extends Set<@NotNull T> {
    [...]
}
```

A future revision of this specification might define support for such usages of container element constraints.

#### 5.5.1. Implicit unwrapping of containers

Besides specifying container element constraints on type arguments, it is also possible to declare container element constraints on non-generic container types.
This is done by means of *implicit unwrapping*, i.e. a constraint doesn’t apply to the annotated container itself but to its element(s).
Examples for types being subject to implicit unwrapping are `java.util.OptionalInt`, `OptionalLong` and `OptionalDouble` as well as JavaFX’s non-generic property types such as `StringProperty` or `IntegerProperty`:

Example 5.19: Implicit unwrapping of container elements
```
@Min(1)
private OptionalInt optionalNumber;

@Negative
private LongProperty negativeLong;

@Positive
private IntegerProperty positiveInt;

private final ListProperty<@NotBlank StringProperty> notBlankStrings;
```

Here the `@Min`, `@Negative`, `@Positive` and `@NotBlank` constraints don’t apply to the annotated `OptionalInt`, `LongProperty`, `IntegerProperty` and `StringProperty` objects themselves, but rather to the wrapped numeric and string values, respectively.

For this to work, an unambiguously resolvable value extractor (see [ValueExtractor resolution algorithm for applying container-level constraints to container elements](#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-implicitunwrapping)) must be defined which carries the `@UnwrapByDefault` annotation (see [@UnwrapByDefault](#valueextractordefinition-unwrapbydefault)).

If needed, the target (container or container element) of a constraint declared on a container can be explicitly specified via the `Unwrap` and `Skip` payload definitions:

Listing 5.5: `Payload` types for unwrapping control
```
package javax.validation.valueextraction;

/**
 * Set of interfaces used in the {@code payload()} of a constraint to indicate if a value
 * should be unwrapped before validation.
 * <p>
 * This is used to overwrite the default configuration defined on the {@link ValueExtractor}.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
public interface Unwrapping {

    /**
     * Unwrap the value before validation.
     *
     * @since 2.0
     */
    public interface Unwrap extends Payload {
    }

    /**
     * Skip the unwrapping if it has been enabled on the {@link ValueExtractor} by the
     * {@link UnwrapByDefault}
     * annotation.
     *
     * @since 2.0
     */
    public interface Skip extends Payload {
    }

}
```

This is useful for applying a constraint given on a non-generic container to

* the container element(s) if there is no value extractor marked with `@UnwrapByDefault` (by using `Unwrap`)
* the container itself in case there is a value extractor marked with `@UnwrapByDefault` (by using `Skip`)

For instance the `@NotNull` constraint is applied to the `StringProperty` container:

```
@NotNull(payload = Unwrapping.Skip.class)
private StringProperty name;
```

If both `Unwrap` and `Skip` are present in the definition of a payload, a `ConstraintDeclarationException` is raised.

| Note | For the sake of readability, when applying constraints to the elements of a generic container, it is strongly recommended to put the constraints to the type argument instead of the container itself in conjunction with `Unwrapping.Unwrap`. I.e. you should prefer  ``` List<@Email String> emails; ```    over  ``` @Email(payload = Unwrapping.Unwrap.class) List<String> emails; ``` |
| --- | --- |

### 5.6. Method and constructor constraints

| Note | In the following, the term "method constraint" refers to constraints declared on methods as well as constructors. |
| --- | --- |

Method constraints are declared by adding constraint annotations directly to methods or constructors and/or their parameters. In the former case, all the parameters of an executable (cross-parameter constraint) or the return value is constrained, in the latter individual parameters are constrained. As with bean constraints, this can be done using either actual Java annotations or using an XML constraint mapping file (see [Method-level overriding](#xml-mapping-constraintdeclarationinxml-methodleveloverriding)). Jakarta Bean Validation providers are free to provide additional means of defining method constraints such as an API-based approach.

Getters are not considered constrained methods by default (see [Method and constructor validation](#integration-general-executable)).

#### 5.6.1. Requirements on methods to be validated

Static methods are ignored by validation. Putting constraints on a static method is not portable. No other restrictions exist from the perspective of this specification, however it is possible that technologies integrating with method validation impose further restrictions to methods for which a validation shall be applied. For instance certain integration technologies might require that methods to be validated must have `public` visibility and/or must not be `final`.

#### 5.6.2. Declaring parameter constraints

Parameter constraints are declared by putting constraint annotations on method or constructor parameters.

Example 5.20: Declaring parameter constraints
```
public class OrderService {

    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
```

Using constraint annotations, several preconditions are defined here. These preconditions which must be satisfied in order to legally invoke the methods of `OrderService` are:

* The `CreditCardProcessor` passed to the constructor must not be null.
* The customer code passed to the `placeOrder()` method must not be null and must be between 3 and 20 characters long.
* The `Item` passed to the `placeOrder()` method must not be null.
* The quantity value passed to the `placeOrder()` method must be 1 at least.

Note that declaring these constraints does not automatically cause their validation when the concerned methods are invoked. It’s the responsibility of an integration layer to trigger the validation of the constraints using a method interceptor, dynamic proxy or similar. See section [Triggering method validation](#validationapi-triggeringmethodvalidation) for more details.

| Tip | In order to use constraint annotations for method or constructor parameters, their element type must be `ElementType.PARAMETER`. In order to use constraint annotations for cross-parameter validation or on the return values of methods or constructors (see the following sections), their element type must be `ElementType.METHOD` respectively `ElementType.CONSTRUCTOR`. All built-in constraints support these element types and it is considered a best practice to do the same for custom constraints. |
| --- | --- |

##### 5.6.2.1. Cross-parameter constraints

Cross-parameter constraints allow to express constraints based on the value of several method parameters, similar to class-level constraints which are based on several properties of a given class. Cross-parameter constraints are declared by putting cross-parameter constraint annotations on methods or constructors as shown in the following example.

Example 5.21: Declaring cross-parameter constraints
```
public class CalendarService {

    @ConsistentDateParameters
    public void createEvent(
        String title,
        @NotNull Date startDate,
        @NotNull Date endDate) {
        [...]
    }
}
```

The cross-parameter constraint annotation expresses here that the given start date must be before the passed end date in order to legally invoke the `createEvent()` method. The example also shows that it is often useful to combine constraints directly placed on individual parameters (`e.g. @NotNull`) and cross-parameter constraints.

| Tip | Cross-parameter constraints as well as return value constraints are declared directly on a method or a constructor. To make it obvious for a reader that an annotation refers to the parameters of a method or constructor and not its return value, it is recommended to choose a name which clearly expresses this intention. |
| --- | --- |

It is not legal to declare a cross-parameter constraint on a method or constructor which has no parameters. A `ConstraintDeclarationException` is raised in this case.

Some constraints can target an executable’s return value as well as its array of parameters. They are known to be both generic and cross-parameter constraints. When using such a constraint on an executable to target the parameters, one must set `validationAppliesTo` if there is an ambiguity. The set of ambiguities is described in [validationAppliesTo](#constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto). Even without ambiguity, it is recommended to explicitly set `validationAppliesTo` to `ConstraintTarget.PARAMETERS` as it improves readability.

##### 5.6.2.2. Naming parameters

In case the validation of a parameter constraint fails, the concerned parameter needs to be identified in the resulting `ConstraintViolation` (see section [ConstraintViolation](#validationapi-constraintviolation)). Jakarta Bean Validation defines the `javax.validation.ParameterNameProvider` API to which the retrieval of parameter names is delegated:

Listing 5.6: `ParameterNameProvider` interface
```
/**
 * Provides names for method and constructor parameters.
 * <p>
 * Used by the Jakarta Bean Validation runtime when creating constraint violation
 * objects for violated method constraints.
 * <p>
 * Implementations must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterNameProvider {

    /**
     * Returns the names of the parameters of the given constructor.
     *
     * @param constructor the constructor for which the parameter names shall be
     *        retrieved; never {@code null}
     * @return a list containing the names of the parameters of the given
     *         constructor; may be empty but never {@code null}
     */
    List<String> getParameterNames(Constructor<?> constructor);

    /**
     * Returns the names of the parameters of the given method.
     *
     * @param method the method for which the parameter names shall be retrieved;
     *        never {@code null}
     * @return a list containing the names of the parameters of the given method;
     *         may be empty but never {@code null}
     */
    List<String> getParameterNames(Method method);
}
```

A conforming Jakarta Bean Validation implementation provides a default `ParameterNameProvider` implementation which returns parameter names as stored in the class file containing the validated executable, if present. A conforming implementation must either use the Java reflection API or ensure behavioral compatibility to using the reflection API in the following way:

* Obtain the method’s or constructor’s parameters via `java.lang.reflect.Executable.getParameters()`
* Obtain each parameter’s name via `java.lang.reflect.Parameter.getName()`

Depending on whether the class file of the validated executable contains parameter name information or not, the actual parameter names as provided in the executable’s definition will be returned or synthetic names in the form arg`PARAMETER_INDEX`, where `PARAMETER_INDEX` starts at 0 for the first parameter, e.g. `arg0`, `arg1` etc.

Jakarta Bean Validation providers and integrators are free to provide additional implementations (e.g. based on annotations specifying parameter names, debug symbols etc.). If a user wishes to use another parameter name provider than the default implementation, they may specify the provider to use with help of the bootstrap API (see [Bootstrapping](#validationapi-bootstrapping)) or the XML configuration (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)).

If an exception occurs during invocation of the `getParameterNames()` methods, this exception is wrapped into a `ValidationException` by the Jakarta Bean Validation engine.

#### 5.6.3. Declaring return value constraints

Return value constraints are declared by putting constraint annotations directly on a method or constructor.

Some constraints can target both the return value and the array of parameters of an executable. They are known to be both generic and cross-parameter constraints. When using such constraint on an executable to target the return value, one must set `validationAppliesTo` in case there is an ambiguity. The set of ambiguities is described in [validationAppliesTo](#constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto). Even without ambiguity, it is recommended to explicitly set `validationAppliesTo` to `ConstraintTarget.RETURN_VALUE` as it improves readability.

Example 5.22: Declaring return value constraints
```
public class OrderService {

    private CreditCardProcessor creditCardProcessor;

    @ValidOnlineOrderService
    public OrderService(OnlineCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @ValidBatchOrderService
    public OrderService(BatchCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull
    @Size(min=1)
    public Set<CreditCardProcessor> getCreditCardProcessors() { [...] }

    @NotNull
    @Future
    public Date getNextAvailableDeliveryDate() { [...] }
}
```

Here the following postconditions are defined which are guaranteed to the caller of the methods and constructors of the `OrderService` class:

* The newly created `OrderService` object returned by the first constructor satisfies the conditions of the custom `@ValidOnlineOrderService` constraint.
* The newly created `OrderService` object returned by the second constructor satisfies the conditions of the custom `@ValidBatchOrderService` constraint.
* The set of `CreditCardProcessor` objects returned by `getCreditCardProcessors()` will neither be null nor be empty.
* The `Date` object returned by `getNextAvailableDeliveryDate()` will not be null and will be in the future.

Like parameter constraints, these return value constraints are not per-se validated upon method invocation, but instead an integration layer invoking the validation is required.

#### 5.6.4. Marking parameters and return values for cascaded validation

The `@Valid` annotation is used to declare that a cascaded validation of the given method/constructor parameters or return values is performed by the Jakarta Bean Validation provider. When marked, the parameter or return value is considered a bean object to validate. The same rules as for standard object graph validation (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) apply, in particular

* null arguments and null return values are ignored
* The validation is recursive; that is, if validated parameter or return value objects have references marked with `@Valid` themselves, these references will also be validated
* Jakarta Bean Validation providers must guarantee the prevention of infinite loops during cascaded validation

Example 5.23: Marking parameters and return values for cascaded validation
```
public class OrderService {

    @NotNull @Valid
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull @Valid CreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull @Valid
    public Order getOrderByPk(@NotNull @Valid OrderPK orderPk) { [...] }

    @NotNull
    public Set<@Valid Order> getOrdersByCustomer(@NotNull @Valid CustomerPK customerPk) { [...] }
}
```

Here the following recursive validations will happen when validating the methods of the `OrderService` class:

* Validation of the constraints on the object passed for the `creditCardProcessor` parameter of the constructor
* Validation of the constraints on the newly created `OrderService` instance returned by the constructor, i.e. the `@NotNull` constraint on the field `creditCardProcessor` and the constraints on the referenced `CreditCardProcessor` instance (as the field is annotated with `@Valid`).
* Validation of the constraints on the object passed for the `orderPk` parameter and the returned `Order` object of the `getOrderByPk()` method
* Validation of the constraints on the object passed for the `customerPk` parameter and the constraints on each object contained within the returned `Set<Order>` of the `getOrdersByCustomer()` method

Again, solely marking parameters and return values for cascaded validation does not trigger the actual validation.

#### 5.6.5. Method constraints in inheritance hierarchies

When defining method constraints within inheritance hierarchies (that is, class inheritance by extending base classes and interface inheritance by implementing or extending interfaces) one has to obey the [Liskov substitution](https://en.wikipedia.org/wiki/Liskov_substitution_principle) principle which mandates that:

* a method’s preconditions (as represented by parameter constraints) must not be strengthened in sub types
* a method’s postconditions (as represented by return value constraints) must not be weakened in sub types

| Tip | Very informally speaking, the Liskov substitution principle says that where a given type T is used, it should be possible to replace T with a sub-type S of T ("Behavioral subtyping"). If S overrides/implements a method from T and S would strengthen the method’s preconditions (e.g. by adding parameter constraints) this principle would be violated as client code working correctly against T might fail when working against S. Also if S overrides/implements a method from T and S weakens the method’s postconditions this principle would be violated. However S may strengthen the method’s postconditions (by adding return value constraints), as client code working against T still will work against S. |
| --- | --- |

Therefore the following rules with respect to the definition of method level constraints in inheritance hierarchies apply:

* In sub types (be it sub classes/interfaces or interface implementations), no parameter constraints may be declared on overridden or implemented methods, nor may parameters be marked for cascaded validation. This would pose a strengthening of preconditions to be fulfilled by the caller.
* If a sub type overrides/implements a method originally defined in several parallel types of the hierarchy (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class), no parameter constraints may be declared for that method at all nor parameters be marked for cascaded validation. This again is to avoid an unexpected strengthening of preconditions to be fulfilled by the caller.
* In sub types (be it sub classes/interfaces or interface implementations), return value constraints may be declared on overridden or implemented methods and the return value may be marked for cascaded validation. Upon validation, all return value constraints of the method in question are validated, wherever they are declared in the hierarchy. This only poses possibly a strengthening but no weakening of the method’s postconditions guaranteed to the caller.
* One must not mark a method return value for cascaded validation more than once in a line of a class hierarchy. In other words, overriding methods on sub types (be it sub classes/interfaces or interface implementations) cannot mark the return value for cascaded validation if the return value has already been marked on the overridden method of the super type or interface.

Out of the box, a conforming Jakarta Bean Validation provider must throw a `ConstraintDeclarationException` when discovering that any of these rules are violated. In addition providers may implement alternative, potentially more liberal, approaches for handling constrained methods in inheritance hierarchies. Possible means for activating such alternative behavior include provider-specific configuration properties or annotations. Note that client code relying on such alternative behavior is not portable between Jakarta Bean Validation providers.

The above rules do not apply when validating constructor constraints as constructors do not override one another. Parameter and return value constraints can be applied to any constructor in the type hierarchy, but only the constraints defined directly on the validated constructor are evaluated.

##### 5.6.5.1. Examples

This sections provides some examples of illegal constraint definitions which violate the rules stated above in one way or another.

Example 5.24: Illegally declared parameter constraints on interface implementation
```
public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public class SimpleOrderService implements OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
```

The constraints in `SimpleOrderService` are illegal, as they strengthen the preconditions of the `placeOrder()` method as constituted by the interface `OrderService`.

Example 5.25: Illegally declared parameter constraints on sub class
```
public class OrderService {

    void placeOrder(String customerCode, Item item, int quantity) { [...] }
}

public class SimpleOrderService extends OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {
        [...]
    }
}
```

The constraints in `SimpleOrderService` are illegal, as they strengthen the preconditions of the `placeOrder()` method as constituted by the super class `OrderService`.

Example 5.26: Illegally declared parameter constraints on parallel types
```
public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);
}

public interface OrderPlacementService {

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity);
}

public class SimpleOrderService implements OrderService, OrderPlacementService {

    @Override
    public void placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}
```

Here the class `SimpleOrderService` implements the interfaces `OrderService` and `OrderPlacementService`, which themselves are unrelated to each other but both define a method `placeOrder()` with an identical signature. This hierarchy is illegal with respect to the parameter constraints as a client of `SimpleOrderService` would have to fulfill the constraints defined on the interface `OrderPlacementService` even if the client only expects `OrderService`.

Example 5.27: Correctly declared return value constraints on sub class
```
public class OrderService {

    Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}

public class SimpleOrderService extends OrderService {

    @Override
    @NotNull
    @Valid
    public Order placeOrder(String customerCode, Item item, int quantity) {
        [...]
    }
}
```

The return value constraints in `DefaultOrderService` are legal, as they strengthen the postconditions of the `placeOrder()` method as constituted by the super class `OrderService` but don’t weaken them.

### 5.7. Validation routine

For a given group, the validation routine applied on a given bean instance is expected to execute the following constraint validations in no particular order:

* for all *reachable* fields, execute all field level validations (including the ones expressed on superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* for all *reachable* getters, execute all getter level validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* execute all class level validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* for all *reachable* and *cascadable* associations, execute all cascading validations (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) including the ones expressed on interfaces and superclasses (see [Formal group definitions](#constraintdeclarationvalidationprocess-groupsequence-formaldefinition)). Note that group conversion can apply (see [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion)).

Reachable fields, getters and associations as well as cascadable associations are defined in [Traversable property](#constraintdeclarationvalidationprocess-validationroutine-traversable).

Note that this implies that a given validation constraint will not be processed more than once per validation per path. Some implementations might even process a single constraint only once across paths provided that they return the expected set of `ConstraintViolation`.

Unless ordered by group sequences, groups can be validated in no particular order. This implies that the validation routine can be run for several groups in the same pass.

The object validation routine is described as such. For each constraint declaration:

* determine for the constraint declaration, the appropriate `ConstraintValidator` to use (see [ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution)).
* execute the `isValid` operation (from the constraint validation implementation) on the appropriate data (see [Constraint validation implementation](#constraintsdefinitionimplementation-validationimplementation))
* if `isValid()` returns `true`, continue to the next constraint,
* if `isValid()` returns `false`, the Jakarta Bean Validation provider populates `ConstraintViolation` object(s) according to the rules defined in [Constraint validation implementation](#constraintsdefinitionimplementation-validationimplementation) and appends these objects to the list of constraint violations.

#### 5.7.1. Object graph validation

The `@Valid` annotation on a given association (i.e. object reference or collection, array, `Iterable` of objects), dictates the Jakarta Bean Validation implementation to apply recursively the Jakarta Bean Validation routine on (each of) the associated object(s). This mechanism is recursive: an associated object can itself contain cascaded references.

Null references are ignored.

To prevent infinite loops, the Jakarta Bean Validation implementation must ignore the cascading operation if the associated object instance has already been validated in the current navigation path (starting from the root object). See [Object graph limits](#example-oglimit) for an example. A navigation path is defined as a set of `@Valid` associations starting from the root object instance and reaching the associated instance. A given navigation path cannot contain the same instance multiple times (the complete validated object graph can though). See [Object graph limits](#example-oglimit) for an example.

| Note | This object graph navigation can lead to multiple validations of the same constraint and the same object instance but the set of constraint validation is deterministic and the algorithm prevents infinite loops. |
| --- | --- |

Example 5.28: Object graph limits
```
#assuming the following object graph

Order -(lines)→ Orderline1
Order -(lines)→ Orderline2
Orderline1 -(order)→ Order
Orderline2 -(order)→ Order
Order -(customer)→ User
Order -(shippingAddress)→ Address1
Order -(billingAddress)→ Address2
Address1 -(inhabitant)→ User
Address2 -(inhabitant)→ User
User -(addresses)→ Address1
User -(addresses)→ Address2

#validation branches are as followed
Order -(lines)→ Orderline1
  - order is ignored: Order is already present in the branch

Order -(lines)→ Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)→ User -(addresses)→ Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)→ User -(addresses)→ Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)→ Address1 -(inhabitant)→ User
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)→ Address1 -(inhabitant)→ User -(addresses)→ Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)→ Address2 -(inhabitant)→ User
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)→ Address2 -(inhabitant)→ User -(addresses)→ Address1
  - inhabitant is ignored: User is already present in the branch
```

The `ConstraintViolation` objects are built when a failing constraint on an associated object is found. They reflect the path to reach the object from the root validated object (See [ConstraintViolation](#validationapi-constraintviolation)).

`@Valid` is an orthogonal concept to the notion of group. If two groups are in sequence, the first group must pass for all associated objects before the second group is evaluated. Note however that the `Default` group sequence overriding is local to the class it is defined on and is not propagated to the associated objects. The following example illustrates this:

Example 5.29: Class Driver with redefined default group
```
@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}
```

Example 5.30: Class Car with redefined default group
```
@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTrue(groups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}
```

Example 5.31: Defining a group sequence
```
@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}
```

Example 5.32: Group sequence overriding is not propagated to associated objects
```
Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);

Set<ConstraintViolation<Driver>> violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;
```

The default group sequence is redefined for the `Driver` as well as `Car`. When the default group is requested via `validator.validate( driver )` the group `Minimal` gets validated in class `Driver`. The constraint will fail since the driver’s age in the example is only 16. The constraint on `passedDrivingTest` will not be evaluated due to the redefined default sequence of `Driver`. However, there is one more constraint violation, namely the `@NotNull` on `Car.type`. The reason for this is that the group `Default` gets propagated to `Car` (not `Minimal`). Class `Driver` defines its own group sequence which means that `only @NotNull` on `type` gets evaluated.

In the second call to `validate` the group `SequencedGroups` is requested which defines a sequence of `Minimal` followed by `Later`. In this case there is only one constraint violation. Again `@Min` on `age` fails, but in this case the group `Minimal` gets propagated to `Car` which does not have any constraints defined against this group. Constraints belonging to the group `Later` won’t get validated until all constraints belonging to `Minimal` pass.

#### 5.7.2. Method and constructor validation

For a given group, the validation routine applied to validate parameters of a method or constructor is expected to execute the following constraint validations in no particular order:

* execute all parameter validations (in case of overriding method validation, including the ones expressed on overridden methods of the interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* execute all cross parameter validations (in case of overriding method validation, including the ones expressed on overridden methods of the interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* for all parameters marked for cascaded validation, execute all cascading validations (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)), in case of overriding method validation including the ones expressed on overridden methods of the interfaces and superclasses (see [Formal group definitions](#constraintdeclarationvalidationprocess-groupsequence-formaldefinition)). Note that group conversion can apply (see [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion)).

For a given group, the validation routine applied to validate the return value of a method or constructor is expected to execute the following constraint validations in no particular order:

* execute all return value validations (including the ones expressed on interfaces and superclasses) matching the targeted group unless the given validation constraint has already been processed during this validation routine for a given navigation path (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) as part of a previous group match.
* if the return value is marked for cascaded validation, execute all cascading validations (see [Object graph validation](#constraintdeclarationvalidationprocess-validationroutine-graphvalidation)) including the ones expressed on interfaces and superclasses (see [Formal group definitions](#constraintdeclarationvalidationprocess-groupsequence-formaldefinition)). Note that group conversion can apply (see [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion)).

Note that this implies that a given validation constraint will not be processed more than once per validation per path. Some implementations might even process a single constraint only once across paths provided that they return the expected set of `ConstraintViolation`.

Unless ordered by group sequences, groups can be validated in no particular order. This implies that the validation routine can be run for several groups in the same pass.

The object validation routine is as defined in described in [Validation routine](#constraintdeclarationvalidationprocess-validationroutine).

#### 5.7.3. Traversable property

In some cases, the state of some properties should not be accessed. For example, if a property loaded by a Jakarta Persistence provider is a lazy property or a lazy association, accessing its state would trigger a load from the database. An undesired behavior.

Jakarta Bean Validation offers a way to control which property can and cannot be accessed via the `TraversableResolver.isReachable`() contract.

Likewise, it is sometimes undesirable to cascade validation despite the use of `@Valid`. Jakarta Persistence 2 for example does not cascade to associated entities during flush. You can control this behavior by implementing `TraversableResolver.isCascadable()`.

Listing 5.7: `TraversableResolver` interface
```
/**
 * Contract determining if a property can be accessed by the Jakarta Bean Validation provider.
 * This contract is called for each property that is being either validated or cascaded.
 * <p>
 * A traversable resolver implementation must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determines if the Jakarta Bean Validation provider is allowed to reach the property state.
     *
     * @param traversableObject object hosting {@code traversableProperty}
     *        or {@code null} if {@code validateValue} is called
     * @param traversableProperty the traversable property
     * @param rootBeanType type of the root object passed to the Validator
     *        or hosting the method or constructor validated
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validation)
     * @param elementType either {@code FIELD} or {@code METHOD}
     * @return {@code true} if the Jakarta Bean Validation provider is allowed to
     *         reach the property state, {@code false} otherwise
     */
    boolean isReachable(Object traversableObject,
                        Node traversableProperty,
                        Class<?> rootBeanType,
                        Path pathToTraversableObject,
                        ElementType elementType);

    /**
     * Determines if the Jakarta Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as {@code @Valid}.
     * <p>
     * Note that this method is called only if
     * {@link #isReachable(Object, javax.validation.Path.Node, Class, Path, java.lang.annotation.ElementType)}
     * returns {@code true} for the same set of arguments and if the property
     * is marked as {@link Valid}.
     *
     * @param traversableObject object hosting {@code traversableProperty}
     *        or {@code null} if {@code validateValue} is called
     * @param traversableProperty the traversable property
     * @param rootBeanType type of the root object passed to the Validator
     *        or hosting the method or constructor validated
     * @param pathToTraversableObject path from the root object to
     *        {@code traversableObject}
     *        (using the path specification defined by Bean Validation)
     * @param elementType either {@code FIELD} or {@code METHOD}
     * @return {@code true} if the Jakarta Bean Validation provider is allowed to
     *         cascade validation, {@code false} otherwise
     */
    boolean isCascadable(Object traversableObject,
                         Node traversableProperty,
                         Class<?> rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);
}
```

`isReachable()` is called for every property about to be accessed either for validation or for cascading. A property is *reachable* if this method returns `true`.

`isCascadable()` is called for every property about to be cascaded (i.e. marked as `@Valid`). A property is *cascadable* if it is reachable and if the `isCascadable` method returns `true`.

| Note | `isCascadable()` for a given property is only called if `isReachable()` returns `true`. In other words, `isReachable()` is always called before `isCascadable()` for a given property. |
| --- | --- |

`traversableObject` is the object instance being evaluated. `null` if the check is triggered as part of a `validateValue()` call.

`traversableProperty` is the `Node` representing the property hosted by the `traversableObject` being considered for traversal. The name of a property is defined in [Field and property validation](#constraintdeclarationvalidationprocess-requirements-propertyvalidation).

`rootBeanType` is the class of the root being validated, i.e. either the type of the object passed to the `validate` method or the type declaring the validated method/constructor in case of method validation.

`pathToTraversableObject` is the `Path` from the `rootBeanType` down to the `traversableObject`. If the root object is `traversableObject`, `pathToTraversableObject` is composed of a single Node whose name is `null`. The path is described following the conventions described in [ConstraintViolation](#validationapi-constraintviolation) (`getPropertyPath`).

`elementType` is the `java.lang.annotation.ElementType` the annotation is placed on. It can be either `FIELD` or `METHOD`. Any other value is not expected.

The Jakarta Bean Validation provider must not access the state of a property, nor validate its constraints if the property is not traversable. A property is traversable if `TraversableResolver` returns `true` for this property.

If an exception occurs when the `TraversableResolver` is called, the exception is wrapped into a `ValidationException`.

The following elements are not passed through the traversable resolver filter:

* the bean instance validated
* the method and constructor parameter values being validated
* the method and constructor return value being validated

But the properties of these elements (if validated) are. In this case the complete path is provided via `pathToTraversableObject`.

The traversable resolver used by default by a Jakarta Bean Validation provider behaves as followed:

* if Jakarta Persistence is available in the runtime environment, a property is considered reachable if Jakarta Persistence considers the property as loaded. A typical implementation will use `Persistence.getPersistenceUtil().isLoaded(Object, String)` to implement such contract.
* if Jakarta Persistence is not available in the runtime environment, all properties are considered reachable.
* all properties are considered cascadable.

An example implementation of such a resolver is shown in [Jakarta Persistence aware TraversableResolver](#constraintdeclarationvalidationprocess-validationroutine-traversable-jparesolver).

Example 5.33: Jakarta Persistence aware TraversableResolver
```
public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class<?> rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded(
                        traversableObject,
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject,
                               Path.Node traversableProperty,
                               Class<?> rootBeanType,
                               Path pathToTraversableObject,
                               ElementType elementType) {
        return true;
    }
}
```

See [Bootstrapping](#validationapi-bootstrapping) to learn how to pass a custom `TraversableResolver`.

##### 5.7.3.1. Examples

The following example assumes the object graph defined in [Definitions used in the example](#example-ognav-definitions) and assumes the validation operation is applied on an address object.

Example 5.34: Definitions used in the example
```
public class Country {
    @NotNull
    private String name;
    @Size(max=2)
    private String ISO2Code;
    @Size(max=3)
    private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}
```

When the Jakarta Bean Validation provider is about to check constraints of `ISO3Code`, it calls the `TraversableResolver.isReachable()` method to ensure that the `ISO3Code` property is reachable with the following parameter values:

* `traversableObject`: country. The instance returned by `address.getCountry()`.
* `traversableProperty`: a `PropertyNode` whose name is "ISO3Code". Represents the property of `traversableObject` being verified.
* `rootBeanType`: `Address.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a `Path` containing a single `PropertyNode` whose name is "country". The path from address to the country instance.
* `elementType`: `ElementType.FIELD`. The ISO3Code property is annotated on its field.

When the Jakarta Bean Validation provider is about to cascade validation on `country` (`Address` object), it calls the `TraversableResolver.isReachable()` method to ensure that the `country` property is reachable and if this method returns `true`, it calls `TraversableResolver.isCascadable()` with the following parameter values:

* `traversableObject`: address. The address instance.
* `traversableProperty`: a `PropertyNode` whose name is "country". Represents the property of `traversableObject` being verified.
* `rootBeanType`: `Address.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a `Path` containing a single `BeanNode` whose name is `null`.
* `elementType`: `ElementType.FIELD`. The country property is annotated on its field.

The following example shows invocations of the `TraversableResolver` as to be performed by the Jakarta Bean Validation provider during method validation. The example is based on the object graph defined in [Definitions used in the example](#example-ognav-definitions) and the `AddressService` class shown in [Examplary class `AddressService`](#example-ognav-definitions-methodvalidation). It assumes that a call of `persistAddress()` is subject to method parameter validation.

Example 5.35: Examplary class `AddressService`
```
public class AddressService {
    public void persistAddress(@NotNull @Valid Address address) {
        [...]
    }
}
```

When the Jakarta Bean Validation provider is about to validate the `@NotNull` constraint on the `address` parameter, no call to `isReachable()` is expected, since parameters are assumed to always be reachable. Similarly, no call to `isCascadable()` is expected when performing cascaded validation of the `address` parameter, since parameters are assumed to always be cascadable.

When the Jakarta Bean Validation provider is about to validate constraints on the field `addressline1` of the passed `Address` object, it calls the `isReachable()` method to ensure that the property is reachable with the following parameter values:

* `traversableObject`: address. The instance passed to `persistAddress()`.
* `traversableProperty`: a `PropertyNode` whose name is "addressline1". Represents the property of `traversableObject` being verified.
* `rootBeanType`: `AddressService.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a `Path` comprising a `MethodNode` (named "persistService") and a `ParameterNode` (with parameter index 0). The path from `AddressService` to the `Address` instance.
* `elementType`: `ElementType.FIELD`. The `addressline1` property is annotated on its field.

When the Jakarta Bean Validation provider is about to perform a cascaded validation of the `country` property of the passed `Address` object, it calls the `isReachable()` method to ensure that the property is reachable. If this method returns `true`, it calls `TraversableResolver.isCascadable()` with the following parameter values:

* `traversableObject`: address. The instance passed to `persistAddress()`.
* `traversableProperty`: a `PropertyNode` whose name is "country". Represents the property of `traversableObject` being verified.
* `rootBeanType`: `AddressService.class`. The type of the root object being validated.
* `pathtoTraversableObject`: a `Path` comprising a `MethodNode` (named "persistService") and a `ParameterNode` (with parameter index 0). The path from `AddressService` to the `Address` instance.
* `elementType`: `ElementType.FIELD`. The `country` property is annotated on its field.

#### 5.7.4. ConstraintValidator resolution algorithm

A constraint is associated to one or more `ConstraintValidator` implementations. Each `ConstraintValidator<A, T>` accepts the type `T`. The `ConstraintValidator` executed depends on the type hosting the constraint. For a given constraint evaluation, a single `ConstraintValidator` is considered.

The list of `ConstraintValidator`s can contain at most one which targets cross-parameter. If the constraint targets the parameters of an executable either implicitly or by the use of `validationAppliesTo` in the constraint - see [validationAppliesTo](#constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto), then the cross-parameter `ConstraintValidator` is used. If none is present, a `ConstraintDefinitionException` is raised. If more than one cross-parameter `ConstraintValidator` is present, a `ConstraintDefinitionException` is raised.

If the constraint is a generic constraint, the following rules apply:

* If the constraint declaration is hosted on a class or an interface, the targeted type is the class or the interface.
* If the constraint is hosted on a class attribute, the type of the attribute is the targeted type.
* If the constraint is hosted on a method (getter or non-getter) or constructor, the return type is the targeted type.
* If the constraint is hosted on a method or constructor parameter, the parameter type is the targeted type.
* If the constraint is hosted on a type argument of a parameterized type (i.e. a container element constraint, see [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints)), the type argument’s type is the targeted type.
* If the constraint is subject to implicit unwrapping (see [Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)) and the applicable value extractor is defined for a generic type (e.g. `javafx.beans.value.ObservableValue`), the targeted type is the type captured for the type parameter handled by the value extractor (e.g. `String` if the constraint is placed on a `StringProperty`).
* If the constraint is subject to implicit unwrapping and the applicable value extractor is defined for a non-generic type, the targeted type is the type defined by the extractor via `@ExtractedValue#type()` (e.g. `Integer` if the constraint is placed on a `java.util.OptionalInt`).

In other words, the resolution algorithm considers the type as defined in the source code and not the runtime type of the value.

The rules written below describe formally the following statement: the `ConstraintValidator` chosen to validate the generic constraint on a declared type `T` is the one where the `ConstraintValidator` targets the annotated element, where the type supported by the `ConstraintValidator` is a supertype of `T` and where there is no other `ConstraintValidator` whose supported type is a supertype of `T` and not a supertype of the chosen `ConstraintValidator` supported type.

When validating a generic constraint `A` placed on a target declaring the type `T`, the following resolution rules apply:

* Only `ConstraintValidator` implementations targeting annotated elements are considered.
* Primitive types are considered equivalent to their respective primitive wrapper class.
* A `ConstraintValidator<A, U>` is said to be *compliant* with `T` if `T` is a subtype of `U` (according to the [Java Language Specification, Java SE 8 Edition, chapter 4.10, "Subtyping"](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10)). Note that `T` is a subtype of `U` if `T` = `U`.
* If no `ConstraintValidator` compliant with `T` is found among the `ConstraintValidator`s listed by the constraint `A`, an `UnexpectedTypeException` is raised.
* A `ConstraintValidator<A, U>` compliant with `T` is considered *strictly more specific* than a `ConstraintValidator<A, V>` compliant with `T` if `U` is a strict subtype of `V`. `U` is a strict subtype of `V` if `U` is a subtype of `V` and `U` != `V` (according to the [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10)).
* A `ConstraintValidator<A, U>` compliant with `T` is considered maximally specific if no other `ConstraintValidator<A, V>` compliant with `T` is strictly more specific than `ConstraintValidator<A, U>`.
* If more than one maximally specific `ConstraintValidator` is found, an `UnexpectedTypeException` is raised.

| Note | While the Java compiler itself cannot determine if a constraint declaration will lead to a `UnexpectedTypeException`, rules can be statically checked. A tool such as an IDE or an annotation processor can apply these rules and prevent compilation in case of ambiguity. The specification encourages Jakarta Bean Validation providers to provide such a tool to their users. |
| --- | --- |

Let’s see a couple of declarations and their respective `ConstraintValidator` resolution. Assuming the definitions shown in [ConstraintValidator and type resolution](#example-constraintvalidator-resolution):

Example 5.36: ConstraintValidator and type resolution
```
[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { [...] }

public class SizeValidatorForCollection implements ConstraintValidator<Size, Collection> {
    [...]
}
public class SizeValidatorForSet implements ConstraintValidator<Size, Set> {
    [...]
}
public class SizeValidatorForSerializable implements ConstraintValidator<Size, Serializable> {
    [...]
}

public interface SerializableCollection extends Serializable, Collection {
}
```

The resolutions shown in [Resolution of ConstraintValidator for various constraints declarations](#table-constraintvalidator-resolution) occur.

Table 5.1: Resolution of ConstraintValidator for various constraints declarations

| Declaration | Resolution |
| --- | --- |
| `@Size Collection getAddresses() { […​] }` | `SizeValidatorForCollection`: direct match |
| `@Size Collection<?> getAddresses() { […​] }` | `SizeValidatorForCollection`: `Collection` is a direct supertype of `Collection<?>` |
| `@Size Collection<Address> getAddresses() { […​] }` | `SizeValidatorForCollection`: `Collection` is a direct supertype of `Collection<Address>` |
| `@Size Set<Address> getAddresses() { […​] }` | `SizeValidatorForSet`: direct supertype of `Set<Address>` |
| `@Size SortedSet<Address> getAddresses() { […​] }` | `SizeValidatorForSet`: `Set` is the closest supertype of `SortedSet<Address>` |
| `@Size SerializableCollection getAddresses() { […​] }` | `UnexpectedTypeException`: `SerializableCollection` is a subtype of both `Collection` and `Serializable` and neither `Collection` nor `Serializable` are subtypes of each other. |
| `@Size String getName() { […​] }` | `UnexpectedTypeException`: none of the `ConstraintValidator` types are supertypes of `String`. |

#### 5.7.5. ValueExtractor resolution

When detecting a container element constraint or a container element marked with `@Valid`, a value extractor must be determined so that the elements can be obtained from that container.

A value extractor handles one container type and - in the case of a generic container type - one type parameter of that container type.
The applicable extractor is identified based on the container type and - in the case of a generic container type - the type argument hosting the container element constraint or `@Valid`.

Exactly one value extractor must be identified when processing a container element constraint or container element marked with `@Valid`.

##### 5.7.5.1. Registering ValueExtractor implementations

Value extractors can be registered with the validation engine in the following ways (in increasing order of priority):

* Provided by the validation engine itself (see [Built-in value extractors](#valueextractordefinition-builtinvalueextractors))
* Via the Java [service loader](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html) mechanism; for this the file *META-INF/services/javax.validation.valueextraction.ValueExtractor* must be provided,
  with the fully-qualified name(s) of one or more extractor implementations as its contents.
  It is undefined which value extractor will be selected if multiple extractors for the same type and type parameter are registered via the service loader mechanism.
* By specifying the fully-qualified class name of one or several extractors in `META-INF/validation.xml` (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)). Not more than one extractor for the same type and type parameter may be given.
* By invoking the method `Configuration#addValueExtractor(ValueExtractor<?>)` (to apply it at the validator factory level). Not more than one extractor for the same type and type parameter may be passed.
* By invoking the method `ValidatorContext#addValueExtractor(ValueExtractor<?>)` (to apply it for a single `Validator` instance). Not more than one extractor for the same type and type parameter may be passed.

A value extractor for a given type and type parameter specified at a higher priority overrides any other extractors for the same type and type parameter given at lower priorities.
If e.g. a value extractor defined as `class MyListValueExtractor implements ValueExtractor<List<@ExtractedValue ?>> { …​ }` is given via `ValidatorContext#addValueExtractor(ValueExtractor<?>)`,
it will take precedence over any other value extractor implementing `List<@ExtractedValue ?>` given via `Configuration#addValueExtractor(ValueExtractor<?>)`,
*META-INF/validation.xml* or the service loader mechanism as well as the built-in extractor for `List` values.

##### 5.7.5.2. ValueExtractor resolution algorithm for container element constraints

For a container with the declared type `C` whose element type is hosting a constraint, the following resolution rules apply for identifying the value extractor:

* A `ValueExtractor<T>` is said to be *type-compliant* with `C`, if `C` is a subtype of `T`
  (according to the [Java Language Specification, Java SE 8 Edition, chapter 4.10, "Subtyping"](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.10)).
  Note that `C` is a subtype of `T` if `C` = `T`.
* A `ValueExtractor` implementation is said to be *container-element-compliant* with `C`, if `C` is a generic container type and the value extractor implementation handles a type parameter that maps to the constrained type argument.
* If no `ValueExtractor` type-compliant and container-element-compliant with `C` is found among the available value extractors, a `ConstraintDeclarationException` is raised.
* A `ValueExtractor<U>` type-compliant with `C` is considered *strictly more specific* than a `ValueExtractor<V>` compliant with `C` if `U` is a strict subtype of `V`.
  `U` is a strict subtype of `V` if `U` is a subtype of `V` and `U` != `V`.
* A `ValueExtractor<U>` type-compliant with `C` is considered maximally specific if no other `ValueExtractor<V>` type-compliant with `C` is strictly more specific than `ValueExtractor<U>`.
* If more than one maximally specific and container-element-compliant `ValueExtractor` is found, a `ConstraintDeclarationException` is raised.

| Note | Implementation note  Extractor retrieval for container element constraints is based on the declared type of constrained elements, hence it is recommended that implementations perform the resolution once and then cache the value extractor for a given constraint. |
| --- | --- |

##### 5.7.5.3. ValueExtractor resolution algorithm for cascaded validation

For a container with the declared type `C` and the runtime type `C'` whose element type is marked for cascaded validation, the following resolution rules apply for identifying the value extractor:

* A `ValueExtractor<T>` is said to be *type-compliant* with `C'`, if `C'` is a subtype of `T`.
  Note that `C'` is a subtype of `T` if `C'` = `T`.
* A `ValueExtractor` implementation is said to be *container-element-compliant* with `C`, if it handles a type parameter that maps to the type argument marked with `@Valid`.
* If no `ValueExtractor` type-compliant with `C'` and container-element-compliant with `C` is found among the available value extractors, a `ConstraintDeclarationException` is raised.
* A `ValueExtractor<U>` type-compliant with `C'` is considered *strictly more specific* than a `ValueExtractor<V>` compliant with `C'` if `U` is a strict subtype of `V`.
  `U` is a strict subtype of `V` if `U` is a subtype of `V` and `U` != `V`.
* A `ValueExtractor<U>` type-compliant with `C'` is considered maximally specific if no other `ValueExtractor<V>` type-compliant with `C'` is strictly more specific than `ValueExtractor<U>`.
* If more than one maximally specific and container-element-compliant `ValueExtractor` is found, a `ConstraintDeclarationException` is raised.

| Note | Implementation note  Extractor retrieval for cascaded validation is based on the runtime type of the container hosting `@Valid` (this is to be consistent with the semantics of property paths for cascaded validation), hence it is not possible to perform the extractor resolution only once per usage of `@Valid` and cache the result. |
| --- | --- |

##### 5.7.5.4. ValueExtractor resolution algorithm for applying container-level constraints to container elements

When detecting a constraint given as a *declaration annotation* and not as a *type annotation* (i.e. it is given on field, parameter etc. and not given on a type argument of a parameterized type), the applicable value extractor, if any, is determined as follows:

* If the constraint carries the `Unwrapping.Skip` payload, no value extractor is applied.
* If the constraint carries the `Unwrapping.Unwrap` payload and there is exactly one maximally-specific type-compliant value extractor, this extractor is applied;
  if no type-compliant extractor or multiple maximally-specific type-compliant extractors exist, a `ConstraintDeclarationException` is raised.
* If the constraint carries neither the `Unwrapping.Unwrap` nor the `Unwrapping.Skip` payload:

  + If there is exactly one maximally-specific type-compliant value extractor and this extractor is marked with `@UnwrapByDefault`, this extractor is applied;
  + Otherwise, no value extractor is applied.

##### 5.7.5.5. Examples

Let’s consider a couple of value extractor definitions and their respective `ValueExtractor` resolution against container element constraint declarations:

Example 5.37: `ValueExtractor` resolution
```
public interface ConcurrentList<T> {
    [...]
}

public class MyList<T> implements List<T>, ConcurrentList<T> {
    [...]
}

public interface Table<R, C, V> {
    [...]
}

interface ConfusingMap<K, V> extends Map<V, K> {
    [...]
}

interface SingleTypeMap<T> extends Map<T, T> {
    [...]
}

interface StringMap extends Map<String, String> {
    [...]
}

interface Property<T> {
    [...]
}

class StringProperty implements Property<String> {
    [...]
}

public class IterableValueExtractor implements ValueExtractor<Iterable<@ExtractedValue ?>> {
    [...]
}

public class ListValueExtractor implements ValueExtractor<List<@ExtractedValue ?>> {
    [...]
}

public class ConcurrentListValueExtractor implements ValueExtractor<
        ConcurrentList<@ExtractedValue ?>> {

    [...]
}

public class MapKeyExtractor implements ValueExtractor<Map<@ExtractedValue ?, ?>> {
    [...]
}

public class MapValueExtractor implements ValueExtractor<Map<?, @ExtractedValue ?>> {
    [...]
}

public class TableValueExtractor implements ValueExtractor<Table<?, ?, @ExtractedValue ?>> {
    [...]
}

@UnwrapByDefault
public class PropertyValueExtractor implements ValueExtractor<Property<@ExtractedValue ?>> {
    [...]
}

@UnwrapByDefault
public class OptionalIntValueExtractor implements ValueExtractor<
        @ExtractedValue(type = Integer.class) OptionalInt> {

    [...]
}
```

The following value extractor resolutions occur:

Table 5.2: Resolution of `ValueExtractor` for various container element constraints

| Declaration | Resolution |
| --- | --- |
| `List<@Email String> emails` | `ListValueExtractor`; strictly more specific than `IterableValueExtractor` |
| `Iterable<@Valid Address> addresses = new ArrayList<>()` | `ListValueExtractor` (the runtime type `ArrayList` is used for resolving value extractors for cascaded validation) |
| `Map<@Email String, String> emails` | `MapKeyExtractor`; equally specific as `MapValueExtractor`, but the latter isn’t container-element-compliant |
| `ConfusingMap<@Email String, String> map` | `MapValueExtractor`; the constrained type argument maps to the type parameter `V` of `Map` |
| `@Email StringProperty` | `PropertyValueExtractor`; the extractor is marked with `@UnwrapByDefault`, i.e. implicit unwrapping is performed; `String` will be used for validator resolution as that’s the type captured for the type parameter handled by the applied value extractor |
| `@Min(1) OptionalInt` | `OptionalIntValueExtractor`; the extractor is marked with `@UnwrapByDefault`, i.e. implicit unwrapping is performed; `Integer` as given via `@ExtractedValue#type()` will be used for validator resolution |
| `Optional<@Email String> getEmail() {…​}` | `ConstraintDeclarationException`; no compliant extractor exists |
| `Table<@Min(1) String, String, String> table` | `ConstraintDeclarationException`; `TableValueExtractor` is type-compliant but not container-element-compliant |
| `MyList<@Email String> emails` | `ConstraintDeclarationException`; `ListValueExtractor` and `ConcurrentListValueExtractor` are equally specific |
| `SingleTypeMap<@NotEmpty String> map` | `ConstraintDeclarationException`; `MapKeyExtractor` and `MapValueExtractor` are equally specific and both container-element-compliant |
| `@NotEmpty(payload=Unwrapping.Unwrap.class) StringMap` | `ConstraintDeclarationException`; more than one maximally-specific extractor is found (`MapKeyExtractor` and `MapValueExtractor`) |

### 5.8. Examples

The first example demonstrates how beans, fields and getters are annotated to express some constraints.

Example 5.38: Place constraint declarations on the element to validate
```
@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}
```

During the validation routine execution on an `Address` object,

* `addressline1` field value is passed to the `@NotNull` as well as `@Size` constraint validation implementations.
* `addressline2` field value is passed to the `@Size` constraint validation implementation.
* `getCity` value is passed to the `@Size` and `@NotNull` constraint validation implementations.
* `@ZipCodeCoherenceChecker` is a constraint whose validation implementation’s `isValid` method receives the `Address` object.

The second example demonstrates object graph validation.

Example 5.39: Define object graph validation
```
public class Country {
    @NotNull
    private String name;
    @Size(max=2)
    private String ISO2Code;
    @Size(max=3)
    private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @NotNull @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}
```

During the validation routine execution on an `Address` object, constraints on `addressLine1`, `addressLine2`, `zipCode`, `getCity` and `country` are processed as well as the validation of the `Country` object itself, more specifically `country.name` is checked for `@NotNull`, `ISO2Code` and `ISO3Code` are checked for `@Size`.

Assuming that `@NonEmpty` is defined as such:

```
@Documented
@NotNull
@Size(min = 1)
@ReportAsSingleViolation
@Constraint(validatedBy = NonEmpty.NonEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface NonEmpty {

    String message() default "{com.acme.constraint.NonEmpty.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NonEmpty[] value();
    }

    class NonEmptyValidator implements ConstraintValidator<NonEmpty, String> {

        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}
```

The third example demonstrates superclass, inheritance and composite constraints.

Example 5.40: Use inheritance, constraints on superclasses and composite constraints
```
public interface Person {
    @NonEmpty
    String getFirstName();

    String getMiddleName();

    @NonEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}
```

When validating a `PreferredGuest` the following constraints are processed:

* `@NonEmpty`, `@NotNull` and `@Size(min=1)` on `firstName`
* `@NonEmpty`, `@NotNull` and `@Size(min=1)` on `lastName`
* `@NotNull` on `customerId`, `@Password` on `password`
* `@CreditCard` on `guestCreditCardNumber`

When validating `CommonGuest`, the following constraints are processed:

* `@NonEmpty`, `@NotNull` and `@Size(min=1)` on `firstName`
* `@NonEmpty`, `@NotNull` and `@Size(min=1)` on `lastName`
* `@NotNull` on `customerId`, `@Password` on `password`

The fourth example demonstrates the influence of group sequence.

Example 5.41: Use groups and group sequence to define constraint ordering
```
@GroupSequence({First.class, Second.class, Last.class})
public interface Complete {}

public class Book {
    @NonEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NonEmpty(groups=Last.class)
    private String firstName;

    @NonEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}
```

Assuming the validation of the `Complete` group on the following book instance:

```
Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );
```

the validation routine will return the following failure:

* `@NotNull` failure (from `@NonEmpty`) on the `title` field

As both `title` and `author.lastname` are checked as part of the `First` group. If the instance is updated:

```
book.setTitle( "Les fleurs du mal" );
author.setCompany( "Some random publisher with a very very very long name" );
```

the validation routine will return the following failures:

* `author.firstName` fails to pass the `@Size(min=1)` (from `@NonEmpty`) constraint
* `author.company` fails to pass the `@Size` constraint

As the `First` and `Second` groups pass without failure, the `Last` group is going through validation.

## 6. Validation APIs

The default package for the Jakarta Bean Validation APIs is `javax.validation`.

### 6.1. Validator API

The main Jakarta Bean Validation API is the `javax.validation.Validator` interface.

A `Validator` instance is able to validate instances of beans and their associated objects if any. It is recommended to leave the caching of `Validator` instances to the `ValidatorFactory`. `Validator` implementations must be thread-safe.

Listing 6.1: `Validator` interface
```
/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    /**
     * Validates all constraints on {@code object}.
     *
     * @param object object to validate
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @param <T> the type of the object to validate
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if object is {@code null}
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups);

    /**
     * Validates all constraints placed on the property of {@code object}
     * named {@code propertyName}.
     *
     * @param object object to validate
     * @param propertyName property to validate (i.e. field and getter constraints)
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @param <T> the type of the object to validate
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if {@code object} is {@code null},
     *         if {@code propertyName} is {@code null}, empty or not a valid object property
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    <T> Set<ConstraintViolation<T>> validateProperty(T object,
                                                     String propertyName,
                                                     Class<?>... groups);

    /**
     * Validates all constraints placed on the property named {@code propertyName}
     * of the class {@code beanType} would the property value be {@code value}.
     * <p>
     * {@link ConstraintViolation} objects return {@code null} for
     * {@link ConstraintViolation#getRootBean()} and
     * {@link ConstraintViolation#getLeafBean()}.
     *
     * @param beanType the bean type
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default}).
     * @param <T> the type of the object to validate
     * @return constraint violations or an empty set if none
     * @throws IllegalArgumentException if {@code beanType} is {@code null},
     *         if {@code propertyName} is {@code null}, empty or not a valid object property
     *         or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *         during the validation process
     */
    <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType,
                                                  String propertyName,
                                                  Object value,
                                                  Class<?>... groups);

    /**
     * Returns the descriptor object describing bean constraints.
     * <p>
     * The returned object (and associated objects including
     * {@link ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     * @return the bean descriptor for the specified class
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *         during the metadata discovery or if some
     *         constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class<?> clazz);

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs.
     * <p>
     * If the Jakarta Bean Validation provider implementation does not support
     * the specified class, {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @param <T> the type of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     */
    <T> T unwrap(Class<T> type);

    /**
     * Returns the contract for validating parameters and return values of methods
     * and constructors.
     *
     * @return contract for method and constructor validation
     *
     * @since 1.1
     */
    ExecutableValidator forExecutables();
}
```

The methods `validate()`, `validateProperty()` and `validateValue()` are used for the validation of Java beans respectively single bean properties. See the next section for more details.

`forExecutables()` provides access to the contract for validating method and constructor parameters and return values. The individual methods for method and constructor validation are described in [Methods for validating method and constructor constraints](#validationapi-validatorapi-methodlevelvalidationmethods).

`getConstraintsForClass()` returns constraint-related metadata for given types and is described in detail in [Constraint metadata request APIs](#constraintmetadata).

`unwrap()` is provided as a way to access objects of a given type specific to a Jakarta Bean Validation provider typically as a complement to the `Validator` contract. Using this method makes your code non portable.

Example 6.1: Using unwrap to access a provider specific contract
```
//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration( [...] );
```

#### 6.1.1. Validation methods

`<T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups)` is used to validate a given object. This method implements the logic described in [Validation routine](#constraintdeclarationvalidationprocess-validationroutine). An `IllegalArgumentException` is thrown when null is passed for the `object` parameter or the varargs `groups` parameter. A `Set` containing all `ConstraintViolation` objects representing the failing constraints is returned, an empty `Set` is returned otherwise.

`<T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, Class<?>... groups)` validates a given field or property of an object. An `IllegalArgumentException` is thrown when `validateProperty()` is called and `object` is null or `propertyName` is null, empty or invalid or null is passed to the varargs `groups` parameter. The property name is the JavaBeans property name (as defined by the JavaBeans `Introspector` class). This method implements the logic described in [Validation routine](#constraintdeclarationvalidationprocess-validationroutine) but only to the given property. `@Valid` is not honored by this method. This method is useful for partial object validation.

`<T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value, Class<?>... groups)` validates the property referenced by `propertyName` present on `beanType` or any of its superclasses, if the property value were `value`. An `IllegalArgumentException` is thrown when `validateValue()` is called and `beanType` is null or `propertyName` is null, empty or invalid or null is passed to the varargs `groups` parameter. This method implements the logic described in [Validation routine](#constraintdeclarationvalidationprocess-validationroutine) and apply it only to the given property and for the given value. `@Valid` is not honored by this method. This method is useful for ahead of time validation (i.e. before the JavaBean is populated or updated).

| Note | If multiple constrained fields or getters share the same name and hide one another in the class hierarchy according to the Java visibility rules, the list of constraints evaluated is unspecified. This will be clarified in a later version of this specification. Note that method overriding is not impacted.   If getters and fields share the same name and are present at different levels of the hierarchy, the list of constraints evaluated is unspecified. This will be clarified in a later version of this specification.   However, constraints hosted on the most specific (hierarchy wise) element type are always evaluated. |
| --- | --- |

| Note | `validateProperty()` and `validateValue()` accept property names and not full paths. Jakarta Bean Validation implementations might accept string representations of paths but this behavior is not portable. |
| --- | --- |

If some unrecoverable failure happens during validation, a `ValidationException` is raised. This exception can be specialized in some situations (invalid group definition, invalid constraint definition, invalid constraint declaration). See [Exception model](#exception) or the relative sections for more information.

##### 6.1.1.1. Examples

All the examples will be based on the following class definition, constraint declarations and address instance.

```
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales
```

The following code will return two `ConstraintViolation` objects. One for `addressline1` violating `@NotNull` and one for `city` violating `@Size`.

```
validator.validate(address).size() == 2
```

The following code will return one `ConstraintViolation` since `city` violates `@Size` and only `city` is validated.

```
validator.validateProperty(address, "city").size() == 1
```

The following code will return no `ConstraintViolation` objects because the value "Paris" for `city` would not raise any constraint failures.

```
validator.validateValue(Address.class, "city", "Paris").size() == 0
```

#### 6.1.2. Methods for validating method and constructor constraints

The methods for the validation of parameters and return values of methods and constructors can be found on the interface `javax.validation.executable.ExecutableValidator`.

Listing 6.2: `ExecutableValidator` interface
```
package javax.validation.executable;

/**
 * Validates parameters and return values of methods and constructors.
 * Implementations of this interface must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ExecutableValidator {

    /**
     * Validates all constraints placed on the parameters of the given method.
     *
     * @param <T> the type hosting the method to validate
     * @param object the object on which the method to validate is invoked
     * @param method the method for which the parameter constraints is validated
     * @param parameterValues the values provided by the caller for the given method's
     *        parameters
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    <T> Set<ConstraintViolation<T>> validateParameters(T object,
                                                       Method method,
                                                       Object[] parameterValues,
                                                       Class<?>... groups);

    /**
     * Validates all return value constraints of the given method.
     *
     * @param <T> the type hosting the method to validate
     * @param object the object on which the method to validate is invoked
     * @param method the method for which the return value constraints is validated
     * @param returnValue the value returned by the given method
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the object,
     *         method or groups parameters or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    <T> Set<ConstraintViolation<T>> validateReturnValue(T object,
                                                        Method method,
                                                        Object returnValue,
                                                        Class<?>... groups);

    /**
     * Validates all constraints placed on the parameters of the given constructor.
     *
     * @param <T> the type hosting the constructor to validate
     * @param constructor the constructor for which the parameter constraints is validated
     * @param parameterValues the values provided by the caller for the given constructor's
     *        parameters
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         Will be empty if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor,
                                                                  Object[] parameterValues,
                                                                  Class<?>... groups);

    /**
     * Validates all return value constraints of the given constructor.
     *
     * @param <T> the type hosting the constructor to validate
     * @param constructor the constructor for which the return value constraints is validated
     * @param createdObject the object instantiated by the given method
     * @param groups the group or list of groups targeted for validation (defaults to
     *        {@link Default})
     * @return a set with the constraint violations caused by this validation;
     *         will be empty, if no error occurs, but never {@code null}
     * @throws IllegalArgumentException if {@code null} is passed for any of the parameters
     *         or if parameters don't match with each other
     * @throws ValidationException if a non recoverable error happens during the
     *         validation process
     */
    <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(Constructor<? extends T> constructor,
                                                                   T createdObject,
                                                                   Class<?>... groups);
}
```

`<T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues, Class<?>... groups)` validates the arguments (as given in `parameterValues`) for the parameters of a given method (identified by `method`). Cross-parameter constraints are also validated. A set containing all `ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred. An `IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don’t match with each other (i.e. `object` and `method` don’t match, `parameterValues` and `method` don’t match).

`<T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue, Class<?>... groups)` validates the return value (specified by `returnValue`) of a given method (identified by `method`). A set containing all `ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred. An `IllegalArgumentException` will be thrown if null is passed for any of the parameters `object`, `method` and `groups` or if the parameters don’t match with each other (i.e. `object` and `method` don’t match, `returnValue` and `method` don’t match).

`<T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<T> constructor, Object[] parameterValues, Class<?>... groups)` validates the arguments (as given in `parameterValues`) for the parameters of a given constructor (identified by `constructor`). Cross-parameter constraints are also validated. A set containing all `ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred. An `IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don’t match with each other (i.e. `parameterValues` and `constructor` don’t match).

`<T> Set<ConstraintViolation<T>> validateConstructorReturnValue(Constructor<T> constructor, T createdObject, Class<?>... groups)` validates the object (specified by `createdObject`) of a given constructor (identified by `constructor`). A set containing all `ConstraintViolation` objects representing the failing constraints is returned, an empty set is returned if no constraint violations occurred. An `IllegalArgumentException` will be thrown if null is passed for any of the parameters or if the parameters don’t match with each other (i.e. `createdObject` and `constructor` don’t match).

None of those methods honor the XML configuration around executable validation nor the presence of `@ValidateOnExecution`. In other words, elements will be validated regardless of these settings when explicitly calling the validation methods.

##### 6.1.2.1. Examples

All the examples will be based on the following class definitions, constraint declarations and instances.

```
public class OrderService {

    @NotNull
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        [...]
    }

    @NotNull
    public Order placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull @Valid Item item,
        @Min(1) int quantity) {

        [...]
    }
}

public class Item {

    @NotNull;
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

Item item1 = new Item();
item1.setName("Kiwi");

Item item2 = new Item();
item2.setName(null);

Constructor<OrderService> constructor = [...]; //get constructor object
Method placeOrder = [...]; //get method object

OrderService orderService = new OrderService(new DefaultCreditCardProcessor());

ExecutableValidator executableValidator = Validation
    .buildDefaultValidatorFactory().getValidator().forExecutables();
```

The following method parameter validation will return one `ConstraintViolation` object as the customer code is null:

```
//orderService.placeOrder(null, item1, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { null, item1, 1 }).size() == 1;
```

The following method parameter validation will return one `ConstraintViolation` object as the `item` parameter is marked for cascaded validation and the given `Item` instance is not valid (its name is null):

```
//orderService.placeOrder("CUST-123", item2, 1);
executableValidator.validateParameters(
    orderService, placeOrder, new Object[] { "CUST-123", item2, 1 }).size() == 1;
```

The following constructor parameter validation will return one `ConstraintViolation` object as null is passed for the `creditCardProcessor` parameter:

```
//new OrderService(null);
executableValidator.validateConstructorParameters(constructor, new Object[] { null })
    .size() == 1;
```

Assuming the `placeOrder()` method returned `null`, the following return value validation will return one `ConstraintViolation`:

```
executableValidator.validateReturnValue(orderService, placeOrder, null).size() == 1;
```

Assuming the constructor of `OrderService` failed to store the given credit card processor into the `creditCardProcessor` field, the following validation of the constructor return value would fail as the constructor is marked with `@Valid` and the `@NotNull` constraint of the `OrderService` class would be violated:

```
executableValidator.validateConstructorReturnValue(constructor, orderService).size() == 1;
```

Let’s now look at how a validation interceptor would use these methods.

```
@Interceptor
public class SampleMethodInterceptor {
    @Inject
    private Validator validator;

    @AroundInvoke
    public Object validateMethodInvocation(InvocationContext ctx) throws Exception {
        //validate parameters
        Set<ConstraintViolation<Object>> violations;
        violations = validator.forExecutables().validateParameters(
                ctx.getTarget(),
                ctx.getMethod(),
                ctx.getParameters()
        );

        //if a violation occurs for parameters, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //execute the method proper
        Object result = ctx.proceed();

        //validate the return type
        violations = validator.forExecutables().validateReturnValue(
                ctx.getTarget(),
                ctx.getMethod(),
                result
        );

        //if a violation occurs for the return type, raise an exception
        if ( !violations.isEmpty() ) {
            throw new ConstraintViolationException(
                    buildMessage( ctx.getMethod(), ctx.getParameters(), violations ),
                    violations
            );
        }

        //return the result
        return result;
    }
}
```

#### 6.1.3. groups

Groups allow you to restrict the set of constraints applied during validation. Groups targeted are passed as parameters to the `validate()`, `validateProperty()` and `validateValue()` methods as well as the methods to validate method/constructor constraints (see [Methods for validating method and constructor constraints](#validationapi-validatorapi-methodlevelvalidationmethods)). All constraints belonging to the targeted group(s) are applied during the [Validation routine](#constraintdeclarationvalidationprocess-validationroutine). If no group is passed, the `Default` group is assumed. [groups](#constraintsdefinitionimplementation-constraintdefinition-properties-groups) describes how to define groups on constraints.

When more than one group is evaluated and passed to the various validate methods, order is not constrained. It is equivalent to the validation of a group `G` inheriting all groups (i.e. implementing all interfaces) passed to the validation method.

##### 6.1.3.1. Examples

```
/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NonEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;

    @NonEmpty
    private String city;

    @NonEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;

    [...]
}
```

In the previous example, `@NonEmpty` (and its composing constraints, assuming the definition given in chapter [Constraint declaration and validation process](#constraintdeclarationvalidationprocess)) on `street1` applies to the group `Minimal`, `@Size` on `street1` applies to the group `Default` and `@NonEmpty`(and its composing constraints) on `zipCode` applies to the groups `Default` and `Minimal`.

```
validator.validate(address);
```

validates the group `Default` (implicitly) and applies `@Size` on `street1`, `@NonEmpty` (and its composing constraints) on `city`, `@NonEmpty` (and its composing constraints) on `zipCode`. Particularly, `@NonEmpty` (and its composing constraints) on `street1` are not applied.

```
validator.validate(address, Minimal.class);
```

applies `@NonEmpty` (and its composing constraints) on `street1` and `@NonEmpty` (and its composing constraints) on `zipCode` because they belong to the `Minimal` group.

```
validator.validate(address, Minimal.class, Default.class);
```

validates both `Default` and `Minimal` groups. The routine applies `@NonEmpty` (and its composing constraints) and `@Size` on `street1`, `@NonEmpty` (and its composing constraints) on `city`, `@NonEmpty` (and its composing constraints) on `zipCode`. Note that if `zipCode` is empty, only one `ConstraintViolation` object will represent the failure and the not empty validation will only be executed once.

Let’s look at a more complex example involving group sequence.

```
public class Address {
    @NonEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;

    @NonEmpty(groups=SecondStep.class)
    private String city;

    @NonEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;

    [...]

    public interface FirstStep {}

    public interface SecondStep {}

    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}
```

When running:

```
validator.validate(address, Minimal.class, Total.class);
```

the validation process will process `@NonEmpty` (and its composing constraints) and `@Size` from `street1` and `@NonEmpty` (and its composing constraints) from `zipCode`. If `@Size` from `street1` does not generate a failure, then `@NonEmpty` (and its composing constraints) from `city` will be processed as part of `SecondStep`. Note that `@NonEmpty` (and its composing constraints) from `zipCode` are not reprocessed as they have already been processed before.

When running:

```
validator.validate(address, Total.class, SecondStep.class);
```

`@NonEmpty` (and its composing constraints) from `city` and `@NonEmpty` (and its composing constraints) from `zipCode` will be processed even if `@Size` from `street1` fails: while `SecondStep` is in the `Total` group sequence and hence should not be triggered if `FirstStep` has a failure, it also has been requested outside the sequence (in this case explicitly).

| Note | If the group definition is invalid, a `GroupDefinitionException` is raised. |
| --- | --- |

### 6.2. ConstraintViolation

`ConstraintViolation` is the class describing a single constraint failure. A set of `ConstraintViolation` is returned for an object validation.

Listing 6.3: `ConstraintViolation` interface
```
/**
 * Describes a constraint violation. This object exposes the constraint
 * violation context as well as the message describing the violation.
 *
 * @param <T> the type of the root bean
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintViolation<T> {

    /**
     * @return the interpolated error message for this constraint violation
     */
    String getMessage();

    /**
     * @return the non-interpolated error message for this constraint violation
     */
    String getMessageTemplate();

    /**
     * Returns the root bean being validated. For method validation, returns
     * the object the method is executed on.
     * <p>
     * Returns {@code null} when:
     * <ul>
     *     <li>the {@code ConstraintViolation} is returned after calling
     *     {@link Validator#validateValue(Class, String, Object, Class[])}</li>
     *     <li>the {@code ConstraintViolation} is returned after validating a
     *     constructor.</li>
     * </ul>
     *
     * @return the validated object, the object hosting the validated element or {@code null}
     */
    T getRootBean();

    /**
     * Returns the class of the root bean being validated.
     * For method validation, this is the object class the
     * method is executed on.
     * For constructor validation, this is the class the constructor
     * is declared on.
     *
     * @return the class of the root bean or of the object hosting the validated element
     */
    Class<T> getRootBeanClass();

    /**
     * Returns:
     * <ul>
     *     <li>the bean instance the constraint is applied on if it is
     *     a bean constraint</li>
     *     <li>the bean instance hosting the property the constraint
     *     is applied on if it is a property constraint or a container element constraint
     *     hosted on a property</li>
     *     <li>{@code null} when the {@code ConstraintViolation} is returned
     *     after calling {@link Validator#validateValue(Class, String, Object, Class[])}
     *     </li>
     *     <li>the object the method is executed on if it is
     *     a method parameter, cross-parameter or return value constraint or a
     *     container element constraint hosted on a method parameter or return value</li>
     *     <li>{@code null} if it is a constructor parameter or
     *     cross-parameter constraint or a container element constraint hosted on a
     *     constructor parameter</li>
     *     <li>the object the constructor has created if it is a
     *     constructor return value constraint</li>
     * </ul>
     *
     * @return the leaf bean
     */
    Object getLeafBean();

    /**
     * Returns an {@code Object[]} representing the constructor or method invocation
     * arguments if the {@code ConstraintViolation} is returned after validating the
     * method or constructor parameters.
     * Returns {@code null} otherwise.
     *
     * @return parameters of the method or constructor invocation or {@code null}
     *
     * @since 1.1
     */
    Object[] getExecutableParameters();

    /**
     * Returns the return value of the constructor or method invocation
     * if the {@code ConstraintViolation} is returned after validating the method
     * or constructor return value.
     * <p>
     * Returns {@code null} if the method has no return value.
     * Returns {@code null} otherwise.
     *
     * @return the method or constructor return value or {@code null}
     *
     * @since 1.1
     */
    Object getExecutableReturnValue();

    /**
     * @return the property path to the value from {@code rootBean}
     */
    Path getPropertyPath();

    /**
     * Returns the value failing to pass the constraint.
     * For cross-parameter constraints, an {@code Object[]} representing
     * the method invocation arguments is returned.
     *
     * @return the value failing to pass the constraint
     */
    Object getInvalidValue();

    /**
     * Returns the constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor<?> getConstraintDescriptor();

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Jakarta Bean Validation provider
     * implementation does not support the specified class,
     * {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @param <U> the type of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 1.1
     */
    <U> U unwrap(Class<U> type);
}
```

The `getMessage()` method returns the interpolated (localized) message for the failing constraint (see [Message interpolation](#validationapi-message) for more information on message interpolator). This can be used by clients to expose user friendly messages.

The `getMessageTemplate()` method returns the non-interpolated error message (usually the `message` attribute on the constraint declaration). Frameworks can use this as an error code key.

The `getRootBean()` method returns the root object being validated that led to the failing constraint (i.e. the object the client code passes to the `Validator.validate()` method). For method validation, returns the object the method is executed on. For constructors or when `Validator.validateValue()` is used, returns `null`.

The `getRootBeanClass()` method returns the class of the root bean being validated. For method validation, this is the object class the method is executed on. For constructor validation, this is the class the constructor is declared on.

The `getLeafBean()` method returns the following object:

* If a bean constraint, the bean instance the constraint is applied on.
* If a property constraint or a [container element constraint](#constraintdeclarationvalidationprocess-containerelementconstraints) hosted on a property, the bean instance hosting the property the constraint is applied on.
* If a property constraint, `null` when the `ConstraintViolation` is returned after calling `Validator.validateValue()`.
* If a method parameter, cross-parameter or return value constraint or a container element constraint hosted on a method parameter or return value, the object the method is executed on.
* If a constructor parameter or cross-parameter constraint or a container element constraint hosted on a constructor parameter, `null`.
* If a constructor return value constraint, the object the constructor has created.

The `getExecutableParameters()` returns the parameters provided to the method or constructor invocation or `null` if not validating a method or constructor parameters.

The `getExecutableReturnValue()` returns the return value of the method or constructor invocation or `null` if the method has no return value or if not validating a method or constructor return value.

The `getInvalidValue()` method returns the value (field, property, method/constructor parameter, method/constructor return value, container element or validated object) being passed to `isValid()`. For a cross-parameter constraint failure, an `Object[]` representing the method/constructor invocation arguments is returned.
In case a constraint given on a container is subject to implicit application to the container element(s) (see [Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)), `getInvalidValue()` returns the invalid container element value.

`getConstraintDescriptor()` provides access to the failing constraint metadata (see [ConstraintDescriptor](#constraintmetadata-constraintdescriptor)).

The `getPropertyPath()` method returns the `Path` object representing the navigation path from the root object to the failing object.

`unwrap()` is provided as a way to access objects of a given type specific to a Jakarta Bean Validation provider typically as a complement to the `ConstraintViolation` contract. Using this method makes your code non portable.

Listing 6.4: `Path` and `Node` interfaces and `ElementKind` enum
```
/**
 * Represents the navigation path from an object to another
 * in an object graph.
 * Each path element is represented by a {@code Node}.
 * <p>
 * The path corresponds to the succession of nodes
 * in the order they are returned by the {@code Iterator}.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Guillaume Smet
 */
public interface Path extends Iterable<Path.Node> {

    /**
     * Returns a human-readable representation of this path.
     * <p>
     * Clients should not rely on any specific structure of the returned value. Instead they
     * should iterate through the path nodes and obtain any required information by calling
     * the methods on {@link Node} and its sub-types.
     *
     * @return a human-readable representation of this path
     * @since 2.0
     */
    @Override
    String toString();

    /**
     * Represents an element of a navigation path.
     */
    interface Node {

        /**
         * Returns the name of the element which the node represents:
         * <ul>
         *     <li>{@code null} if it is a leaf node which represents an entity / bean.
         *     In particular, the node representing the root object.</li>
         *     <li>The property name for a property.</li>
         *     <li>The method name for a method.</li>
         *     <li>The unqualified name of the type declaring the constructor
         *     for a constructor.</li>
         *     <li>The parameter named as defined by the {@link ParameterNameProvider}
         *     for a method or constructor parameter.</li>
         *     <li>The literal {@code <cross-parameter>} for a method or constructor
         *     cross-parameter.</li>
         *     <li>The literal {@code <return value>} for a method or constructor return
         *     value.</li>
         *     <li>The node name as defined by the {@link ValueExtractor} for a container
         *     element; specifically, the literal {@code <list element>} for elements
         *     stored in a list, the literal {@code <iterable element>} for elements
         *     stored in an {@code Iterable}, the literal {@code <map key>} for the keys
         *     stored in a {@code Map} and the literal {@code <map value>} for the values
         *     stored in a {@code Map}.
         * </ul>
         *
         * @return name of the element which the node represents
         */
        String getName();

        /**
         * @return {@code true} if the node represents an object contained in
         * a multi-valued container such as {@code Iterable} or {@code Map} or an array,
         * {@code false} otherwise
         */
        boolean isInIterable();

        /**
         * @return the index the node is placed in if contained in an array, a {@code List}
         *         or any other container supporting indexed access, {@code null} otherwise
         */
        Integer getIndex();

        /**
         * @return the key the node is placed in if contained in a {@code Map} or any
         *         other container supporting keyed access, {@code null} otherwise
         */
        Object getKey();

        /**
         * The kind of element represented by the node. The following relationship
         * between an {@link ElementKind} and its {@code Node} subtype exists:
         * <ul>
         *     <li>{@link ElementKind#BEAN}: {@link BeanNode}</li>
         *     <li>{@link ElementKind#PROPERTY}: {@link PropertyNode}</li>
         *     <li>{@link ElementKind#METHOD}: {@link MethodNode}</li>
         *     <li>{@link ElementKind#CONSTRUCTOR}: {@link ConstructorNode}</li>
         *     <li>{@link ElementKind#PARAMETER}: {@link ParameterNode}</li>
         *     <li>{@link ElementKind#CROSS_PARAMETER}: {@link CrossParameterNode}</li>
         *     <li>{@link ElementKind#RETURN_VALUE}: {@link ReturnValueNode}</li>
         *     <li>{@link ElementKind#CONTAINER_ELEMENT}: {@link ContainerElementNode}</li>
         * </ul>
         * <p>
         * This is useful to narrow down the {@code Node} type and access node specific
         * information:
         * <pre>
         * switch(node.getKind() {
         * case METHOD:
         *     name = node.getName();
         *     params = node.as(MethodNode.class).getParameterTypes();
         * case PARAMETER:
         *     index = node.as(ParameterNode.class).getParameterIndex();
         * [...]
         * }
         * </pre>
         *  @return the {@code ElementKind}
         *
         * @since 1.1
         */
        ElementKind getKind();

        /**
         * Narrows the type of this node down to the given type. The appropriate
         * type should be checked before by calling {@link #getKind()}.
         *
         * @param <T> the type to narrow down to
         * @param nodeType class object representing the descriptor type to narrow down to
         *                 to
         *
         * @return this node narrowed down to the given type.
         *
         * @throws ClassCastException if this node is not assignable to the type {@code T}
         * @since 1.1
         */
        <T extends Node> T as(Class<T> nodeType);

        /**
         * Returns a human-readable representation of this node.
         * <p>
         * Clients should not rely on any specific structure of the returned value. Instead
         * they should obtain any required information by calling the methods on this
         * interface and its sub-types.
         *
         * @return a human-readable representation of this node
         * @since 2.0
         */
        @Override
        String toString();
    }

    /**
     * Node representing a method.
     *
     * @since 1.1
     */
    interface MethodNode extends Node {

        /**
         * @return the list of parameter types
         */
        List<Class<?>> getParameterTypes();
    }

    /**
     * Node representing a constructor.
     *
     * @since 1.1
     */
    interface ConstructorNode extends Node {

        /**
         * @return the list of parameter types
         */
        List<Class<?>> getParameterTypes();
    }

    /**
     * Node representing the return value of a method or constructor.
     *
     * @since 1.1
     */
    interface ReturnValueNode extends Node {
    }

    /**
     * Node representing a parameter of a method or constructor.
     *
     * @since 1.1
     */
    interface ParameterNode extends Node {

        /**
         * @return the parameter index in the method or constructor definition
         */
        int getParameterIndex();
    }

    /**
     * Node representing the element holding cross-parameter constraints
     * of a method or constructor.
     *
     * @since 1.1
     */
    interface CrossParameterNode extends Node {
    }

    /**
     * Node representing a bean.
     *
     * @since 1.1
     */
    interface BeanNode extends Node {

        /**
         * @return the type of the container the node is placed in, if contained in a
         * container type such as {@code Optional}, {@code List} or {@code Map},
         * {@code null} otherwise
         *
         * @since 2.0
         */
        Class<?> getContainerClass();

        /**
         * @return the index of the type argument affected by the violated constraint, if
         * contained in a generic container type such as {@code Optional}, {@code List} or
         * {@code Map}.
         *
         * @since 2.0
         */
        Integer getTypeArgumentIndex();
    }

    /**
     * Node representing a property.
     *
     * @since 1.1
     */
    interface PropertyNode extends Node {

        /**
         * @return the type of the container the node is placed in, if contained in a
         * container type such as {@code Optional}, {@code List} or {@code Map},
         * {@code null} otherwise
         *
         * @since 2.0
         */
        Class<?> getContainerClass();

        /**
         * @return the index of the type argument affected by the violated constraint, if
         * contained in a generic container type such as {@code Optional}, {@code List} or
         * {@code Map}, {@code null} otherwise
         *
         * @since 2.0
         */
        Integer getTypeArgumentIndex();
    }

    /**
     * Node representing an element in a generic container such as {@code Optional},
     * {@code List} or {@code Map}.
     *
     * @since 2.0
     */
    interface ContainerElementNode extends Node {

        /**
         * @return the type of the container the node is placed in
         */
        Class<?> getContainerClass();

        /**
         * @return the index of the type argument affected by the violated constraint
         */
        Integer getTypeArgumentIndex();
    }
}
```

```
/**
 * Enum of possible kinds of elements encountered in Jakarta Bean Validation.
 * <p>
 * Mostly elements that can be constrained and described in the metadata
 * but also elements that can be part of a {@link Path} and represented
 * by a {@link Path.Node}
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Guillaume Smet
 *
 * @since 1.1
 */
public enum ElementKind {
    /**
     * A Java Bean or object.
     */
    BEAN,

    /**
     * A property of a Java Bean.
     */
    PROPERTY,

    /**
     * A method.
     */
    METHOD,

    /**
     * A constructor.
     */
    CONSTRUCTOR,

    /**
     * A parameter of a method or constructor.
     */
    PARAMETER,

    /**
     * Element holding cross-parameter constraints of a method or constructor.
     */
    CROSS_PARAMETER,

    /**
     * The return value of a method or constructor.
     */
    RETURN_VALUE,

    /**
     * An element stored in a container, e.g. a key or value of a {@code Map} or an element
     * of a {@code List}.
     *
     * @since 2.0
     */
    CONTAINER_ELEMENT
}
```

`Path` is an iterable of `Node` objects. `Node` offers the following methods:

* `getName()` returns the name of the element which the node represents:

  + `null` if it is a leaf node which represents an entity / bean. In particular, the node representing the root object.
  + The property name for a property.
  + The method name for a method.
  + The unqualified name of the type declaring the constructor for a constructor.
  + The parameter named as defined by the `ParameterNameProvider` (see [Naming parameters](#constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters)) for a method or constructor parameter.
  + The literal `<cross-parameter>` for a method or constructor cross-parameter.
  + The literal `<return value>` for a method or constructor return value.
  + The name set by the applied value extractor for a container element constraint;
    specifically, when applying the default value extractor for iterable elements, list elements, map keys or map values, the literal `<iterable element>`, `<list element>`, `<map key>` or `<map value>`, respectively.
* `isInIterable()` returns `true` if the node represents an object contained in an array or in a multi-valued container such as `Iterable` or `Map`, `false` otherwise.
* `getIndex()` returns the index of the node if it is contained in an array, `List` or any other container supporting indexed access. Returns `null` otherwise.
* `getKey()` returns the key of the node if it is contained in a `Map` or any other container supporting keyed access. Returns `null` otherwise.
* `getKind()` returns the `ElementKind` corresponding to the actual node type. This can be used in conjunction with the method `as()` to narrow the type and access node specific methods
* `as(Class<? extends Node>)` returns the node instance narrowed to the type passed as a parameter or throws a `ClassCastException` if the type and node don’t match.

Nodes are of the following possible types:

* `BeanNode`
* `PropertyNode`
* `MethodNode`
* `ConstructorNode`
* `ParameterNode`
* `CrossParameterNode`
* `ReturnValueNode`
* `ContainerElementNode`

It is possible to narrow a node instance to its precise type and extract node specific information by the use of `Node.getKind()` and `Node.as(Class<? extends Node>)`.

In particular, `MethodNode` and `ConstructorNode` host `getParameterTypes()` which return the method or constructor parameter list.
Likewise `ParameterNode` hosts `getParameterIndex()` which returns the parameter index in the method or constructor parameter list.

`BeanNode`, `PropertyNode` and `ContainerElementNode` host `getContainerClass()` and `getTypeArgumentIndex()`.
If the node represents an element that is contained in a container such as `Optional`, `List` or `Map`,
the former returns the declared type of the container and, if the container is of a generic type, the latter returns the index of the affected type argument.

Example 6.2: Narrow a node to its specific type
```
Node node = [...];
switch ( node.getKind() ) {
case METHOD:
    MethodNode methodNode = node.as(MethodNode.class);
    methodName = methodNode.getName();
    params = methodNode.getParameterTypes().toArray(
        new Class<?>[methodNode.getParameterTypes().size()] );
    break;
case CONSTRUCTOR:
    ConstructorNode constructorNode = node.as(ConstructorNode.class);
    methodName = constructorNode.getName();
    params = constructorNode.getParameterTypes().toArray(
        new Class<?>[constructorNode.getParameterTypes().size()] );
    break;
case PARAMETER:
    arg = node.as(ParameterNode.class).getParameterIndex();
    break;
case CONTAINER_ELEMENT:
    ContainerElementNode containerElementNode = node.as(ContainerElementNode.class);
    containerClass = containerElementNode.getContainerClass();
    typeArgumentIndex = containerElementNode.getTypeArgumentIndex();
    break;
case CROSS_PARAMETER:
    [...]
case RETURN_VALUE:
    [...]
case PARAMETER:
    [...]
case BEAN:
    [...]
case PROPERTY:
    [...]
}
```

`Path` objects are built according to the following rules:

* The runtime type is considered, not the static type. For example if a property is declared `Collection<String>` but its runtime type is `ArrayList<String>`, the property is considered an `ArrayList<String>`.
* If the failing object is the root object, a `BeanNode` with name set to `null` is added to the `Path`. The `ElementKind` of the node is `ElementKind.BEAN`.
* When an association is traversed:

  + a `PropertyNode` object whose `name` equals the name of the association property (field name or Java Bean property name) is added to `Path`. The `ElementKind` of the node is `ElementKind.PROPERTY`.
  + if the association is an array, a `List` or any other container whose value extractor invokes `ValueReceiver#indexedValue()` (see [Value extractor definition](#valueextractordefinition)), the following `Node` object added contains the index value in `getIndex()`
  + if the association is a `Map` or any other container whose value extractor invokes `ValueReceiver#keyedValue()`, the following `Node` object added (representing a given map entry) contains the key value in `getKey()`
  + for all `Iterable`, `Map` or other container whose value extractor invokes `ValueReceiver#indexedValue()`, `ValueReceiver#keyedValue()` or `ValueReceiver#iterableValue()`, the following `Node` object added is marked as `inIterable` (`isInIterable()`)
  + if the traversed object is of a container type (e.g. a `List` or `Map`), the following `Node` object added returns the declared type of the traversed container via `getContainerClass()` and the index of the affected type argument via `getTypeArgumentIndex()`
* When a nested container is traversed (e.g. when traversing into the elements of the lists in `Map<String, List<@Valid Address>>`):

  + if the value extractor of the outer container has provided a non-null node name, a `ContainerElementNode` object whose `name` equals that name is added to `Path`. The `ElementKind` of the node is `ElementKind.CONTAINER_ELEMENT`
  + if the container is a `List` or any other container whose value extractor invokes `ValueReceiver#indexedValue()`, the following `Node` object added contains the index value in `getIndex()`
  + if the container is a `Map` or any other container whose value extractor invokes `ValueReceiver#keyedValue()`, the following `Node` object added (representing a given map entry) contains the key value in `getKey()`
  + for all `Iterable`, `Map` or other container whose value extractor invokes `ValueReceiver#indexedValue()`, `ValueReceiver#keyedValue()` or `ValueReceiver#iterableValue()`, the following `Node` object added is marked as `inIterable` (`isInIterable()`)
  + the following `Node` object added returns the declared type of the traversed container via `getContainerClass()` and the index of the affected type argument via `getTypeArgumentIndex()`

* For a property level constraint (field and getter)

  + a `PropertyNode` object is added to `Path` whose `name` equals the name of the property (field name or Java Bean property name). The `ElementKind` of the node is `ElementKind.PROPERTY`.
  + the property path is considered complete

* For a class level constraint:

  + a `BeanNode` object is added to `Path` whose `name` is null. The `ElementKind` of the node is `ElementKind.BEAN`.
  + the property path is considered complete

* For a method/constructor constraint (parameter, cross-parameter or return value constraint on a method or constructor):

  + a `MethodNode` respectively a `ConstructorNode` object is added to the `Path` which represents the validated method respectively constructor. The `name` of the node equals the validated method name or the validated constructor’s unqualified class name, the `ElementKind` of the node is `ElementKind.METHOD` respectively `ElementKind.CONSTRUCTOR`.
  + if the constraint is on a parameter, a `ParameterNode` object is added to the `Path` which represents the validated parameter. The `name` of the node equals the parameter name as determined by the current parameter name provider (see [Naming parameters](#constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters)). The `ElementKind` of the node is `ElementKind.PARAMETER`.
  + if the constraint is a cross-parameter constraint, a `CrossParameterNode` object is added to the `Path` which represents the validated cross-parameter element. The `name` of the node has the constant value `<cross-parameter>`. The `ElementKind` of the node is `ElementKind.CROSS_PARAMETER.`
  + if the constraint is on the return value, a `ReturnValueNode` object is added to the `Path` which represents the validated return value. The `name` of the node has the constant value `<return value>`. The `ElementKind` of the node is `ElementKind.RETURN_VALUE.`
  + the property path is considered complete
* If a parameter or the return value of a method or constructor is traversed:

  + a `MethodNode` respectively `ConstructorNode` object is added to the `Path` which represents the concerned method respectively constructor. The `name` of the node equals the concerned method name or the constructor’s unqualified class name, the `ElementKind` of the node is `ElementKind.METHOD` or `ElementKind.CONSTRUCTOR`, respectively.
  + if a parameter is traversed, a `ParameterNode` object is added to the `Path` which represents the traversed parameter. The `name` of the node equals the parameter name as determined by the current parameter name provider. The `ElementKind` of the node is `ElementKind.PARAMETER`.
  + if a return value is traversed, a `ReturnValueNode` object is added to the `Path` which represents the traversed return value. The `name` of the node has the constant value `<return value>`. The `ElementKind` of the node is `ElementKind.RETURN_VALUE.`
  + if the parameter/return value is a `List` or an array, the following `Node` object added contains the index value in `getIndex()`.
  + if the parameter/return value is a `Map`, the following `Node` object added (representing a given map entry) contains the key value in `getKey()`.
  + for all `Iterable` or `Map`, the following `Node` object added is marked as `inIterable` (`isInIterable()`).

* For a container element constraint:

  + if the corresponding value extractor (see [Value extractor definition](#valueextractordefinition)) has specified a node name when calling one of the receiver methods, a `ContainerElementNode` object with that name is added to the `Path`.
    The `ElementKind` of the node is `ElementKind.CONTAINER_ELEMENT`.
    `getContainerClass()` returns the declared type of the container hosting the constraint.
    `getTypeArgumentIndex()` returns the index of the type argument hosting the constraint.
    If the constraint is given on a container and is subject to implicit application to the container’s element(s) (see [Implicit unwrapping of containers](#constraintdeclarationvalidationprocess-containerelementconstraints-implicitunwrapping)) and the applied value extractor is not tied to a type parameter, `getTypeArgumentIndex()` returns null.
  + if the corresponding value extractor has passed no node name to the called receiver method, no node is appended.
  + the property path is considered complete

If additional path nodes are added in a constraint validator implementation using the node builder API (see [Constraint validation implementation](#constraintsdefinitionimplementation-validationimplementation)), the following rules apply:

* if the default path ends with a `BeanNode`, this node is removed and the first added node (a `PropertyNode`) inherits its `inIterable`, `key` and `index` values. `inIterable`, `key` and `index` value must not be specified directly on this first node by the user.
* if the default path ends with a `CrossParameterNode`, this node is removed.
* then the additional nodes are appended to the (possibly amended) path generated by the Jakarta Bean Validation engine as previously described:

* A `PropertyNode` is appended in case `addPropertyNode(String)` is invoked. The node name is equal to the name provided. The `ElementKind` of the node is `ElementKind.PROPERTY`.
* A `BeanNode` is appended in case `addBeanNode()` is invoked. The node name is `null`. The `ElementKind` of the node is `ElementKind.BEAN`.
* A `ParameterNode` is appended in case `addParameterNode(int)` is invoked. The node name is equal to the parameter name at the provided index. The name is determined by the current parameter name provider. The `ElementKind` of the node is `ElementKind.PARAMETER`. The previous node (removed) must be a `CrossParameterNode`.
* A `ContainerElementNode` is appended in case `addContainerElementNode(String, Class, Integer)` is invoked. The name, container type and type argument index of the node are equal to the values provided. The `ElementKind` of the node is `ElementKind.CONTAINER_ELEMENT`.
* If `inIterable()` is invoked, the node returns `true` for `isInIterable()`, `false` otherwise.
* If `inContainer(Class, Integer)` is invoked, the node returns the passed container type and type argument index from `getContainerClass()` and `getTypeArgumentIndex()`, respectively.
* If `atIndex(Integer)` is invoked, the node returns the provided integer for `getIndex()`, `null` otherwise.
* If `atKey(Object)` is invoked, the node returns the provided object for `getKey()`, `null` otherwise.

| Note | A given `Node` object derives its `inIterable`, `key` and `index` properties from the previous association, method parameter or return value traversed. The same applies to `typeArgumentIndex` and `containerClass` if the given node type defines these properties. |
| --- | --- |

| Note | From `getRootBean()`, `getPropertyPath()`, `getExecutableParameters()` and `getExecutableReturnValue()`, it is possible to rebuild the context of the failure. |
| --- | --- |

| Note | `ConstraintViolation`s occurred during standard Jakarta Bean Validation can be distinguished from violations occurred during method/constructor validation by analyzing the `ElementKind` of the `Node` of the first node in the violation’s property path. In case of constructor or method validation, that `ElementKind` will be either `CONSTRUCTOR` or `METHOD`. |
| --- | --- |

Let there be the following object definitions:

Example 6.3: Object model definition for examples
```
@SecurityChecking
public class Author {
    private String firstName;

    @NonEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    [...]

    @OldAndNewPasswordsDifferent
    @NewPasswordsIdentical
    public void renewPassword(
            String oldPassword, String newPassword, String retypedNewPassword) {
        [...]
    }
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NonEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List<Author> authors;

    @Valid
    private Map<String, Review> reviewsPerSource;

    @Valid
    private Review pickedReview;

    private List<@NotBlank String> tags;

    private Map<Integer, List<@NotBlank String>> tagsByChapter;

    private List<@Valid Category> categories;

    private Map<Integer, List<@Valid Author>> authorsByChapter;

    [...]
}

public class Review {

    @Min(0)
    private int rating;
    [...]
}

public class Category {

    @Size(min=3)
    private String name;

    // [...]
}

public class Library {

    public Library(@NotNull String name, @NotNull String location) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    public void addAllBooks(@NotNull List<@Valid Book> books) {
        [...]
    }

    @NotNull public String getLocation() {
        [...]
    }

    public Map<Author, @Valid Book> getMostPopularBookPerAuthor() {
        [...]
    }
}
```

Assuming a `Book` instance gets validated, the property paths to the different constraints would be as described in [propertyPath examples](#table-propertypath):

Table 6.1: propertyPath examples

| Constraint | propertyPath |
| --- | --- |
| `@AvailableInStore` on `Book` | BeanNode(name=null, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.BEAN) |
| `@NonEmpty` on `Book.title` | PropertyNode(name=title, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY) |
| `@NotNull` on `Book.authors` | PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY) |
| `@SecurityChecking` on the fourth author, `Author` | PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  BeanNode(name=null, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.BEAN) |
| `@NonEmpty` on the fourth author, `Author.lastname` | PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  PropertyNode(name=lastName, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY) |
| `@Size` on the first author, `Author.company` | PropertyNode(name=authors, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  PropertyNode(name=company, inIterable=true, index=0, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY) |
| `@Min` on the review associated to Consumer Report, `Review.rating` | PropertyNode(name=reviewsPerSource, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  PropertyNode(name=rating, inIterable=true, index=null, key="Consumer Report", containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.PROPERTY) |
| `@Min` on the picked review, `Review.rating` | PropertyNode(name=pickedReview, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  PropertyNode(name=rating, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY) |
| `@NotBlank` on the second tag, `Book.tags` | PropertyNode(name=tags, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  ContainerElementNode(name=<list element>, inIterable=true, index=1, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.CONTAINER\_ELEMENT) |
| `@NotBlank` on the third tag of chapter 4, `Book.tagsByChapter` | PropertyNode(name=tagsByChapter, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  ContainerElementNode(name=<map value>, inIterable=true, index=null, key=4, containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.CONTAINER\_ELEMENT)  ContainerElementNode(name=<list element>, inIterable=true, index=2, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.CONTAINER\_ELEMENT) |
| `@Size` on the name of the second category, `Category.name` | PropertyNode(name=categories, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  PropertyNode(name=name, inIterable=true, index=1, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY) |
| `@NonEmpty` on the last name of the third author of chapter 4, `Author.lastname` | PropertyNode(name=authorsByChapter, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY)  ContainerElementNode(name=<map value>, inIterable=true, index=null, key=4, containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.CONTAINER\_ELEMENT)  PropertyNode(name=lastName, inIterable=true, index=2, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY) |

Assuming the constructor and methods of the `Library` class are subject to method constraint validation and parameter names can be obtained for them, the following property paths would exist for the different constraints:

Table 6.2: Property path examples for constrained methods or constructors

| Constraint | propertyPath |
| --- | --- |
| `@NotNull` on the `location` parameter of the constructor | ConstructorNode(name=Library, inIterable=false, index=null, key=null, kind=ElementKind.CONSTRUCTOR, parameterTypes=[String.class,String.class])  ParameterNode(name=location, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=1) |
| `@NotNull` on the `book` parameter of the `addBook()` method | MethodNode(name=addBook, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[Book.class])  ParameterNode(name=book, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0) |
| `@NonEmpty` on `Book.title` during validation of `addBook()` | MethodNode(name=addBook, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[Book.class])  ParameterNode(name=book, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0)  PropertyNode(name=title, inIterable=false, index=null, key=null, containerClass=null, typeArgumentIndex=null, kind=ElementKind.PROPERTY) |
| `@NonEmpty` on fourth book, `Book.title` during validation of `addAllBooks()` | MethodNode(name=addAllBooks, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[List.class])  ParameterNode(name=books, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=0)  PropertyNode(name=title, inIterable=true, index=3, key=null, containerClass=List.class, typeArgumentIndex=0, kind=ElementKind.PROPERTY) |
| `@NotNull` on the return value of the `getLocation()` method | MethodNode(name=getLocation, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[])  ReturnValueNode(name=<return value>, inIterable=false, index=null, key=null, kind=ElementKind.RETURN\_VALUE) |
| `@NonEmpty` on most popular book of author "John Doe", `Book.title` during validation of `getMostPopularBookPerAuthor()` | MethodNode(name=getMostPopularBookPerAuthor, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[])  ReturnValueNode(name=<return value>, inIterable=false, index=null, key=null, kind=ElementKind.RETURN\_VALUE)  PropertyNode(name=title, inIterable=true, index=null, key=Author(firstName=John, lastName=Doe), containerClass=Map.class, typeArgumentIndex=1, kind=ElementKind.PROPERTY) |
| `@OldAndNewPasswordsDifferent` when executing `Author.renewPassword()` with `oldPassword`, `newPassword` and `retypedNewPassword` set to "foo". `@OldAndNewPasswordsDifferent` is a cross-parameter constraint. | MethodNode(name=renewPassword, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[String.class, String.class, String.class])  CrossParameterNode(name=<cross-parameter>, inIterable=false, index=null, key=null, kind=ElementKind.CROSS\_PARAMETER) |
| `@NewPasswordsIdentical` when executing `Author.renewPassword()` with `oldPassword` as "foo", `newPassword` as "bar" and `retypedNewPassword` as "baz". `@NewPasswordsIdentical` is a cross-parameter constraint creating a constraint violation on the `retypedNewPassword` parameter. | MethodNode(name=renewPassword, inIterable=false, index=null, key=null, kind=ElementKind.METHOD, parameterTypes=[String.class, String.class, String.class])  ParameterNode(name=retypedNewPassword, inIterable=false, index=null, key=null, kind=ElementKind.PARAMETER, parameterIndex=2) |

| Note | Jakarta Bean Validation implementations should ensure that a `ConstraintViolation` implementation is `Serializable` provided that the root bean, the leaf bean, the invalid value and keys in the `Path` object are `Serializable` objects.   If a user wishes to send `ConstraintViolation` remotely, it should make sure the object graph validated is itself `Serializable`. |
| --- | --- |

#### 6.2.1. Examples

These examples assume the following definition of `@NonEmpty`:

```
package com.acme.constraint;

@Documented
@NotNull
@Size(min = 1)
@ReportAsSingleViolation
@Constraint(validatedBy = NonEmpty.NonEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface NonEmpty {

    String message() default "{com.acme.constraint.NonEmpty.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        NonEmpty[] value();
    }

    class NonEmptyValidator implements ConstraintValidator<NonEmpty, String> {

        @Override
        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}
```

And the following class definitions:

```
public class Author {

    private String firstName;

    @NonEmpty(message = "lastname must not be null")
    private String lastName;

    @Size(max = 30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}
```

```
public class Book {

    @NonEmpty(groups = { FirstLevelCheck.class, Default.class })
    private String title;

    @Valid
    @NotNull
    private Author author;

    private List<@Size(min=3, max=30) String> tags;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }
}
```

When executing the following validation:

```
Author author = new Author();
author.setCompany( "ACME" );

List<String> tags = Arrays.asList( "a", "science fiction" );

Book book = new Book();
book.setTitle( "" );
book.setAuthor( author );

book.setTags( tags );

Validator validator = Validation.buildDefaultValidatorFactory().getValidator();
Set<ConstraintViolation<Book>> constraintViolations = validator.validate( book );
```

Then `constraintViolations` is a set of size 3. One of the entries represents the failure of `@NonEmpty` (or more precisely `@Size(min=1)` a composing constraint of `@NonEmpty`) on the `title` property.

The `ConstraintViolation` object for this failure passes the following assertions:

Example 6.4: Test assertions on `ContraintViolation` for `title`
```
//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

//the offending property
Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();
Node node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

The second failure, `@NonEmpty` (or more precisely `@NotNull` a composing constraint of `@NonEmpty`) on the author’s `lastname`, will produce the `ConstraintViolation` object satisfying the following assertions:

Example 6.5: Test assertions on `ContraintViolation` for `lastName`
```
assert "lastname must not be null".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();

//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();

//the offending property
Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "author".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

node = nodeIter.next();
assert "lastName".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

The third failure, `@Size` on one of the book’s `tags`, will produce a `ConstraintViolation` object satisfying the following assertions:

Example 6.6: Test assertions on `ContraintViolation` for `tags`
```
assert "size must be between 3 and 30".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

//the offending value
assert book.getTags().get( 0 ) == constraintViolation.getInvalidValue();

//the offending property
Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "tags".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

node = nodeIter.next();
assert "<list element>".equals( node.getName() );
assert ElementKind.CONTAINER_ELEMENT.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

#### 6.2.2. Examples for method and constructor constraint violations

The following examples assume the constraint, class and object definitions given in the previous section. Additionally the following class and object definitions are assumed:

```
public class Library {

    @PublicLibrary
    public Library() {
        [...]
    }

    public Library(@NotNull List<@Valid Book> books) {
        [...]
    }

    public void addBook(@NotNull @Valid Book book) {
        [...]
    }

    @Valid public Map<Author, Book> getMostPopularBookPerAuthor() {
        [...]
    }
}

public class User {

    @OldAndNewPasswordsDifferent
    public void renewPassword(String oldPassword, String newPassword, String retypedNewPassword);
}

Library library = new Library();
author.setLastName("Doe");
```

Assuming the following invocation of `addBook()` is subject to method parameter validation:

```
library.addBook(null);
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateParameters()` which satisfies the following assertions:

```
//assuming an english locale, the interpolated message is returned
assert "must not be null".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert library == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "book".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

Assuming the following invocation of `addBook()` is subject to method parameter validation:

```
library.addBook(book);
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateParameters()` which satisfies the following assertions:

```
//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert new Object[]{ book }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "book".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

Assuming the following invocation of `User.renewPassword()` is subject to method parameter validation and the `@OldAndNewPasswordsDifferent` constraint is violated:

```
User user = [...];
user.renewPassword("foo", "foo", "foo");
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateParameters()` which satisfies the following assertions:

```
assert user == constraintViolation.getRootBean();
assert User.class == constraintViolation.getRootBeanClass();
assert user == getLeafBean();
assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getInvalidValue() );

assert new Object[]{ "foo", "foo", "foo" }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "renewPassword".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "<cross-parameter>" == node.getName();
assert ElementKind.CROSS_PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

Assuming the following invocation of the `Library` constructor accepting a list of books is subject to constructor parameter validation:

```
Library anotherLibrary = new Library(null);
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateConstructorParameters()` which satisfies the following assertions:

```
//assuming an english locale, the interpolated message is returned
assert "must not be null".equals( constraintViolation.getMessage() );

assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert null == constraintViolation.getLeafBean();
assert null == constraintViolation.getInvalidValue();

assert new Object[]{ null }.equals( constraintViolation.getExecutableParameters() );
assert null == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used and parameter names can
//be obtained
assert "books".equals( node.getName() );
assert ElementKind.PARAMETER.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

Assuming the following invocation of `getMostPopularBookPerAuthor()` is subject to method return value validation and returns a `Map` containing one entry with key `author` and value `book`:

```
Map<Author, Book> mostPopularBookPerAuthor = library.getMostPopularBookPerAuthor();
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateReturnValue()` which satisfies the following assertions:

```
//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );

assert library == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert book == constraintViolation.getLeafBean();
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

assert null == constraintViolation.getExecutableParameters();
assert mostPopularBookPerAuthor == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "getMostPopularBookPerAuthor".equals( node.getName() );
assert ElementKind.METHOD.equals( node.getKind() );

node = nodeIter.next();
assert "<return value>" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert ElementKind.PROPERTY.equals( node.getKind() );
assert author.equals( node.getKey() );
assert true == node.isInIterable();

assert false == nodeIter.hasNext();
```

Assuming the following invocation of the `Library` default constructor is subject to constructor return value validation and returns an instance which violates the `@PublicLibrary` constraint:

```
Library publicLibrary = new Library();
```

Then one `ConstraintViolation` object would be returned by `ExecutableValidator.validateConstructorReturnValue()` which satisfies the following assertions:

```
assert null == constraintViolation.getRootBean();
assert Library.class == constraintViolation.getRootBeanClass();
assert publicLibrary == constraintViolation.getLeafBean();
assert publicLibrary == constraintViolation.getInvalidValue();

assert null == constraintViolation.getExecutableParameters();
assert library == constraintViolation.getExecutableReturnValue();

Iterator<Node> nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "Library".equals( node.getName() );
assert ElementKind.CONSTRUCTOR.equals( node.getKind() );

node = nodeIter.next();
assert "<return value>" == node.getName();
assert ElementKind.RETURN_VALUE.equals( node.getKind() );

assert false == nodeIter.hasNext();
```

### 6.3. Message interpolation

A message interpolator is responsible for transforming the so called message descriptor specified via the message attribute of the constraint into a fully expanded, human-readable error message.

#### 6.3.1. Default message interpolation

Every conforming Jakarta Bean Validation implementation includes a default message interpolator which has to comply with the algorithm defined here to interpolate message descriptors. As precondition for message interpolation the following applies:

* Each constraint defines a message descriptor via its `message` property.
* Every constraint definition defines a default message descriptor for that constraint.
* Messages can be overridden at constraint declaration time by setting the `message` property on the constraint.

The message descriptor is a string literal and may contain one or more message parameters or expressions. Message parameters and expressions are string literals enclosed in `{}` or `${}` respectively. The following character escaping rules apply:

* `\{` is considered as the literal `{` instead of being considered as the beginning of a message parameter
* `\}` is considered as the literal `}` instead of being considered as the end of a message parameter
* `\\` is considered as the literal `\` instead of being considered as the escaping character
* `\$` is considered as the literal `$` instead of being considered as the beginning of a message expression

Below are two examples using message parameters and expressions. The second is evaluated using Jakarta Expression Language as defined in [Message expressions using Jakarta Expression Language](#validationapi-message-defaultmessageinterpolation-expressionlanguage).

Example 6.7: Message using parameters
```
Value must be between {min} and {max}
```

Example 6.8: Message using expressions
```
Must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}
```

##### 6.3.1.1. Default message interpolation algorithm

The default message interpolator uses the following steps:

1. Message parameters are extracted from the message string and used as keys to search the `ResourceBundle` named `ValidationMessages` (often materialized as the property file `/ValidationMessages.properties` and its locale variations) using the defined locale (see [Locale for default message interpolation](#validationapi-message-defaultmessageinterpolation-locale)). If a property is found, the message parameter is replaced with the property value in the message string. Step 1 is applied recursively until no replacement is performed (i.e. a message parameter value can itself contain a message parameter).
2. Message parameters are extracted from the message string and used as keys to search the Jakarta Bean Validation provider’s built-in `ResourceBundle` using the defined locale (see [Locale for default message interpolation](#validationapi-message-defaultmessageinterpolation-locale)). If a property is found, the message parameter is replaced with the property value in the message string. Contrary to step 1, step 2 is not processed recursively.
3. If step 2 triggers a replacement, then step 1 is applied again. Otherwise step 4 is performed.
4. Message parameters are extracted from the message string. Those matching the name of an attribute of the constraint are replaced by the value of that attribute in the constraint declaration. Parameter interpolation has precedence over message expressions. For example for the message descriptor `${value}`, trying to evaluate `{value}` as message parameter has precedence over evaluating `${value}` as message expression.
5. Message expressions are extracted from the message string and evaluated using Jakarta Expression Language. See also [Message expressions using Jakarta Expression Language](#validationapi-message-defaultmessageinterpolation-expressionlanguage).

| Note | The proposed algorithm ensures that custom resource bundle always have priority over built-in resource bundle at all level of the recursive resolution. It also ensures that constraint declarations attributes values are not interpolated further. |
| --- | --- |

| Note | The precedence of message parameter over expression interpolation ensures backwards compatibility to Jakarta Bean Validation 1.0. |
| --- | --- |

##### 6.3.1.2. Locale for default message interpolation

The locale to be used for message interpolation is defined as following:

* if the locale is passed explicitly to the interpolator method via `interpolate(String, Context, Locale)`, this provided instance is used.
* otherwise, the default `Locale` as provided by `Locale.getDefault()` is used.

##### 6.3.1.3. Message expressions using Jakarta Expression Language

The default message interpolation allows the use of Jakarta Expression Language. Expressions to be evaluated by Jakarta Expression Language need to be enclosed in `${}` within the message descriptor . The following properties and beans have to be made available in the Jakarta Expression Language context:

* the attribute values of the constraint declaration mapped to their attribute name
* the validated value mapped under the name `validatedValue`.
* a bean mapped to the name `formatter` exposing the vararg method `format(String format, Object... args)`. This method must behave like `java.util.Formatter.format(String format, Object... args)`. The locale used for formatting is defined by [Locale for default message interpolation](#validationapi-message-defaultmessageinterpolation-locale). The `formatter` bean allows to format property values, for example in the case of the validated value being 98.12345678, `${formatter.format('%1$.2f', validatedValue)}` would format it to 98.12 (two digits after the decimal point, where the use of '.' vs ',' would be locale specific).

If an exception occurs during message interpolation, e.g. due to invalid expressions or references to an unknown property, the message expression stays unchanged.

#### 6.3.2. Custom message interpolation

A custom message interpolator may be provided (e.g., to interpolate contextual data, or to adjust the default `Locale` used). A message interpolator implements the `MessageInterpolator` interface.

Listing 6.5: `MessageInterpolator` interface
```
/**
 * Interpolates a given constraint violation message.
 * <p>
 * Implementations should be as tolerant as possible on syntax errors.
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {

    /**
     * Interpolates the message template based on the constraint validation context.
     * <p>
     * The locale is defaulted according to the {@code MessageInterpolator}
     * implementation. See the implementation documentation for more detail.
     *
     * @param messageTemplate the message to interpolate
     * @param context contextual information related to the interpolation
     *
     * @return interpolated error message
     */
    String interpolate(String messageTemplate, Context context);

    /**
     * Interpolates the message template based on the constraint validation context.
     * The {@code Locale} used is provided as a parameter.
     *
     * @param messageTemplate the message to interpolate
     * @param context contextual information related to the interpolation
     * @param locale the locale targeted for the message
     *
     * @return interpolated error message
     */
    String interpolate(String messageTemplate, Context context,  Locale locale);

    /**
     * Information related to the interpolation context.
     */
    interface Context {
        /**
         * @return {@link ConstraintDescriptor} corresponding to the constraint being
         * validated
         */
        ConstraintDescriptor<?> getConstraintDescriptor();

        /**
         * @return value being validated
         */
        Object getValidatedValue();

        /**
         * Returns an instance of the specified type allowing access to
         * provider-specific APIs. If the Jakarta Bean Validation provider
         * implementation does not support the specified class,
         * {@link ValidationException} is thrown.
         *
         * @param type the class of the object to be returned
         * @param <T> the type of the object to be returned
         * @return an instance of the specified class
         * @throws ValidationException if the provider does not support the call
         *
         * @since 1.1
         */
        <T> T unwrap(Class<T> type);
    }
}
```

`messageTemplate` is the value of the `message` attribute of the constraint declaration or provided to the `ConstraintValidatorContext` methods.

The `Context` object contains contextual information related to the interpolation.

`getConstraintDescriptor()` returns the `ConstraintDescriptor` object representing the metadata of the failing constraint (see [Constraint metadata request APIs](#constraintmetadata)).

`getValidatedValue()` returns the value being validated.

`MessageInterpolator.interpolate(String, Context)` is invoked for each constraint violation report generated. The default `Locale` of custom message interpolators is implementation specific.

`MessageInterpolator.interpolate(String, Context, Locale)` can be invoked by a wrapping `MessageInterpolator` to enforce a specific `Locale` value by bypassing or overriding the default `Locale` strategy (see [Use MessageInterpolator to use a specific Locale value](#validationapi-message-examples-specificlocale)).

A message interpolator implementation must be thread-safe.

The message interpolator is provided to the `ValidatorFactory` at construction time using `Configuration.messageInterpolator(MessageInterpolator)`. This message interpolator is shared by all `Validator` objects generated by this `ValidatorFactory`.

It is possible to override the `MessageInterpolator` implementation for a given `Validator` instance by invoking `ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()`.

It is recommended that `MessageInterpolator` implementations delegate final interpolation to the Jakarta Bean Validation default `MessageInterpolator` to ensure standard Jakarta Bean Validation interpolation rules are followed, The default implementation is accessible through `Configuration.getDefaultMessageInterpolator()`.

If the interpolation process leads to an exception, the exception is wrapped into a `ValidationException`.

#### 6.3.3. Examples

These examples describe message interpolation based on the default message interpolator’s built-in messages (see [Standard ResourceBundle messages](#standard-resolver-messages)), and the `ValidationMessages.properties` file shown in table [message interpolation](#table-messageinterpolation). The current locale is assumed English.

```
//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid
```

Table 6.3: message interpolation

| Failing constraint declaration | interpolated message |
| --- | --- |
| `@NotNull` | must not be null |
| `@Max(30)` | must be less than or equal to 30 |
| `@Size(min=5, max=15, message="Key must have \\{{min}\\} \\ \\{{max}\\} characters")` | Key must have {5} \ {15} characters |
| `@Digits(integer=9, fraction=2)` | numeric value out of bounds (<9 digits>.<2 digits> expected) |
| `@CreditCard(message={myapp.creditcard.error})` | credit card number not valid |

Here is an approach to specify the `Locale` value to choose on a given `Validator` using a `Locale` aware `MessageInterpolator`. See [Bootstrapping](#validationapi-bootstrapping) for more details on the APIs.

Example 6.9: Use MessageInterpolator to use a specific Locale value
```
/**
 * Delegates to a MessageInterpolator implementation but enforces a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforces the locale passed to the interpolator
     */
    @Override
    public String interpolate(String message,
                              Context context) {
        return defaultInterpolator.interpolate(message,
                                               context,
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    @Override
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}

Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();
```

Most of the time, however, the relevant `Locale` will be provided by your application framework transparently. This framework will implement its own version of `MessageInterpolator` and pass it during the `ValidatorFactory` configuration. The application will not have to set the `Locale` itself. This example shows how a container framework would implement `MessageInterpolator` to provide a user specific default locale.

Example 6.10: Contextual container possible `MessageInterpolator` implementation
```
public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) {
        this.delegate = delegate;
    }

    @Override
    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    @Override
    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}

//Build the ValidatorFactory
Configuration<?> configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator(
        new ContextualMessageInterpolator(
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();
```

### 6.4. Triggering method validation

Jakarta Bean Validation itself doesn’t trigger the evaluation of method constraints. That is, just annotating any methods or constructors with parameter or return value constraints doesn’t automatically enforce these constraints, just as annotating any fields or properties with bean constraints doesn’t enforce these either.

Instead method constraints must be validated by invoking the appropriate methods on `javax.validation.executable.ExecutableValidator`. Typically this won’t happen by manually calling these methods but rather automatically upon invocation of the constrained methods or constructors, using approaches and techniques such as Jakarta Context and Dependency Injection/Jakarta Enterprise Beans interceptors, aspect-oriented programming or dynamic proxies.

The validation of method / constructor constraints comprises the following steps:

* Intercept the method call to be validated
* Validate the parameter values provided by the method caller using `ExecutableValidator.validateParameters()` or `ExecutableValidator.validateConstructorParameters()`.
* If this validation yields a non-empty set of constraint violations, throw a `ConstraintViolationException` wrapping the violations. Otherwise proceed with the actual method invocation.
* Validate the result returned by the invoked method using `ExecutableValidator.validateReturnValue()` or `ExecutableValidator.validateConstructorReturnValue()`.
* If this validation yields a non-empty set of constraint violations, throw a `ConstraintViolationException` wrapping the violations. Otherwise return the invocation result to the method caller.

By throwing a `ConstraintViolationException` if either of the validation steps fails, it is ensured that the control flow

* only arrives at the method’s body if the caller has satisfied the method’s preconditions and
* only returns to the method caller if the method’s postconditions are guaranteed.

By default, integrators intercept and validate methods either hosting a constraint or being marked for cascaded validation (`@Valid`) whether it be on the method itself or on any of its parameters. The `Default` group is used for validation out of the box.

Integrators are encouraged to use Jakarta Bean Validation’s metadata API to find whether or not a method or a constructor should be intercepted. This guarantees that XML descriptors as well as future mapping strategies are taken into account. Note that the metadata API does not take into account the fact that a method or constructor validation has been enabled or disabled by the techniques described in [Method and constructor validation](#integration-general-executable).

Here is an example of what such metadata usage would be:

Example 6.11: Using metadata API to figure out if method interception is required
```
//For methods

// is there any constrained method on this type
// assuming we don't validate on getter execution
public boolean interceptMethods(Class<?> type) {
    return validator.getConstraintsForClass( type ).getConstrainedMethods(MethodType.NON_GETTER).size() > 0;
}

// is this method constrained
public boolean interceptMethod(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    return methodDescriptor != null;
}

// should method parameters be validated
public boolean requiresParametersValidation(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should method return value be validated?
public boolean requiresReturnValueValidation(Class<?> type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}
```

Example 6.12: Using metadata API to figure out if constructor interception is required
```
//For constructors

// is there any constrained constructor on this type
public <T> boolean interceptConstructors(Class<T> type) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    return bean.getConstrainedConstructors().size() > 0;
}

// is this constructor constrained
public <T> boolean interceptConstructor(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    return constructorDescriptor != null;
}

// should constructor parameters be validated
public <T> boolean requiresParametersValidation(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedParameters();
    }
    else {
        return false;
    }
}

// should constructor return value be validated?
public <T> boolean requiresReturnValueValidation(Class<T> type, Constructor<T> ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getName(),
        ctor.getParameterTypes()
    );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.hasConstrainedReturnValue();
    }
    else {
        return false;
    }
}
```

| Note | Calls to the metadata API is likely only going to be needed during the initialization phase of the interception framework. Results can then be cached. |
| --- | --- |

| Note | Only methods or constructors intercepted by the underlying interception technology can be validated. |
| --- | --- |

The integration technology must put the validation interceptor as late as possible (if not last) in the interception stack. In particular, validation of parameters should be done after the security and transaction start logic. Likewise, return value validation should be done before the transaction stop logic. Putting the validation interceptor as late as possible in the stack ensures this.

| Note | Why have the validation interceptor after other interceptors?  There are several reasons for delaying validation compared to other interceptors:   * You don’t want to start business code before security has been cleared * You might need transaction support in your validations * You want transaction to fail if the return value is invalid * Generally speaking, it makes more sense to apply technical layers around the more business focused constraints |
| --- | --- |

### 6.5. Bootstrapping

The bootstrapping API aims at providing a `ValidatorFactory` object which is used to create `Validator` instances. The bootstrap process is decoupled from the provider implementation initialization: a bootstrap implementation must be able to bootstrap any Jakarta Bean Validation provider implementation. The bootstrap sequence has been designed to achieve several goals:

* plug multiple implementations
* choose a specific implementation
* extensibility: an application using a specific provider implementation can use specific configurations
* share and reuse of metadata across `Validator`s
* leave as much freedom as possible to implementations
* provide integration mechanisms to Jakarta EE (starting from version 6) and other containers
* type safety

The main artifacts involved in the bootstrap process are:

* `Validation`: API entry point. Lets you optionally define the Jakarta Bean Validation provider targeted as well as a provider resolution strategy. `Validation` generates `Configuration` objects and can bootstrap any provider implementation.
* `ValidationProvider`: contract between the bootstrap procedure and a Jakarta Bean Validation provider implementation.
* `ValidationProviderResolver`: returns a list of all Jakarta Bean Validation providers available in the execution context (generally the classpath).
* `Configuration`: collects the configuration details that will be used to build `ValidatorFactory`. A specific sub interface of `Configuration` must be provided by Jakarta Bean Validation providers. This sub interface typically hosts provider specific configurations.
* `ValidatorFactory`: result of the bootstrap process. Build `Validator` instances from a given Jakarta Bean Validation provider.
* `META-INF/validation.xml`: a configuration file Jakarta Bean Validation users can use to customize the configuration of the default `ValidatorFactory`.

Let’s first see the API in action through some examples before diving into the concrete definitions.

#### 6.5.1. Examples

The most simple approach is to initialize the default Jakarta Bean Validation provider or the one defined in the XML configuration file. The `ValidatorFactory` is then ready to provide `Validator` instances.

Example 6.13: Simple Jakarta Bean Validation bootstrap sequence
```
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();
```

The `ValidatorFactory` object is thread-safe. Building `Validator` instances is typically a cheap operation. Building a `ValidatorFactory` is typically more expensive. Make sure to check your Jakarta Bean Validation implementation documentation for more accurate details.

The second example shows how a container can customize aspects like message interpolation, constraint validator instantiation and others.

Example 6.14: Customize message resolution, traversable resolver etc.
```
//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .parameterNameProvider( new AnnotationBasedParameterNameProvider() )
          .clockProvider( new BatchJobClockProvider() )
          .addValueExtractor( new TableValueExtractor() )
          .addValueExtractor( new MultiMapValueExtractor() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close();
```

The third example shows how to bootstrap Jakarta Bean Validation in an environment not following the traditional Java class loader strategies (such as tools or alternative service containers like OSGi). They can provide some alternative provider resolution strategy to discover Jakarta Bean Validation providers.

Example 6.15: Customize the Jakarta Bean Validation provider resolution mechanism
```
//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the bundle shuts down, close ValidatorFactory
factory.close();
```

The next example shows how a client can choose a specific Jakarta Bean Validation provider and configure provider specific properties programmatically in a type-safe way.

Example 6.16: Use a specific provider and add specific configuration
```
ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration<ACMEConfiguration> {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class<?> entity,
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider<ACMEConfiguration> {
    [...]
}
```

The last example shows how a `Validator` can use a specific `MessageInterpolator` implementation.

Example 6.17: Use a specific MessageInterpolator instance for a given Validator
```
ValidatorFactory factory = [...];
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale,
    factory.getMessageInterpolator()
);

Validator localizedValidator =
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();
```

In the same way, a custom `TraversableResolver` can be passed.

We will now explore the various interfaces, their constraints and usage. We will go from the `ValidatorFactory` to the `Validation` class walking up the bootstrap chain.

#### 6.5.2. ValidatorFactory

`ValidatorFactory` objects build and provide initialized instances of `Validator` to Jakarta Bean Validation clients. Each `Validator` instance is configured for a given context (message interpolator, traversable resolver etc.). Clients should cache `ValidatorFactory` objects and reuse them for optimal performances. The API is designed to allow implementors to share constraint metadata in `ValidatorFactory`. `ValidatorFactory` instances must be closed (by calling the `close()` method) by its creator when no longer in use.

`ValidatorFactory` implementations must be thread-safe. `ValidatorFactory` implementations can cache `Validator` instances if needed.

Listing 6.6: `ValidatorFactory` interface
```
/**
 * Factory returning initialized {@code Validator} instances.
 * <p>
 * Implementations are thread-safe and instances are typically cached and reused.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 * @author Guillaume Smet
 */
public interface ValidatorFactory extends AutoCloseable {

    /**
     * Returns an initialized {@link Validator} instance using the
     * factory defaults for message interpolator, traversable resolver
     * and constraint validator factory.
     * <p>
     * Validator instances can be pooled and shared by the implementation.
     *
     * @return an initialized {@code Validator} instance
     */
    Validator getValidator();

    /**
     * Defines a new validator context and returns a {@code Validator}
     * compliant this new context.
     *
     * @return a {@link ValidatorContext} instance
     */
    ValidatorContext usingContext();

    /**
     * Returns the {@link MessageInterpolator} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code MessageInterpolator} instance
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns the {@link TraversableResolver} instance configured
     * at initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code TraversableResolver} instance
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the {@link ConstraintValidatorFactory} instance
     * configured at initialization time for the
     * {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return {@code ConstraintValidatorFactory} instance
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the {@link ParameterNameProvider} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return {@code ParameterNameProvider} instance
     *
     * @since 1.1
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns the {@link ClockProvider} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return {@code ClockProvider} instance
     *
     * @since 2.0
     */
    ClockProvider getClockProvider();

    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Jakarta Bean Validation provider
     * implementation does not support the specified class, a
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @param <T> the type of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not
     *         support the call.
     */
    public <T> T unwrap(Class<T> type);

    /**
     * Closes the {@code ValidatorFactory} instance.
     *
     * After the {@code ValidatorFactory} instance is closed, calling the following
     * methods is not allowed:
     * <ul>
     *     <li>methods of this {@code ValidatorFactory} instance</li>
     *     <li>methods of {@link Validator} instances created by this
     *     {@code ValidatorFactory}</li>
     * </ul>
     *
     * @since 1.1
     */
    @Override
    public void close();
}
```

A `ValidatorFactory` is provided by a `Configuration` object.

`unwrap()` is provided as a way to access objects of a given type specific to a Jakarta Bean Validation provider typically as a complement to the `ValidatorFactory` contract. Using this method makes your code non portable.

Example 6.18: Using unwrap to access a provider specific contract
```
//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration( [...] );
```

`close()` closes the `ValidatorFactory` instance which becomes unavailable and should be immediately discarded. This is also true of all the `Validator` instances it has spawned. The behavior is undefined and non portable if these instances are used after the `ValidatorFactory` has been closed.

`getMessageInterpolator()` returns the `MessageInterpolator` instance configured during the initialization of the `ValidatorFactory`. It is particularly useful to build a `Validator` specific `MessageInterpolator` wrapping the one from the `ValidatorFactory`.

`getTraversableResolver()` returns the `TraversableResolver` instance configured during the initialization of the `ValidatorFactory`. It is particularly useful to build a `Validator` specific `TraversableResolver` wrapping the one from the `ValidatorFactory`.

`getConstraintValidatorFactory()` returns the `ConstraintValidatorFactory` instance configured during the initialization of the `ValidatorFactory`. It is particularly useful to build a `Validator` specific `ConstraintValidatorFactory` wrapping the one from the `ValidatorFactory`.

`getParameterNameProvider()` returns the `ParameterNameProvider` instance configured during the initialization of the `ValidatorFactory`. It is particularly useful to build a `Validator` specific `ParameterNameProvider` wrapping the one from the `ValidatorFactory`.

`getClockProvider()` returns the `ClockProvider` instance configured during the initialization of the `ValidatorFactory`. It is particularly useful to build a `Validator` specific `ClockProvider` wrapping the one from the `ValidatorFactory`.

`ValidatorContext` returned by `usingContext()` can be used to customize the state in which the `Validator` must be initialized. This is used to customize the `MessageInterpolator`, the `TraversableResolver`, the `ParameterNameProvider`, the `ClockProvider` or the `ConstraintValidatorFactory`.

Listing 6.7: `ValidatorContext` interface
```
/**
 * Represents the context that is used to create {@link Validator}
 * instances.
 *
 * A client may use methods of the {@code ValidatorContext} returned by
 * {@link ValidatorFactory#usingContext()} to customize
 * the context used to create {@code Validator} instances
 * (for instance establish different message interpolators or
 * traversable resolvers).
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Guillaume Smet
 */
public interface ValidatorContext {

    /**
     * Defines the message interpolator implementation used by the
     * {@link Validator}.
     * <p>
     * If not set or if {@code null} is passed as a parameter,
     * the message interpolator of the {@link ValidatorFactory}
     * is used.
     *
     * @param messageInterpolator the {@link MessageInterpolator} used by the
     * {@code Validator}
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * Defines the traversable resolver implementation used by the
     * {@link Validator}.
     * <p>
     * If not set or if {@code null} is passed as a parameter,
     * the traversable resolver of the {@link ValidatorFactory} is used.
     *
     * @param traversableResolver the {@code TraversableResolver} used by the
     * {@code Validator}
     * @return self following the chaining method pattern
     */
    ValidatorContext traversableResolver(TraversableResolver traversableResolver);

    /**
     * Defines the constraint validator factory implementation used by the
     * {@link Validator}.
     * If not set or if {@code null} is passed as a parameter,
     * the constraint validator factory of the {@link ValidatorFactory} is used.
     *
     * @param factory the {@link ConstraintValidatorFactory} used by the {@code Validator}
     * @return self following the chaining method pattern
     */
    ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory factory);

    /**
     * Defines the parameter name provider implementation used by the
     * {@link Validator}. If not set or if {@code null} is passed as a parameter,
     * the parameter name provider of the {@link ValidatorFactory} is used.
     *
     * @param parameterNameProvider parameter name provider implementation.
     * @return self following the chaining method pattern
     *
     * @since 1.1
     */
    ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Defines the {@link ClockProvider} implementation used by the {@link Validator}.
     * If not set or if {@code null} is passed as a parameter,
     * the clock provider of the {@link ValidatorFactory} is used.
     *
     * @param clockProvider {@code ClockProvider} implementation
     * @return self following the chaining method pattern
     *
     * @since 2.0
     */
    ValidatorContext clockProvider(ClockProvider clockProvider);

    /**
     * Adds a value extractor to be used by the {@link Validator}. Has
     * priority over any extractor for the same type and type parameter
     * detected through the service loader, given in the XML configuration or
     * configured for the validator factory.
     *
     * @param extractor value extractor implementation
     * @return self following the chaining method pattern
     * @throws ValueExtractorDeclarationException if more than one extractor for
     *         the same type and type parameter is added
     * @since 2.0
     */
    ValidatorContext addValueExtractor(ValueExtractor<?> extractor);

    /**
     * Returns an initialized {@link Validator} instance respecting the defined state.
     * {@code Validator} instances can be pooled and shared by the implementation.
     *
     * @return contextualized {@code Validator}
     */
    Validator getValidator();
}
```

The `MessageInterpolator`, the `TraversableResolver`, the `ConstraintValidatorFactory`, the `ParameterNameProvider` or the `ClockProvider` passed to the `ValidatorContext` are used instead of the `ValidatorFactory`'s `MessageInterpolator`, `TraversableResolver`, `ConstraintValidatorFactory`, `ParameterNameProvider` or `ClockProvider` instances.
A `ValueExtractorDeclarationException` is raised if more than one extractor for the same type and type parameter is added via `addValueExtractor()`.

Example 6.19: Use of ValidatorFactory
```
ValidatorFactory factory = [...];
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();
```

See [Use MessageInterpolator to use a specific Locale value](#validationapi-message-examples-specificlocale) for an example using `ValidatorFactory.getMessageInterpolator()`.

#### 6.5.3. Configuration

The responsibility of the `Configuration` is to collect configuration information, to determine the correct provider implementation and to delegate the `ValidatorFactory` creation to the selected provider. More concretely `Configuration` lets you define:

* the message interpolator instance
* the traversable resolver instance
* the constraint validator factory instance
* the parameter name provider instance
* the clock provider instance
* value extractor instances
* XML constraint mappings
* provider specific properties
* whether or not `META-INF/validation.xml` is considered

`Configuration` does provide a `MessageInterpolator` implementation following the default Jakarta Bean Validation `MessageInterpolator` rules as defined in [Default message interpolation](#validationapi-message-defaultmessageinterpolation). You can access it by calling `getDefaultMessageInterpolator()`. Such an implementation is useful to let a custom `MessageInterpolator` delegate to the standard `MessageInterpolator` (see [Custom message interpolation](#validationapi-message-customresolution) and an example making use of `getDefaultMessageInterpolator()` in [Contextual container possible `MessageInterpolator` implementation](#validationapi-message-examples-faceslocale)).

`Configuration` does provide a `TraversableResolver` implementation following the default Jakarta Bean Validation `TraversableResolver` rules as defined in [Traversable property](#constraintdeclarationvalidationprocess-validationroutine-traversable). You can access it by calling `getDefaultTraversableResolver()`. Such an implementation is useful to let a custom `TraversableResolver` delegate to the standard `TraversableResolver`.

`Configuration` does provide a `ConstraintValidatorFactory` implementation following the default Jakarta Bean Validation `ConstraintValidatorFactory` rules as defined in [The ConstraintValidatorFactory](#constraintsdefinitionimplementation-constraintfactory). You can access it by calling `getDefaultConstraintValidatorFactory()`. Such an implementation is useful to let a custom `ConstraintValidatorFactory` delegate to the standard `ConstraintValidatorFactory`.

`Configuration` does provide a `ParameterNameProvider` implementation following the default Jakarta Bean Validation `ParameterNameProvider` rules as defined in [Naming parameters](#constraintdeclarationvalidationprocess-methodlevelconstraints-parameterconstraints-namingparameters). You can access it by calling `getDefaultParameterNameProvider()`. Such an implementation is useful to let a custom `ParameterNameProvider` delegate to the standard `ParameterNameProvider`.

`Configuration` does provide a `ClockProvider` implementation following the default Jakarta Bean Validation `ClockProvider` rules as defined in [Implementation of temporal constraint validators](#constraintsdefinitionimplementation-validationimplementation-temporalvalidators). You can access it by calling `getDefaultClockProvider()`.

Via `getBootstrapConfiguration()`, `Configuration` also exposes data stored in `META-INF/validation.xml` (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)). This is particularly useful for containers wishing to control the instance creation and lifecycle (more information at [Bootstrapping considerations](#validationapi-bootstrapping-usageandcontainerexpectation)).

| Note | `BootstrapConfiguration.getDefaultValidatedExecutableTypes()` and `BootstrapConfiguration.isExecutableValidationEnabled()` are not used by the Jakarta Bean Validation engine but exposed here for interception technologies - see [Method and constructor validation](#integration-general-executable). |
| --- | --- |

Via `addValueExtractor()`, additional value extractor implementations can be added to the configuration.
A value extractor for a given type and type parameter takes precedence over any extractor for the same type and type parameter
detected through the service loader or given in the XML configuration.
A `ValueExtractorDeclarationException` is raised if more than one extractor for the same type and type parameter is added.

Using `addMapping()`, additional constraint mapping XML descriptors can be added to the configuration (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)). The given input streams should support the `mark()` and `reset()` methods defined by `java.io.InputStream`. Streams not supporting the `mark()` and `reset()` methods will be wrapped with an `InputStream` implementation supporting these methods by the Jakarta Bean Validation provider in order to allow the streams to be read several times.

Clients call `Configuration.buildValidatorFactory()` to retrieve the initialized `ValidatorFactory` instance. It is legal to invoke `buildValidatorFactory()` several times, e.g. in order to retrieve several `ValidatorFactory` instances with a slightly different configuration (see [Using Configuration to create several validator factories](#using-configuration-several-times)).

Listing 6.8: `Configuration` and `BootstrapConfiguration` interfaces
```
/**
 * Receives configuration information, selects the appropriate
 * Jakarta Bean Validation provider and builds the appropriate {@link ValidatorFactory}.
 * <p>
 * Usage:
 * <pre>
 * //provided by one of the Validation bootstrap methods
 * Configuration&lt;?&gt; configuration =
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();
 * </pre>
 * <p>
 * By default, the configuration information is retrieved from
 * {@code META-INF/validation.xml}.
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the {@code Configuration} methods.
 * <p>
 * The {@link ValidationProviderResolver} is specified at configuration time
 * (see {@link ValidationProvider}).
 * If none is explicitly requested, the default {@code ValidationProviderResolver} is used.
 * <p>
 * The provider is selected in the following way:
 * <ul>
 *     <li>if a specific provider is requested programmatically using
 *     {@link Validation#byProvider(Class)}, find the first provider implementing
 *     the provider class requested and use it</li>
 *     <li>if a specific provider is requested in {@code META-INF/validation.xml},
 *     find the first provider implementing the provider class requested and use it</li>
 *     <li>otherwise, use the first provider returned by the
 *     {@code ValidationProviderResolver}</li>
 * </ul>
 * <p>
 * Implementations are not meant to be thread-safe.
 *
 * @param <T> the type of a provider-specific specialization of this contract
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 * @author Guillaume Smet
 */
public interface Configuration<T extends Configuration<T>> {

    /**
     * Ignores data from the {@code META-INF/validation.xml} file if this
     * method is called.
     * <p>
     * This method is typically useful for containers that parse
     * {@code META-INF/validation.xml} themselves and pass the information
     * via the {@code Configuration} methods.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T ignoreXmlConfiguration();

    /**
     * Defines the message interpolator used. Has priority over the configuration
     * based message interpolator.
     * <p>
     * If {@code null} is passed, the default message interpolator is used
     * (defined in XML or the specification default).
     *
     * @param interpolator message interpolator implementation
     * @return {@code this} following the chaining method pattern
     */
    T messageInterpolator(MessageInterpolator interpolator);

    /**
     * Defines the traversable resolver used. Has priority over the configuration
     * based traversable resolver.
     * <p>
     * If {@code null} is passed, the default traversable resolver is used
     * (defined in XML or the specification default).
     *
     * @param resolver traversable resolver implementation
     * @return {@code this} following the chaining method pattern
     */
    T traversableResolver(TraversableResolver resolver);

    /**
     * Defines the constraint validator factory. Has priority over the configuration
     * based constraint factory.
     * <p>
     * If {@code null} is passed, the default constraint validator factory is used
     * (defined in XML or the specification default).
     *
     * @param constraintValidatorFactory constraint factory implementation
     * @return {@code this} following the chaining method pattern
     */
    T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

    /**
     * Defines the parameter name provider. Has priority over the configuration
     * based provider.
     * <p>
     * If {@code null} is passed, the default parameter name provider is used
     * (defined in XML or the specification default).
     *
     * @param parameterNameProvider parameter name provider implementation
     * @return {@code this} following the chaining method pattern.
     *
     * @since 1.1
     */
    T parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Defines the clock provider. Has priority over the configuration
     * based provider.
     * <p>
     * If {@code null} is passed, the default clock provider is used
     * (defined in XML or the specification default).
     *
     * @param clockProvider clock provider implementation
     * @return {@code this} following the chaining method pattern.
     *
     * @since 2.0
     */
    T clockProvider(ClockProvider clockProvider);

    /**
     * Adds a value extractor. Has priority over any extractor for the same
     * type and type parameter detected through the service loader or given in
     * the XML configuration.
     *
     * @param extractor value extractor implementation
     * @return {@code this} following the chaining method pattern.
     * @throws ValueExtractorDeclarationException if more than one extractor for
     *         the same type and type parameter is added
     * @since 2.0
     */
    T addValueExtractor(ValueExtractor<?> extractor);

    /**
     * Add a stream describing constraint mapping in the Jakarta Bean Validation XML
     * format.
     * <p>
     * The stream should be closed by the client API after the
     * {@link ValidatorFactory} has been built. The Jakarta Bean Validation provider
     * must not close the stream.
     *
     * @param stream
     *        XML mapping stream; the given stream should support the
     *        mark/reset contract (see {@link InputStream#markSupported()});
     *        if it doesn't, it will be wrapped into a stream supporting the
     *        mark/reset contract by the Jakarta Bean Validation provider
     *
     * @return {@code this} following the chaining method pattern
     * @throws IllegalArgumentException if {@code stream} is null
     */
    T addMapping(InputStream stream);

    /**
     * Adds a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If the underlying provider does not know how to handle the property,
     * it must silently ignore it.
     * <p>
     * Note: Using this non type-safe method is generally not recommended.
     * <p>
     * It is more appropriate to use, if available, the type-safe equivalent provided
     * by a specific provider via its {@link Configuration} subclass.
     * <pre>
     * ValidatorFactory factory = Validation.byProvider(ACMEProvider.class)
     *     .configure()
     *         .providerSpecificProperty(ACMEState.FAST)
     *     .buildValidatorFactory();
     * </pre>
     * This method is typically used by containers parsing {@code META-INF/validation.xml}
     * themselves and injecting the state to the {@code Configuration} object.
     * <p>
     * If a property with a given name is defined both via this method and in the
     * XML configuration, the value set programmatically has priority.
     * <p>
     * If {@code null} is passed as a value, the value defined in XML is used. If no value
     * is defined in XML, the property is considered unset.
     *
     * @param name property name
     * @param value property value
     * @return {@code this} following the chaining method pattern
     * @throws IllegalArgumentException if {@code name} is null
     */
    T addProperty(String name, String value);

    /**
     * Returns an implementation of the {@link MessageInterpolator} interface
     * following the default {@code MessageInterpolator} defined in the
     * specification:
     * <ul>
     *     <li>use the {@code ValidationMessages} resource bundle to load keys</li>
     *     <li>use {@code Locale.getDefault()}</li>
     * </ul>
     *
     * @return default {@code MessageInterpolator} implementation compliant with the
     *         specification
     */
    MessageInterpolator getDefaultMessageInterpolator();

    /**
     * Returns an implementation of the {@link TraversableResolver} interface
     * following the default {@code TraversableResolver} defined in the
     * specification:
     * <ul>
     *     <li>if Java Persistence is available in the runtime environment,
     *     a property is considered reachable if Java Persistence considers
     *     the property as loaded</li>
     *     <li>if Java Persistence is not available in the runtime environment,
     *     all properties are considered reachable</li>
     *     <li>all properties are considered cascadable.</li>
     * </ul>
     *
     * @return default {@code TraversableResolver} implementation compliant with the
     *         specification
     */
    TraversableResolver getDefaultTraversableResolver();

    /**
     * Returns an implementation of the {@link ConstraintValidatorFactory} interface
     * following the default {@code ConstraintValidatorFactory} defined in the
     * specification:
     * <ul>
     *     <li>uses the public no-arg constructor of the {@link ConstraintValidator}</li>
     * </ul>
     *
     * @return default {@code ConstraintValidatorFactory} implementation compliant with the
     *         specification
     */
    ConstraintValidatorFactory getDefaultConstraintValidatorFactory();

    /**
     * Returns an implementation of the {@link ParameterNameProvider}
     * interface following the default {@code ParameterNameProvider}
     * defined in the specification:
     * <ul>
     *     <li>returns the actual parameter names as provided in the validated
     *     executable’s definition, if the class file of the executable contains
     *     parameter name information</li>
     *     <li>
     *     otherwise returns names in the form {@code arg&lt;PARAMETER_INDEX&gt;},
     *     where {@code PARAMETER_INDEX} starts at 0 for the first parameter,
     *     e.g. {@code arg0}, {@code arg1} etc.</li>
     * </ul>
     *
     * @return default {@code ParameterNameProvider} implementation compliant with
     *         the specification
     *
     * @since 1.1
     */
    ParameterNameProvider getDefaultParameterNameProvider();

    /**
     * Returns an implementation of the {@link ClockProvider}
     * interface following the default {@code ClockProvider}
     * defined in the specification:
     * <ul>
     *     <li>returns a clock representing the current system time and default time
     *     zone.</li>
     * </ul>
     *
     * @return default {@code ClockProvider} implementation compliant with
     *         the specification
     *
     * @since 2.0
     */
    ClockProvider getDefaultClockProvider();

    /**
     * Returns configuration information stored in the {@code META-INF/validation.xml} file.
     * <p>
     * <b>Note</b>:
     * <br>
     * Implementations are encouraged to lazily build this object to delay parsing.
     *
     * @return returns an instance of {@link BootstrapConfiguration}; this method never
     *         returns {@code null}; if there is no {@code META-INF/validation.xml} the
     *         different getters of the returned instance will return {@code null}
     *         respectively an empty set or map
     *
     * @since 1.1
     */
    BootstrapConfiguration getBootstrapConfiguration();

    /**
     * Build a {@link ValidatorFactory} implementation.
     *
     * @return the {@code ValidatorFactory}
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    ValidatorFactory buildValidatorFactory();
}
```

```
/**
 * Represents the user specified default configuration in
 * {@code META-INF/validation.xml}.
 * <p>
 * Note that modifications to the returned objects do not have any effect.
 * Instead use the methods provided on {@link Configuration} in order to
 * apply modifications to the configuration.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 * @author Guillaume Smet
 * @since 1.1
 */
public interface BootstrapConfiguration {

    /**
     * Class name of the {@link ValidationProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return validation provider class name or {@code null}
     */
    String getDefaultProviderClassName();

    /**
     * Class name of the {@link ConstraintValidatorFactory} implementation
     * or {@code null} if none is specified.
     *
     * @return constraint validator factory class name or {@code null}
     */
    String getConstraintValidatorFactoryClassName();

    /**
     * Class name of the {@link MessageInterpolator} implementation
     * or {@code null} if none is specified.
     *
     * @return message interpolator class name or {@code null}
     */
    String getMessageInterpolatorClassName();

    /**
     * Class name of the {@link TraversableResolver} implementation
     * or {@code null} if none is specified.
     *
     * @return traversable resolver class name or {@code null}
     */
    String getTraversableResolverClassName();

    /**
     * Class name of the {@link ParameterNameProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return parameter name provider class name or {@code null}
     */
    String getParameterNameProviderClassName();

    /**
     * Class name of the {@link ClockProvider} implementation or
     * {@code null} if none is specified.
     *
     * @return clock provider class name or {@code null}
     *
     * @since 2.0
     */
    String getClockProviderClassName();

    /**
     * Returns the class names of {@link ValueExtractor}s.
     *
     * @return the value extractor class names or an empty set if none are specified
     * @since 2.0
     */
    Set<String> getValueExtractorClassNames();

    /**
     * Returns a set of resource paths pointing to XML constraint mapping files.
     * The set is empty if none are specified.
     *
     * @return set of constraint mapping resource paths
     */
    Set<String> getConstraintMappingResourcePaths();

    /**
     * Returns true if the validation execution is explicitly marked as enabled
     * or if it is left undefined.
     *
     * @return whether validation execution is globally enabled
     */
    boolean isExecutableValidationEnabled();

    /**
     * Returns the set of executable types that should be considered
     * unless explicitly overridden via {@link ValidateOnExecution}.
     * <p>
     * Returns a set containing {@link ExecutableType#CONSTRUCTORS} and
     * {@link ExecutableType#NON_GETTER_METHODS} if unspecified in the configuration.
     *
     * @return set of validated executable types
     */
    Set<ExecutableType> getDefaultValidatedExecutableTypes();

    /**
     * Returns properties as a map of string based key/value pairs.
     * The map is empty if no property has been specified.
     *
     * @return the properties map
     */
    Map<String, String> getProperties();
}
```

A Jakarta Bean Validation provider must define a sub interface of `Configuration` uniquely identifying the provider. This subclass is linked to its provider via the `ValidationProvider` generic parameter. The `Configuration` sub interface typically hosts provider specific configuration methods.

To facilitate the use of provider specific configuration methods, `Configuration` uses generics: `Configuration<T extends Configuration<T>>` ; the generic return type `T` is returned by chaining methods. The provider specific sub interface must resolve the generic T as itself as shown in [Example of provider specific Configuration sub interface](#example-providerspecific-config).

Example 6.20: Example of provider specific Configuration sub interface
```
/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration
    extends Configuration<ACMEConfiguration> {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}
```

When `Configuration.buildValidatorFactory()` is called, the initialized `ValidatorFactory` is returned. More specifically, the requested Jakarta Bean Validation provider is determined and the result of `validationProvider.buildValidatorFactory(ConfigurationState)` is returned. `ConfigurationState` gives access to the configuration artifacts defined in `META-INF/validation.xml` (unless XML configuration is ignored) and provided programmatically to `Configuration`. Generally speaking, programmatically defined elements have priority over XML defined configuration elements (read the `Configuration` JavaDoc and see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration) for more information).

| Note | A typical implementation of `Configuration` also implements `ConfigurationState`, hence `this` can be passed to `buildValidatorFactory(ConfigurationState)`. |
| --- | --- |

Streams represented in the XML configuration and opened by the `Configuration` implementation must be closed by the `Configuration` implementation after the `ValidatorFactory` creation (or if an exception occurs). Streams provided programmatically are the responsibility of the application.

Listing 6.9: `ConfigurationState` interface
```
package javax.validation.spi;

/**
 * Contract between a {@link Configuration} and a
 * {@link ValidationProvider} to create a {@link ValidatorFactory}.
 * <p>
 * The configuration artifacts defined in the XML configuration and provided to the
 * {@code Configuration} are merged and passed along via
 * {@code ConfigurationState}.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 * @author Guillaume Smet
 */
public interface ConfigurationState {

    /**
     * Returns {@code true} if {@link Configuration#ignoreXmlConfiguration()} has been
     * called.
     * <p>
     * In this case, the {@link ValidatorFactory} must ignore
     * {@code META-INF/validation.xml}.
     *
     * @return {@code true} if {@code META-INF/validation.xml} should be ignored
     */
    boolean isIgnoreXmlConfiguration();

    /**
     * Returns the message interpolator of this configuration.
     * <p>
     * Message interpolator is defined in the following decreasing priority:
     * <ul>
     *     <li>set via the {@link Configuration} programmatic API</li>
     *     <li>defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is false. In this case the instance
     *     is created via its no-arg constructor.</li>
     *     <li>{@code null} if undefined.</li>
     * </ul>
     *
     * @return message interpolator instance or {@code null} if not defined
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns a set of configuration streams.
     * <p>
     * The streams are defined by:
     * <ul>
     *     <li>mapping XML streams passed programmatically in {@link Configuration}</li>
     *     <li>mapping XML streams located in the resources defined in
     *     {@code META-INF/validation.xml} (constraint-mapping element)</li>
     * </ul>
     * <p>
     * Streams represented in the XML configuration and opened by the
     * {@code Configuration} implementation must be closed by the
     * {@code Configuration} implementation after the {@link ValidatorFactory}
     * creation (or if an exception occurs). All streams are guaranteed to
     * adhere to the mark/reset contract (see {@link InputStream#markSupported()}
     * by the Jakarta Bean Validation provider.
     *
     * @return set of input stream
     */
    Set<InputStream> getMappingStreams();

    /**
     * Returns a set of value extractors.
     * <p>
     * The extractors are retrieved from the following sources in decreasing
     * order:
     * <ul>
     *     <li>extractors passed programmatically to {@link Configuration}</li>
     *     <li>extractors defined in {@code META-INF/validation.xml} provided
     *     that {@code ignoredXmlConfiguration} is {@code false}</li>
     *     <li>extractors loaded through the Java service loader</li>
     * </ul>
     * An extractor for a given type and type parameter passed in
     * programmatically takes precedence over any extractor for the same type
     * and type parameter defined in {@code META-INF/validation.xml} or loaded
     * through the service loader. Extractors defined in
     * {@code META-INF/validation.xml} take precedence over any extractor for
     * the same type and type parameter loaded through the service loader.
     * <p>
     * Extractors defined in {@code META-INF/validation.xml} or loaded through
     * the service loader are instantiated using their no-arg constructor.
     *
     * @return set of value extractors; may be empty but never {@code null}
     *
     * @since 2.0
     */
    Set<ValueExtractor<?>> getValueExtractors();

    /**
     * Returns the constraint validator factory of this configuration.
     * <p>
     * The {@link ConstraintValidatorFactory} implementation is defined in the following
     * decreasing priority:
     * <ul>
     *     <li>set via the {@link Configuration} programmatic API</li>
     *     <li>defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoredXmlConfiguration} is {@code false}. In this case the instance
     *     is created via its no-arg constructor.</li>
     *     <li>{@code null} if undefined.</li>
     * </ul>
     *
     * @return factory instance or {@code null} if not defined
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the traversable resolver for this configuration.
     * <p>
     * {@link TraversableResolver} is defined in the following decreasing priority:
     * <ul>
     *     <li>set via the {@link Configuration} programmatic API</li>
     *     <li>defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoredXmlConfiguration} is {@code false}. In this case the
     *     instance is created via its no-arg constructor.</li>
     *     <li>{@code null} if undefined.</li>
     * </ul>
     *
     * @return traversable resolver instance or {@code null} if not defined
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the parameter name provider for this configuration.
     * <p>
     * {@link ParameterNameProvider} is defined in the following decreasing priority:
     * <ul>
     *     <li>set via the {@link Configuration} programmatic API</li>
     *     <li>defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is {@code false}. In this case the instance
     *     is created via its no-arg constructor.</li>
     *     <li>{@code null} if undefined.</li>
     * </ul>
     *
     * @return parameter name provider instance or {@code null} if not defined
     *
     * @since 1.1
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns the clock provider for this configuration.
     * <p>
     * {@link ClockProvider} is defined in the following decreasing priority:
     * <ul>
     *     <li>set via the {@link Configuration} programmatic API</li>
     *     <li>defined in {@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is {@code false}. In this case the instance
     *     is created via its no-arg constructor.</li>
     *     <li>{@code null} if undefined.</li>
     * </ul>
     *
     * @return clock provider instance or {@code null} if not defined
     *
     * @since 2.0
     */
    ClockProvider getClockProvider();

    /**
     * Returns a map of non type-safe custom properties.
     * <p>
     * Properties defined via:
     * <ul>
     *     <li>{@link Configuration#addProperty(String, String)}</li>
     *     <li>{@code META-INF/validation.xml} provided that
     *     {@code ignoreXmlConfiguration} is {@code false}.</li>
     * </ul>
     * <p>
     * If a property is defined both programmatically and in XML,
     * the value defined programmatically has priority.
     *
     * @return {@code Map} whose key is the property key and the value
     *         the property value
     */
    Map<String, String> getProperties();
}
```

The requested provider implementation is resolved according to the following rules in the following order:

* Use the provider implementation requested if `Configuration` has been created from `Validation.byProvider(Class)`.
* Use the provider implementation described in the XML configuration (under `validation-config.default-provider` see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)) if defined: the value of this element is the fully qualified class name of the `ValidationProvider` implementation uniquely identifying the provider.
* Use the first provider implementation returned by `validationProviderResolver.getValidationProviders()`.

The `ValidationProviderResolver` is specified when `Configuration` instances are created (see `ValidationProvider`). If no `ValidationProviderResolver` instance has been specified, the default `ValidationProviderResolver` is used.

`Configuration` instances are provided to the Jakarta Bean Validation client through the `Validation` methods. `Configuration` instances are created by `ValidationProvider`.

If a problem occurs while building the `ValidatorFactory`, a `ValidationException` is raised. This can be due to various reasons including:

* malformed XML configuration
* malformed XML mapping
* inability to find the provider (or a provider)
* inability to instantiate extension classes provided in the XML configuration
* inconsistent XML mapping (entity declared more than once, incorrect field etc.)
* invalid constraint declaration or definition

Other exception causes may occur.

Here is an example of `Configuration` use.

Example 6.21: Use Configuration
```
Configuration<?> configuration = [...];
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();
```

The following shows an example of setting up a `Configuration`, retrieving a validator factory from it, subsequently altering the configuration and then retrieving another factory:

Example 6.22: Using Configuration to create several validator factories
```
Configuration<?> configuration = [...];
ValidatorFactory factory1 = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .buildValidatorFactory();

ValidatorFactory factory2 = configuration
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();
```

Here, `factory1` is set up using a custom message interpolator, while `factory2` is set up using the same message interpolator and additionally using a custom traversable resolver.

#### 6.5.4. ValidationProvider and ValidationProviderResolver

`ValidationProvider` is the contract between the bootstrap process and a specific Jakarta Bean Validation provider. `ValidationProviderResolver` implements the discovery mechanism for Jakarta Bean Validation provider implementations. Any Jakarta Bean Validation client can implement such a discovery mechanism but it is typically implemented by containers having specific class loader structures and restrictions.

##### 6.5.4.1. ValidationProviderResolver

`ValidationProviderResolver` returns the list of Jakarta Bean Validation providers available at runtime and more specifically a `ValidationProvider` instance for each provider available in the context. This service can be customized by implementing `ValidationProviderResolver`. Implementations must be thread-safe.

Listing 6.10: `ValidationProviderResolver` interface
```
/**
 * Determines the list of Jakarta Bean Validation providers available in the runtime environment
 * <p>
 * Jakarta Bean Validation providers are identified by the presence of
 * {@code META-INF/services/javax.validation.spi.ValidationProvider}
 * files following the Service Provider pattern described
 * <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider">here</a>.
 * <p>
 * Each {@code META-INF/services/javax.validation.spi.ValidationProvider} file contains the
 * list of {@link ValidationProvider} implementations each of them representing a provider.
 * <p>
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {

    /**
     * Returns a list of {@link ValidationProvider} available in the runtime environment.
     *
     * @return list of validation providers
     */
    List<ValidationProvider<?>> getValidationProviders();
}
```

By default, providers are resolved using the Service Provider pattern described in [http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider](https://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider). Jakarta Bean Validation providers must supply a service provider configuration file by creating a text file `javax.validation.spi.ValidationProvider` and placing it in the `META-INF/services` directory of one of its jar files. The content of the file contains the name of the provider implementation class of the `javax.validation.spi.ValidationProvider` interface.

Jakarta Bean Validation provider jars may be installed or made available in the same ways as other service providers, e.g. as extensions or added to the application classpath according to the guidelines in the JAR file specification.

The default `ValidationProviderResolver` implementation will locate all the Jakarta Bean Validation providers by their provider configuration files visible in the classpath. The default `ValidationProviderResolver` implementation is recommended and custom `ValidationProviderResolver` implementations should be rarely used. A typical use of a custom resolution is resolving providers in a class loader constrained container like OSGi or in a tool environment (IDE).

The default `ValidationProviderResolver` can be accessed via `BootStrapState.getDefaultValidationProviderResolver()`. This method is typically used by the Jakarta Bean Validation provider `Configuration` implementation.

##### 6.5.4.2. ValidationProvider

`ValidationProvider` represents the SPI (Service Provider Interface) defining the contract between the provider discovery and initialization mechanism, and the provider. A `ValidationProvider` does:

* Provide a generic `Configuration` implementation (i.e. not tied to a given provider).
* Provide a provider specific `Configuration` implementation. This `Configuration` will specifically build `ValidatorFactory` instances of the provider it comes from.
* Build a `ValidatorFactory` object from the configuration provided by `ConfigurationState`.

Listing 6.11: `ValidationProvider` interface
```
package javax.validation.spi;

/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * <p>
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * @param <T> the provider specific Configuration subclass which typically host provider's
 * additional configuration methods
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider<T extends Configuration<T>> {

    /**
     * Returns a {@link Configuration} instance implementing {@code T},
     * the {@code Configuration} sub-interface.
     * The returned {@code Configuration} instance must use the current provider
     * ({@code this}) to build the {@code ValidatorFactory} instance.
     *
     * @param state bootstrap state
     * @return specific {@code Configuration} implementation
     */
    T createSpecializedConfiguration(BootstrapState state);

    /**
     * Returns a {@link Configuration} instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@code Configuration}
     * <p>
     * The {@link ValidationProviderResolver} used by {@code Configuration}
     * is provided by {@code state}.
     * If null, the default {@code ValidationProviderResolver} is used.
     *
     * @param state bootstrap state
     * @return non specialized Configuration implementation
     */
    Configuration<?> createGenericConfiguration(BootstrapState state);

    /**
     * Build a {@link ValidatorFactory} using the current provider implementation.
     * <p>
     * The {@code ValidatorFactory} is assembled and follows the configuration passed
     * via {@link ConfigurationState}.
     * <p>
     * The returned {@code ValidatorFactory} is properly initialized and ready for use.
     *
     * @param configurationState the configuration descriptor
     * @return the instantiated {@code ValidatorFactory}
     * @throws ValidationException if the {@code ValidatorFactory} cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}
```

Listing 6.12: `BootstrapState` interface
```
package javax.validation.spi;

/**
 * Defines the state used to bootstrap the {@link Configuration}.
 *
 * @author Emmanuel Bernard
 * @author Sebastian Thomschke
 */
public interface BootstrapState {

    /**
     * User defined {@code ValidationProviderResolver} strategy
     * instance or {@code null} if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();

    /**
     * Specification default {@code ValidationProviderResolver}
     * strategy instance.
     *
     * @return default implementation of ValidationProviderResolver
     */
    ValidationProviderResolver getDefaultValidationProviderResolver();
}
```

A client can request a specific Jakarta Bean Validation provider by using `<T extends Configuration<T>, U extends ValidationProvider<T>> Validation.byProvider(Class<U>)` or by defining the provider in the XML configuration file. The key uniquely identifying a Jakarta Bean Validation provider is the `ValidationProvider` implementation specific to this provider.

A `ValidationProvider` implementation is linked (via its generic parameter) to a specific sub interface of `Configuration`. The Jakarta Bean Validation bootstrap API makes use of this link to return the specific `Configuration` subinterface implementation in a type-safe way when a specific provider is requested. The sub interface does not have to add any new methods but is the natural holder for provider specific configuration methods.

Example 6.23: Example of provider specific Configuration sub interface
```
/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration
    extends Configuration<ACMEConfiguration> {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider<ACMEConfiguration> {
    [...]
}
```

| Note | `Configuration` references itself in the generic definition. Methods of `Configuration` will return the `ACMEConfiguration` making the API easy to use even for vendor specific extensions. |
| --- | --- |

The provider discovery mechanism uses the following algorithm:

* Retrieve available providers using `ValidationProviderResolver.getValidationProviders()`.
* The first `ValidationProvider` matching the requested provider is returned. Providers are evaluated in the order they are returned by `ValidationProviderResolver`. A provider instance is considered matching if it is assignable to the requested provider class.

When the default Jakarta Bean Validation provider is requested, the first `ValidationProvider` returned by the `ValidationProviderResolver` strategy is returned.

Every Jakarta Bean Validation provider must provide a `ValidationProvider` implementation containing a public no-arg constructor and add the corresponding `META-INF/services/javax.validation.spi.ValidationProvider` file descriptor in one of its jars.

If a problem occurs while building the `ValidatorFactory`, a `ValidationException` is raised. This can be due to various reasons including:

* malformed XML mapping
* inability to find the provider (or a provider)
* inability to instantiate extension classes provided in the XML configuration
* inconsistent XML mapping (entity declared more than once, incorrect field etc.)
* invalid constraint declaration or definition

#### 6.5.5. Validation

The `Validation` class is the entry point used to bootstrap Jakarta Bean Validation providers. The first entry point, `buildDefaultValidatorFactory()`, is considered to be the default `ValidatorFactory` and is equivalent to the `ValidatorFactory` returned by `Validation.byDefaultProvider().configure().buildValidatorFactory()`.

Example 6.24: Validation methods available
```
/**
 * This class is the entry point for Jakarta Bean Validation.
 * <p>
 * There are three ways to bootstrap it:
 * <ul>
 *     <li>The easiest approach is to build the default {@link ValidatorFactory}.
 *     <pre>
 * ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
 * </pre>
 *     In this case, the default validation provider resolver
 *     will be used to locate available providers.
 *     <p>
 *     The chosen provider is defined as followed:
 *     <ul>
 *         <li>if the XML configuration defines a provider, this provider is used</li>
 *         <li>if the XML configuration does not define a provider or if no XML
 *         configuration is present the first provider returned by the
 *         {@link ValidationProviderResolver} instance is used.</li>
 *     </ul>
 *     </li>
 *     <li>
 *     The second bootstrap approach allows to choose a custom
 *     {@code ValidationProviderResolver}. The chosen
 *     {@link ValidationProvider} is then determined in the same way
 *     as in the default bootstrapping case (see above).
 *     <pre>
 * Configuration&lt;?&gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * </pre>
 *     </li>
 *     <li>
 *     The third approach allows you to specify explicitly and in
 *     a type safe fashion the expected provider.
 *     <p>
 *     Optionally you can choose a custom {@code ValidationProviderResolver}.
 *     <pre>
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEProvider.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();
 * </pre>
 *     </li>
 * </ul>
 * <p>
 * Note:
 * <ul>
 *     <li>
 *     The {@code ValidatorFactory} object built by the bootstrap process should be cached
 *     and shared amongst {@code Validator} consumers.
 *     </li>
 *     <li>This class is thread-safe.</li>
 * </ul>
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public class Validation {

    /**
     * Builds and returns a {@link ValidatorFactory} instance based on the
     * default Jakarta Bean Validation provider and following the XML configuration.
     * <p>
     * The provider list is resolved using the default validation provider resolver
     * logic.
     * <p>
     * The code is semantically equivalent to
     * {@code Validation.byDefaultProvider().configure().buildValidatorFactory()}.
     *
     * @return {@code ValidatorFactory} instance
     *
     * @throws NoProviderFoundException if no Jakarta Bean Validation provider was found
     * @throws ValidationException if a Jakarta Bean Validation provider was found but the
     * {@code ValidatorFactory} cannot be built
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Builds a {@link Configuration}. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * <pre>
     * Configuration&lt;?&gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * </pre>
     * The provider can be specified in the XML configuration. If the XML
     * configuration does not exist or if no provider is specified,
     * the first available provider will be returned.
     *
     * @return instance building a generic {@code Configuration}
     *         compliant with the bootstrap state provided
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Builds a {@link Configuration} for a particular provider implementation.
     * <p>
     * Optionally overrides the provider resolution strategy used to determine the provider.
     * <p>
     * Used by applications targeting a specific provider programmatically.
     * <pre>
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEProvider.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * </pre>,
     * where {@code ACMEConfiguration} is the
     * {@code Configuration} sub interface uniquely identifying the
     * ACME Jakarta Bean Validation provider. and {@code ACMEProvider} is the
     * {@link ValidationProvider} implementation of the ACME provider.
     *
     * @param providerType the {@code ValidationProvider} implementation type
     * @param <T> the type of the {@code Configuration} corresponding to this
     *        {@code ValidationProvider}
     * @param <U> the type of the {@code ValidationProvider} implementation
     *
     * @return instance building a provider specific {@code Configuration}
     *         sub interface implementation
     */
    public static <T extends Configuration<T>, U extends ValidationProvider<T>>
    ProviderSpecificBootstrap<T> byProvider(Class<U> providerType) {
        [...]
    }

    [...]
}
```

The second entry point lets the client provide a custom `ValidationProviderResolver` instance. This instance is passed to `GenericBootstrap`. `GenericBootstrap` builds a generic `Configuration` using the first `ValidationProvider` returned by `ValidationProviderResolution` and calling `ValidationProvider.createGenericConfiguration(BootstrapState state)`. `BootstrapState` holds the `ValidationProviderResolution` instance passed to `GenericBootstrap` and will be used by the `Configuration` instance when resolving the provider to use. Note that `ValidationProvider.createGenericConfiguration` returns a `Configuration` object not bound to any particular provider.

Listing 6.13: `GenericBootstrap` interface
```
package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Jakarta Bean Validation and
 * creates a provider agnostic {@link Configuration}.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {

    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the {@link Configuration}.
     * <p>
     * If no resolver is defined, the default {@link ValidationProviderResolver}
     * implementation is used.
     *
     * @param resolver the {@code ValidationProviderResolver} to use for bootstrapping
     * @return {@code this} following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic {@link Configuration} implementation.
     * At this stage the provider used to build the {@link ValidatorFactory}
     * is not defined.
     * <p>
     * The {@code Configuration} implementation is provided by the first provider
     * returned by the {@link ValidationProviderResolver} strategy.
     *
     * @return a {@code Configuration} implementation compliant with the bootstrap state
     * @throws NoProviderFoundException if no Jakarta Bean Validation provider was found
     * @throws ValidationException if a Jakarta Bean Validation provider was found but the
     *         {@code Configuration} object cannot be built; this is generally due to an
     *         issue with the {@code ValidationProviderResolver}
     */
    Configuration<?> configure();
}
```

The last entry point lets the client define the specific Jakarta Bean Validation provider requested as well as a custom `ValidationProviderResolver` implementation if needed. The entry point method, `Validation.byProvider(Class<U> providerType)`, takes the provider specific `ValidationProvider` implementation type and returns a `ProviderSpecificBootstrap` object that guarantees to return an instance of the specific `Configuration` sub interface. Thanks to the use of generics, the client API does not have to cast to the `Configuration` sub interface.

A `ProviderSpecificBootstrap` object can optionally receive a `ValidationProviderResolver` instance.

Listing 6.14: `ProviderSpecificBootstrap` interface
```
package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Jakarta Bean Validation and
 * creates a provider specific {@link Configuration}
 * of type {@code T}.
 * <p>
 * The specific {@code Configuration} is linked to the provider via the generic
 * parameter of the {@link ValidationProvider} implementation.
 * <p>
 * The requested provider is the first provider instance assignable to
 * the requested provider type (known when {@link ProviderSpecificBootstrap} is built).
 * The list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no {@code ValidationProviderResolver} is defined, the
 * default {@code ValidationProviderResolver} strategy is used.
 *
 * @param <T> the provider specific {@link Configuration} type
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap<T extends Configuration<T>> {

    /**
     * Optionally defines the provider resolver implementation used.
     * If not defined, use the default {@link ValidationProviderResolver}
     *
     * @param resolver {@code ValidationProviderResolver} implementation used
     *
     * @return {@code this} following the chaining method pattern
     */
    public ProviderSpecificBootstrap<T> providerResolver(
            ValidationProviderResolver resolver);

    /**
     * Determines the provider implementation suitable for {@code T} and delegates
     * the creation of this specific {@link Configuration} subclass to the provider.
     *
     * @return {@code Configuration} sub interface implementation
     *
     * @throws ValidationException if the {@code Configuration} object cannot be built;
     *         this is generally due to an issue with the {@code ValidationProviderResolver}
     */
    public T configure();
}
```

`ProviderSpecificBootstrap.configure()` must return the result of `ValidationProvider.createSpecializedConfiguration(BootstrapState state)`. The state parameter holds the `ValidationProviderResolver` passed to `ProviderSpecificBootstrap`. The validation provider instance used is the one assignable to the type passed as a parameter in `Validation.byProvider(Class)`. The validation provider is selected according to the algorithm described in [ValidationProvider](#validationapi-bootstrapping-validationprovider-provider).

The `Validation` implementation must not contain any non private attribute or method aside from the three public static bootstrap methods:

* `public static ValidatorFactory buildDefaultValidatorFactory()`
* `public static GenericBootstrap byDefaultProvider()`
* `public static <T extends Configuration<T>, U extends ValidationProvider<T>> ProviderSpecificBootstrap<T> byProvider(Class<U> providerType)`

The bootstrap API is designed to allow complete portability among Jakarta Bean Validation provider implementations. The bootstrap implementation must ensure it can bootstrap third party providers.

When bootstrapping a Jakarta Bean Validation provider, if the `ValidationProviderResolver` either fails or if the expected provider is not found, a `ValidationException` is raised.

#### 6.5.6. XML configuration: META-INF/validation.xml

Unless explicitly ignored by calling `Configuration.ignoreXMLConfiguration()`, a `Configuration` takes into account the configuration available in `META-INF/validation.xml`. This configuration file is optional but can be used by applications to refine some of the Jakarta Bean Validation behavior. If more than one `META-INF/validation.xml` file is found in the classpath, a `ValidationException` is raised.

Unless stated otherwise, XML based configuration settings are overridden by values explicitly set via the `Configuration` API. For example, the `MessageInterpolator` defined via `Configuration.messageInterpolator(MessageInterpolator)` has priority over the `message-interpolator` definition.

`default-provider`: represents the class name of the provider specific `ValidationProvider` implementation class. If defined, the specific provider is used (unless a specific provider has been chosen via the programmatic approach).

`message-interpolator`: represents the fully qualified class name of the `MessageInterpolator` implementation. When defined in XML, the implementation must have a public no-arg constructor.

`traversable-resolver`: represents the fully qualified class name of the `TraversableResolver` implementation. When defined in XML, the implementation must have a public no-arg constructor.

`constraint-validator-factory`: represents the fully qualified class name of the `ConstraintValidatorFactory` implementation. When defined in XML, the implementation must have a public no-arg constructor.

`parameter-name-provider`: represents the fully qualified class name of the `ParameterNameProvider` implementation. When defined in XML, the implementation must have a public no-arg constructor.

`clock-provider`: represents the fully qualified class name of the `ClockProvider` implementation. When defined in XML, the implementation must have a public no-arg constructor.

`value-extractor`: represents the fully qualified class name of a `ValueExtractor` implementation.
`value-extractor` can be given several times for declaring multiple extractors.
When defined in XML, the implementation must have a public no-arg constructor.
An extractor for a given type and type parameter configured via XML takes precedence
over any extractor for the same type and type parameter detected through the service loader or provided by the Jakarta Bean Validation implementation itself.
If more than one value extractor for the same type and type parameter is configured via XML, a `ValueExtractorDeclarationException` is raised.

`executable-validation`: allows to disable executable validation entirely via its attribute `enabled="false"` and optionally contains `default-validated-executable-types`. `enabled` defaults to `true`.

`default-validated-executable-types`: declared under `executable-validation`, contains the list of `executable-type` that are considered by default by the integration technology validating executables upon execution.

`constraint-mapping`: represents the resource path of an XML mapping file. More than one `constraint-mapping` element can be present. Mappings provided via `Configuration.addMapping(InputStream)` are added to the list of mappings described via `constraint-mapping`.

`property`: represents a key/value pair property providing room to provider specific configurations. Vendors should use vendor namespaces for properties (e.g., `com.acme.validation.logging`). Entries that make use of the namespace `javax.validation` and its subnamespaces must not be used for vendor-specific information. The namespace `javax.validation` is reserved for use by this specification. Properties defined via `Configuration.addProperty(String, String)` are added to the properties defined via `property`. If a property with the same name are defined in both XML and via the programmatic API, the value provided via programmatic API has priority.

All these top level elements are optional.

If a public no-arg constructor is missing on any of the classes referenced by the relevant XML elements, a `ValidationException` is raised during the `Configuration.buildValidatorFactory()` call.

Example 6.25: Example of META-INF/validation.xml file
```
<?xml version="1.0" encoding="UTF-8"?>
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
        version="2.0">
    <default-provider>com.acme.ACMEProvider</default-provider>
    <message-interpolator>com.acme.ACMEAwareMessageInterpolator</message-interpolator>

    <executable-validation>
        <default-validated-executable-types>
            <executable-type>NONE</executable-type>
        </default-validated-executable-types>
    </executable-validation>

    <constraint-mapping>META-INF/validation/order-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/catalog-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/customer-constraints.xml</constraint-mapping>

    <property name="com.acme.validation.logging">WARN</property>
    <property name="com.acme.validation.safetyChecking">failOnError</property>

</validation-config>
```

The XML schema is described in [Configuration schema](#xml-config-xsd).

#### 6.5.7. Bootstrapping considerations

The Jakarta Bean Validation bootstrap API can be used directly by any application or made available through a container or other framework. In all cases, the following rules apply:

* `ValidatorFactory` is a thread-safe object that should be built once per deployment unit.
* `ValidatorFactory` should be closed when it is no longer needed (e.g. when the unit is undeployed or the server stopped).
* `Validator` is a thread-safe and lightweight object which can be cached by the `ValidatorFactory` instance.

## 7. Constraint metadata request APIs

The Jakarta Bean Validation specification provides a way to query the constraint repository. This API is expected to be used for tooling support as well as integration with other frameworks, libraries and other specifications. The Jakarta Bean Validation specification aims to provide both a validation engine and a metadata repository for object constraints. Frameworks (EE or SE) in need for constraint definition, validation and metadata will be able to rely on the Jakarta Bean Validation specification for these services avoiding any unnecessary duplication work from an application and infrastructure point of view.

### 7.1. Validator

The main API to access all metadata related to a given object is `Validator` (see [Bootstrapping](#validationapi-bootstrapping) for more information on how to retrieve a `Validator` instance).

A `Validator` instance hosts the method to access to the metadata repository for a given class. It is recommended to leave the caching of `Validator` instances to the `ValidatorFactory`. `Validator` implementations are thread-safe.

Example 7.1: Validator interface (metadata request API)
```
/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    [...] //See 5.1
    /**
     * Returns the descriptor object describing bean constraints.
     * <p>
     * The returned object (and associated objects including
     * {@link ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     * @return the bean descriptor for the specified class
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     *         during the metadata discovery or if some
     *         constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class<?> clazz);

}
```

`getConstraintsForClass()` returns a `BeanDescriptor` object describing the bean level constraints (see [Object validation](#constraintdeclarationvalidationprocess-requirements-objectvalidation)) and providing access to the property level constraints metadata. An `IllegalArgumentException` is raised if the `clazz` parameter is null.

If a constraint definition or declaration hosted by the requested class (or any of its superclasses and interfaces according to the constraint propagation rules) is invalid, a `ValidationException` is raised. This can be a subclass of `ValidationException` like `ConstraintDefinitionException`, `ConstraintDeclarationException` or `UnexpectedTypeException`.

All descriptor types accessible via `getConstraintsForClass()` and introduced in the following sections are located in the package `javax.validation.metadata`.

### 7.2. ElementDescriptor

`ElementDescriptor` is the root interface describing elements hosting constraints. It is used to describe the list of constraints for a given element (whether it be a class, property, method etc.).

Listing 7.1: `ElementDescriptor` interface and `Scope` enum
```
package javax.validation.metadata;

/**
 * Describes a validated element (class, property, method etc.).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ElementDescriptor {

    /**
     * @return returns {@code true} if at least one constraint declaration is present
     *         for this element in the class hierarchy, {@code false} otherwise
     */
    boolean hasConstraints();

    /**
     * @return the statically defined returned type
     */
    Class<?> getElementClass();

    /**
     * Returns all constraint descriptors for this element in the class hierarchy
     * or an empty {@code Set} if none are present.
     *
     * @return {@code Set} of constraint descriptors for this element
     */
    Set<ConstraintDescriptor<?>> getConstraintDescriptors();

    /**
     * Finds constraints and potentially restricts them to certain criteria.
     *
     * @return {@code ConstraintFinder} object
     */
    ConstraintFinder findConstraints();

    /**
     * Declares restrictions on retrieved constraints.
     * Restrictions are cumulative.
     * <p>
     * A {@code ConstraintFinder} is not thread-safe. The set of matching
     * {@link ConstraintDescriptor} is.
     */
    interface ConstraintFinder {

        /**
         * Restricts to the constraints matching a given set of groups for this element.
         * <p>
         * This method respects group conversion, group sequences
         * and group inheritance (including class-level {@link Default} group
         * overriding) but does not return {@link ConstraintDescriptor}s
         * in any particular order.
         * Specifically, ordering of the group sequence is not respected.
         *
         * @param groups groups targeted
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder unorderedAndMatchingGroups(Class<?>... groups);

        /**
         * Restricts to the constraints matching the provided scope for this element.
         *
         * Defaults to {@link Scope#HIERARCHY}
         *
         * @param scope expected scope
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder lookingAt(Scope scope);

        /**
         * Restricts to the constraints hosted on the listed {@code types}
         * for a given element.
         * <p>
         * Defaults to all possible types of the element.
         * <p>
         * Typically used to restrict to fields ({@code FIELD})
         * or getters ({@code METHOD}).
         *
         * @param types targeted types
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder declaredOn(ElementType... types);

        /**
         * Retrieves the constraint descriptors following the defined
         * restrictions and hosted on the element described by
         * {@link ElementDescriptor}.
         *
         * @return matching constraint descriptors
         */
        Set<ConstraintDescriptor<?>> getConstraintDescriptors();

        /**
         * Returns {@code true} if at least one constraint declaration
         * matching the restrictions is present on the element,
         * {@code false} otherwise.
         *
         * @return {@code true} if there is at least one constraint
         */
        boolean hasConstraints();
    }
}
```

Listing 7.2: `Scope` enum
```
package javax.validation.metadata;

/**
 * Scope looked at when discovering constraints.
 *
 * @author Emmanuel Bernard
 */
public enum Scope {

    /**
     * Look for constraints declared on the current class element
     * and ignore inheritance and elements with the same name in
     * the class hierarchy.
     */
    LOCAL_ELEMENT,

    /**
     * Look for constraints declared on all elements of the class hierarchy
     * with the same name.
     */
    HIERARCHY
}
```

`getElementClass()` returns

* the object type when invoked on `BeanDescriptor`,
* the type of a property or parameter when invoked on `PropertyDescriptor` or `ParameterDescriptor` respectively,
* `Object[].class` when invoked on `CrossParameterDescriptor`,
* the return type when invoked on `ConstructorDescriptor`, `MethodDescriptor` or `ReturnValueDescriptor`,
* the container element type when invoked on `ContainerElementTypeDescriptor` (e.g. when invoked on a descriptor representing the container element type of `List<String>`, `String.class` will be returned).

`getConstraintDescriptors()` returns all the `ConstraintDescriptor`s (see [ConstraintDescriptor](#constraintmetadata-constraintdescriptor)) hosted on the given element in the class hierarchy, each `ConstraintDescriptor` describing one of the constraints declared on the given element.

`hasConstraints()` returns `true` if the given element in the class hierarchy holds at least one constraint declaration.

If you need to query the metadata API in a more fine grained way for example by restricting the constraints to the ones described on fields or on getters or by restricting to a given set of groups, you can use the `ConstraintFinder` fluent API by calling `findConstraints()`.

`unorderedAndMatchingGroups()` restricts the results to the `ConstraintDescriptor`s (see [ConstraintDescriptor](#constraintmetadata-constraintdescriptor)) matching the given groups. Order is not respected but group inheritance and inheritance via sequence (including the `Default` group overriding at the class level) are honored.

`declaredOn()` lets you restrict the list of element types constraints are hosted on. This is particularly useful to retrieve property constraints only hosted on fields (`ElementType.FIELD`) or only hosted on getters (`ElementType.METHOD`).

`lookingAt()` lets you restrict which constraints are considered. Either constraints belonging to the element but hosted on the class represented by the given descriptor (`Scope.LOCAL_ELEMENT`), or constraints belonging to the element but hosted anywhere in the class hierarchy (`Scope.HIERARCHY`).

Here is an example restricting the list of constraints on getters, matching the default group and declared physically on the `name` getter of `Customer` (and not any of the getters on the super classes).

Example 7.2: Using the fluent API to restrict matching constraints
```
public class User {

    @Size(max=50)
    String getName() {
        [...]
    }

    [...]
}

public class Customer extends User {

    @NotNull
    String getName() {
        [...]
    }
}

PropertyDescriptor pd =
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set<ConstraintDescriptor<?>> constraints =
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
        .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints().getConstraintDescriptors();
assert 2 == constraints.size();
```

The following example shows how the fluent API is used to retrieve parameter, cross-parameter and return value constraints, taking into account locally declared constraints as well as constraints declared in the inheritance hierarchy.

Example 7.3: Using the fluent API to select method and constructor constraints
```
public class User {

    public User(@Size(max=50) String name) {
        [...]
    }

    @PasswordParametersMatch
    @NotNull
    public String resetPassword(
        @NotNull @Size(min=8) String password,
        @NotNull @Size(min=8) String confirmation) {
        [...]
    }
}

public class Customer extends User {

    public Customer(@NotNull String name) {
        [...]
    }

    @Size(min=8)
    public String resetPassword(String password, String confirmation) {
        [...]
    }
}

MethodDescriptor methodDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForMethod( "resetPassword", String.class, String.class );

//one cross-parameter constraint
assert 1 == methodDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size();

//one local return value constraint
assert 1 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.LOCAL_ELEMENT )
    .getConstraintDescriptors()
    .size();

//two return value constraints in the complete hierarchy
assert 2 == methodDescriptor.getReturnValueDescriptor()
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();

//two parameter constraints, defined on overridden method
assert 2 == methodDescriptor.getParameterDescriptors()
    .get( 0 )
    .getConstraintDescriptors()
    .size();

ConstructorDescriptor constructorDescriptor = validator
    .getConstraintsForClass( Customer.class )
    .getConstraintsForConstructor( String.class );

//one parameter constraint; constraints from super constructor don't apply
assert 1 == constructorDescriptor.getParameterDescriptors()
    .get( 0 )
    .findConstraints()
    .lookingAt( Scope.HIERARCHY )
    .getConstraintDescriptors()
    .size();
```

### 7.3. BeanDescriptor

The `BeanDescriptor` interface describes a constrained Java Bean. This interface is returned by `Validator.getConstraintsForClass(Class<?>)`.

Listing 7.3: `BeanDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a constrained Java Bean and the constraints associated to it. All
 * objects returned by the methods of this descriptor (and associated objects
 * including {@link ConstraintDescriptor}s) are immutable.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface BeanDescriptor extends ElementDescriptor {

    /**
     * Returns {@code true} if the bean involves validation:
     * <ul>
     *     <li>a constraint is hosted on the bean itself</li>
     *     <li>a constraint is hosted on one of the bean properties</li>
     *     <li>or a bean property is marked for cascaded validation ({@link Valid})</li>
     * </ul>
     * <p>
     * Constrained methods and constructors are ignored.
     *
     * @return {@code true} if the bean involves validation, {@code false} otherwise
     */
    boolean isBeanConstrained();

    /**
     * Returns the property descriptor for a given property.
     * <p>
     * Returns {@code null} if the property does not exist or has no
     * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()})
     * Properties of super types are considered.
     *
     * @param propertyName property evaluated
     * @return the property descriptor for a given property
     * @throws IllegalArgumentException if {@code propertyName} is {@code null}
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * Returns a set of property descriptors having at least one constraint defined
     * or marked as cascaded ({@link Valid}).
     * <p>
     * If no property matches, an empty set is returned.
     * Properties of super types are considered.
     *
     * @return the set of {@link PropertyDescriptor}s for the constraint properties; if
     *         there are no constraint properties, the empty set is returned
     */
    Set<PropertyDescriptor> getConstrainedProperties();

    /**
     * Returns a method descriptor for the given method.
     * <p>
     * Returns {@code null} if no method with the given name and parameter types
     * exists or the specified method neither has parameter or return value constraints nor a
     * parameter or return value marked for cascaded validation.
     * Methods of super types are considered.
     *
     * @param methodName the name of the method
     * @param parameterTypes the parameter types of the method
     * @return a method descriptor for the given method
     * @throws IllegalArgumentException if {@code methodName} is {@code null}
     *
     * @since 1.1
     */
    MethodDescriptor getConstraintsForMethod(String methodName, Class<?>... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained methods of the bean
     * represented by this descriptor.
     * <p>
     * Constrained methods have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     * Methods of super types are considered.
     * <p>
     * Only methods matching the given method type(s) are considered.
     *
     * @param methodType method type to consider
     * @param methodTypes remaining optional method types to consider
     * @return a set with descriptors for the constrained methods of this bean;
     *         will be empty if this bean has no constrained methods of the considered
     *         method type(s) but never {@code null}
     *
     * @since 1.1
     */
    Set<MethodDescriptor> getConstrainedMethods(MethodType methodType,
                                                MethodType... methodTypes);

    /**
     * Returns a constructor descriptor for the given constructor.
     * <p>
     * Returns {@code null} if no constructor with the given parameter types
     * exists or the specified constructor neither has parameter or return value
     * constraints nor a parameter or return value marked for cascaded
     * validation.
     *
     * @param parameterTypes the parameter types of the constructor
     * @return a constructor descriptor for the given constructor
     *
     * @since 1.1
     */
    ConstructorDescriptor getConstraintsForConstructor(Class<?>... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained constructors of the
     * bean represented by this descriptor.
     * <p>
     * Constrained constructors have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     *
     * @return a set with descriptors for the constrained constructor of this
     *         bean; will be empty if this bean has no constrained constructor
     *         but never {@code null}
     *
     * @since 1.1
     */
    Set<ConstructorDescriptor> getConstrainedConstructors();
}
```

Listing 7.4: `MethodType` enum
```
package javax.validation.metadata;

/**
 * Represents the type of a method: getter or non getter.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum MethodType {

    /**
     * A method following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * <ul>
     *     <li>name starts with get, has a return type but no parameter</li>
     *     <li>name starts with is, has a return type and is returning {@code boolean}.</li>
     * </ul>
     */
    GETTER,

    /**
     * A method that does not follow the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * <ul>
     *     <li>name starts with get, has a return type but no parameter</li>
     *     <li>name starts with is, has a return type and is returning {@code boolean}.</li>
     * </ul>
     */
    NON_GETTER
}
```

`isBeanConstrained()` returns `true` if the given class (and superclasses and interfaces) has at least one class-level or property-level constraint or validation cascade. If the method returns false, the Jakarta Bean Validation engine can safely ignore the bean as it will not be impacted by validation.

`getConstraintsForProperty()` returns a `PropertyDescriptor` object describing the property level constraints (See [Field and property validation](#constraintdeclarationvalidationprocess-requirements-propertyvalidation)). The property is uniquely identified by its name as per the JavaBeans convention: field level and getter level constraints of the given name are all returned. An `IllegalArgumentException` is raised if the `propertyName` parameter is null.

`getConstrainedProperties()` returns the `PropertyDescriptor`s of the bean properties having at least one constraint or being cascaded (`@Valid` annotation).

`getConstraintsForMethod()` returns a `MethodDescriptor` object describing the method constraints of the given method. The method is uniquely identified by its name and the types of its parameters.

`getConstrainedMethods()` returns the `MethodDescriptor`s of the methods matching the `MethodType`s provided as parameter and having at least one constraint or cascaded parameter or return value.

`getConstraintsForConstructor()` returns a `ConstructorDescriptor` object describing the method constraints of the given constructor. The constructor is uniquely identified by its name and the types of its parameters.

`getConstrainedConstructors()` returns the `ConstructorDescriptor`s of the constructors having at least one constraint or cascaded parameter or return value.

### 7.4. CascadableDescriptor

The `CascadableDescriptor` interface describes a cascadable element, i.e. an element which can be marked with `@Valid` in order to perform a cascaded validation of the element as described in [Graph validation](#constraintdeclarationvalidationprocess-requirements-graphvalidation).

Listing 7.5: `CascadableDescriptor` interface
```
package javax.validation.metadata;

/**
 * Represents a cascadable element.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface CascadableDescriptor {

    /**
     * Whether this element is marked for cascaded validation or not.
     *
     * @return {@code true}, if this element is marked for cascaded validation,
     *         {@code false} otherwise
     */
    boolean isCascaded();

    /**
     * Returns the group conversions configured for this element.
     *
     * @return a set containing this element's group conversions; an empty set
     *         may be returned if no conversions are configured but never
     *         {@code null}
     */
    Set<GroupConversionDescriptor> getGroupConversions();
}
```

The `isCascaded()` method returns `true` if the element is marked for cascaded validation.

The method `getGroupConversions()` returns a set with the group conversions declared for the cascadable element. An empty set will be returned if no group conversions are configured.

### 7.5. GroupConversionDescriptor

The `GroupConversionDescriptor` interface describes a group conversion rule configured for a cascadable element as described in [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion). It is returned by `CascadableDescriptor.getGroupConversions()`.

Listing 7.6: `GroupConversionDescriptor` interface
```
package javax.validation.metadata;

/**
 * A group conversion rule to be applied during cascaded validation. Two group
 * conversion descriptors are considered equal if they have the same
 * {@code from} and {@code to} group respectively.
 *
 * @author Gunnar Morling
 * @see ConvertGroup
 * @since 1.1
 */
public interface GroupConversionDescriptor {

    /**
     * Returns the source group of this conversion rule.
     *
     * @return the source group of this conversion rule
     */
    Class<?> getFrom();

    /**
     * Returns the target group of this conversion rule.
     *
     * @return the target group of this conversion rule
     */
    Class<?> getTo();
}
```

The `getFrom()` method returns the source of a group conversion rule.

The `getTo()` method returns the target of a group conversion rule.

### 7.6. PropertyDescriptor

The `PropertyDescriptor` interface describes a constrained property of a Java Bean.

This interface is returned by `BeanDescriptor.getConstraintsForProperty(String)` or `BeanDescriptor.getConstrainedProperties()`. Constraints declared on the attribute and the getter of the same name according to the JavaBeans rules are returned by this descriptor.

Listing 7.7: `PropertyDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter of a given property
 * are all referenced.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor, CascadableDescriptor, ContainerDescriptor {

    /**
     * Name of the property according to the Java Bean specification.
     *
     * @return property name
     */
    String getPropertyName();
}
```

`getPropertyName()` returns the property name as described in [ConstraintViolation](#validationapi-constraintviolation).

### 7.7. ExecutableDescriptor, MethodDescriptor and ConstructorDescriptor

The `ExecutableDescriptor` interface describes a constrained method or constructor of a Java type.

Listing 7.8: `ExecutableDescriptor` interface
```
package javax.validation.metadata;

/**
 * Provides the common functionality of {@link MethodDescriptor} and
 * {@link ConstructorDescriptor}.
 *
 * @author Gunnar Morling
 *
 * @since 1.1
 */
public interface ExecutableDescriptor extends ElementDescriptor {

    /**
     * Returns the method name in case this descriptor represents a method or
     * the non-qualified name of the declaring class in case this descriptor
     * represents a constructor.
     *
     * @return the name of the executable represented by this descriptor
     */
    String getName();

    /**
     * Returns a list of descriptors representing this executable's
     * parameters, in the order of their declaration, including synthetic
     * parameters.
     *
     * @return a list of descriptors representing this executable's
     *         parameters; an empty list will be returned if this executable has
     *         no parameters, but never {@code null}
     */
    List<ParameterDescriptor> getParameterDescriptors();

    /**
     * Returns a descriptor containing the cross-parameter constraints
     * of this executable.
     *
     * @return a descriptor containing the cross-parameter constraints of
     *         this executable
     */
    CrossParameterDescriptor getCrossParameterDescriptor();

    /**
     * Returns a descriptor for this executable's return value.
     * <p>
     * An executable without return value will return a descriptor
     * representing {@code void}. This descriptor will have no constraint
     * associated.
     *
     * @return a descriptor for this executable's return value
     */
    ReturnValueDescriptor getReturnValueDescriptor();

    /**
     * Returns {@code true} if the executable parameters are constrained either:
     * <ul>
     *     <li>because of a constraint on at least one of the parameters</li>
     *     <li>because of a cascade on at least one of the parameters (via
     *     {@link Valid})</li>
     *     <li>because of at least one cross-parameter constraint</li>
     * </ul>
     * <p>
     * Also returns {@code false} if there is no parameter.
     *
     * @return {@code true} if the executable parameters are constrained
     */
    boolean hasConstrainedParameters();

    /**
     * Returns {@code true} if the executable return value is constrained
     * either:
     * <ul>
     *     <li>because of a constraint on the return value</li>
     *     <li>because validation is cascaded on the return value (via
     *     {@link Valid})</li>
     * </ul>
     * <p>
     * Also returns {@code false} if there is no return value.
     *
     * @return {@code true} if the executable return value is constrained
     */
    boolean hasConstrainedReturnValue();

    /**
     * Returns {@code false}.
     * <p>
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return {@code false}
     */
    @Override
    boolean hasConstraints();

    /**
     * Returns an empty {@code Set}.
     * <p>
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return an empty {@code Set}
     */
    @Override
    Set<ConstraintDescriptor<?>> getConstraintDescriptors();

    /**
     * Returns a finder that will always return an empty {@code Set}.
     * <p>
     * An executable per se does not host constraints, use
     * {@link #getParameterDescriptors()}, {@link #getCrossParameterDescriptor()}
     * and {@link #getReturnValueDescriptor()} to discover constraints.
     *
     * @return {@code ConstraintFinder} object
     */
    @Override
    ConstraintFinder findConstraints();
}
```

`getName()` returns the name of the represented method (e.g. "placeOrder") respectively the non-qualified name of the declaring class of the represented constructor (e.g. "OrderService").

`getParameterDescriptors()` returns a list of `ParameterDescriptor`s representing the method’s or constructor’s parameters in order of their declaration, including synthetic parameters. An empty list will be returned in case the method or constructor has no parameters.

`getCrossParameterDescriptor()` returns a descriptor containing cross-parameter constraints of the method or constructor. If no cross-parameter constraint is present, the descriptor will return an empty set of constraint descriptors.

`getReturnValueDescriptor()` returns a descriptor for the method’s or constructor’s return value. A descriptor representing the special class `void`, without any constraint descriptors, will be returned for executables which have no return value.

`hasConstrainedParameters()` returns `true` if any of the parameters is constrained or cascaded or if the represented executable has at least one cross-parameter constraint. Returns `false` if there is no parameter.

`hasConstrainedReturnValue()` returns `true` if the return value is constrained or cascaded. Returns `false` if there is no return value.

The methods `hasConstraints()`, `getConstraintDescriptors()` and `findConstraints()` defined on `ElementDescriptor` are redefined to clarify that executables do not host constraints directly and thus will always return `false` or an empty set of constraints, respectively. Constraint descriptors for individual parameters can be obtained from the corresponding `ParameterDescriptor` object, constraint descriptors for cross-parameter constraints can be obtained from the corresponding `CrossParameterDescriptor` object and constraint descriptors for the return value can be obtained from `ReturnValueDescriptor`.

The interfaces `MethodDescriptor` and `ConstructorDescriptor` are derived from `ExecutableDescriptor` and allow to distinguish between descriptors representing methods and descriptors representing constructors.

Listing 7.9: `MethodDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a validated method.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface MethodDescriptor extends ExecutableDescriptor {
}
```

Listing 7.10: `ConstructorDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a validated constructor.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface ConstructorDescriptor extends ExecutableDescriptor {
}
```

`MethodDescriptor` objects are returned by `BeanDescriptor.getConstraintsForMethod(String, Class<?>…​)` and `BeanDescriptor.getConstrainedMethods(MethodType, MethodType…​)`, while `ConstructorDescriptor` objects are returned by `BeanDescriptor.getConstraintsForConstructor(Class<?>…​)` and `BeanDescriptor.getConstrainedConstructors()`.

None of the metadata API methods honor the XML configuration around executable validation nor the presence of `@ValidateOnExecution`. In other words, all constrained methods and constructors will be returned by the metadata API regardless of these settings.

### 7.8. ParameterDescriptor

The `ParameterDescriptor` interface describes a constrained parameter of a method or constructor.

This interface is returned by `MethodDescriptor.getParameterDescriptors()` and `ConstructorDescriptor.getParameterDescriptors()`.

Listing 7.11: `ParameterDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a validated method or constructor parameter.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ParameterDescriptor extends ElementDescriptor, CascadableDescriptor,
        ContainerDescriptor {

    /**
     * Returns this parameter's index within the parameter array of the method
     * or constructor holding it.
     *
     * @return this parameter's index
     */
    int getIndex();

    /**
     * Returns this parameter's name as retrieved by the current parameter name
     * resolver.
     *
     * @return this parameter's name
     */
    String getName();
}
```

`getIndex()` returns the index of the represented parameter within the parameter array of the method or constructor holding it.

`getName()` returns the name of the represented parameter.

### 7.9. CrossParameterDescriptor

The `CrossParameterDescriptor` interface describes an element containing all cross-parameter constraints of a method or constructor.

This interface is returned by `MethodDescriptor.getCrossParameterDescriptor()` and `ConstructorDescriptor.getCrossParameterDescriptor()`.

Listing 7.12: `CrossParameterDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes an element holding cross-parameter constraints of a method or constructor
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface CrossParameterDescriptor extends ElementDescriptor {

    /**
     * @return {@code Object[].class} - the type of the parameter array
     */
    @Override
    Class<?> getElementClass();
}
```

`getElementClass()` returns `Object[]`.

### 7.10. ReturnValueDescriptor

The `ReturnValueDescriptor` interface describes the return value of a method or constructor.

This interface is returned by `MethodDescriptor.getReturnValueDescriptor()` and `ConstructorDescriptor.getReturnValueDescriptor()`.

Listing 7.13: `ReturnValueDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a validated return value of a method or constructor.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface ReturnValueDescriptor extends ElementDescriptor, CascadableDescriptor, ContainerDescriptor {
}
```

### 7.11. ContainerDescriptor and ContainerElementTypeDescriptor

The `ContainerDescriptor` interface describes those elements that can be of a container type, e.g. `List` or `Map`, and as such may host container element constraints (see [Container element constraints](#constraintdeclarationvalidationprocess-containerelementconstraints)) or have container element types that are marked with `@Valid`.

`ContainerDescriptor` is extended by `PropertyDescriptor`, `ParameterDescriptor`, `ReturnValueDescriptor` and `ContainerElementTypeDescriptor`.

Listing 7.14: `ContainerDescriptor` interface
```
package javax.validation.metadata;

/**
 * Represents an element that might be a container, thus allowing container element
 * constraints.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
public interface ContainerDescriptor {

    /**
     * If this element is of a container type, e.g. {@code List} or {@code Map}, a set of
     * descriptors of those container element types is returned, which are constrained or
     * marked with {@link Valid}. A container element type is constrained, if it hosts at
     * least one constraint.
     * <p>
     * In the context of properties and method return values, container element types of
     * super-types are considered.
     *
     * @return the set of descriptors representing the container element types that are
     * constrained or are marked with {@code Valid}. An empty set will be returned if this
     * element is not of a container type or is of a container type but there are no
     * container element types hosting constraints or marked with {@code Valid}.
     */
    Set<ContainerElementTypeDescriptor> getConstrainedContainerElementTypes();
}
```

If a given element is of a container type, `getConstrainedContainerElementTypes()` returns a set with descriptors representing those container element types that either host at least one constraint or are marked with `@Valid`.
The returned set will be empty if the given element is not of a container type or is of a container type but has no element types that are constrained or marked with `@Valid`.
In the context of properties and method return values, container element types of super-types are considered.

The `ContainerElementTypeDescriptor` interface describes the potential container element constraints applied to one element type of a container.

This interface is returned by `ContainerDescriptor.getConstrainedContainerElementTypes()`.

Listing 7.15: `ContainerElementTypeDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a validated container element type, e.g. the element type of {@code List} if it
 * hosts at least one constraint or is marked with {@link Valid}.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
public interface ContainerElementTypeDescriptor extends ElementDescriptor, CascadableDescriptor, ContainerDescriptor {

    /**
     * Returns the index of the type argument corresponding to this container element type.
     * @return the index of the type argument corresponding to this container element type
     */
    Integer getTypeArgumentIndex();

    /**
     * Returns the container class hosting this container element type.
     * @return the container class hosting this container element type
     */
    Class<?> getContainerClass();
}
```

`getTypeArgumentIndex()` returns the index of the type argument corresponding to this descriptor instance.
`getContainerClass()` returns the type of the container declaring the container element type represented by this descriptor instance.

### 7.12. ConstraintDescriptor

A `ConstraintDescriptor` object describes a given constraint declaration (i.e. a constraint annotation).

Listing 7.16: `ConstraintDescriptor` interface
```
package javax.validation.metadata;

/**
 * Describes a single constraint and its composing constraints.
 *
 * @param <T> the constraint's annotation type
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor<T extends Annotation> {

    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, attribute values are reflecting
     * the overridden attributes of the composing constraint
     *
     * @return the annotation for this constraint
     */
    T getAnnotation();

    /**
     * The non-interpolated error message
     *
     * @return the non-interpolated error message
     *
     * @since 1.1
     */
    String getMessageTemplate();

    /**
     * The set of groups the constraint is applied on.
     * If the constraint declares no group, a set with only the {@link Default}
     * group is returned.
     *
     * @return the groups the constraint is applied on
     */
    Set<Class<?>> getGroups();

    /**
     * The set of payload the constraint hosts.
     *
     * @return payload classes hosted on the constraint or an empty set if none
     */
    Set<Class<? extends Payload>> getPayload();

    /**
     * The {@link ConstraintTarget} value of {@code validationAppliesTo} if the constraint
     * hosts it or {@code null} otherwise.
     *
     * @return the {@code ConstraintTarget} value or {@code null}
     *
     * @since 1.1
     */
    ConstraintTarget getValidationAppliesTo();

    /**
     * List of the constraint validation implementation classes.
     *
     * @return list of the constraint validation implementation classes
     */
    List<Class<? extends ConstraintValidator<T, ?>>> getConstraintValidatorClasses();

    /**
     * Returns a map containing the annotation attribute names as keys and the
     * annotation attribute values as value.
     * <p>
     * If this constraint is used as part of a composed constraint, attribute
     * values are reflecting the overridden attribute of the composing constraint.
     *
     * @return a map containing the annotation attribute names as keys
     *         and the annotation attribute values as value
     */
    Map<String, Object> getAttributes();

    /**
     * Return a set of composing {@link ConstraintDescriptor}s where each
     * descriptor describes a composing constraint. {@code ConstraintDescriptor}
     * instances of composing constraints reflect overridden attribute values in
     * {@link #getAttributes()}  and {@link #getAnnotation()}.
     *
     * @return a set of {@code ConstraintDescriptor} objects or an empty set
     *         in case there are no composing constraints
     */
    Set<ConstraintDescriptor<?>> getComposingConstraints();

    /**
     * @return {@code true} if the constraint is annotated with {@link ReportAsSingleViolation}
     */
    boolean isReportAsSingleViolation();

    /**
     * @return a {@link ValidateUnwrappedValue} describing the unwrapping behavior as given
     * via the {@link Unwrapping} constraint payloads.
     *
     * @since 2.0
     */
    ValidateUnwrappedValue getValueUnwrapping();

    /**
     * Returns an instance of the specified type allowing access to provider-specific APIs.
     * <p>
     * If the Jakarta Bean Validation provider implementation does not support the specified class,
     * a {@link ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     * @param <U> the type of the object to be returned
     * @return an instance of the specified class
     * @throws ValidationException if the provider does not support the call
     *
     * @since 2.0
     */
    <U> U unwrap(Class<U> type);
}
```

`getAnnotation()` returns the annotation instance (or an annotation instance representing the given constraint declaration). If `ConstraintDescriptor` represents a composing annotation (see [Constraint composition](#constraintsdefinitionimplementation-constraintcomposition)), the returned annotation must reflect parameter overriding. In other words, the annotation parameter values are the overridden values.

`getAttributes()` returns a map containing the annotation attribute names as a key, and the annotation attribute values as a value (this API is anticipated to be simpler to use by tools than reflection over the annotation instance). If `ConstraintDescriptor()` represents a composing annotation (see [Constraint composition](#constraintsdefinitionimplementation-constraintcomposition)), the returned `Map` must reflect attribute overriding.

`getMessageTemplate()` returns the non-interpolated error message.

`getGroups()` returns the groups the constraint is supposed to be applied upon. If no group is set on the constraint declaration, the `Default` group is returned. The groups of a composing constraint are the groups of the composed constraint.

`getPayload()` returns the payloads associated to the constraint or an empty set if none. The payload from the main constraint annotation is inherited by the composing annotations. Any payload definition on a composing annotation is ignored.

`getValidationAppliesTo()` returns the `ConstraintTarget` returned by `validationAppliesTo` if the constraint hosts the attribute or `null` otherwise. The constraint target from the main constraint annotation is inherited by the composing annotation. Any constraint target definition on a composing annotation is ignored.

`isReportAsSingleViolation()` returns `true` if the constraint is annotated with `@ReportAsSingleViolation`.

`getComposingConstraints()` return a set of composing `ConstraintDescriptor`s where each descriptor describes a composing constraint.

`getConstraintValidatorClasses()` returns the `ConstraintValidator` classes associated with the constraint.

`getValueUnwrapping()` returns a `ValidateUnwrappedValue` instance describing the unwrapping behavior.

Listing 7.17: `ValidateUnwrappedValue` enum
```
package javax.validation.metadata;

/**
 * The unwrapping behavior that can be applied to a specific constraint.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
public enum ValidateUnwrappedValue {

    /**
     * No specific unwrapping behavior has been defined for this constraint and the default
     * behavior applies: if there is exactly one maximally-specific type-compliant
     * {@link ValueExtractor} and this extractor is marked with {@link UnwrapByDefault}, this
     * extractor is applied and the constraint is applied to the value(s) wrapped by the
     * annotated container. Otherwise, no value extractor is applied.
     */
    DEFAULT,

    /**
     * The value is unwrapped before validation, i.e. the constraint is applied to the
     * value(s) wrapped by the annotated container.
     */
    UNWRAP,

    /**
     * The value is not unwrapped before validation, i.e. the constraint is applied to the
     * annotated element.
     */
    SKIP;
}
```

`unwrap()` is provided as a way to access objects of a given type specific to a Jakarta Bean Validation provider, exposing functionality complementary to the `ConstraintDescriptor` contract.
Using this method makes your code non portable.

### 7.13. Example

Assuming the following constraint definitions

```
package com.acme.constraint;

@Documented
@Constraint(validatedBy = ValidInterval.Validator.class)
@Target({ METHOD, ANNOTATION_TYPE, CONSTRUCTOR })
@Retention(RUNTIME)
@Repeatable( List.class )
public @interface ValidInterval {

    String message() default "{com.acme.constraint.ValidInterval.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    int startParameter();

    int endParameter();

    @Target({ METHOD, ANNOTATION_TYPE, CONSTRUCTOR })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        ValidInterval[] value();
    }

    @SupportedValidationTarget(PARAMETERS)
    class Validator implements ConstraintValidator<ValidInterval, Object[]> {

        private int start;
        private int end;

        @Override
        public void initialize(ValidInterval constraintAnnotation) {
            this.start = constraintAnnotation.startParameter();
            this.end = constraintAnnotation.endParameter();
        }

        @Override
        public boolean isValid(Object[] value, ConstraintValidatorContext context) {
            return Integer.parseInt( String.valueOf( value[start] ) ) <
                    Integer.parseInt( String.valueOf( value[end] ) );
        }
    }
}

@Documented
@Constraint(validatedBy = ValidAddress.Validator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable( List.class )
public @interface ValidAddress {

    String message() default "{com.acme.constraint.ValidAddress.message}";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        ValidAddress[] value();
    }

    class Validator implements ConstraintValidator<ValidAddress, Address> {

        @Override
        public boolean isValid(Address value, ConstraintValidatorContext context) {
            // [...]
        }
    }
}
```

and the following class definitions

```
public class Author {

    private String firstName;

    @NotEmpty(message = "lastname must not be null")
    private String lastName;

    @Size(max = 30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {

    public interface FirstLevelCheck {
    }

    public interface SecondLevelCheck {
    }

    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @Valid
    public Book(
            String title,
            @Size(max = 30) String description,
            @Valid @ConvertGroup(from = Default.class, to = SecondLevelCheck.class) Author author) {
        // [...]
    }

    public Book() {
        // [...]
    }

    @NotEmpty(groups = { FirstLevelCheck.class, Default.class })
    @Size(max = 30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }

    @ValidInterval(startParameter = 1, endParameter = 2)
    public void addChapter(String title, int startPage, int endPage) {
        // [...]
    }
}

public class Account {
    // [...]
}

public class Address {
    // [...]
}

public abstract class Roles implements Set<String> {
    // [...]
}

public interface LegalEntity {

    Iterable<@NotNull String> getRoles();
}

public interface Person extends LegalEntity {

    @Override
    Set<@NotEmpty String> getRoles();

    Map<@NotNull String, @Valid Account> getAccounts();
}

public interface Employee extends Person {

    @Override
    Set<@NotBlank String> getRoles();

    Map<String, List<@NotNull @Valid Address>> getAddresses();
}

public class EmployeeImpl implements Employee {

    @Override
    public Roles getRoles() {
        // [...]
    }

    @Override
    public Map<String, List<@ValidAddress Address>> getAddresses() {
        // [...]
    }

    @Override
    public Map<String, Account> getAccounts() {
        // [...]
    }
}
```

The following assertions are true.

```
BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();
assert bookDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() > 0;

assert bookDescriptor.getConstraintDescriptors().size() == 0; //no bean-level constraint

//more specifically "author", "title" and "keywordsPerChapter"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty( "doesNotExist" ) == null;

//property with no constraint
assert bookDescriptor.getConstraintsForProperty( "description" ) == null;

PropertyDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty( "title" );
assert propertyDescriptor.getConstraintDescriptors().size() == 2;
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor<?> constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
        .iterator().next();
assert constraintDescriptor.getAnnotation().annotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true;

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor<?> composingDescriptor :
            constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().annotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence;

//assuming the implementation returns the Size constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next();
assert constraintDescriptor.getAnnotation().annotationType().equals( Size.class );
assert constraintDescriptor.getAttributes().get( "max" ) == Integer.valueOf( 30 );
assert constraintDescriptor.getGroups().size() == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty( "author" );
assert propertyDescriptor.getConstraintDescriptors().size() == 1;
assert propertyDescriptor.isCascaded();

//getTitle() and addChapter()
assert bookDescriptor.getConstrainedMethods( MethodType.GETTER, MethodType.NON_GETTER ).size() ==
        2;

//the constructor accepting title, description and author
assert bookDescriptor.getConstrainedConstructors().size() == 1;

ConstructorDescriptor constructorDescriptor = bookDescriptor.getConstraintsForConstructor(
        String.class, String.class, Author.class
);
assert constructorDescriptor.getName().equals( "Book" );
assert constructorDescriptor.getElementClass() == Book.class;
assert constructorDescriptor.hasConstrainedParameters() == true;

//return value is marked for cascaded validation
assert constructorDescriptor.hasConstrainedReturnValue() == true;

//constraints are retrieved via the sub-descriptors for parameters etc.
assert constructorDescriptor.hasConstraints() == false;

//one descriptor for each parameter
assert constructorDescriptor.getParameterDescriptors().size() == 3;

//"description" parameter
ParameterDescriptor parameterDescriptor = constructorDescriptor.getParameterDescriptors()
        .get( 1 );

//assuming the default parameter name provider is used and parameter names can
//be obtained
assert parameterDescriptor.getName().equals( "description" );
assert parameterDescriptor.getElementClass() == String.class;
assert parameterDescriptor.getIndex() == 1;
assert parameterDescriptor.hasConstraints() == true;

Set<ConstraintDescriptor<?>> parameterConstraints =
        parameterDescriptor.getConstraintDescriptors();
assert parameterConstraints.iterator().next().getAnnotation().annotationType() == Size.class;

//"author" parameter
parameterDescriptor = constructorDescriptor.getParameterDescriptors().get( 2 );
assert parameterDescriptor.hasConstraints() == false;
assert parameterDescriptor.isCascaded() == true;

//group conversion on "author" parameter
GroupConversionDescriptor groupConversion =
        parameterDescriptor.getGroupConversions().iterator().next();
assert groupConversion.getFrom() == Default.class;
assert groupConversion.getTo() == SecondLevelCheck.class;

//constructor return value
ReturnValueDescriptor returnValueDescriptor = constructorDescriptor.getReturnValueDescriptor();
assert returnValueDescriptor.hasConstraints() == false;
assert returnValueDescriptor.isCascaded() == true;

//a getter is also a method which is constrained on its return value
MethodDescriptor methodDescriptor = bookDescriptor.getConstraintsForMethod( "getTitle" );
assert methodDescriptor.getName().equals( "getTitle" );
assert methodDescriptor.getElementClass() == String.class;
assert methodDescriptor.hasConstrainedParameters() == false;
assert methodDescriptor.hasConstrainedReturnValue() == true;
assert methodDescriptor.hasConstraints() == false;

returnValueDescriptor = methodDescriptor.getReturnValueDescriptor();
assert returnValueDescriptor.getElementClass() == String.class;
assert returnValueDescriptor.getConstraintDescriptors().size() == 2;
assert returnValueDescriptor.isCascaded() == false;

//void method which has a cross-parameter constraint
methodDescriptor = bookDescriptor.getConstraintsForMethod(
        "addChapter", String.class, int.class, int.class
);
assert methodDescriptor.getElementClass() == void.class;
assert methodDescriptor.hasConstrainedParameters() == true;
assert methodDescriptor.hasConstrainedReturnValue() == false;

//cross-parameter constraints accessible via separate descriptor
assert methodDescriptor.hasConstraints() == false;

assert methodDescriptor.getReturnValueDescriptor().getElementClass() == void.class;

//cross-parameter descriptor
CrossParameterDescriptor crossParameterDescriptor =
        methodDescriptor.getCrossParameterDescriptor();
assert crossParameterDescriptor.getElementClass() == Object[].class;
assert crossParameterDescriptor.hasConstraints() == true;

ConstraintDescriptor<?> crossParameterConstraint =
        crossParameterDescriptor.getConstraintDescriptors().iterator().next();
assert crossParameterConstraint.getAnnotation().annotationType() == ValidInterval.class;

// no constrained container element types for title
assert bookDescriptor.getConstraintsForProperty( "title" )
        .getConstrainedContainerElementTypes().size() == 0;

BeanDescriptor employeeImplDescriptor = validator.getConstraintsForClass( Employee.class );

// container element constraints for property "roles"
PropertyDescriptor rolesDescriptor = employeeImplDescriptor.getConstraintsForProperty( "roles" );
assert rolesDescriptor != null;

Set<ContainerElementTypeDescriptor> constrainedContainerElementTypes = rolesDescriptor
        .getConstrainedContainerElementTypes();
// the container element types of Set and Iterable; Roles does not declare any container element types itself
assert constrainedContainerElementTypes.size() == 2;

Iterator<ContainerElementTypeDescriptor> it = constrainedContainerElementTypes.iterator();

// assuming that the descriptor for Set is returned first
ContainerElementTypeDescriptor containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Set.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotEmpty and @NotBlank
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 2;

// assuming that the descriptor for Iterable is returned next
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Iterable.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotNull
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 1;

// container element constraints for property "accounts"
PropertyDescriptor accountsDescriptor = employeeImplDescriptor
        .getConstraintsForProperty( "accounts" );
constrainedContainerElementTypes = accountsDescriptor.getConstrainedContainerElementTypes();
// the map key type and the map value type
assert constrainedContainerElementTypes.size() == 2;

it = constrainedContainerElementTypes.iterator();

// assuming that the descriptor for the map key is returned first
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == String.class;
// @NotNull
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 1;
assert containerElementTypeDescriptor.isCascaded() == false;

// assuming that the descriptor for the map value is returned next
containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 1;
assert containerElementTypeDescriptor.getElementClass() == Account.class;
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 0;
assert containerElementTypeDescriptor.isCascaded() == true;

// container element constraints for property "addresses"
PropertyDescriptor addressesDescriptor = employeeImplDescriptor
        .getConstraintsForProperty( "addresses" );
constrainedContainerElementTypes = addressesDescriptor.getConstrainedContainerElementTypes();
// the map value type
assert constrainedContainerElementTypes.size() == 1;

it = constrainedContainerElementTypes.iterator();

containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == Map.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 1;
assert containerElementTypeDescriptor.getElementClass() == List.class;
// No constraints nor @Valid on List itself
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 0;
assert containerElementTypeDescriptor.isCascaded() == false;

// container element type of the nested List container
constrainedContainerElementTypes = containerElementTypeDescriptor.getConstrainedContainerElementTypes();
assert constrainedContainerElementTypes.size() == 1;
it = constrainedContainerElementTypes.iterator();

containerElementTypeDescriptor = it.next();
assert containerElementTypeDescriptor.getContainerClass() == List.class;
assert containerElementTypeDescriptor.getTypeArgumentIndex() == 0;
assert containerElementTypeDescriptor.getElementClass() == Address.class;
// @NotNull and @ValidAddress
assert containerElementTypeDescriptor.getConstraintDescriptors().size() == 2;
assert containerElementTypeDescriptor.isCascaded() == true;
```

## 8. Built-in Constraint definitions

The specification defines a small set of built-in constraints. Their usage is encouraged both in regular constraint declarations and as composing constraints. Using this set of constraints will enhance portability of your constraints across constraint-consuming frameworks relying on the metadata API (such as client side validation frameworks or database schema generation frameworks).

Built-in annotations are annotated with an empty `@Constraint` annotation to avoid any dependency between the specification API and a specific implementation. Each Jakarta Bean Validation provider must recognize built-in constraint annotations as valid constraint definitions and provide compliant constraint implementations for each. The built-in constraint validation implementation is having a lower priority than an XML mapping definition. In other words `ConstraintValidator` implementations for built-in constraints can be overridden by using the XML mapping (see [Overriding constraint definitions in XML](#xml-mapping-constraintdefinition)).

All built-in constraints are in the `javax.validation.constraints` package. Here is the list of constraints and their declaration.

### 8.1. `@Null` constraint

Listing 8.1: `@Null` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Null {

    String message() default "{javax.validation.constraints.Null.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link Null} annotations on the same element.
     *
     * @see javax.validation.constraints.Null
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Null[] value();
    }
}
```

### 8.2. `@NotNull` constraint

Listing 8.2: `@NotNull` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must not be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface NotNull {

    String message() default "{javax.validation.constraints.NotNull.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link NotNull} annotations on the same element.
     *
     * @see javax.validation.constraints.NotNull
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        NotNull[] value();
    }
}
```

### 8.3. `@AssertTrue` constraint

Listing 8.3: `@AssertTrue` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be true.
 * Supported types are {@code boolean} and {@code Boolean}.
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface AssertTrue {

    String message() default "{javax.validation.constraints.AssertTrue.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link AssertTrue} annotations on the same element.
     *
     * @see AssertTrue
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        AssertTrue[] value();
    }
}
```

### 8.4. `@AssertFalse` constraint

Listing 8.4: `@AssertFalse` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be false.
 * Supported types are {@code boolean} and {@code Boolean}.
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface AssertFalse {

    String message() default "{javax.validation.constraints.AssertFalse.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link AssertFalse} annotations on the same element.
     *
     * @see javax.validation.constraints.AssertFalse
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        AssertFalse[] value();
    }
}
```

### 8.5. `@Min` constraint

Listing 8.5: `@Min` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers</li>
 * </ul>
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Min {

    String message() default "{javax.validation.constraints.Min.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * @return value the element must be higher or equal to
     */
    long value();

    /**
     * Defines several {@link Min} annotations on the same element.
     *
     * @see Min
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Min[] value();
    }
}
```

### 8.6. `@Max` constraint

Listing 8.6: `@Max` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers</li>
 * </ul>
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Max {

    String message() default "{javax.validation.constraints.Max.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * @return value the element must be lower or equal to
     */
    long value();

    /**
     * Defines several {@link Max} annotations on the same element.
     *
     * @see Max
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Max[] value();
    }
}
```

### 8.7. `@DecimalMin` constraint

Listing 8.7: `@DecimalMin` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code CharSequence}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers</li>
 * </ul>
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMin {

    String message() default "{javax.validation.constraints.DecimalMin.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * The {@code String} representation of the min value according to the
     * {@code BigDecimal} string representation.
     *
     * @return value the element must be higher or equal to
     */
    String value();

    /**
     * Specifies whether the specified minimum is inclusive or exclusive.
     * By default, it is inclusive.
     *
     * @return {@code true} if the value must be higher or equal to the specified minimum,
     *         {@code false} if the value must be higher
     *
     * @since 1.1
     */
    boolean inclusive() default true;

    /**
     * Defines several {@link DecimalMin} annotations on the same element.
     *
     * @see DecimalMin
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        DecimalMin[] value();
    }
}
```

### 8.8. `@DecimalMax` constraint

Listing 8.8: `@DecimalMax` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code CharSequence}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrappers</li>
 * </ul>
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support).
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMax {

    String message() default "{javax.validation.constraints.DecimalMax.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * The {@code String} representation of the max value according to the
     * {@code BigDecimal} string representation.
     *
     * @return value the element must be lower or equal to
     */
    String value();

    /**
     * Specifies whether the specified maximum is inclusive or exclusive.
     * By default, it is inclusive.
     *
     * @return {@code true} if the value must be lower or equal to the specified maximum,
     *         {@code false} if the value must be lower
     *
     * @since 1.1
     */
    boolean inclusive() default true;

    /**
     * Defines several {@link DecimalMax} annotations on the same element.
     *
     * @see DecimalMax
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        DecimalMax[] value();
    }
}
```

### 8.9. `@Negative` constraint

Listing 8.9: `@Negative` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a strictly negative number (i.e. 0 is considered as an
 * invalid value).
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
 *     {@code double} and their respective wrappers</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Gunnar Morling
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Negative {

    String message() default "{javax.validation.constraints.Negative.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link Negative} constraints on the same element.
     *
     * @see Negative
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Negative[] value();
    }
}
```

### 8.10. `@NegativeOrZero` constraint

Listing 8.10: `@NegativeOrZero` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a negative number or 0.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
 *     {@code double} and their respective wrappers</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Gunnar Morling
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface NegativeOrZero {

    String message() default "{javax.validation.constraints.NegativeOrZero.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link NegativeOrZero} constraints on the same element.
     *
     * @see NegativeOrZero
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        NegativeOrZero[] value();
    }
}
```

### 8.11. `@Positive` constraint

Listing 8.11: `@Positive` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a strictly positive number (i.e. 0 is considered as an
 * invalid value).
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
 *     {@code double} and their respective wrappers</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Gunnar Morling
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Positive {

    String message() default "{javax.validation.constraints.Positive.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link Positive} constraints on the same element.
     *
     * @see Positive
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Positive[] value();
    }
}
```

### 8.12. `@PositiveOrZero` constraint

Listing 8.12: `@PositiveOrZero` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a positive number or 0.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
 *     {@code double} and their respective wrappers</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Gunnar Morling
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface PositiveOrZero {

    String message() default "{javax.validation.constraints.PositiveOrZero.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link PositiveOrZero} constraints on the same element.
     *
     * @see PositiveOrZero
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        PositiveOrZero[] value();
    }
}
```

### 8.13. `@Size` constraint

Listing 8.13: `@Size` constraint
```
package javax.validation.constraints;

/**
 * The annotated element size must be between the specified boundaries (included).
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code CharSequence} (length of character sequence is evaluated)</li>
 *     <li>{@code Collection} (collection size is evaluated)</li>
 *     <li>{@code Map} (map size is evaluated)</li>
 *     <li>Array (array length is evaluated)</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Size {

    String message() default "{javax.validation.constraints.Size.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * @return size the element must be higher or equal to
     */
    int min() default 0;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;

    /**
     * Defines several {@link Size} annotations on the same element.
     *
     * @see Size
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Size[] value();
    }
}
```

### 8.14. `@Digits` constraint

Listing 8.14: `@Digits` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be a number within accepted range.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code BigDecimal}</li>
 *     <li>{@code BigInteger}</li>
 *     <li>{@code CharSequence}</li>
 *     <li>{@code byte}, {@code short}, {@code int}, {@code long}, and their respective
 *     wrapper types</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Digits {

    String message() default "{javax.validation.constraints.Digits.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * @return maximum number of integral digits accepted for this number
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this number
     */
    int fraction();

    /**
     * Defines several {@link Digits} annotations on the same element.
     *
     * @see Digits
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Digits[] value();
    }
}
```

### 8.15. `@Past` constraint

Listing 8.15: `@Past` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be an instant, date or time in the past.
 * <p>
 * <i>Now</i> is defined by the {@link ClockProvider} attached to the {@link Validator} or
 * {@link ValidatorFactory}. The default {@code clockProvider} defines the current time
 * according to the virtual machine, applying the current default time zone if needed.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code java.util.Date}</li>
 *     <li>{@code java.util.Calendar}</li>
 *     <li>{@code java.time.Instant}</li>
 *     <li>{@code java.time.LocalDate}</li>
 *     <li>{@code java.time.LocalDateTime}</li>
 *     <li>{@code java.time.LocalTime}</li>
 *     <li>{@code java.time.MonthDay}</li>
 *     <li>{@code java.time.OffsetDateTime}</li>
 *     <li>{@code java.time.OffsetTime}</li>
 *     <li>{@code java.time.Year}</li>
 *     <li>{@code java.time.YearMonth}</li>
 *     <li>{@code java.time.ZonedDateTime}</li>
 *     <li>{@code java.time.chrono.HijrahDate}</li>
 *     <li>{@code java.time.chrono.JapaneseDate}</li>
 *     <li>{@code java.time.chrono.MinguoDate}</li>
 *     <li>{@code java.time.chrono.ThaiBuddhistDate}</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Past {

    String message() default "{javax.validation.constraints.Past.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link Past} annotations on the same element.
     *
     * @see Past
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Past[] value();
    }
}
```

### 8.16. `@PastOrPresent` constraint

Listing 8.16: `@PastOrPresent` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be an instant, date or time in the past or in the present.
 * <p>
 * <i>Now</i> is defined by the {@link ClockProvider} attached to the {@link Validator} or
 * {@link ValidatorFactory}. The default {@code clockProvider} defines the current time
 * according to the virtual machine, applying the current default time zone if needed.
 * <p>
 * The notion of present is defined relatively to the type on which the constraint is
 * used. For instance, if the constraint is on a {@link Year}, present would mean the whole
 * current year.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code java.util.Date}</li>
 *     <li>{@code java.util.Calendar}</li>
 *     <li>{@code java.time.Instant}</li>
 *     <li>{@code java.time.LocalDate}</li>
 *     <li>{@code java.time.LocalDateTime}</li>
 *     <li>{@code java.time.LocalTime}</li>
 *     <li>{@code java.time.MonthDay}</li>
 *     <li>{@code java.time.OffsetDateTime}</li>
 *     <li>{@code java.time.OffsetTime}</li>
 *     <li>{@code java.time.Year}</li>
 *     <li>{@code java.time.YearMonth}</li>
 *     <li>{@code java.time.ZonedDateTime}</li>
 *     <li>{@code java.time.chrono.HijrahDate}</li>
 *     <li>{@code java.time.chrono.JapaneseDate}</li>
 *     <li>{@code java.time.chrono.MinguoDate}</li>
 *     <li>{@code java.time.chrono.ThaiBuddhistDate}</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface PastOrPresent {

    String message() default "{javax.validation.constraints.PastOrPresent.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link PastOrPresent} annotations on the same element.
     *
     * @see PastOrPresent
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        PastOrPresent[] value();
    }
}
```

### 8.17. `@Future` constraint

Listing 8.17: `@Future` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be an instant, date or time in the future.
 * <p>
 * <i>Now</i> is defined by the {@link ClockProvider} attached to the {@link Validator} or
 * {@link ValidatorFactory}. The default {@code clockProvider} defines the current time
 * according to the virtual machine, applying the current default time zone if needed.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code java.util.Date}</li>
 *     <li>{@code java.util.Calendar}</li>
 *     <li>{@code java.time.Instant}</li>
 *     <li>{@code java.time.LocalDate}</li>
 *     <li>{@code java.time.LocalDateTime}</li>
 *     <li>{@code java.time.LocalTime}</li>
 *     <li>{@code java.time.MonthDay}</li>
 *     <li>{@code java.time.OffsetDateTime}</li>
 *     <li>{@code java.time.OffsetTime}</li>
 *     <li>{@code java.time.Year}</li>
 *     <li>{@code java.time.YearMonth}</li>
 *     <li>{@code java.time.ZonedDateTime}</li>
 *     <li>{@code java.time.chrono.HijrahDate}</li>
 *     <li>{@code java.time.chrono.JapaneseDate}</li>
 *     <li>{@code java.time.chrono.MinguoDate}</li>
 *     <li>{@code java.time.chrono.ThaiBuddhistDate}</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Future {

    String message() default "{javax.validation.constraints.Future.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link Future} annotations on the same element.
     *
     * @see Future
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Future[] value();
    }
}
```

### 8.18. `@FutureOrPresent` constraint

Listing 8.18: `@FutureOrPresent` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must be an instant, date or time in the present or in the future.
 * <p>
 * <i>Now</i> is defined by the {@link ClockProvider} attached to the {@link Validator} or
 * {@link ValidatorFactory}. The default {@code clockProvider} defines the current time
 * according to the virtual machine, applying the current default time zone if needed.
 * <p>
 * The notion of present here is defined relatively to the type on which the constraint is
 * used. For instance, if the constraint is on a {@link Year}, present would mean the whole
 * current year.
 * <p>
 * Supported types are:
 * <ul>
 *     <li>{@code java.util.Date}</li>
 *     <li>{@code java.util.Calendar}</li>
 *     <li>{@code java.time.Instant}</li>
 *     <li>{@code java.time.LocalDate}</li>
 *     <li>{@code java.time.LocalDateTime}</li>
 *     <li>{@code java.time.LocalTime}</li>
 *     <li>{@code java.time.MonthDay}</li>
 *     <li>{@code java.time.OffsetDateTime}</li>
 *     <li>{@code java.time.OffsetTime}</li>
 *     <li>{@code java.time.Year}</li>
 *     <li>{@code java.time.YearMonth}</li>
 *     <li>{@code java.time.ZonedDateTime}</li>
 *     <li>{@code java.time.chrono.HijrahDate}</li>
 *     <li>{@code java.time.chrono.JapaneseDate}</li>
 *     <li>{@code java.time.chrono.MinguoDate}</li>
 *     <li>{@code java.time.chrono.ThaiBuddhistDate}</li>
 * </ul>
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Guillaume Smet
 * @since 2.0
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface FutureOrPresent {

    String message() default "{javax.validation.constraints.FutureOrPresent.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@link FutureOrPresent} annotations on the same element.
     *
     * @see FutureOrPresent
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        FutureOrPresent[] value();
    }
}
```

### 8.19. `@Pattern` constraint

Listing 8.19: `@Pattern` constraint
```
package javax.validation.constraints;

/**
 * The annotated {@code CharSequence} must match the specified regular expression.
 * The regular expression follows the Java regular expression conventions
 * see {@link java.util.regex.Pattern}.
 * <p>
 * Accepts {@code CharSequence}. {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface Pattern {

    /**
     * @return the regular expression to match
     */
    String regexp();

    /**
     * @return array of {@code Flag}s considered when resolving the regular expression
     */
    Flag[] flags() default { };

    /**
     * @return the error message template
     */
    String message() default "{javax.validation.constraints.Pattern.message}";

    /**
     * @return the groups the constraint belongs to
     */
    Class<?>[] groups() default { };

    /**
     * @return the payload associated to the constraint
     */
    Class<? extends Payload>[] payload() default { };

    /**
     * Possible Regexp flags.
     */
    public static enum Flag {

        /**
         * Enables Unix lines mode.
         *
         * @see java.util.regex.Pattern#UNIX_LINES
         */
        UNIX_LINES( java.util.regex.Pattern.UNIX_LINES ),

        /**
         * Enables case-insensitive matching.
         *
         * @see java.util.regex.Pattern#CASE_INSENSITIVE
         */
        CASE_INSENSITIVE( java.util.regex.Pattern.CASE_INSENSITIVE ),

        /**
         * Permits whitespace and comments in pattern.
         *
         * @see java.util.regex.Pattern#COMMENTS
         */
        COMMENTS( java.util.regex.Pattern.COMMENTS ),

        /**
         * Enables multiline mode.
         *
         * @see java.util.regex.Pattern#MULTILINE
         */
        MULTILINE( java.util.regex.Pattern.MULTILINE ),

        /**
         * Enables dotall mode.
         *
         * @see java.util.regex.Pattern#DOTALL
         */
        DOTALL( java.util.regex.Pattern.DOTALL ),

        /**
         * Enables Unicode-aware case folding.
         *
         * @see java.util.regex.Pattern#UNICODE_CASE
         */
        UNICODE_CASE( java.util.regex.Pattern.UNICODE_CASE ),

        /**
         * Enables canonical equivalence.
         *
         * @see java.util.regex.Pattern#CANON_EQ
         */
        CANON_EQ( java.util.regex.Pattern.CANON_EQ );

        //JDK flag value
        private final int value;

        private Flag(int value) {
            this.value = value;
        }

        /**
         * @return flag value as defined in {@link java.util.regex.Pattern}
         */
        public int getValue() {
            return value;
        }
    }

    /**
     * Defines several {@link Pattern} annotations on the same element.
     *
     * @see Pattern
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        Pattern[] value();
    }
}
```

### 8.20. `@NotEmpty` constraint

Listing 8.20: `@NotEmpty` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must not be {@code null} nor empty.
 * <p>
 * Supported types are:
 * <ul>
 * <li>{@code CharSequence} (length of character sequence is evaluated)</li>
 * <li>{@code Collection} (collection size is evaluated)</li>
 * <li>{@code Map} (map size is evaluated)</li>
 * <li>Array (array length is evaluated)</li>
 * </ul>
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 *
 * @since 2.0
 */
@Documented
@Constraint(validatedBy = { })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
public @interface NotEmpty {

    String message() default "{javax.validation.constraints.NotEmpty.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@code @NotEmpty} constraints on the same element.
     *
     * @see NotEmpty
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        NotEmpty[] value();
    }
}
```

### 8.21. `@NotBlank` constraint

Listing 8.21: `@NotBlank` constraint
```
package javax.validation.constraints;

/**
 * The annotated element must not be {@code null} and must contain at least one
 * non-whitespace character. Accepts {@code CharSequence}.
 *
 * @author Hardy Ferentschik
 * @since 2.0
 *
 * @see Character#isWhitespace(char)
 */
@Documented
@Constraint(validatedBy = { })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
public @interface NotBlank {

    String message() default "{javax.validation.constraints.NotBlank.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * Defines several {@code @NotBlank} constraints on the same element.
     *
     * @see NotBlank
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        NotBlank[] value();
    }
}
```

### 8.22. `@Email` constraint

Listing 8.22: `@Email` constraint
```
package javax.validation.constraints;

/**
 * The string has to be a well-formed email address. Exact semantics of what makes up a valid
 * email address are left to Jakarta Bean Validation providers. Accepts {@code CharSequence}.
 * <p>
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 *
 * @since 2.0
 */
@Documented
@Constraint(validatedBy = { })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
public @interface Email {

    String message() default "{javax.validation.constraints.Email.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    /**
     * @return an additional regular expression the annotated element must match. The default
     * is any string ('.*')
     */
    String regexp() default ".*";

    /**
     * @return used in combination with {@link #regexp()} in order to specify a regular
     * expression option
     */
    Pattern.Flag[] flags() default { };

    /**
     * Defines several {@code @Email} constraints on the same element.
     *
     * @see Email
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    public @interface List {
        Email[] value();
    }
}
```

## 9. XML deployment descriptor

Two kinds of XML descriptors are used by Jakarta Bean Validation. The first one describes the Jakarta Bean Validation configuration provided as `META-INF/validation.xml`. The second one describes constraints declarations and closely matches the annotations declaration approach. If an XML descriptor does not validate against the corresponding XSD file, a `ValidationException` is raised.

### 9.1. Constraint definition and declaration

Jakarta Bean Validation lets you declare constraints via XML rather than annotations. You can either ignore constraints declared via annotations or consider XML as adding additional constraints on top of annotation constraints. While it is not possible to define a new constraint via XML, you can redefine the list of `ConstraintValidator` classes associated to a given constraint definition.

There is no distinction between an annotation based constraint declaration and an XML based constraint declaration: they are considered equivalent and should be treated as such by the Jakarta Bean Validation provider. The rest of the specification only refers to annotations as validation metadata: it should be read as annotation or their XML descriptor equivalent.

Specifically when exploring metadata, the Jakarta Bean Validation provider must ensure that an annotation instance corresponding to the XML declaration is provided via `ConstraintDescriptor.getAnnnotation()`. The annotation elements as well as `ConstraintValidator.getAttributes()` must reflect the values described in the XML declaration (see [Converting the string representation of a value](#xml-mapping-typeconversion)). Likewise, `ConstraintDescriptor.getConstraintValidatorClasses()` must reflect XML based constraint definition overriding (see [Overriding constraint definitions in XML](#xml-mapping-constraintdefinition)).

A given class must not be described more than once among all the XML mapping descriptors. A given field or getter must not be described more than once on a given class description. A given constraint definition must not be overridden more than once among all the XML mapping descriptors. If any of these rules is violated in a given validation deployment, a `ValidationException` is raised during the creation of the `ValidatorFactory`.

The schema is provided in [XML Schema](#xml-mapping-xsd).

#### 9.1.1. Constraint declaration in XML

If `default-package` is set, all unqualified class names (including annotations) are considered part of the package described by `default-package`.

A given JavaBean is described by the `bean` element. The name of the class is mandatory. By default, all constraint declarations expressed via annotations are ignored for classes described in XML. You can force Jakarta Bean Validation to consider both annotations and XML constraint declarations by using `ignore-annotations="false"` on `bean`.

| Note | The `ignore-annotations` setting is not inherited from nor by the class hierarchy. In other words, it applies to the current bean only. |
| --- | --- |

If the name of the class does refer to a class not present in the classpath, a `ValidationException` is raised.

Example 9.1: Example of bean XML declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">

    <default-package>com.acme.app.domain</default-package>

    <bean class="Customer" ignore-annotations="false">
        [...]
    </bean>
    <bean class="com.acme.common.model.Address">
        [...]
    </bean>
</constraint-mappings>
```

##### 9.1.1.1. Class-level overriding

Class level annotations are described via the `class` element. If `ignore-annotations` is declared, Jakarta Bean Validation must honor the explicit value for this element. If not declared, the default value defined in the encapsulating `bean` element is considered.

When `ignore-annotations` is true, class-level Jakarta Bean Validation annotations are ignored for this class (including the `@GroupSequence`). When `ignore-annotations` is false:

* Constraints declared in XML and constraints declared in annotations are added and form the list of class-level declared constraints.
* `@GroupSequence` is considered unless `group-sequence` element is explicitly used.

Example 9.2: Example of class-level declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <class ignore-annotations="true">
            [...]
        </class>
    </bean>
    <bean class="com.acme.common.model.Address">
        <class>
            [...]
        </class>
    </bean>
</constraint-mappings>
```

##### 9.1.1.2. Field-level overriding

Field level annotations are described via the `field` element. The `name` attribute corresponds to the name of the field considered. If `ignore-annotations` is declared, Jakarta Bean Validation must honor the explicit value for this element. If not declared, the default value defined in the encapsulating `bean` element is considered.

When `ignore-annotations` is true, field-level Jakarta Bean Validation annotations on the targeted field are ignored (including `@Valid` and `@ConvertGroup`). When `ignore-annotations` is false:

* Constraints declared in XML and constraints declared in annotations are added and form the list of field-level declared constraints.
* `@Valid` is considered unless the `valid` element is explicitly used. Note that the only way to disable cascading on a field marked as `@Valid` is to use `ignore-annotations=true`.
* Group conversions declared in XML and via the `@ConvertGroup` annotation are added and form the list of applied conversions. Note that the rules for the declaration of group conversions as outlined in [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion) apply, in particular it is not legal to declare several conversions for the same source group.

If the name of the field does not correspond to a field in the given bean a `ValidationException` is raised.

Example 9.3: Field-level declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <field name="firstName">
            [...]
        </field>
        <field name="orders">
            <valid/>
            [...]
        </field>
    </bean>
</constraint-mappings>
```

##### 9.1.1.3. Property-level overriding

Property-level annotations are described via the `getter` element. The `name` attribute corresponds to the name of the property considered as defined in [Field and property validation](#constraintdeclarationvalidationprocess-requirements-propertyvalidation) (for example a getter `String getAge()` would have `<getter name="age"/>` as a corresponding descriptor). If `ignore-annotations` is declared, Jakarta Bean Validation must honor the explicit value for this element. If not declared, the default value defined in the encapsulating `bean` element is considered.

When `ignore-annotations` is true, property-level Jakarta Bean Validation annotations on the targeted property are ignored (including `@Valid` and `@ConvertGroup`). When `ignore-annotations` is false:

* Constraints declared in XML and constraints declared in annotations are added and form the list of property-level declared constraints.
* `@Valid` is considered unless the `valid` element is explicitly used. Note that the only way to disable cascading on a property marked as `@Valid` is to use `ignore-annotations=true`.
* Group conversions declared in XML and via the `@ConvertGroup` annotation are added and form the list of applied conversions. Note that the rules for the declaration of group conversions as outlined in [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion) apply, in particular it is not legal to declare several conversions for the same source group.

If the name of the property does not correspond to a property in the given bean a `ValidationException` is raised.

Example 9.4: Property-level declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <getter name="firstName">
            [...]
        </getter>
        <getter name="orders">
            <valid/>
            [...]
        </getter>
    </bean>
</constraint-mappings>
```

##### 9.1.1.4. Constructor-level overriding

Constructor-level annotations are described via the `constructor` element.

To identify a constructor to be configured, zero or more `parameter` elements are used, matching the number and types of parameters of the configured constructor. When configuring the default constructor, no `parameter` element is to be used. The parameter types are specified using their fully qualified name using the syntax described in the documentation of `java.lang.Class.getName()`.

Let’s look at some examples:

* `"java.lang.String"` must be specified for a parameter of type `java.lang.String`
* `"long"` must be specified for a parameter of type `long`
* `"[Ljava.lang.Object;"` must be specified for a parameter of type `java.lang.Object[]`

Varargs parameters are specified using the corresponding array type, e.g. a parameter `String...` must be specified as `"[Ljava.lang.String;"`.

If the `default-package` element is configured for the mapping file, any unqualified class names will be resolved using the given default package.

| Note | You must declare all parameters even if they are not reconfigured to ensure the right constructor is identified. |
| --- | --- |

If no constructor with the specified parameter types exists in the given bean a `ValidationException` is raised.

The optional `return-value` element is used to change the configuration of a constructor’s return value if required.

The optional `cross-parameter` element is used to change the configuration of a constructor’s cross-parameter constraints if required.

The constraints applying for a constructor’s parameters and its return value are specified by adding `constraint` elements to the `parameter` and `return-value` elements respectively. Whether or not to perform cascaded validation is controlled using the `valid` element . Group conversion rules for cascaded validation are specified using the `convert-group` element.

The cross-parameter constraints applied on a constructor parameter list are specified by adding `constraint` elements to the `cross-parameter` element.

If `ignore-annotations` is declared on the `parameter`, `cross-parameter` or `return-value` element, Jakarta Bean Validation must honor the explicit value for this element. Otherwise, if `ignore-annotations` is declared for the `constructor` element, Jakarta Bean Validation must honor this value. Otherwise, the default value declared in the encapsulating `bean` element is considered.

When `ignore-annotations` is true, Jakarta Bean Validation annotations on the targeted constructor or parameter are ignored (including `@Valid` and `@ConvertGroup`). When `ignore-annotations` is false:

* Constraints declared in XML and constraints declared in annotations are added and form the list of declared parameter, cross-parameter or return value constraints respectively.
* `@Valid` is considered unless the `valid` element is explicitly used. Note that the only way to disable cascading on a constructor parameter or return value marked as `@Valid` is to use `ignore-annotations=true`. This does not apply to cross-parameter elements as cascading does not make sense in this situation.
* Group conversions declared in XML and via the `@ConvertGroup` annotation are added and form the list of applied conversions. Note that the rules for the declaration of group conversions as outlined in [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion) apply, in particular it is not legal to declare several conversions for the same source group. This does not apply to cross-parameter elements as cascading does not make sense in this situation.

Example 9.5: Constructor-level declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <constructor ignore-annotations="true">
            <parameter type="java.lang.String">
                [...]
            </parameter>
            <parameter type="int">
                <valid/>
                [...]
            </parameter>
            <parameter type="long" ignore-annotations="false"/>
            <cross-parameter ignore-annotations="false">
                [...]
            </cross-parameter>
            <return-value>
                <valid/>
                [...]
            </return-value>
            [...]
        </constructor>

    </bean>
</constraint-mappings>
```

##### 9.1.1.5. Method-level overriding

Method-level annotations are described via the `method` element.

To identify a method to be configured, zero or more `parameter` elements are used, matching the number and types of parameters of the configured method. The parameter types are specified using their fully qualified name using the syntax described in the documentation of `java.lang.Class.getName()`.

Let’s look at some examples:

* `"java.lang.String"` must be specified for a parameter of type `java.lang.String`
* `"long"` must be specified for a parameter of type `long`
* `"[Ljava.lang.Object;"` must be specified for a parameter of type `java.lang.Object[]`

Varargs parameters are specified using the corresponding array type, e.g. a parameter `String...` must be specified as `"[Ljava.lang.String;"`.

If the `default-package` element is configured for the mapping file, any unqualified class names will be resolved using the given default package.

| Note | You must declare all parameters even if they are not reconfigured to ensure the right method is identified. |
| --- | --- |

| Note | A given getter method representing a JavaBeans property may either be configured using the `getter` or the `method` element, but not both. If a `getter` element and a `method` element referring to the same method are detected by the Jakarta Bean Validation provider, a `ValidationException` is raised. |
| --- | --- |

If no method with the specified name and parameter types exists in the given bean a `ValidationException` is raised.

The optional `return-value` element is used to change the configuration of a method’s return value if required.

The optional `cross-parameter` element is used to change the configuration of a method’s cross-parameter constraints if required.

The constraints applying for a method’s parameters and its return value are specified by adding `constraint` elements to the `parameter` and `return-value` elements respectively. Whether or not to perform cascaded validation is controlled using the `valid` element. Group conversion rules for cascaded validation are specified using the `convert-group` element.

The cross-parameter constraints applied on a method parameter list are specified by adding `constraint` elements to the `cross-parameter` element.

If `ignore-annotations` is declared on the `parameter`, `cross-parameter` or `return-value` element, Jakarta Bean Validation must honor the explicit value for this element. Otherwise, if `ignore-annotations` is declared for the `method` element, Jakarta Bean Validation must honor this value. Otherwise, the default value declared in the encapsulating `bean` element is considered.

When `ignore-annotations` is true, Jakarta Bean Validation annotations on the targeted method or parameter are ignored (including `@Valid` and `@ConvertGroup`). When `ignore-annotations` is false:

* Constraints declared in XML and constraints declared in annotations are added and form the list of declared parameter, cross-parameter or return value constraints respectively.
* `@Valid` is considered unless the `valid` element is explicitly used. Note that the only way to disable cascading on a method parameter or return value marked as `@Valid` is to use `ignore-annotations=true`. This does not apply to cross-parameter elements as cascading does not make sense in this situation.
* Group conversions declared in XML and via the `@ConvertGroup` annotation are added and form the list of applied conversions. Note that the rules for the declaration of group conversions as outlined in [Group conversion](#constraintdeclarationvalidationprocess-groupsequence-groupconversion) apply, in particular it is not legal to declare several conversions for the same source group. This does not apply to cross-parameter elements as cascading does not make sense in this situation.

Example 9.6: Method-level declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <method name="update" ignore-annotations="true">
            <parameter type="java.lang.String">
                [...]
            </parameter>
            <parameter type="int">
                <valid/>
                [...]
            </parameter>
            <parameter type="long" ignore-annotations="false"/>
            <cross-parameter ignore-annotations="false">
                [...]
            </cross-parameter>
            <return-value>
                <valid/>
                [...]
            </return-value>
            [...]
        </method>

    </bean>
</constraint-mappings>
```

##### 9.1.1.6. Container-element overriding

To apply constraints to the elements of generic container types or to mark them for cascaded validation, the `container-element-type` element is used.

`container-element-type` can be used within the `field`, `getter`, `parameter` and `return-value` elements.

The `type-argument-index` is used to specify the index of the configured type argument.
The `type-argument-index` can be omitted, if the container type has exactly one type argument.
The `ignore-annotations` settings effectively applying to the encapsulating element (`field`, `getter` etc.) are applied to `container-element-type`, too.
The `container-element-type` element can be nested for configuring nested generic containers such as `List<List<String>>`.

Constraints are applied by adding `constraint` elements to `container-element-type`.
Whether or not to perform cascaded validation is controlled using the `valid` element.
Group conversion rules for cascaded validation are specified using the `convert-group` element.

If an invalid container element type configuration is detected, a `ValidationException` is raised.
This includes the following configuration errors:

* The type of the surrounding element (field, getter etc.) has no type arguments.
* The type of the surrounding element has no type argument with the index given via `type-argument-index`.
* The type of the surrounding element has multiple type arguments and no index is given via `type-argument-index`.
* The same type argument of the surrounding element is configured multiple times.

Example 9.7: Container-element declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">
        <!-- Map<String, Address> -->
        <field name="addressesByType" ignore-annotations="true">
            <container-element-type type-argument-index="0">
                [...]
            </container-element-type>
            <container-element-type type-argument-index="1">
                <valid/>
                [...]
            </container-element-type>
            [...]
        </field>

        <!-- setContactsByType(Map<String, List<String>>) -->
        <method name="setContactsByType" ignore-annotations="true">
            <parameter type="java.util.Map">
                <container-element-type type-argument-index="1">
                    <valid/>
                    <container-element-type type-argument-index="0">
                        <valid/>
                        [...]
                    </container-element-type>
                    [...]
                </container-element-type>
                [...]
            </parameter>
            [...]
        </method>

    </bean>
</constraint-mappings>
```

##### 9.1.1.7. Constraint declaration

New constraint declarations are represented by the `constraint` element. The `annotation` attribute is the class name of the annotation representing the constraint. Message, groups and payload are defined respectively by the `message`, `groups` and `payload` elements.

Other custom elements of an annotation are represented by `element`. The `name` attribute is mandatory and represents the name of the element in the constraint declaration. `message`, `groups` and `payload` are not permitted names, use the `message`, `groups` or `payload` elements instead. Otherwise a `ValidationException` is raised.

| Note | `validationAppliesTo` (see [validationAppliesTo](#constraintsdefinitionimplementation-constraintdefinition-properties-validationappliesto)) is not necessary as cross-parameter constraints and return value constraints are declared in different XML elements, respectively `cross-parameter` and `return-value`. |
| --- | --- |

If the element represents a primitive type, a class or an enum, the string representation of its value is placed in the element itself. See [Converting the string representation of a value](#xml-mapping-typeconversion) for a detailed explanation of the conversion rules from string to the type.

If the element represents a primitive type array, a class array or an enum array, the string representation of each value is placed in a `value` element placed under the element itself.

If the element represents an annotation, the `annotation` element is used to represent the annotation and placed under `element`. An `annotation` element contains `element` elements.

If the element represents an array of annotations, one or more `annotation` elements are placed under `element`.

Elements with default values in the annotation definition do not have to be represented in XML: the default value will be used in this case. If an XML constraint declaration is missing mandatory elements, or if it contains elements not part of the constraint definition, a `ValidationException` is raised.

Example 9.8: Constraint declaration
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">

        <field name="firstName">

            <!-- @LooksLike(patterns={
                      @Pattern(value="myRegExp", flag=PatternFlag.INSENSITIVE),
                      @Pattern(value="my2ndRegExp")}
                  )
             -->
            <constraint annotation="com.acme.app.constraint.LooksLike">
                <element name="patterns">
                    <annotation>
                        <element name="value">myRegExp</element>
                        <element name="flag">
                            <value>INSENSITIVE</value>
                        </element>
                    </annotation>
                    <annotation>
                        <element name="value">my2ndRegExp</element>
                    </annotation>
                </element>
            </constraint>

        </field>
        <field name="orders">
            <valid/>

            <!-- @DiscreteSize(value={ 0, 20 } )
             -->
            <constraint annotation="com.acme.app.constraint.DiscreteSize">
                <element name="value">
                    <value>0</value>
                    <value>20</value>
                </element>
            </constraint>

        </field>

        <!-- Map<@NotBlank String, @Valid PhoneNumber>
         -->
        <field name="phoneNumbersByType">
            <container-element-type type-argument-index="0">
                <constraint annotation="javax.validation.constraints.NotBlank"/>
            </container-element-type>
            <container-element-type type-argument-index="1">
                <valid/>
            </container-element-type>
        </field>

        <getter name="orders">
            <valid/>

            <!-- @Size(message="Size is limited",
                       groups={Default.class, LightValidation.class},
                       max=30
                 )
            -->
            <constraint annotation="javax.validation.constraints.Size">
                <message>Size is limited</message>
                <groups>
                    <value>com.acme.app.model.LightValidation</value>
                    <value>javax.persistence.Default</value>
                </groups>
                <payload>
                    <value>com.acme.app.model.WARN</value>
                </payload>
                <element name="max">30</element>
            </constraint>

        </getter>

        <constructor ignore-annotations="true">
            <parameter type="java.lang.String">

                <!-- @DiscreteSize(value={ 0, 20 } ) -->
                <constraint annotation="com.acme.app.constraint.DiscreteSize">
                    <element name="value">
                        <value>0</value>
                        <value>20</value>
                    </element>
                </constraint>
            </parameter>
        </constructor>

        <method name="update" ignore-annotations="true">
            <parameter type="java.lang.String">

                <!-- @DiscreteSize(value={ 0, 20 } ) -->
                <constraint annotation="com.acme.app.constraint.DiscreteSize">
                    <element name="value">
                        <value>0</value>
                        <value>20</value>
                    </element>
                </constraint>
            </parameter>

            <return-value>

                <!-- @ValidCustomer -->
                <constraint annotation="com.acme.app.constraint.ValidCustomer"/>
            </return-value>
        </method>

        <method name="resetPassword" ignore-annotations="false">
            <parameter type="java.lang.String"/>
            <parameter type="java.lang.String"/>

            <cross-parameter>
                <!-- @ValidResetPasswordParameters -->
                <constraint
                        annotation="com.acme.app.constraint.ValidResetPasswordParameters"/>
            </cross-parameter>
        </method>
    </bean>
</constraint-mappings>
```

##### 9.1.1.8. Declaration of group conversions

Group conversion rules are declared by specifying one or more `convert-group` elements within the `field`, `getter`, `parameter`, `return-value` and `container-element-type` elements.

Source and target group of a conversion rule are given by specifying their fully-qualified names within the `from` and `to` attribute respectively. If the `default-package` element is configured for the mapping file, any unqualified class names will be resolved using the given default package.

Example 9.9: Declaration of group conversions
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
    <default-package>com.acme.app.domain</default-package>
    <bean class="Customer" ignore-annotations="false">

        <field name="firstName">
            <valid/>
            <convert-group from="javax.validation.groups.Default"
                    to="com.acme.CustomerBasic"/>
            <convert-group from="com.acmenote.Advanced" to="com.acme.CustomerComplex"/>
        </field>

        <getter name="orders">
            <valid/>
            <convert-group from="javax.validation.groups.Default"
                    to="com.acme.CustomerBasic"/>
        </getter>

        <constructor>
            <parameter type="java.lang.String">
                <valid/>
                <convert-group from="javax.validation.groups.Default"
                        to="com.acme.CustomerBasic"/>
            </parameter>
            <return-value>
                <valid/>
                <convert-group from="javax.validation.groups.Default"
                        to="com.acme.CustomerBasic"/>
            </return-value>
        </constructor>

        <method name="update">
            <parameter type="java.lang.String">
                <valid/>
                <convert-group from="javax.validation.groups.Default"
                        to="com.acme.CustomerBasic"/>
            </parameter>
            <return-value>
                <valid/>
                <convert-group from="javax.validation.groups.Default"
                        to="com.acme.CustomerBasic"/>
            </return-value>
        </constructor>
    </bean>
</constraint-mappings>
```

#### 9.1.2. Overriding constraint definitions in XML

A constraint definition (i.e. the annotation representing a constraint), cannot be fully expressed in XML but the list of `ConstraintValidator`s associated to a given constraint can be altered.

A constraint definition is represented by a `constraint-definition` element. The `annotation` attribute represents the constraint annotation being altered. The `validated-by` elements represent the (ordered) list of `ConstraintValidator` implementations associated to the constraint.

If `include-existing-validator` is set to false, `ConstraintValidator` defined on the constraint annotation are ignored. If set to true, the list of `ConstraintValidator`s described in XML are concatenated to the list of `ConstraintValidator` described on the annotation to form a new array of `ConstraintValidator` evaluated. Annotation based `ConstraintValidator`s come before XML based `ConstraintValidator`s in the array. The new list is returned by `ConstraintDescriptor.getConstraintValidatorClasses()`.

Example 9.10: Overriding constraint definitions
```
<?xml version="1.0" encoding="UTF-8"?>
<constraint-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
        version="2.0">
   <default-package>com.acme.app.domain</default-package>
   <bean class="com.acme.common.model.Address">
       [...]
    </bean>

    <constraint-definition annotation="javax.validation.constraints.Size">
        <validated-by include-existing-validators="true">
            <value>com.acme.app.constraint.SizeValidatorForDictionary</value>
        </validated-by>
    </constraint-definition>
    <constraint-definition annotation="AcmeOrderNumber">
        [...]
    </constraint-definition>
</constraint-mappings>
```

#### 9.1.3. Converting the string representation of a value

Primitive types, `Class` and `Enum` are represented as strings in the XML descriptor. Elements of an array are represented by the `value` element.

A `byte` is represented according to the rules defined in `Byte.parseByte(String)`.

A `short` is represented according to the rules defined in `Short.parseShort(String)`.

An `int` is represented according to the rules defined in `Integer.parseInt(String)`.

A `long` is represented according to the rules defined in `Long.parseLong(String)`.

A `float` is represented according to the rules defined in `Float.parseFloat(String)`.

A `double` is represented according to the rules defined in `Double.parseDouble(String)`.

A `boolean` is represented according to the rules defined in `Boolean.parseBoolean(String)`.

A `char` is represented according to the following rules:

* the string must be of one character long
* the character extracted from the string is the returned `char`

A `Class` is represented by the fully qualified class name of the class or more precisely according to the syntax described in the documentation of `java.lang.Class.getName()`. Note that if the raw string is unqualified, default package is taken into account.

An enum is represented by its `enum.name()` value.

If any of the string representation does not match its type counterpart, a `ValidationException` is raised.

#### 9.1.4. XML Schema

This section contains the XML schema used for constraint mapping descriptors.

From Jakarta Bean Validation revision 1.1 onwards, mapping authors must specify the used version of the schema within the `version` attribute of the `constraint-mappings` element. Implementations supporting Jakarta Bean Validation 2.0 must properly parse mapping descriptors of Jakarta Bean Validation 1.0, 1.1 and 2.0. If the `version` attribute attribute is not given, schema version 1.0 is to be assumed by the Jakarta Bean Validation provider.

In case an unknown version is given (e.g. if a mapping descriptor adhering to a future schema version is parsed by a Jakarta Bean Validation 2.0 provider) a `ValidationException` is raised.

Listing 9.1: XML schema for constraint mapping descriptors
```
<?xml version="1.0" encoding="UTF-8"?>

<xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://xmlns.jcp.org/xml/ns/validation/mapping"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:map="http://xmlns.jcp.org/xml/ns/validation/mapping"
           version="2.0">

    <xs:annotation>
        <xs:documentation><![CDATA[
            This is the XML Schema for Jakarta Bean Validation constraint mapping files.

            Jakarta Bean Validation constraint mapping files must indicate the Jakarta Bean Validation
            XML schema by using the constraint mapping namespace:

            http://xmlns.jcp.org/xml/ns/validation/mapping

            and indicate the version of the schema by using the version attribute
            as shown below:

            <constraint-mappings
                xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://xmlns.jcp.org/xml/ns/validation/mapping
                    http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
                version="2.0">
                ...
            </constraint-mappings>
        ]]>
        </xs:documentation>
    </xs:annotation>

    <xs:element name="constraint-mappings" type="map:constraint-mappingsType"/>

    <xs:complexType name="payloadType">
        <xs:sequence>
            <xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="groupsType">
        <xs:sequence>
            <xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="groupSequenceType">
        <xs:sequence>
            <xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="groupConversionType">
        <xs:attribute type="xs:string" name="from" use="optional"/>
        <xs:attribute type="xs:string" name="to" use="required"/>
    </xs:complexType>
    <xs:complexType name="constraint-mappingsType">
        <xs:sequence>
            <xs:element type="xs:string" name="default-package" minOccurs="0"/>
            <xs:element type="map:beanType"
                        name="bean"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
            <xs:element type="map:constraint-definitionType"
                        name="constraint-definition"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="version" type="map:versionType" fixed="2.0" use="required"/>
    </xs:complexType>
    <xs:simpleType name="versionType">
        <xs:restriction base="xs:token">
            <xs:pattern value="[0-9]+(\.[0-9]+)*"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="validated-byType">
        <xs:sequence>
            <xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute type="xs:boolean" name="include-existing-validators" use="optional"/>
    </xs:complexType>
    <xs:complexType name="constraintType">
        <xs:sequence>
            <xs:element type="xs:string" name="message" minOccurs="0"/>
            <xs:element type="map:groupsType"
                        name="groups"
                        minOccurs="0"/>
            <xs:element type="map:payloadType"
                        name="payload"
                        minOccurs="0"/>
            <xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="annotation" use="required"/>
    </xs:complexType>
    <xs:complexType name="elementType" mixed="true">
        <xs:sequence>
            <xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/>
            <xs:element type="map:annotationType"
                        name="annotation"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="name" use="required"/>
    </xs:complexType>
    <xs:complexType name="containerElementTypeType">
        <xs:sequence>
            <xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/>
            <xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:containerElementTypeType"
                        name="container-element-type"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="type-argument-index" use="optional">
            <xs:simpleType>
                <xs:restriction base="xs:int">
                    <xs:minInclusive value="0" />
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="classType">
        <xs:sequence>
            <xs:element type="map:groupSequenceType"
                        name="group-sequence"
                        minOccurs="0"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="beanType">
        <xs:sequence>
            <xs:element type="map:classType"
                        name="class"
                        minOccurs="0">
            </xs:element>
            <xs:element type="map:fieldType"
                        name="field"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:getterType"
                        name="getter"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:constructorType"
                        name="constructor"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:methodType"
                        name="method"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="class" use="required"/>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"
                default="true"/>
    </xs:complexType>
    <xs:complexType name="annotationType">
        <xs:sequence>
            <xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="getterType">
        <xs:sequence>
            <xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/>
            <xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:containerElementTypeType"
                        name="container-element-type"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="name" use="required"/>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="methodType">
        <xs:sequence>
            <xs:element type="map:parameterType"
                        name="parameter"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:crossParameterType"
                        name="cross-parameter"
                        minOccurs="0"
                        maxOccurs="1"/>
            <xs:element type="map:returnValueType"
                        name="return-value"
                        minOccurs="0"
                        maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="name" use="required"/>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="constructorType">
        <xs:sequence>
            <xs:element type="map:parameterType"
                        name="parameter"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:crossParameterType"
                        name="cross-parameter"
                        minOccurs="0"
                        maxOccurs="1"/>
            <xs:element type="map:returnValueType"
                        name="return-value"
                        minOccurs="0"
                        maxOccurs="1"/>
        </xs:sequence>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="parameterType">
        <xs:sequence>
            <xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/>
            <xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:containerElementTypeType"
                        name="container-element-type"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="type" use="required"/>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="returnValueType">
        <xs:sequence>
            <xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/>
            <xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:containerElementTypeType"
                        name="container-element-type"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="crossParameterType">
        <xs:sequence>
            <xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
    <xs:complexType name="constraint-definitionType">
        <xs:sequence>
            <xs:element type="map:validated-byType"
                        name="validated-by"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="annotation" use="required"/>
    </xs:complexType>
    <xs:complexType name="fieldType">
        <xs:sequence>
            <xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/>
            <xs:element type="map:groupConversionType"
                        name="convert-group"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:containerElementTypeType"
                        name="container-element-type"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
            <xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute type="xs:string" name="name" use="required"/>
        <xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/>
    </xs:complexType>
</xs:schema>
```

### 9.2. Configuration schema

XML Configuration is set in `META-INF/validation.xml`. The file is optional. The XML schema followed by the configuration file is as followed.

Listing 9.2: XML schema for XML configuration
```
<?xml version="1.0" encoding="UTF-8"?>

<xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://xmlns.jcp.org/xml/ns/validation/configuration"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:config="http://xmlns.jcp.org/xml/ns/validation/configuration"
           version="2.0">

    <xs:annotation>
        <xs:documentation><![CDATA[
            This is the XML Schema for the Jakarta Bean Validation configuration file.
            The configuration file must be named "META-INF/validation.xml".

            Jakarta Bean Validation configuration files must indicate the Jakarta Bean Validation
            XML schema by using the validation namespace:

            http://xmlns.jcp.org/xml/ns/validation/configuration

            and indicate the version of the schema by using the version attribute
            as shown below:

            <validation-config
                xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://xmlns.jcp.org/xml/ns/validation/configuration
                    http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
                version="2.0">
                [...]
            </validation-config>
        ]]>
        </xs:documentation>
    </xs:annotation>

    <xs:element name="validation-config" type="config:validation-configType"/>
    <xs:complexType name="validation-configType">
        <xs:sequence>
            <xs:element type="xs:string" name="default-provider" minOccurs="0"/>
            <xs:element type="xs:string" name="message-interpolator" minOccurs="0"/>
            <xs:element type="xs:string" name="traversable-resolver" minOccurs="0"/>
            <xs:element type="xs:string" name="constraint-validator-factory" minOccurs="0"/>
            <xs:element type="xs:string" name="parameter-name-provider" minOccurs="0"/>
            <xs:element type="xs:string" name="clock-provider" minOccurs="0"/>
            <xs:element type="xs:string" name="value-extractor" maxOccurs="unbounded"
                    minOccurs="0"/>
            <xs:element type="config:executable-validationType" name="executable-validation"
                    minOccurs="0"/>
            <xs:element type="xs:string" name="constraint-mapping" maxOccurs="unbounded"
                    minOccurs="0"/>
            <xs:element type="config:propertyType" name="property" maxOccurs="unbounded"
                    minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="version" type="config:versionType" fixed="2.0" use="required"/>
    </xs:complexType>

    <xs:complexType name="executable-validationType">
        <xs:sequence>
            <xs:element type="config:default-validated-executable-typesType"
                    name="default-validated-executable-types" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="enabled" use="optional" type="xs:boolean" default="true"/>
    </xs:complexType>
    <xs:complexType name="default-validated-executable-typesType">
        <xs:sequence>
            <xs:element name="executable-type" maxOccurs="unbounded" minOccurs="1">
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="NONE"/>
                        <xs:enumeration value="CONSTRUCTORS"/>
                        <xs:enumeration value="NON_GETTER_METHODS"/>
                        <xs:enumeration value="GETTER_METHODS"/>
                        <xs:enumeration value="ALL"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="propertyType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="name" use="required" type="xs:string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="versionType">
        <xs:restriction base="xs:token">
            <xs:pattern value="[0-9]+(\.[0-9]+)*" />
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
```

From Jakarta Bean Validation revision 1.1 onwards, the used version of the schema must be specified within the `version` attribute of the `validation-config` element. Implementations supporting Jakarta Bean Validation 2.0 must properly parse configuration descriptors of Jakarta Bean Validation 1.0, 1.1 and 2.0. If the `version` attribute attribute is not given, schema version 1.0 is to be assumed by the Jakarta Bean Validation Provider.

In case an unknown version is given a `ValidationException` is raised.

See [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration) for more information on XML based configuration.

## 10. Exception model

Illegal arguments passed to the Jakarta Bean Validation APIs generally lead to an `IllegalArgumentException` (see the JavaDoc for specific details). Other exceptions raised by Jakarta Bean Validation are or inherit from the runtime exception `javax.validation.ValidationException`. Exception cases are described in their respective sections but include (non exhaustive list):

* invalid constraint definitions (missing mandatory elements, illegal composition cycle, illegal attribute overriding, etc.)
* invalid constraint declarations (`ConstraintValidator` implementation matching failure, etc.)
* invalid group definition (circularity)
* invalid `Default` group redefinition for classes (missing class group etc)
* invalid group conversion definitions
* error when retrieving, initializing, executing `ConstraintValidator`s
* error when parsing the XML configuration or mappings
* multiple XML configuration files found
* missing expected provider or no default provider found
* missing no-arg constructor on extension implementations described in XML configuration files
* same entity described more than once across the XML mapping files
* same property or field described more than once for a given entity in the XML mapping files
* class, field or getter declared in XML mapping files but not found
* illegal XML constraint definition
* illegal XML constraint declaration
* exception raised either at initialization time or execution time by any of the extension interfaces

Each of these error cases lead to a `ValidationException` or a subclass of `ValidationException` (see following subsections).

Every (runtime) exception raised either at initialization time or execution time by any of the extension interfaces (`ConstraintValidator`, `ConstraintValidatorFactory`, `MessageInterpolator`, `TraversableResolver`, `ValidationProviderResolver`, `ParameterNameProvider`, `ClockProvider`, `ValueExtractor`) is wrapped in a `ValidationException`.

If a constraint definition or constraint declaration is invalid for a given class, the metadata API should raise the according exception.

### 10.1. Error report: `ConstraintViolationException`

Some frameworks or applications need to convey the result of a validation by raising an exception if the validation returns constraint violations.

Jakarta Bean Validation provides a reference exception for such cases. Frameworks and applications are encouraged to use `ConstraintViolationException` as opposed to a custom exception to increase consistency of the Java platform. The exception can be raised directly or wrapped into the framework or application specific parent exception.

Example 10.1: ConstraintViolationException
```
/**
 * Reports the result of constraint violations.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public class ConstraintViolationException extends ValidationException {
    [...]

    /**
     * Creates a constraint violation report.
     *
     * @param message error message
     * @param constraintViolations {@code Set} of {@link ConstraintViolation}
     */
    public ConstraintViolationException(String message,
                                        Set<? extends ConstraintViolation<?>> constraintViolations) {
        [...]
    }

    /**
     * Creates a constraint violation report.
     *
     * @param constraintViolations {@code Set} of {@link ConstraintViolation}
     */
    public ConstraintViolationException(Set<? extends ConstraintViolation<?>> constraintViolations) {
        [...]
    }

    /**
     * Set of constraint violations reported during a validation.
     *
     * @return {@code Set} of {@link ConstraintViolation}
     */
    public Set<ConstraintViolation<?>> getConstraintViolations() {
        [...]
    }
}
```

The `ConstraintViolationException` carries a `Set` of `ConstraintViolation`.

| Note | Jakarta Bean Validation never raises this exception itself. Other frameworks like Jakarta Persistence 2 or interception framework wiring method validation do. |
| --- | --- |

| Note | If this exception is meant to be sent remotely, `ConstraintViolation` objects should be `Serializable` as defined and explained in [ConstraintViolation](#validationapi-constraintviolation). |
| --- | --- |

### 10.2. Constraint definition: `ConstraintDefinitionException`

If a constraint definition does not respect the Jakarta Bean Validation rules or is inconsistent, a `ConstraintDefinitionException` is raised. `ConstraintDefinitionException` is a subclass of `ValidationException`.

This exception can be raised during validation or when the metadata model for the class hosting this constraint is requested.

| Note | These exception cases can be determined at compile time by a tool such as an annotation processor. |
| --- | --- |

### 10.3. Constraint declaration: `ConstraintDeclarationException` and `UnexpectedTypeException`

When a constraint declaration is illegal, `ConstraintDeclarationException` is raised.
Reasons include:

* incorrect group conversion rules (definition or positioning)
* no suitable value extractor could be unambiguously identified for container element validation or cascaded validation of a container
* illegal method constraint declarations
  (e.g. inheritance rules, cross-parameter constraint used in an illegal situation, improper use of `validationAppliesTo`).

`ConstraintDeclarationException` is a subclass of `ValidationException`.

When the return type of a property cannot be processed for a given constraint, an `UnexpectedTypeException` is raised. This problem typically arises when either no `ConstraintValidator`s or too many `ConstraintValidator`s match the return type (see [ConstraintValidator resolution algorithm](#constraintdeclarationvalidationprocess-validationroutine-typevalidatorresolution)).

`UnexpectedTypeException` is a subclass of `ConstraintDeclarationException`.

This exception can be raised during validation or when the metadata model for the class hosting this constraint is requested.

| Note | These exception cases can be determined at compile time by a tool such as an annotation processor. |
| --- | --- |

### 10.4. Group definition: `GroupDefinitionException`

When a group definition is illegal, a `GroupDefinitionException` is raised. This typically arises when a cyclic group dependency is discovered, an illegal attribute overriding is defined etc.

`GroupDefinitionException` is a subclass of `ValidationException`.

| Note | These exception cases can be determined at compile time by a tool such as an annotation processor. |
| --- | --- |

### 10.5. Value extractor definition: `ValueExtractorDefinitionException`

When detecting an illegal value extractor definition, a `ValueExtractorDefinitionException` will be raised.

Reasons for raising this exception include:

* The extracted type is not marked with `@ExtractedValue`
* The `@ExtractedValue` annotation is given more than once for one value extractor type

`ValueExtractorDefinitionException` is a subclass of `ValidationException`.

### 10.6. Value extractor declaration: `ValueExtractorDeclarationException`

When detecting an illegal configuration of value extractors, a `ValueExtractorDeclarationException` will be raised.
One example is the configuration of multiple extractors for the same container element type in `META-INF/validation.xml`.

`ValueExtractorDeclarationException` is a subclass of `ValidationException`.

### 10.7. No Jakarta Bean Validation Provider detected: `NoProviderFoundException`

When trying to bootstrap Jakarta Bean Validation via `Validation.buildDefaultValidatorFactory()` or `Validation.byDefaultProvider().configure()` and no Jakarta Bean Validation provider could be found, a `NoProviderFoundException` is raised.

`NoProviderFoundException` is a subclass of `ValidationException`.

## 11. Integration

In this chapter, integration points between Jakarta Bean Validation and other technologies are discussed. We first address the integration in generic terms applying to all integrations and we then detail how integration with various Jakarta EE specifications is handled more specifically.

### 11.1. General requirements

This section covers general requirements that should be followed by any container and interception technology integrating Jakarta Bean Validation.

#### 11.1.1. Objects lifecycle

Generally speaking, containers and frameworks controlling the lifecycle of objects (such as Jakarta EE, dependency injection frameworks or component frameworks) should:

* build and bootstrap the `ValidatorFactory` instance for an application.
* provide access to the `ValidatorFactory` instance as well as `Validator` instances in their default configuration using the paradigm of the container: for example, such instances would be injectable in other objects via a dependency injection framework.
* configure `ValidatorFactory` with a custom `ConstraintValidatorFactory` instance that returns managed `ConstraintValidator` instances, unless a custom `ConstraintValidatorFactory` is requested by the user. The scope of `ConstraintValidator` instances is still fully controlled by the Jakarta Bean Validation provider as described in [The ConstraintValidatorFactory](#constraintsdefinitionimplementation-constraintfactory), but as managed beans they can receive expected services like injection of other objects.
* configure `ValidatorFactory` with managed instances of `ConstraintValidatorFactory`, `MessageInterpolator`, `ParameterNameProvider`, `ClockProvider` and `TraversableResolver`, if such instances are defined in the XML deployment descriptor. Services provided by the container (like dependency injection) should thus be available to these instances.
* invoke `ValidatorFactory.close()` when the `ValidatorFactory` instance is no longer needed.
* dispose of managed instances provided to the Jakarta Bean Validation bootstrap process after `ValidatorFactory.close()` has been invoked.

| Important | In this context, a default `ValidatorFactory` is a factory configured like the factory returned by `Validation.buildDefaultValidatorFactory` (see also [Validation](#validationapi-bootstrapping-validation)) except for the enhancements described above. A default `Validator` instance is a `Validator` instance retrieved via `getValidator()` from the default `ValidatorFactory`. |
| --- | --- |

#### 11.1.2. Method and constructor validation

This section expresses the behavior that integration with interception frameworks should follow. Any deviation should be considered with care as it will surprise Jakarta Bean Validation users.

Method interception frameworks (such as AOP or interceptor frameworks) enable interception of constrained methods following the steps defined in [Triggering method validation](#validationapi-triggeringmethodvalidation). Method validation execution is implicit for any method or constructor annotated with constraints.

By default, method validation is applied to all constrained methods or constructors provided the integration technology can intercept the call. By default, getters (as defined in [Requirements on classes to be validated](#constraintdeclarationvalidationprocess-requirements)) are not considered constrained methods. Static methods are ignored by validation. Putting constraints on a static method is not portable.

Jakarta Bean Validation - via the interception technology - offers a way to customize whether or not a constructor, method or getter is validated when executed. This is achieved:

* via the `@ValidateOnExecution` annotation on the executable (see [`@ValidateOnExecution` annotation](#example-validateonexecution))
* via the `@ValidateOnExecution` annotation on the type declaring the executable
* via a global configuration defined in `validation.xml`: `executable-validation` and `default-validated-executable-types`. See [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration) for more details.

| Note | Integration layers can read the list of validated executable types defined in the global configuration as well as read whether or not executable validation is disabled via the `Configuration` object: `configuration.getBootstrapConfiguration().getDefaultValidatedExecutableTypes()` and `configuration.getBootstrapConfiguration().isExecutableValidationEnabled()` respectively. This list is extracted from `validation.xml`. |
| --- | --- |

More formally, a given executable (constructor or method) is validated upon execution according to the following rules in decreasing order:

* the executable is validated if it is annotated with `@ValidateOnExecution` and the `type` attribute contains the executable type or `IMPLICIT`. If the `type` attribute does neither contain the executable type nor `IMPLICIT`, the executable is not validated.
* otherwise the executable is validated if the type (class, interface) on which it is declared is annotated with `@ValidateOnExecution` and the `type` attribute contains the executable type. If the `type` attribute contains `IMPLICIT`, then this rule is ignored and the behavior is equivalent to `@ValidateOnExecution` not being present. If the `type` attribute does not contain the executable type, the executable is not validated.
* otherwise the executable is validated if the global executable validation setting contains the executable type. If the global setting does not contain the executable type, the executable is not validated.
* The rules above do not apply to methods overriding a superclass method or implementing an interface method. In this case, the method inherits the behavior of the method it overrides / implements. Out of the box, a conforming integration implementation raises a `ValidationException` if the overriding / implementing method hosts the `@ValidateOnExecution` annotation.

The last point is present to enforce the Liskov substitution principle (more info at [Method constraints in inheritance hierarchies](#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance)). In addition, providers may implement alternative, potentially more liberal, approaches for handling validated methods in inheritance hierarchies. Possible means for activating such alternative behavior include provider-specific configuration properties or annotations. Note that client code relying on such alternative behavior is not portable.

The following executable types are available:

* `NONE`: parameters and return values are not validated upon execution. This option is equivalent to an empty list of executable types and is present to improve readability. A list containing `NONE` and other types of executables is equivalent to a list containing the types of executables without `NONE`.
* `CONSTRUCTORS`: parameters and return values are validated provided the executable is a constructor.
* `NON_GETTER_METHODS`: parameters and return values are validated provided the executable is a method but not a getter.
* `GETTER_METHODS`: return values are validated provided the executable is a getter method.
* `ALL`: parameters and return values are validated for all executables (getters, non getters and constructors). This option is equivalent to a list of all executable types and is present to improve readability. A list containing `ALL` and other types of executables is equivalent to a list containing only `ALL`.
* `IMPLICIT`: if `@ValidateOnExecution` is on a type (class or interface), then it is equivalent to `@ValidateOnExecution` not being present; if `@ValidateOnExecution` is on a an executable, the following applies:

  + if on a constructor, it is equivalent to `CONSTRUCTORS`.
  + if on a non-getter method, it is equivalent to `NON_GETTER_METHODS`.
  + if on a getter, it is equivalent to `GETTER_METHODS`.

Mixing `IMPLICIT` and other executable types is illegal.

Listing 11.1: `@ValidateOnExecution` annotation
```
package javax.validation.executable;

/**
 * Expresses which executables (methods or constructors) should have their parameters
 * and return value validated upon execution. Can be on executable (method, constructor)
 * or type level (with the former taking precedence).
 * <p>
 * If not present for a given executable, the default configuration from
 * {@code META-INF/validation.xml} and finally the implicit default
 * validated executable types (constructors and non-getters) are taken into account to
 * determine whether a given executable is validated upon execution or not.
 * <p>
 * The following describes the formal rules for deciding whether an executable is validated.
 * They are applied in decreasing order:
 * <ul>
 *     <li>the executable is validated if it is annotated with {@code @ValidateOnExecution}
 *     and the {@code type} attribute contains the executable type or
 *     {@link ExecutableType#IMPLICIT}. If the {@code type} attribute does neither contain
 *     the executable type nor {@code IMPLICIT}, the executable is not validated.</li>
 *     <li>otherwise the executable is validated if the type (class, interface) on which it
 *     is declared is annotated with {@code @ValidateOnExecution} and the {@code type}
 *     attribute contains the executable type. If the {@code type} attribute contains
 *     {@code IMPLICIT}, then this rule is ignored and the behavior is equivalent to
 *     {@code ValidateOnExecution} not being present. If the {@code type} attribute does not
 *     contain the executable type, the executable is not validated.</li>
 *     <li>otherwise the executable is validated if the global executable validation setting
 *     contains the executable type. If the global setting does not contain the executable
 *     type, the executable is not validated.</li>
 *     <li>The rules above do not apply to methods overriding a superclass method or
 *     implementing an interface method. In this case, the method inherits the behavior
 *     of the method it overrides or implements. Out of the box, a conforming implementation
 *     raises a {@link ValidationException} if the overriding / implementing method hosts
 *     the {@code ValidateOnExecution} annotation.</li>
 * </ul>
 * <p>
 * Note that you can exclude an executable from validation by making sure the rules above do
 * not match or by annotating the executable with {@code @ValidateOnExecution(NONE)}.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ CONSTRUCTOR, METHOD, TYPE, PACKAGE })
@Retention(RUNTIME)
@Documented
public @interface ValidateOnExecution {

    /**
     * List of executable types to be validated when called.
     * Defaults to the types discovered implicitly (see {@link ExecutableType#IMPLICIT}).
     *
     * @return array of {@code ExecutableType}s to be validated
     */
    ExecutableType[] type() default {ExecutableType.IMPLICIT};
}
```

```
package javax.validation.executable;

/**
 * Defines the types of executables targeted by an operation.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
public enum ExecutableType {

    /**
     * If the annotation using {@code ExecutableType} is on a type (class or interface),
     * the behavior is equivalent to the annotation not being present.
     * <p>
     * If on a constructor, it is equivalent to {@link #CONSTRUCTORS}.
     * <p>
     * If on a non-getter method, it is equivalent to {@link #NON_GETTER_METHODS}.
     * <p>
     * If on a getter method, it is equivalent to {@link #GETTER_METHODS}.
     */
    IMPLICIT,

    /**
     * None of the executables.
     * <p>
     * Note that this option is equivalent to an empty list of executable types
     * and is present to improve readability. If {@code NONE} and other types of executables
     * are present in a list, {@code NONE} is ignored.
     */
    NONE,

    /**
     * All constructors.
     */
    CONSTRUCTORS,

    /**
     * All methods except the ones following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * <ul>
     *     <li>name starts with get, has a return type but no parameter</li>
     *     <li>name starts with is, has a return type and is returning {@code boolean}.</li>
     * </ul>
     */
    NON_GETTER_METHODS,

    /**
     * All methods following the getter pattern. A getter according to the
     * JavaBeans specification is a method whose:
     * <ul>
     *     <li>name starts with get, has a return type but no parameter</li>
     *     <li>name starts with is, has a return type and is returning {@code boolean}.</li>
     * </ul>
     */
    GETTER_METHODS,

    /**
     * All executables (constructors and methods).
     */
    ALL
}
```

If a sub type overrides/implements a method originally defined in several parallel types of the hierarchy (e.g. two interfaces not extending each other, or a class and an interface not implemented by said class), `@ValidateOnExecution` cannot be placed in the parallel types of the hierarchy. This is to avoid an unexpected altering of the post conditions to be guaranteed to the caller.

You can globally disable executable validation by using `<executable-validation enabled="false"/>`, in this case, `<default-validated-executable-types/>` and `@ValidateOnExecution` are ignored.

Example 11.1: validation.xml disabling executable validation
```
<?xml version="1.0" encoding="UTF-8"?>
<validation-config
        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
        version="2.0">
    <default-provider>com.acme.ACMEProvider</default-provider>
    <message-interpolator>com.acme.ACMEAwareMessageInterpolator</message-interpolator>

    <executable-validation enabled="false"/>

    <constraint-mapping>META-INF/validation/order-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/catalog-constraints.xml</constraint-mapping>
    <constraint-mapping>META-INF/validation/customer-constraints.xml</constraint-mapping>

    <property name="com.acme.validation.logging">WARN</property>
    <property name="com.acme.validation.safetyChecking">failOnError</property>

</validation-config>
```

`@ValidateOnExecution(type=IMPLICIT)` on a type (class or interface) is useful to mark a class as being involved in executable validation without affecting the behavior. This is used when the integration technology needs a little help to find the classes and interfaces involved.

| Note | The proper selection of the validated executables is the responsibility of the integration between the interception technology and Jakarta Bean Validation. Jakarta Bean Validation engines ignore the XML configuration around executable validation and `@ValidateOnExecution` when validating executables and when providing metadata. |
| --- | --- |

##### 11.1.2.1. Examples

The following example shows some of the way you can refine executable validation with `@ValidateOnExecution`.

Example 11.2: Method validation configurations
```
//optional: @ValidateOnExecution
public class OrderService {

    boolean isValidCustomer(@NotNull String customerCode) { [...] }

    @ValidateOnExecution
    @Min(0)
    Integer getBacklog() { [...] }

    @ValidateOnExecution(type=NONE)
    Order placeOrder(@NotNull String customerCode, @Valid Item item, int quantity) { [...] }

}

@ValidateOnExecution(type={GETTER_METHODS, NON_GETTER_METHODS})
public class SimpleOrderService extends OrderService {

    public SimpleOrderService(@NotNull ServiceProvider provider) { [...] }

    @Overrides
    Order placeOrder(String customerCode, Item item, int quantity) { [...] }

}

//optional: @ValidateOnExecution
public class ComplexOrderService extends SimpleOrderService {
    public ComplexOrderService(@NotNull ServiceProvider provider) { [...] }
}
```

All constructors and non-getter methods of `OrderService` are validated upon execution as this is the default setting. `isValidCustomer()` is validated as this method is not a getter (it has a parameter). `getBacklog()` is a getter but is validated thanks to `@ValidateOnExecution` defaulting to `GETTER_METHODS`. `placeOrder()` is not validated as `@ValidateOnExecution` is set to `NONE`.

All getter and non-getter methods of `SimpleOrderService` are validated upon execution by default due to the presence of `@ValidateOnExecution` on the class. The `SimpleOrderService` constructor is thus not validated. `SimpleOrderService.placeOrder()` is not validated either because it overrides `OrderService.placeOrder()` and thus inherits its settings.

All constructors and non-getter methods of `ComplexOrderService` are validated upon execution as this is the default setting - the type level settings of `SimpleOrderService` are not inherited. This means that the `ComplexOrderService` constructor is validated.

`@ValidateOnExecution` can be optionally set on `OrderService` and `ComplexOrderService` without altering the semantic. This marker is necessary for some integration technology in some situations.

### 11.2. Jakarta EE

Jakarta EE must obey the rules defined above and make the following instances available under JNDI:

* `ValidatorFactory` under `java:comp/ValidatorFactory`
* `Validator` under `java:comp/Validator`

Instead of looking the instances up via JNDI, the user can request them to be injected via the `Resource` annotation:

```
@Resource ValidatorFactory validatorFactory;
@Resource Validator validator;
```

When the application is Jakarta Context and Dependency Injection enabled, the `ValidatorFactory` and `Validator` instances returned by JNDI or `@Resource` injection are Jakarta Context and Dependency Injection enhanced as defined in [Jakarta Context and Dependency Injection integration](#integration-dependencyinjection). In particular, dependency injection is available to Jakarta Bean Validation components.

### 11.3. Jakarta Context and Dependency Injection integration

There are several integrations points between Jakarta Bean Validation and Jakarta Context and Dependency Injection. If a Jakarta Bean Validation provider integrates with Jakarta Context and Dependency Injection, it must follow the rules laid out in this section. In a Jakarta EE container, a Jakarta Bean Validation provider must integrate with Jakarta Context and Dependency Injection.

#### 11.3.1. `ValidatorFactory` and `Validator`

Similar to the Jakarta EE integration via `@Resource` (see [Jakarta EE](#integration-jakartaee)), a Jakarta Context and Dependency Injection container must support injection of built-in default `ValidatorFactory` and `Validator` beans via `@Inject`. These default beans are injectable via the `@Default` qualifier.

```
@Inject ValidatorFactory;
@Inject Validator;
```

Optionally, the Jakarta Context and Dependency Injection container can support injection of provider specific - as defined by `Validation.byProvider()` - `ValidatorFactory` and `Validator` beans via `@Inject`. These beans must be registered with a custom qualifier, for example `@ACME`. Using the product name or brand for the qualifier is considered good practice.

```
@Inject @ACME ValidatorFactory;
@Inject @ACME Validator;
```

| Note | Discussion on possible implementations  Registration of the built-in default beans and the provider specific beans may be achieved using the Jakarta Context and Dependency Injection portable extension SPI or a vendor specific SPI. |
| --- | --- |

#### 11.3.2. `ConstraintValidatorFactory`, `MessageInterpolator`, `ParameterNameProvider`, `ClockProvider`, `TraversableResolver` and `ValueExtractor`

If custom `ConstraintValidatorFactory`, `MessageInterpolator`, `ParameterNameProvider`, `ClockProvider`, `TraversableResolver` or `ValueExtractor` classes are defined in the XML deployment descriptor (see [XML configuration: META-INF/validation.xml](#validationapi-bootstrapping-xmlconfiguration)), the `ValidatorFactory` must be configured with Jakarta Context and Dependency Injection managed beans representing the requested classes. Services like dependency injection, interception and decoration must thus be made available to these instances by the container.
The same applies to value extractors discovered through the service loader mechanism (see [Registering ValueExtractor implementations](#constraintdeclarationvalidationprocess-validationroutine-valueextractorresolution-registering)).

If no custom `ConstraintValidatorFactory` is requested by the user, the `ValidatorFactory` must be configured with a custom `ConstraintValidatorFactory` instance that returns Jakarta Context and Dependency Injection managed beans representing the requested `ConstraintValidator` types. The factory

* creates non-contextual `ConstraintValidator` instances for each `ConstraintValidatorFactory.getInstance()` call. To inject dependencies into the `ConstraintValidator` instance, the Jakarta Context and Dependency Injection `InjectionTarget` API should be used. Before returning the instance the following calls should be made: `InjectionTarget.produce()`, `InjectionTarget.inject()` and `InjectionTarget.postConstruct()`.
* calls `InjectionTarget.preDestroy()` and `InjectionTarget.dispose()` upon `ConstraintValidatorFactory.releaseInstance` (see also [The ConstraintValidatorFactory](#constraintsdefinitionimplementation-constraintfactory) for more information about the lifecycle of a `ConstraintValidator`).

Using directly or indirectly a Jakarta Persistence `EntityManager` that might call back Jakarta Bean Validation for validation is not allowed in the Jakarta Bean Validation extension points and in `ConstraintValidator` instances. This would lead to infinite flush or unexpected behavior.

#### 11.3.3. Method and constructor validation

Jakarta Bean Validation requires that Jakarta Context and Dependency Injection beans support constructor and method validation as defined in [Method and constructor validation](#integration-general-executable). Validation must happen at the equivalent time an interceptor occurs when having priority `Interceptor.Priority.PLATFORM_AFTER+800`, in other words priority of `4800`.

For maximum portability, it is recommended to mark Jakarta Context and Dependency Injection bean interfaces and classes involved in executable validation with `@ValidateOnExecution` (defaults to `IMPLICIT`). This helps some implementations to bind the method validation interceptor. Most Jakarta Context and Dependency Injection - Jakarta Bean Validation integration implementations do not need such marker. In particular this marker should not be needed on validated beans annotated with constraint annotations, `@Valid` or `@ValidateOnExecution` anywhere in the class. Such limitation will be removed in a future version of this specification.

| Note | Discussion on possible implementations  The Jakarta Context and Dependency Injection interceptor binding facility does not directly support this, but the effect may be achieved using the Jakarta Context and Dependency Injection portable extension SPI, or vendor specific SPIs. For example, an interceptor with the expected priority can be programmatically bound to the constructors and methods expected to be validated according to the rules at [Method and constructor validation](#integration-general-executable).   It is recommended to only intercept methods and constructors that are both constrained and validated according to the rules defined at [Method and constructor validation](#integration-general-executable). [Triggering method validation](#validationapi-triggeringmethodvalidation) gives examples how the metadata API can be used to determine whether or not a method is constrained (regardless of the filtering rules of `@ValidateOnExecution`). |
| --- | --- |

### 11.4. Jakarta Persistence 2.0 integration

Integration with Jakarta Persistence is described in the [Jakarta Persistence 2 specification](https://projects.eclipse.org/projects/ee4j.jpa). Persistence frameworks are encouraged to mimic the integration work done with Jakarta Persistence.

### 11.5. Jakarta Server Faces 2.0 integration

Integration with Jakarta Server Faces is described in the [Jakarta Server Faces 2 specification](https://projects.eclipse.org/projects/ee4j.faces). Presentation frameworks are encouraged to study the integration work done with Jakarta Server Faces 2.

### 11.6. Jakarta RESTful Web Services 2 integration

Integration with Jakarta RESTful Web Services is described in the [Jakarta RESTful Web Services 2 specification](https://projects.eclipse.org/projects/ee4j.jaxrs).

## Appendix A: Terminology

This appendix aims at giving an overview on the different key terms used through this specification. They are not to be considered formal definitions. Formal definitions are to be inferred from the core specification.

Constraint

A restriction on a bean instance, the value of a field or the value of a JavaBean property.

Constraint declaration

Assignment of a constraint to a target (bean, field, property) for a specific class. Typically by declaring an annotation on the target but can also be done through a XML deployment descriptor.

Validation routine

Sequence of operations executed by the Jakarta Bean Validation provider to validate a given object graph.

Constraint definition

Defines a type of constraint, its attributes and the actual constraint validation implementations. Done through annotations. The list of constraint validation implementations can be provided via XML.

Group

Constraints can belong to one or more group or context. Useful to apply a subset of the constraints for a given use case. By default, the `Default` group is used.

Group Sequence

Defines a group ordering in the validation process. If a given group in the sequence contains one or more failure, the following groups in the sequence must be ignored.

Constraint validation

Constraint logic algorithm used to determine whether a given value passes a constraint or not.

Constraint validation implementation

Class implementing the constraint logic and used to determine whether a given value passes a constraint or not.

Jakarta Bean Validation provider

Product implementing this specification.

Message interpolator

Algorithm used to build the end user message associated to a constraint failure. Typically useful for i18n.

Constraint metadata API

API exposing the constraints applied to a given bean type. Also considered one of the integration points with other specification or frameworks.

Bootstrap API

Bootstrapping part of the Jakarta Bean Validation API producing a `ValidatorFactory`.

javax.validation.ConstraintValidator

Interface implemented by a constraint validation implementation.

Composing constraint

Constraint declared on another constraint definition. When the main constraint is validated, the composing constraints are validated too.

javax.validation.Validator

Main API. Holds contracts to validate object graphs.

javax.validation.ConstraintViolation

Interface describing a given constraint failure on a given bean.

Getter

Method whose:

* name starts with `get` and has a return type but no parameter
* name starts with `is`, has no parameter and is returning `boolean`

Generic type

A class or interface with one or more type parameters, e.g. `class List<E> { …​ }`

Parameterized type (instantiated type)

A type created from a generic type by providing an actual type argument per formal type parameter, e.g. `List<String>`

Type argument

A reference type or a wildcard that is used for instantiation / invocation of a generic type or a reference type used for instantiation / invocation of a generic method. In the following example, `?` and `String` are two type arguments:

```
List<?> list = new LinkedList<String>();
```

Type parameter

A place holder for a type argument. Each type parameter is replaced by a type argument when a generic type or generic method is instantiated / invoked. In the following example, `E` is a type parameter:

```
interface Comparable<E> {
}
```

Container type

A type of object containing one or more elements, e.g. `List`, `Map` or `Optional`

Container element type

A type of object contained in a container, e.g. the type of the elements of a `List`, the type of the keys and values of a `Map` or the type contained in an `Optional`

## Appendix B: Standard ResourceBundle messages

The properties listed below are resolved by the default message interpolator.

```
javax.validation.constraints.AssertFalse.message=must be false
javax.validation.constraints.AssertTrue.message=must be true
javax.validation.constraints.DecimalMax.message=\
    must be less than ${inclusive == true ? 'or equal to ' : ''}{value}
javax.validation.constraints.DecimalMin.message=\
    must be greater than ${inclusive == true ? 'or equal to ' : ''}{value}
javax.validation.constraints.Digits.message=\
    numeric value out of bounds (<{integer} digits>.<{fraction} digits> expected)
javax.validation.constraints.Email.message=must be a well-formed email address
javax.validation.constraints.Future.message=must be a future date
javax.validation.constraints.FutureOrPresent.message=must be a date in the present or in the future
javax.validation.constraints.Max.message=must be less than or equal to {value}
javax.validation.constraints.Min.message=must be greater than or equal to {value}
javax.validation.constraints.Negative.message=\
    must be less than 0
javax.validation.constraints.NegativeOrZero.message=\
    must be less than or equal to 0
javax.validation.constraints.NotBlank.message=must not be blank
javax.validation.constraints.NotEmpty.message=must not be empty
javax.validation.constraints.NotNull.message=must not be null
javax.validation.constraints.Null.message=must be null
javax.validation.constraints.Past.message=must be a past date
javax.validation.constraints.PastOrPresent.message=must be a date in the past or in the present
javax.validation.constraints.Pattern.message=\
    must match the following regular expression: {regexp}
javax.validation.constraints.Positive.message=\
    must be greater than 0
javax.validation.constraints.PositiveOrZero.message=\
    must be greater than or equal to 0
javax.validation.constraints.Size.message=size must be between {min} and {max}
```

## Appendix C: Jakarta Persistence 2.0 and schema generation

While not specified by this specification or the Jakarta Persistence 2.0 specification, Persistence Providers are encouraged to make use of Jakarta Bean Validation constraint metadata when generating DDL schemas. The proposal is as followed.

```
Ideas explored and not standardized

Jakarta Persistence consumes Jakarta Bean Validation metadata to enhance persistence property
metadata.

A Persistence provider must use the Jakarta Bean Validation metadata of a given list of groups.
The default group evaluated is Default (default Jakarta Bean Validation group). Groups evaluated
can be overridden by a property.
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm.
For each persistent property in a given entity:
 - extract the list of Jakarta Bean Validation constraints (including the composing constraints)
 - determine the subset of applicable constraints
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata
 - if the property type is an embeddable object or a collection
of embeddable objects, apply the algorithm on the embeddable object properties.

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) /
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length
     for String properties
 - @Digits (which contains integer and fraction) should be considered
     equivalent to @Column.precision = integer+fraction,
     @Column.scale = fraction for decimal columns

The Jakarta Bean Validation annotation metadata should have priority over Jakarta Persistence metadata
(Jakarta Persistence has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)?
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part
of the Jakarta Bean Validation spec today.

Persistence Provider should optionally recognize and try to apply the
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model.
For example, provider ACME might recognize and understand @com.acme.validation.Email
and apply it to the database model.

While most high level constraints will not be recognized, the Jakarta Bean Validation built-in constraints
will be the common language spoken by Persistence Providers. Any high level constraint
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database
(not null, etc), the Java persistence provider catches this report and translates
it into a Jakarta Bean Validation error report. From the perspective of the application, constraint
errors are viewed through a unified layer. Jakarta Bean Validation must provide some API to create a
constraint violation error (constraintDescriptor.createConstraintViolation(…​)).

While this proposal has a lot of value-add, I wonder how difficult it can be to
implement this in persistence providers.

Provide a way to disable Jakarta Bean Validation metadata use by a persistence provider (property based).
```

This is not an endorsement of the Jakarta Persistence expert group or the Jakarta Bean Validation expert group. Such approach may or may not be standardized in the future. Such integration should not be considered portable.

## Appendix D: Module name

While not specified by this specification, Jakarta Bean Validation providers are encouraged to use the module name `java.validation`
in case they provide the Jakarta Bean Validation API as a module for the Java Platform Module System (as defined by JSR 376).

A mandatory module name - which may be `java.validation` or another one - will be defined in a future revision of this specification.

## Appendix E: Changelog

| Note | Names used under the JCP for specifications are preserved in the Changelog section for versions released prior to the move to Jakarta EE in order to preserve historical accuracy. |
| --- | --- |

```
2.0.2 (2019-08-01)
------------------

** Improvement
    * [BVAL-721] - Do not include the license check configuration files into the published
                   artifact

** Task
    * [BVAL-736] - Update TestNG to 6.11 for consistency with the TCK
    * [BVAL-730] - Move specification under Eclipse (EE4J umbrella)
    * [BVAL-723] - Upgrade Asciidoctor tooling
    * [BVAL-720] - Create a specific branch for the Jakarta artifact and adjust the GAV

2.0.1.Final
-----------

Skipped to sync API and specification releases for the first Jakarta EE release.

2.0.0.Final (2017-08-03)
------------------------

2.0.0.CR3 (Final Approval Ballot, 2017-07-11)
---------------------------------------------

** Improvement
    * [BVAL-693] - Make order of <constraint> and <container-element-type> consistent in XSD
    * [BVAL-692] - Misc. findings after review
    * [BVAL-690] - Clarify getLeafBean() for container element constraints
    * [BVAL-464] - Create CONTRIBUTING.md page

** Task
    * [BVAL-687] - Update license information for submission to Final Approval Ballot

2.0.0.CR2 (2017-07-05)
----------------------

** Bug
    * [BVAL-569] - Remove TYPE from targets of @ConvertGroup for consistency with @Valid

** Improvement
    * [BVAL-689] - Make @ConvertGroup#from() default to Default.class
    * [BVAL-685] - Use the full URLs in xsi:schemaLocation of our XML files
    * [BVAL-683] - Fix the release scripts: changelog injection needs to be updated
    * [BVAL-682] - Misc. clarifications around container element validation
    * [BVAL-675] - ValueExtractor exceptions should be wrapped in ValidationException
    * [BVAL-674] - Rename ConstraintDescriptor#validateUnwrappedValue() into
                   getValueUnwrapping()
    * [BVAL-673] - In @Future/@Past and allegates, use imports instead of FQNs (except for
                   the date types)
    * [BVAL-667] - Avoid usage of @NotEmpty example constraint in the spec
    * [BVAL-604] - Use less characters per line to avoid forced line breaks in the rendered
                   PDF

** New Feature
    * [BVAL-510] - Fix JavaDoc warnings, copy changed/new JavaDoc into spec

** Task
    * [BVAL-688] - Upgrade to hibernate-asciidoctor-theme 1.0.2.Final
    * [BVAL-686] - Add JavaDoc for class-level type parameters
    * [BVAL-681] - Clarify value returned by getInvalidValue() for implicitly unwrapped
                   container constraint
    * [BVAL-678] - Clarify "If there is exactly one maximally-specific type-compliant value
                   extractor marked with @UnwrapByDefault, this extractor is applied"
    * [BVAL-677] - Add a section for each built-in constraint so that they appear in the TOC
    * [BVAL-676] - Differentiate the API listings from the examples
    * [BVAL-613] - Add an Automatic-Module-Name entry to the JAR manifest
    * [BVAL-608] - Review the remaining examples in the API to see if we can get rid of them

2.0.0.CR1 (Proposed Final Draft 1, 2017-06-21)
----------------------------------------------

** Bug
    * [BVAL-657] - Fix wrong map key in example

** Improvement
    * [BVAL-671] - Address Yoann's review remarks
    * [BVAL-668] - Address Guillaume's review remarks
    * [BVAL-666] - Clarify that constraints on type parameters are unsupported
    * [BVAL-664] - ValueExtractor exceptions should be wrapped in ValidationException
    * [BVAL-661] - Proof-read on "type argument" vs. "type parameter" and "generic type" vs.
                   "parameterized type"
    * [BVAL-660] - Constructors from super-classes are not considered by
                   getConstraintsForConstructor()
    * [BVAL-659] - Fix some cut-off listings
    * [BVAL-658] - Some JavaDoc fixes
    * [BVAL-653] - In Examples for method and constructor constraint violations, we still use
                   the legacy @Valid location
    * [BVAL-649] - Use parameter names instead of arg<i> in Table 6.2: Property path examples
                   for constrained methods or constructors
    * [BVAL-647] - Relax a few tck-testable assertions
    * [BVAL-646] - Missing assertions in 9.1.1.6. Container-element overriding (XML definition
                   of container element constraints)
    * [BVAL-631] - Clarify which type should be used as the containerClass
    * [BVAL-630] - Add containerClass info in propertyPath examples and add examples for
                   container element
    * [BVAL-618] - Add missing tck-testable markers
    * [BVAL-616] - Provide @PositiveOrZero and @NegativeOrZero constraints

** New Feature
    * [BVAL-672] - Create new constraints @PastOrPresent and @FutureOrPresent

** Task
    * [BVAL-670] - Contradictory sentences about the default locale
    * [BVAL-663] - Raise an exception if both Unwrap and Skip are present in the payload
    * [BVAL-662] - Adjustment on the value extractor resolution algorithm for "non-generic
                   containers"
    * [BVAL-656] - Remove unused imports in Past and Future constraints
    * [BVAL-655] - Allow metadata API to expose container element constraints inherited from
                   the hierarchy
    * [BVAL-652] - State in the spec that a ValueExtractorDeclarationException will be raised
                   by addValueExtractor()
    * [BVAL-650] - Improve the value-extractor XML element description
    * [BVAL-648] - Add example of OptionalInt to value extractor resolution chapter
    * [BVAL-640] - Explicitly state that ValueExtractor#extractValues() must not be called if
                   the container is null
    * [BVAL-639] - Address Emmanuel's review remarks
    * [BVAL-637] - Indicate the extracted type for OptionalInt... value extractors
    * [BVAL-636] - Mandate JavaFX extractors only in environments with JavaFX present
    * [BVAL-635] - Add current git revision to generated tck-audit.xml
    * [BVAL-634] - @OverridesAttribute#name() should have a default value as stated in its
                   docs
    * [BVAL-628] - Fix node builder assertions
    * [BVAL-625] - Clarify structure of property paths for nested containers
    * [BVAL-624] - Clarify whether value extractors discovered through the service loader
                   benefit from CDI
    * [BVAL-601] - Clarify semantics around nested usage of @Valid
    * [BVAL-552] - Clarify the isInIterable() return value for arrays
    * [BVAL-551] - Consider removing the cache of validation providers

2.0.0.Beta2 (Public Review Draft 1, 2017-05-17)
-----------------------------------------------

** Bug
    * [BVAL-627] - Build - Always download new artifacts on CI

** Improvement
    * [BVAL-620] - Clarify semantics when @Valid is used for a collection in the old and the
                   new style at the same time
    * [BVAL-617] - Fix typo "in happening" in Group conversion paragraph
    * [BVAL-615] - Use the new asciidoctor-ant core artifact and upgrade to the latest
                   Asciidoctor
    * [BVAL-614] - Use new Ant 1.9 features to simplify the dependency management in our
                   build.xml
    * [BVAL-611] - Use the new hibernate-asciidoctor-extensions project
    * [BVAL-610] - Inject the section id constants in tck-audit.xml
    * [BVAL-609] - Consider JavaFX's set types in the list of built-in extractors
    * [BVAL-607] - Fix wrong message key in example constraint
    * [BVAL-605] - Avoid empty initialize() methods in spec examples
    * [BVAL-603] - Clarify that CDI is available to value extractors
    * [BVAL-600] - Only use the CustomRoleBlockProcessor for the DocBook output
    * [BVAL-526] - Restart example numbering for each chapter

** New Feature
    * [BVAL-592] - Consider container element constraints in node builder API
    * [BVAL-579] - Support OptionalInt, OptionalLong, OptionalDouble
    * [BVAL-517] - Define module name for BV API

2.0.0.Beta1 (Public Review Draft 1, 2017-04-24)
-----------------------------------------------

** Improvement
    * [BVAL-598] - Use the license-maven-plugin to check the presence of the license
    * [BVAL-596] - Move ValidateUnwrappedValue to javax.validation.metadata
    * [BVAL-595] - Adding missing @since tags

** New Feature
    * [BVAL-594] - Extend meta-data API to cover container element constraints
    * [BVAL-593] - Allow to configure group conversions for container elements in XML
    * [BVAL-591] - Dissolve "container element validation" appendix into spec sections
    * [BVAL-589] - Document release process of the spec
    * [BVAL-549] - Nested cascaded validation

** Task
    * [BVAL-602] - Check that every section has an id
    * [BVAL-599] - Remove metadata usage example from API
    * [BVAL-585] - Add descriptions of build goals to beanvalidation-spec/README.md
    * [BVAL-584] - Use short license headers
    * [BVAL-581] - Discuss with Java EE EG whether it's actually WEB-INF/validation.xml
    * [BVAL-577] - Proof-read "3.3. Constraint composition" on "composing" vs. "composed"
    * [BVAL-575] - Update documentation of Configuration#getDefaultParameterNameProvider()

2.0.0.Alpha2 (2017-03-28)
-------------------------

** Bug
    * [BVAL-566] - Configuration JavaDoc still references "TODO BVAL-496 paste definition of
                   the specification"

** New Feature
    * [BVAL-548] - New constraints: @NotEmpty, @NotBlank, @Email, @Positive, @Negative
    * [BVAL-559] - Add NoProviderFoundException
    * [BVAL-562] - Create new ElementKind for constraint violations on the type-use level
    * [BVAL-571] - Discover value extractor implementations using the service loader mechanism
    * [BVAL-572] - Allow to add value extractors per validator factory and validator and via
                   validation.xml
    * [BVAL-586] - Support defining constraint on container element type in XML mapping

** Task
    * [BVAL-560] - Mention Oracle instead of Sun in the evaluation license
    * [BVAL-565] - Configure japicmp plug-in for creating API change report
    * [BVAL-578] - Make the assertion related to NoProviderFoundException not testable
    * [BVAL-587] - Go back to coderay for code highlighting in the spec

** Improvement
    * [BVAL-264] - Improve toString() in ConstraintViolationException
    * [BVAL-528] - Replace all inline listings with includes of the actual API files / spec
                   examples
    * [BVAL-561] - Make @OverridesAttribute repeatable and documented
    * [BVAL-567] - Tone down @Past / @Future JavaDoc on clockprovider
    * [BVAL-568] - Make built-in annotations documented
    * [BVAL-576] - Revise wording in 10.3.3 "Method and constructor validation"
    * [BVAL-580] - Switch assertion section ids to a string instead of a numeric
                   representation
    * [BVAL-583] - Use the common theme for the asciidoc output

2.0.0.Alpha1 (Early Draft 1, 2017-02-02)
----------------------------------------

** Bug
    * [BVAL-558] - Ensure correct concurrent access to cacheValidationProviders in
                   Validation#GetValidationProviderListAction

** New Feature
    * [BVAL-467] - Support JDK8's Optional class
    * [BVAL-496] - @Future/@Past validators for JSR 310 data types
    * [BVAL-497] - Mark BV-defined constraint types with @Repeatable
    * [BVAL-498] - Retrieve method parameter names via new API in Java 8
    * [BVAL-508] - Offer validation of values contained in containers
    * [BVAL-544] - Promote TYPE_USE usage for constraint annotations
    * [BVAL-550] - Make @ConvertGroup repeatable and usable on type arguments

** Task
    * [BVAL-509] - Make BVAL compilable with Java 9
    * [BVAL-512] - Provide a way to reference validation-api source code in the spec
    * [BVAL-513] - Add Google Analytics to HTML version of the specification
    * [BVAL-538] - Rename createTckAuditFile ant task to create-tck-audit-file for consistency
    * [BVAL-540] - Use Maven to download the snapshot of the API sources
    * [BVAL-541] - Change CI links in README.md
    * [BVAL-547] - Use simplified license header for API files
    * [BVAL-554] - Add the ability to generate an asciidoc document containing all the spec in
                   a single file

** Improvement
    * [BVAL-455] - Move XML namespace to jcp.org from jboss.org
    * [BVAL-460] - Set ignore-annotation default value for beans to true in XSD to document
                   the spec behavior
    * [BVAL-486] - Do not use validation provider resolver when provider is explicitly given
    * [BVAL-527] - Raise Java baseline to version 8
    * [BVAL-529] - Mention JSR 380 and BV 2.0 in the spec
    * [BVAL-530] - Rename master.asciidoc to index.asciidoc
    * [BVAL-532] - Fix javadoc warnings
    * [BVAL-533] - Update Maven dependencies
    * [BVAL-534] - Update all outdated links to java.sun.com
    * [BVAL-535] - Reduce the number of compilation warnings in the API
    * [BVAL-536] - Update tck-audit.xsl to the current version of BV
    * [BVAL-537] - Make section numbers stable from 1.1 to 2.0
    * [BVAL-539] - Set the version of the maven-deploy-plugin
    * [BVAL-545] - Fix description of validateValue() method
    * [BVAL-546] - Make ValidatorFactory extend AutoClosable
    * [BVAL-555] - Provide default implementation for ConstraintValidator#initialize()

1.1.0.Final (2013-04-10)
------------------------

** Improvement
    * [BVAL-452] - Remove @Deprecate annotation from addNode() method

1.1.0.CR3 (2013-03-20)
----------------------

** Bug
    * [BVAL-444] - Remove revisionflags from specification
    * [BVAL-445] - Do not consider arrays of primitives equivalent to arrays of wrappers in
                   ConstraintValidation resolution

** Improvement
    * [BVAL-448] - Mention "boolean" instead of "Boolean" in getter definition
    * [BVAL-450] - Make @ValidateOnExecutable for @Override methods raise an exception

** Task
    * [BVAL-449] - Remove tck-needs-update

1.1.0.CR2 (2013-03-14)
----------------------

** Bug
    * [BVAL-431] - Typo in EL expression exemple
    * [BVAL-435] - Rename element <validated-executables/> to
                   <default-validated-executable-types/>
    * [BVAL-436] - Offer global switch to disable executable validation altogether
    * [BVAL-437] - Redesign @ValidateExecutable into @ValidateOnExecution and as CDI marker
                   for portability

** Improvement
    * [BVAL-420] - Add missing @since in metadata package
    * [BVAL-421] - Clarify whether or not getters are provided by the metadata API
    * [BVAL-422] - Update TCK markers
    * [BVAL-423] - Clarify behavior of ConstraintViolation#getLeafBean() for validateValue()
    * [BVAL-424] - Refer to @SupportedValidationTarget in ConstraintValidation JavaDoc
    * [BVAL-429] - Throw a ConstraintDefinitionException if there a several cross-parameter
                   validators
    * [BVAL-432] - Rename areParametersConstrained to hasConstrainedParameters and
                   isReturnValueConstrained to hasConstrainedReturnValue on
                   ExecutableDescriptor
    * [BVAL-433] - Forbid @ValidatedExecutable on methods of parallel hierarchies
    * [BVAL-434] - Clarify exception type if cross-parameter validator support neither Object
                   nor Object[]
    * [BVAL-440] - Improve description of ExecutableType.GETTER_METHODS
    * [BVAL-442] - Make getConstrainedMethods(MethodType methodType,
                   MethodType... methodTypes) to be less error-prone

** New Feature
    * [BVAL-441] - Allow for identical configuration in subtypes

** Task
    * [BVAL-425] - Raise IllegalArgumentException when validateParameters and
                   validateReturnValue are passed parameters that do not match
    * [BVAL-428] - Map remaining assertions for BV 1.1
    * [BVAL-438] - Integration chapter should not mention that the boostrap API can be used to
                   create additional ValidationFactory
    * [BVAL-439] - Clarify that EE validator factory supports CDI services

1.1.0.CR1 (proposed final draft, 2013-02-20)
--------------------------------------------

** Bug
    * [BVAL-322] - Formatting and style improvements
    * [BVAL-369] - Specify copyright year correctly in license headers
    * [BVAL-391] - Use @SupportValidationTarget instead of @CrossParameterConstraint for
                   cross-parameter constraint validators
    * [BVAL-397] - Align the JavaDoc on temps (return vs returns, define vs defines)
    * [BVAL-401] - validateReturnValue should not throw an exception if the method has no
                   return value
    * [BVAL-402] - Remove notion of "reachable" parameters in method validation routine
    * [BVAL-403] - Add example on method validation to 4.6.3. ("Traversable property")
    * [BVAL-407] - ConstraintViolation.unwrap parameterized type hides ConstraintViolation
                   parameterized type

** Improvement
    * [BVAL-275] - Align on style for referencing methods in spec text
    * [BVAL-277] - Align on style for author names in JavaDoc
    * [BVAL-285] - ValidatorFactory#close should clearly state post conditions
    * [BVAL-350] - Add more examples on how to use methods for validating method and
                   constructor constraints
    * [BVAL-362] - Reference the various specs (JPA, JSF, CDI, JavaBeans)
    * [BVAL-400] - Add xml and exception chapters to the list in "How this document is
                   organized"
    * [BVAL-404] - Path examples in table 5.2 are missing node specific attributes like
                   parameterIndex
    * [BVAL-405] - Clarify what isBeanConstrained does and add hasExecutableConstrained
    * [BVAL-406] - Add ConstraintDescriptor.getValidationAppliesTo() and getMessageTemplate()
    * [BVAL-409] - Make ParameterNameProvider use List instead of arrays
    * [BVAL-410] - Make node creation suppress the cross-param and bean-level node in case of
                   subnode creation
    * [BVAL-412] - Make <convert-group/> follow <valid/> and precede <constraint/> in the
                   mapping XSD
    * [BVAL-413] - Fix method validation and ConstraintViolation example
    * [BVAL-414] - Add example for metadata API with executables
    * [BVAL-415] - Make sure maven plugins are set in beanvalidation-api
    * [BVAL-417] - Mention "validationAppliesTo" in docs of @SupportedValidationTarget
    * [BVAL-419] - Clarify that using a cross-parameter constraint on a method without
                   parameter is illegal

1.1.0.Beta4 (2013-02-15)
------------------------

** Sub-task
    * [BVAL-316] - Decide on whether to allow validation of static methods or not
    * [BVAL-330] - Refinements around metadata API

** Bug
    * [BVAL-221] - The constraint violation builder cannot put constraint on a top level map
                   key
    * [BVAL-283] - Clarify that ConstraintValidator instances must be destroyed after each
                   method validation call if the ConstraintValidatorFactory is provided to the
                  Validator
    * [BVAL-284] - Clarify that ConstraintValidator instances passed to CVF.releaseInstance
                   must be coming from the CVF creating them
    * [BVAL-326] - Fix metadata and error reports for cross-parameter validation
    * [BVAL-328] - Add recommendation that @Inherited shouldn't be added to constraint
                   annotation types
    * [BVAL-337] - Clarifications around ConstraintViolation for method validation
    * [BVAL-370] - Re-consider how cross-parameter constraints are represented in metadata API
                   and XML descriptors
    * [BVAL-375] - Add dedicated "validationAppliesTo" element to schema type representing
                   constraints
    * [BVAL-378] - Mismatch between enum ExecutableType and corresponding schema type
    * [BVAL-380] - Remove improper sentence around constraint being validated once globally in
                   validation routine
    * [BVAL-381] - Specify which path is pathed to traversable resolvers in case of cascaded
                   method validation
    * [BVAL-388] - Create sub-types of Node instead of Node#getElementDescriptor() and remove
                   ElementDescriptor.getKind()
    * [BVAL-389] - @ValidateExecutable.type should default to ALL and NONE should be renamed
                   OFF
    * [BVAL-390] - Clarify syntax for specifying parameter types in XML
    * [BVAL-393] - Revert "intersection type trick"

** Improvement
    * [BVAL-191] - Introduce a addBeanNode() method to the fluent node builder API
    * [BVAL-269] - Polish support for dependency injection after draft feedback
    * [BVAL-336] - Decide what to do about element descriptor when using constraint violation
                   builder API
    * [BVAL-344] - Improve wording around CDI integration
    * [BVAL-368] - Return constant value from Node#getName() for return value nodes
    * [BVAL-372] - Consider moving ExecutableValidator to the executable subpackage
    * [BVAL-379] - Clarify that modifications to BootstrapConfiguration have no effect
    * [BVAL-384] - Add example for ElementDescriptor#findConstraints() for methods
    * [BVAL-385] - Return void ReturnValueDescriptor from
                   ExecutableDescriptor#getReturnValueDescriptor() for void methods
    * [BVAL-386] - Clarify that CDI integration is mandatory under Java EE only
    * [BVAL-398] - Make validateReturnValue raise ValidationException if the method has no
                   return value

** New Feature
    * [BVAL-329] - Method validation support (III)
    * [BVAL-383] - Add a  unwrap method in ConstraintViolation
    * [BVAL-387] - Add ability to add a node corresponding to a parameter in
                   ConstraintViolationBuilder

** Task
    * [BVAL-394] - Verify that we don't need a spec defined API to expose classes hosting
                   constrained methods or constructor defined in XML

1.1.0.Beta3 (2013-02-01)
------------------------

** Sub-task
    * [BVAL-273] - Extend the XML descriptor schema to represent method-level constraints
    * [BVAL-314] - Provide ability to disable validation for method/constructor validation

** Bug
    * [BVAL-327] - Provide way to change the executable validation (ie accept getters)
    * [BVAL-342] - Clarify that validateProperty / validateValue does not support property
                   paths
    * [BVAL-343] - "Provider org.hibernate.validator.HibernateValidator not a subtype" error
                   during service discovery
    * [BVAL-345] - List of messages in the standard resource bundle is incomplete
    * [BVAL-346] - Clarify that getters must have no parameter
    * [BVAL-347] - Add implicit assumptions from TCK to spec text
    * [BVAL-351] - Clarify that EntityManager cannot be injected if validating from JPA
    * [BVAL-361] - Expose group conversions via meta-data API
    * [BVAL-363] - Clarify that super method constraints are considered in the validation
                   routine but not constructors
    * [BVAL-366] - Fix typo on ConfigurationState JavaDoc
    * [BVAL-371] - Add package level javadoc (package-info.java)
    * [BVAL-377] - Provide MessageInterpolator.Context#unwrap to allow for custom extensions

** Improvement
    * [BVAL-192] - Add 'exclusive' boolean attribute to @DecimalMin/@DecimalMax constraints
    * [BVAL-332] - Specify semantics of @ConvertGroup when given several times at overridden
                   property
    * [BVAL-340] - Denote method parameter constraints at declaration site (vs. at definition
                   site)
    * [BVAL-352] - Clarify what managed means in the integration chapter in particular for CDI
    * [BVAL-359] - Relax contract of ExecutableDescriptor#getParameterDescriptors()
    * [BVAL-360] - Describe IllegalArgumentException for ExecutableValidator methods
    * [BVAL-364] - Clarify whether or not the metadata API ignore the method enable/disable
                   settings
    * [BVAL-365] - Clarifications around group conversion in hierarchies
    * [BVAL-367] - Make clear whether methods/properties inherited from super types are
                   reflected by the meta-data API
    * [BVAL-373] - Move ConvertGroup to the groups subpackage

** New Feature
    * [BVAL-219] - Add support for interpolating the value in error messages
    * [BVAL-223] - Add formatter syntax for interpolated messages via EL expression support
    * [BVAL-249] - Add unwrap method to ConstraintValidatorContext for provider extension
    * [BVAL-333] - Enable configuration of group conversions via XML

** Task
    * [BVAL-338] - Clarify lifecycle of managed objects created by BV povider
    * [BVAL-348] - Add example for illegal group conversion on a return value in an
                   inheritance hierarchy
    * [BVAL-349] - Mark spec sentences as TCK-relevant (1.0 assertions)
    * [BVAL-353] - Mark spec sentences as TCK-relevant (1.1 assertions)
    * [BVAL-354] - Describe tagging of TCK-relevant sentences in README.md
    * [BVAL-355] - Rename Validator#forMethods() to forExecutables()
    * [BVAL-357] - Clarify that traversable resolver is not used on parameter and return
                   values during method validation
    * [BVAL-358] - Make ExecutableDescriptor#validateConstructorParameters() and
                   validateConstructorReturnValue() more usable
    * [BVAL-374] - Clarify exceptional case in section 5.5.5 bootstrapping
    * [BVAL-376] - Remove @MethodValidated as it is not adding value to the CDI integration

1.1.0.Beta2 (2012-11-27)
------------------------

** Sub-task
    * [BVAL-331] - Establish common super-interface for MethodDescriptor and
                   ConstructorDescriptor

** Bug
    * [BVAL-335] - @ConvertGroup.List is missing target types and retention policy

** Improvement
    * [BVAL-198] - Simplify creation of ConstraintViolationExceptions
    * [BVAL-334] - Refer to CDI provided beans as "built-in" beans

1.1.0.Beta1 (public review draft, 2012-10-19)
---------------------------------------------

** Sub-task
    * [BVAL-232] - Support cross-parameter constraints
    * [BVAL-274] - Extend the meta-data API with required convenience methods for method
                   validation
    * [BVAL-290] - Mark new method with @since annotation
    * [BVAL-300] - Clarify behavior of constructor validation in class hierachies
    * [BVAL-308] - Settle on approach for constraint refinement in sub-types
    * [BVAL-309] - Specify logic to be implemented by method validation interceptors
    * [BVAL-310] - Move methods related to method validation to delegate interface
    * [BVAL-317] - Rename 'method-level validation' with 'method validation'

** Bug
    * [BVAL-296] - Example using ConstraintValidatorContext is incorrect
    * [BVAL-298] - DefaultValidationProviderResolver should check context and current class
                   loader for service file
    * [BVAL-304] - Add OSGi headers in the reference implementation
    * [BVAL-306] - Clarify interceptor order in method validation triggering

** Improvement
    * [BVAL-208] - Support groups translation during cascaded validations
    * [BVAL-226] - Make clear whether the static or the runtime type should be considered when
                   creating property paths in case of cascaded validations
    * [BVAL-230] - Add support for validating CharSequence types instead of just Strings
    * [BVAL-259] - Evaluation of composed constraints should stops on first validation error
                   in case of @ReportAsSingleViolation
    * [BVAL-281] - Improve message when building a ValidatorFactory but no provider is
                   available in the classpath
    * [BVAL-292] - Clarify the behavior of ConfigurationSource methods when no configuration
                   file is present
    * [BVAL-299] - Add note on required Java version

** New Feature
    * [BVAL-272] - Method validation support (II)
    * [BVAL-295] - Should validation-configuration and validation-mapping xsds define a
                   version attribute

** Task
    * [BVAL-280] - Decide whether DefaultValidationProviderResolver should not throw an
                   exception when a specified provider cannot be loaded
    * [BVAL-307] - Decide how CDI and Bean Validation is integrated

1.1.0.Alpha1 (early draft 1, 2012-03-13)
----------------------------------------

** Sub-task
    * [BVAL-242] - Extend the meta-data API to represent method-level constraints
    * [BVAL-243] - Provide a means for specifying method parameter names
    * [BVAL-244] - Extend Validator API with methods for method validation
    * [BVAL-245] - Define how method constraints are declared at parameters and return values

** Bug
    * [BVAL-194] - Invalid license info
    * [BVAL-196] - Missing </code> element in Javadocs for
                   ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder
    * [BVAL-212] - Wrong closing </code> element in javadocs of BeanDescriptor
    * [BVAL-236] - Fails to load META-INF/services provider configuration files on non-ASCII
                   platforms

** Improvement
    * [BVAL-201] - Fix typo in spec, chapter 4.4.3
    * [BVAL-270] - Specify that Bean Validation 1.1 providers must support deployment
                   descriptors version 1.0

** New Feature
    * [BVAL-238] - Support for container injection in ConstraintValidator
    * [BVAL-241] - Support for method validation
    * [BVAL-258] - Clean introduction section to reflect Bean Validation 1.1
    * [BVAL-263] - Add a close() method to ValidatorFactory
    * [BVAL-265] - Expose settings defined in XML in the Configuration API
                   (for ConstraintValidatorFactory, MessageInterpolator etc)

** Task
    * [BVAL-206] - Update pom to use the new distributationManagement information
    * [BVAL-228] - Prepare specification document and Git repository for public eyes
    * [BVAL-279] - Update POM file for Bean Validation API to use latest Git repo urls and
                   generally be ready for a release

1.0.0 final (2009-10-12)
------------------------

** Bug
    * [BVAL-181] - Fix some namespace issues in validation-configuration-1.0.xsd

** Improvement
    * [BVAL-182] - Add getDefaultTraversableResolver and getDefaultConstraintValidatorFactory
                   to Configuration
    * [BVAL-183] - Add getTraversableResolver and getConstraintValidatorFactory to
                   ValidatorFactory
    * [BVAL-184] - Replace Red Hat Middleware LLC to Red Hat, Inc. and/or its affiliates
    * [BVAL-186] - Clarify method names on the constraint violation builder DSL of
                   ConstraintValidatorContext
    * [BVAL-187] - Imply that ConstraintViolation is serializable if entities are serializable

** New Feature
    * [BVAL-185] - Allow overriding of ConstraintValidatorFactory when creating a Validator
    * [BVAL-190] - Add methods to filter ConstraintDescriptor per groups, target and scope

** Task
    * [BVAL-132] - Define behaviour for BeanDescriptor.getConstraintsForProperty(null)

1.0.CR5 (2009-08-27)
--------------------

** Bug
    * [BVAL-173] - Fix typo getUnorderdConstraintDescriptorsMatchingGroups =>
                   getUnorderedConstraintDescriptorsMatchingGroups
    * [BVAL-177] - Payload of composed constraints are ignored, the main constraint payload is
                   propagated
    * [BVAL-178] - Add payload to the XML schema
    * [BVAL-180] - ConstraintDescriptor.getPayload() should return
                   Set<Class<? extends Payload>> not Set<Class<Payload>>

** Improvement
    * [BVAL-174] - clearer default message for assertTrue and assertFalse
    * [BVAL-179] - Rename ConstraintPayload to Payload

1.0.CR4 Unpublished release
---------------------------

1.0.CR3 (Proposed Final Draft 2, 2009-07-08)
--------------------------------------------

** Bug
    * [BVAL-144] - validation-configuration.xsd property element does not extend basic string
                   type preventing Oxygen to be happy
    * [BVAL-159] - Fix example 3.8 on object graph validation

** Improvement
    * [BVAL-143] - Describe path with an object model
    * [BVAL-147] - Support for unbounded wildcards in ConstraintValidator
    * [BVAL-148] - Built-in constraints annotations now annotated with
                   @Constraint(validatedBy={})
    * [BVAL-151] - TraversableResolver#isTraversable can receive null traversableObject when
                   valudateValue is called
    * [BVAL-152] - TraversableResolver should differentiate reachability and cascadability
    * [BVAL-153] - Generify ConstraintValidatorException
    * [BVAL-154] - Iterable is a superclass of all collection, clarify it's interaction with
                   @Valid
    * [BVAL-155] - ignore-annotation is not inherited hierarchically: make that explicit
    * [BVAL-156] - Pattern.Flag takes the JDK flag int at construction time
    * [BVAL-157] - Add [] to non-indexed iterable path
    * [BVAL-158] - Clarify that @Valid is orthogonal to the idea of group
    * [BVAL-160] - rename message template key as [f.q.c.n of the constraint].message
    * [BVAL-162] - Move metadata classes to the metadata package
                   (BeanDescriptor, ElementDescriptor, PropertyDescriptor,
                   ConstraintDescriptor)
    * [BVAL-164] - Validation.byProvider now accept the provider implementation class
    * [BVAL-166] - IllegalArgumentException raised on BeanDescriptor.getConstraintsForProperty
                   and Validator.getConstraintsForClass
    * [BVAL-167] - Recommend f.q.c.n.message for resource bundle keys and migrate examples
    * [BVAL-169] - Rename ElementDescriptor.getType to getElementClass
    * [BVAL-170] - Let built-in annotations to support ElementType.PARAMETER and
                   ElementType.CONSTRUCTOR

** New Feature
    * [BVAL-149] - Provide access to the ValidationProviderResolver via BootstrapState
    * [BVAL-150] - Add ConstraintViolation.getRootBeanClass
    * [BVAL-161] - Add unwrap methods to ValidatorFactory and Validator
    * [BVAL-163] - Add support for constraint payload
    * [BVAL-168] - Return the list of matching ConstraintDescriptor for a given set of groups
    * [BVAL-172] - Provide ConstraintDescriptor#getPayload

1.0.CR2 Unpublished release
---------------------------

1.0.CR1 (Proposed Final Draft, 2009-03-16)
------------------------------------------

** Bug
    * [BVAL-118] - ConstraintDescriptor.getGroups() returns Default if no group is declared on
                   the constraint
    * [BVAL-125] - @Size.min default value should be 0

** Improvement
    * [BVAL-32] - Describe what is happening when a composition is not consistent
    * [BVAL-50] - Be consistent in the spec, use @author or not
    * [BVAL-54] - Specify that constraints on non getter methods are ignored (if BVAL-36 is
                  not accepted)
    * [BVAL-72] - Validating an object multiple times if in a different branch of the graph
    * [BVAL-86] - Default TraversableResolver is JPA aware
    * [BVAL-88] - Improvement on MessageInterpolator
    * [BVAL-91] - Rename Constraint related classes to improve readability
    * [BVAL-95] - @Size should support Map
    * [BVAL-96] - Support byte in @Min/@Max
    * [BVAL-106] - Constraintdescriptor.getConstraintValidatorClasses() should return a List,
                   not an array
    * [BVAL-114] - Relax property names in ConstraintValidatorContext
    * [BVAL-120] - Rename ConstraintViolation getRawMessage=>getMessageTemplate,
                   getInterpolatedMessage=>getMessage
    * [BVAL-122] - Rename @GroupSequence.sequence to @GroupSequence.value
    * [BVAL-126] - Define group sequence logic more formally and eliminate corner cases
    * [BVAL-129] - Clarify ConstraintValidatorContext propertyPath generation
    * [BVAL-130] - Make ConstraintDescriptor generic:
                   ConstraintDescriptor<T extends Annotation>
    * [BVAL-131] - Provide object graph navigation determinism
    * [BVAL-134] - @Valid accepts objects implementing Iterable
    * [BVAL-135] - Remove DefaultValidationProviderResolver from the public API
    * [BVAL-136] - Add Context object for MessageInterpolator
    * [BVAL-137] - prefix for message template key is constraint. instead of validator.
    * [BVAL-138] - Rename OverridesParameter to OverridesAttribute
    * [BVAL-139] - Remove @OverridesParameters and use the inner class mode
                   (OverridesAttribute.LIst)
    * [BVAL-140] - BeanDescriptor.getConstrainedProperties() returns Set<PropertyDescriptor>
    * [BVAL-141] - Rename ConstraintDescriptor.getParameters() to getAttributes()

** New Feature
    * [BVAL-52] - Define the exception hierarchy and rules
    * [BVAL-55] - Exception policy
    * [BVAL-65] - Additional built-in constraints
    * [BVAL-98] - Type-safe ConstraintValidator
    * [BVAL-100] - Support XML mapping overriding
    * [BVAL-102] - Support META-INF/validation.xml
    * [BVAL-119] - Introduce @Pattern for regexp
    * [BVAL-121] - Define built-in constraints plural forms
    * [BVAL-123] - Add ConstraintViolationException
    * [BVAL-124] - Introduce backslash as escaping character
    * [BVAL-142] - @Min/@max no longer accept float/double and introduce
                   @DecimalMin/@DecimalMax

** Task
    * [BVAL-24] - What should be done when multiple META-INF/validation.xml are found?
    * [BVAL-117] - Specify behaviour of ConstraintValidator.initalize in the case of
                   inconsistent values in constraint parameters
    * [BVAL-127] - Remove ConstraintViolation.getGroups()
    * [BVAL-128] - Clarify invalid cases for validateProperty / validateValue on proeprtyName
                   being empty or null
    * [BVAL-133] - Remove JPA and JSF integration proposals

1.0.Beta2 (Public Draft, 2008-12-15)
------------------------------------

** Bug
    * [BVAL-6] - Wrong example in validation methods section
    * [BVAL-17] - Validator<A>.validate(b) where b:B and B extends A should validate B.
                  Metadata APIs are specific to A
    * [BVAL-42] - Names of message keys in spec inconsistent
    * [BVAL-45] - Typo at ConstraintDescriptor.getContstraintClass()

** Improvement
    * [BVAL-29] - Types should be determined at runtime
    * [BVAL-33] - Should ConstraintDescriptor.getConstraintImplementation() replaced by
                  .getConstraintImplementationClass()?
    * [BVAL-40] - Rename InvalidConstraint to ConstraintViolation
    * [BVAL-48] - Add a way to access the default message resolver
    * [BVAL-49] - Mark metadata classes as immutable
    * [BVAL-59] - Rethink the group sequence inheritance rules
    * [BVAL-60] - ConstraintViolation points to the corresponding ConstraintDescriptor
    * [BVAL-68] - Specify that static methods and fields are not validated
    * [BVAL-73] - Rename ConstraintViolation.getBeanClass() to CV. getRootClass() or simply
                  remove it
    * [BVAL-78] - Forbid a Validation implementation to modify the state of the object being
                  validated

** New Feature
    * [BVAL-30] - Define validation Context to be passed to constraint implementation calls
    * [BVAL-36] - Validation of method parameters and returned values
    * [BVAL-67] - Allow MessageResolver to be Localizable
    * [BVAL-71] - Should we have group aggregation?
    * [BVAL-76] - Expose the raw message to ConstraintViolation
    * [BVAL-79] - Groups are now Type based rather than String based
    * [BVAL-81] - Provide a TraversableResolver contract

** Task
    * [BVAL-1] - Remove references to 'beancheck' in the spec
    * [BVAL-3] - Replace array return types with Sets
    * [BVAL-4] - Return value for @NotEmpty for null values
    * [BVAL-5] - Change order of exmaple classes in Book/Author example
    * [BVAL-7] - Use of example in ConstraintFactory section (2.4)
    * [BVAL-8] - StandardConstraint description (2.5)
    * [BVAL-23] - Make Validator<T> thread-safe
```

Version 2.0

Last updated 2019-08-12 22:54:33 GMT



=== Content from docs.oracle.com_e4f96345_20250110_195959.html ===


Oracle | Hardware and Software, Engineered to Work Together

Documentation

[Search Java EE Documentation](/javaee/search.html)

[Java Platform, Enterprise Edition (Java EE) 7](../index.html)

Send Feedback | Print
| [PDF](../JEETT.pdf) | [ePub](../JEETT.epub) | [Mobi](../JEETT.mobi)

Java Platform, Enterprise Edition: The Java EE Tutorial

[Previous Page](jsf-facelets009.htm "Previous Page")[Next Page](jsf-el001.htm "Next Page")

# 9 Expression Language

This chapter introduces the Expression Language (also referred to as the EL), which provides an important mechanism for enabling the presentation layer (web pages) to communicate with the application logic (managed beans). The EL is used by several JavaEE technologies, such as JavaServer Faces technology, JavaServer Pages (JSP) technology, and Contexts and Dependency Injection for Java EE (CDI). The EL can also be used in stand-alone environments. This chapter only covers the use of the EL in Java EE containers.

The following topics are addressed here:

* [Overview of the EL](jsf-el001.htm#BNAHQ)
* [Immediate and Deferred Evaluation Syntax](jsf-el002.htm#BNAHR)
* [Value and Method Expressions](jsf-el003.htm#BNAHU)
* [Operations on Collection Objects](jsf-el004.htm#CIHGABHD)
* [Operators](jsf-el005.htm#BNAIK)
* [Reserved Words](jsf-el006.htm#BNAIL)
* [Examples of EL Expressions](jsf-el007.htm#BNAIM)
* [Further Information about the Expression Language](jsf-el008.htm#CIHGBBHA)

![Close Window](../assets/img-common/X.png "Close Table of Contents Window")
### Table of Contents

## Java Platform, Enterprise Edition: The Java EE Tutorial

Expand | Collapse

* [Title and Copyright Information](title.htm)
* [Preface](preface.htm#GEXAF)
  + [Audience](preface.htm#CIACGIBD)
  + [Documentation Accessibility](preface.htm#CIAHFICG)
  + [Before You Read This Book](preface.htm#BNAAC)
  + [Related Documentation](preface.htm#GIPRL)
  + [Conventions](preface.htm#GKVTF)
  + [Default Paths and File Names](preface.htm#GFIRK)
* [Part I Introduction](partintro.htm#GFIRP)
  + [1 Overview](overview.htm#BNAAW)
    - [1.1 Java EE 7 Platform Highlights](overview001.htm#GIQVH)
    - [1.2 Java EE Application Model](overview002.htm#BNAAX)
    - [1.3 Distributed Multitiered Applications](overview003.htm#BNAAY)
      * [1.3.1 Security](overview003.htm#BNABA)
      * [1.3.2 Java EE Components](overview003.htm#BNABB)
      * [1.3.3 Java EE Clients](overview003.htm#BNABC)
        + [1.3.3.1 Web Clients](overview003.htm#BNABD)
        + [1.3.3.2 Application Clients](overview003.htm#BNABF)
        + [1.3.3.3 Applets](overview003.htm#BNABE)
        + [1.3.3.4 The JavaBeans Component Architecture](overview003.htm#BNABG)
        + [1.3.3.5 Java EE Server Communications](overview003.htm#BNABH)
      * [1.3.4 Web Components](overview003.htm#BNABJ)
      * [1.3.5 Business Components](overview003.htm#BNABK)
      * [1.3.6 Enterprise Information System Tier](overview003.htm#BNABL)
    - [1.4 Java EE Containers](overview004.htm#BNABO)
      * [1.4.1 Container Services](overview004.htm#BNABP)
      * [1.4.2 Container Types](overview004.htm#BNABQ)
    - [1.5 Web Services Support](overview005.htm#BNABS)
      * [1.5.1 XML](overview005.htm#BNABT)
      * [1.5.2 SOAP Transport Protocol](overview005.htm#BNABU)
      * [1.5.3 WSDL Standard Format](overview005.htm#BNABV)
    - [1.6 Java EE Application Assembly and Deployment](overview006.htm#BNABX)
    - [1.7 Java EE 7 APIs](overview007.htm#BNACJ)
      * [1.7.1 Enterprise JavaBeans Technology](overview007.htm#BNACL)
      * [1.7.2 Java Servlet Technology](overview007.htm#BNACM)
      * [1.7.3 JavaServer Faces Technology](overview007.htm#BNACP)
      * [1.7.4 JavaServer Pages Technology](overview007.htm#BNACN)
      * [1.7.5 JavaServer Pages Standard Tag Library](overview007.htm#BNACO)
      * [1.7.6 Java Persistence API](overview007.htm#BNADB)
      * [1.7.7 Java Transaction API](overview007.htm#BNACR)
      * [1.7.8 Java API for RESTful Web Services](overview007.htm#GIRBT)
      * [1.7.9 Managed Beans](overview007.htm#GJXSD)
      * [1.7.10 Contexts and Dependency Injection for Java EE](overview007.htm#GJXVO)
      * [1.7.11 Dependency Injection for Java](overview007.htm#GJXVG)
      * [1.7.12 Bean Validation](overview007.htm#GJXTY)
      * [1.7.13 Java Message Service API](overview007.htm#BNACQ)
      * [1.7.14 Java EE Connector Architecture](overview007.htm#BNACZ)
      * [1.7.15 JavaMail API](overview007.htm#BNACS)
      * [1.7.16 Java Authorization Contract for Containers](overview007.htm#GIRBE)
      * [1.7.17 Java Authentication Service Provider Interface for Containers](overview007.htm#GIRGP)
      * [1.7.18 Java API for WebSocket](overview007.htm#CJAHDJBJ)
      * [1.7.19 Java API for JSON Processing](overview007.htm#CJAGIEEI)
      * [1.7.20 Concurrency Utilities for Java EE](overview007.htm#CJAFGFCJ)
      * [1.7.21 Batch Applications for the Java Platform](overview007.htm#CJAJHGIH)
    - [1.8 Java EE 7 APIs in the Java Platform, Standard Edition 7](overview008.htm#GIRDR)
      * [1.8.1 Java Database Connectivity API](overview008.htm#BNADA)
      * [1.8.2 Java Naming and Directory Interface API](overview008.htm#BNADC)
      * [1.8.3 JavaBeans Activation Framework](overview008.htm#BNACT)
      * [1.8.4 Java API for XML Processing](overview008.htm#BNACU)
      * [1.8.5 Java Architecture for XML Binding](overview008.htm#BNACW)
      * [1.8.6 Java API for XML Web Services](overview008.htm#BNACV)
      * [1.8.7 SOAP with Attachments API for Java](overview008.htm#BNACX)
      * [1.8.8 Java Authentication and Authorization Service](overview008.htm#BNADD)
      * [1.8.9 Common Annotations for the Java Platform](overview008.htm#sthref108)
    - [1.9 GlassFish Server Tools](overview009.htm#BNADF)
  + [2 Using the Tutorial Examples](usingexamples.htm#GFIUD)
    - [2.1 Required Software](usingexamples001.htm#GEXAJ)
      * [2.1.1 Java Platform, Standard Edition](usingexamples001.htm#GEXAE)
      * [2.1.2 Java EE 7 Software Development Kit](usingexamples001.htm#GEXAB)
        + [2.1.2.1 SDK Installation Tips](usingexamples001.htm#GEXBC)
      * [2.1.3 Java EE 7 Tutorial Component](usingexamples001.htm#GEXBA)
      * [2.1.4 NetBeans IDE](usingexamples001.htm#GEXAZ)
        + [2.1.4.1 To Install NetBeans IDE without GlassFish Server](usingexamples001.htm#GJSEQ)
        + [2.1.4.2 To Add GlassFish Server as a Server Using NetBeans IDE](usingexamples001.htm#GIQZL)
      * [2.1.5 Apache Maven](usingexamples001.htm#GEXAA)
    - [2.2 Starting and Stopping GlassFish Server](usingexamples002.htm#BNADI)
      * [2.2.1 To Start GlassFish Server Using NetBeans IDE](usingexamples002.htm#CHDCACDI)
      * [2.2.2 To Stop GlassFish Server Using NetBeans IDE](usingexamples002.htm#sthref128)
      * [2.2.3 To Start GlassFish Server Using the Command Line](usingexamples002.htm#CHDBDDAF)
      * [2.2.4 To Stop GlassFish Server Using the Command Line](usingexamples002.htm#sthref131)
    - [2.3 Starting the Administration Console](usingexamples003.htm#BNADJ)
      * [2.3.1 To Start the Administration Console Using NetBeans IDE](usingexamples003.htm#GJKST)
    - [2.4 Starting and Stopping the Java DB Server](usingexamples004.htm#BNADK)
      * [2.4.1 To Start the Database Server Using NetBeans IDE](usingexamples004.htm#GJSFS)
    - [2.5 Building the Examples](usingexamples005.htm#BNAAN)
    - [2.6 Tutorial Example Directory Structure](usingexamples006.htm#GEXAP)
    - [2.7 Java EE 7 Maven Archetypes in the Tutorial](usingexamples007.htm#CIHBHEFF)
      * [2.7.1 Installing the Tutorial Archetypes](usingexamples007.htm#CHDJGCCA)
        + [2.7.1.1 Installing the Tutorial Archetypes Using NetBeans IDE](usingexamples007.htm#sthref140)
        + [2.7.1.2 Installing the Tutorial Archetypes Using Maven](usingexamples007.htm#sthref141)
    - [2.8 Getting the Latest Updates to the Tutorial](usingexamples008.htm#GIQWR)
      * [2.8.1 To Update the Tutorial Using NetBeans IDE](usingexamples008.htm#GIQYK)
      * [2.8.2 To Update the Tutorial Using the Command Line](usingexamples008.htm#sthref142)
    - [2.9 Debugging Java EE Applications](usingexamples009.htm#BNADL)
      * [2.9.1 Using the Server Log](usingexamples009.htm#BNADM)
        + [2.9.1.1 To Use the Administration Console Log Viewer](usingexamples009.htm#GJSGH)
      * [2.9.2 Using a Debugger](usingexamples009.htm#BNADN)
        + [2.9.2.1 To Debug an Application Using a Debugger](usingexamples009.htm#GJQWL)
* [Part II Platform Basics](partplatform.htm#GFIRP2)
  + [3 Resource Creation](resource-creation.htm#GKJIQ2)
    - [3.1 Resources and JNDI Naming](resource-creation001.htm#BNCJI)
    - [3.2 DataSource Objects and Connection Pools](resource-creation002.htm#BNCJJ)
    - [3.3 Creating Resources Administratively](resource-creation003.htm#CACFBGBE)
  + [4 Injection](injection.htm#GKJIQ3)
    - [4.1 Resource Injection](injection001.htm#BABHDCAI)
    - [4.2 Dependency Injection](injection002.htm#BABDJGIE)
    - [4.3 The Main Differences between Resource Injection and Dependency Injection](injection003.htm#BABHFECJ)
  + [5 Packaging](packaging.htm#GKJIQ4)
    - [5.1 Packaging Applications](packaging001.htm#BCGDJDFB)
    - [5.2 Packaging Enterprise Beans](packaging002.htm#BCGECBIJ)
      * [5.2.1 Packaging Enterprise Beans in EJB JAR Modules](packaging002.htm#CHDFCDBG)
      * [5.2.2 Packaging Enterprise Beans in WAR Modules](packaging002.htm#CHDJABEJ)
    - [5.3 Packaging Web Archives](packaging003.htm#BCGHAHGD)
    - [5.4 Packaging Resource Adapter Archives](packaging004.htm#BCGDHBHJ)
* [Part III The Web Tier](partwebtier.htm#BNADP)
  + [6 Getting Started with Web Applications](webapp.htm#BNADR)
    - [6.1 Web Applications](webapp001.htm#GEYSJ)
    - [6.2 Web Application Lifecycle](webapp002.htm#BNADU)
    - [6.3 A Web Module That Uses JavaServer Faces Technology: The hello1 Example](webapp003.htm#BNADX)
      * [6.3.1 To View the hello1 Web Module Using NetBeans IDE](webapp003.htm#GJWTV)
        + [6.3.1.1 Introduction to Scopes](webapp003.htm#GLQLK)
      * [6.3.2 Packaging and Deploying the hello1 Web Module](webapp003.htm#BNADZ)
        + [6.3.2.1 To Build and Package the hello1 Web Module Using NetBeans IDE](webapp003.htm#GJRGN)
        + [6.3.2.2 To Build and Package the hello1 Web Module Using Maven](webapp003.htm#GJRKN)
      * [6.3.3 Viewing Deployed Web Modules](webapp003.htm#BNAEI)
        + [6.3.3.1 To View Deployed Web Modules Using the Administration Console](webapp003.htm#GJSGR)
        + [6.3.3.2 To View Deployed Web Modules Using the asadmin Command](webapp003.htm#GJSEW)
        + [6.3.3.3 To View Deployed Web Modules Using NetBeans IDE](webapp003.htm#sthref206)
      * [6.3.4 Running the Deployed hello1 Web Module](webapp003.htm#sthref207)
        + [6.3.4.1 Dynamic Reloading of Deployed Modules](webapp003.htm#BNAEM)
      * [6.3.5 Undeploying the hello1 Web Module](webapp003.htm#BNAEN)
        + [6.3.5.1 To Undeploy the hello1 Web Module Using NetBeans IDE](webapp003.htm#GJSEJ)
        + [6.3.5.2 To Undeploy the hello1 Web Module Using Maven](webapp003.htm#GJSHH)
    - [6.4 A Web Module That Uses Java Servlet Technology: The hello2 Example](webapp004.htm#BNAEO)
      * [6.4.1 Mapping URLs to Web Components](webapp004.htm#BNAEP)
      * [6.4.2 Examining the hello2 Web Module](webapp004.htm#GJWWG)
        + [6.4.2.1 To View the hello2 Web Module Using NetBeans IDE](webapp004.htm#GJWWA)
      * [6.4.3 Running the hello2 Example](webapp004.htm#GKBLH)
        + [6.4.3.1 To Run the hello2 Example Using NetBeans IDE](webapp004.htm#GJSED)
        + [6.4.3.2 To Run the hello2 Example Using Maven](webapp004.htm#GJSHX)
    - [6.5 Configuring Web Applications](webapp005.htm#CHDHGJIA)
      * [6.5.1 Setting Context Parameters](webapp005.htm#BNAES)
        + [6.5.1.1 To Add a Context Parameter Using NetBeans IDE](webapp005.htm#GJSFJ)
        + [6.5.1.2 To Create a web.xml File Using NetBeans IDE](webapp005.htm#GKIHH)
      * [6.5.2 Declaring Welcome Files](webapp005.htm#BNAER)
      * [6.5.3 Mapping Errors to Error Screens](webapp005.htm#GKBKW)
        + [6.5.3.1 To Set Up Error Mapping Using NetBeans IDE](webapp005.htm#BNAET)
      * [6.5.4 Declaring Resource References](webapp005.htm#BNAEU)
        + [6.5.4.1 Declaring a Reference to a Resource](webapp005.htm#BNAEW)
        + [6.5.4.2 Declaring a Reference to a Web Service](webapp005.htm#BNAEX)
    - [6.6 Further Information about Web Applications](webapp006.htm#BNAFC)
  + [7 JavaServer Faces Technology](jsf-intro.htm#BNAPH)
    - [7.1 What Is a JavaServer Faces Application?](jsf-intro001.htm#BNAPK)
    - [7.2 JavaServer Faces Technology Benefits](jsf-intro002.htm#BNAPJ)
    - [7.3 A Simple JavaServer Faces Application](jsf-intro003.htm#GJAAM)
    - [7.4 User Interface Component Model](jsf-intro004.htm#BNAQD)
      * [7.4.1 User Interface Component Classes](jsf-intro004.htm#BNAQE)
      * [7.4.2 Component Rendering Model](jsf-intro004.htm#BNAQF)
      * [7.4.3 Conversion Model](jsf-intro004.htm#BNAQI)
      * [7.4.4 Event and Listener Model](jsf-intro004.htm#GIREH)
      * [7.4.5 Validation Model](jsf-intro004.htm#BNAQK)
    - [7.5 Navigation Model](jsf-intro005.htm#BNAQL)
    - [7.6 The Lifecycle of a JavaServer Faces Application](jsf-intro006.htm#BNAQQ)
      * [7.6.1 Overview of the JavaServer Faces Lifecycle](jsf-intro006.htm#GLPRC)
      * [7.6.2 Restore View Phase](jsf-intro006.htm#BNAQS)
      * [7.6.3 Apply Request Values Phase](jsf-intro006.htm#BNAQT)
      * [7.6.4 Process Validations Phase](jsf-intro006.htm#GJSBP)
      * [7.6.5 Update Model Values Phase](jsf-intro006.htm#BNAQV)
      * [7.6.6 Invoke Application Phase](jsf-intro006.htm#BNAQW)
      * [7.6.7 Render Response Phase](jsf-intro006.htm#BNAQX)
    - [7.7 Partial Processing and Partial Rendering](jsf-intro007.htm#GKNOJ)
    - [7.8 Further Information about JavaServer Faces Technology](jsf-intro008.htm#BNAQY)
  + [8 Introduction to Facelets](jsf-facelets.htm#GIEPX)
    - [8.1 What Is Facelets?](jsf-facelets001.htm#GIJTU)
    - [8.2 The Lifecycle of a Facelets Application](jsf-facelets002.htm#GIPRR)
    - [8.3 Developing a Simple Facelets Application: The guessnumber-jsf Example Application](jsf-facelets003.htm#GIPOB)
      * [8.3.1 Creating a Facelets Application](jsf-facelets003.htm#GIQTE)
        + [8.3.1.1 Developing a Managed Bean](jsf-facelets003.htm#GIQQZ)
        + [8.3.1.2 Creating Facelets Views](jsf-facelets003.htm#GJZPV)
      * [8.3.2 Configuring the Application](jsf-facelets003.htm#GJJKC)
      * [8.3.3 Running the guessnumber-jsf Facelets Example](jsf-facelets003.htm#GIRGF)
        + [8.3.3.1 To Build, Package, and Deploy the guessnumber-jsf Example Using NetBeans IDE](jsf-facelets003.htm#GJQZL)
        + [8.3.3.2 To Build, Package, and Deploy the guessnumber-jsf Example Using Maven](jsf-facelets003.htm#GJQYU)
        + [8.3.3.3 To Run the guessnumber-jsf Example](jsf-facelets003.htm#GJQYX)
    - [8.4 Using Facelets Templates](jsf-facelets004.htm#GIQXP)
    - [8.5 Composite Components](jsf-facelets005.htm#GIQZR)
    - [8.6 Web Resources](jsf-facelets006.htm#GIRGM)
    - [8.7 Relocatable Resources](jsf-facelets007.htm#BABHGBJI)
    - [8.8 Resource Library Contracts](jsf-facelets008.htm#BABHAHDF)
      * [8.8.1 The hello1-rlc Example Application](jsf-facelets008.htm#sthref380)
        + [8.8.1.1 Configuring the hello1-rlc Example](jsf-facelets008.htm#sthref383)
        + [8.8.1.2 The Facelets Pages for the hello1-rlc Example](jsf-facelets008.htm#sthref384)
        + [8.8.1.3 To Build, Package, and Deploy the hello1-rlc Example Using NetBeans IDE](jsf-facelets008.htm#sthref385)
        + [8.8.1.4 To Build, Package, and Deploy the hello1-rlc Example Using Maven](jsf-facelets008.htm#sthref386)
        + [8.8.1.5 To Run the hello1-rlc Example](jsf-facelets008.htm#sthref387)
    - [8.9 HTML5-Friendly Markup](jsf-facelets009.htm#BABGECCJ)
      * [8.9.1 Using Pass-Through Elements](jsf-facelets009.htm#sthref390)
      * [8.9.2 Using Pass-Through Attributes](jsf-facelets009.htm#sthref393)
      * [8.9.3 The reservation Example Application](jsf-facelets009.htm#BABGGIAA)
        + [8.9.3.1 The Facelets Pages for the reservation Application](jsf-facelets009.htm#sthref397)
        + [8.9.3.2 The Managed Bean for the reservation Application](jsf-facelets009.htm#sthref398)
        + [8.9.3.3 To Build, Package, and Deploy the reservation Example Using NetBeans IDE](jsf-facelets009.htm#sthref399)
        + [8.9.3.4 To Build, Package, and Deploy the reservation Example Using Maven](jsf-facelets009.htm#sthref400)
        + [8.9.3.5 To Run the reservation Example](jsf-facelets009.htm#sthref401)
  + [9 Expression Language](jsf-el.htm#GJDDD)
    - [9.1 Overview of the EL](jsf-el001.htm#BNAHQ)
    - [9.2 Immediate and Deferred Evaluation Syntax](jsf-el002.htm#BNAHR)
      * [9.2.1 Immediate Evaluation](jsf-el002.htm#BNAHS)
      * [9.2.2 Deferred Evaluation](jsf-el002.htm#BNAHT)
    - [9.3 Value and Method Expressions](jsf-el003.htm#BNAHU)
      * [9.3.1 Value Expressions](jsf-el003.htm#BNAHV)
        + [9.3.1.1 Referencing Objects](jsf-el003.htm#BNAHW)
        + [9.3.1.2 Referencing Object Properties or Collection Elements](jsf-el003.htm#BNAHX)
        + [9.3.1.3 Referencing Literals](jsf-el003.htm#sthref409)
        + [9.3.1.4 Parameterized Method Calls](jsf-el003.htm#GJHBZ)
        + [9.3.1.5 Where Value Expressions Can Be Used](jsf-el003.htm#BNAHY)
      * [9.3.2 Method Expressions](jsf-el003.htm#BNAHZ)
      * [9.3.3 Lambda Expressions](jsf-el003.htm#sthref415)
    - [9.4 Operations on Collection Objects](jsf-el004.htm#CIHGABHD)
    - [9.5 Operators](jsf-el005.htm#BNAIK)
    - [9.6 Reserved Words](jsf-el006.htm#BNAIL)
    - [9.7 Examples of EL Expressions](jsf-el007.htm#BNAIM)
    - [9.8 Further Information about the Expression Language](jsf-el008.htm#CIHGBBHA)
  + [10 Using JavaServer Faces Technology in Web Pages](jsf-page.htm#BNAQZ)
    - [10.1 Setting Up a Page](jsf-page001.htm#BNARB)
    - [10.2 Adding Components to a Page Using HTML Tag Library Tags](jsf-page002.htm#BNARF)
      * [10.2.1 Common Component Tag Attributes](jsf-page002.htm#BNARG)
        + [10.2.1.1 The id Attribute](jsf-page002.htm#BNARH)
        + [10.2.1.2 The immediate Attribute](jsf-page002.htm#BNARI)
        + [10.2.1.3 The rendered Attribute](jsf-page002.htm#BNARJ)
        + [10.2.1.4 The style and styleClass Attributes](jsf-page002.htm#BNARK)
        + [10.2.1.5 The value and binding Attributes](jsf-page002.htm#BNARL)
      * [10.2.2 Adding HTML Head and Body Tags](jsf-page002.htm#GJDGQ)
      * [10.2.3 Adding a Form Component](jsf-page002.htm#BNARM)
      * [10.2.4 Using Text Components](jsf-page002.htm#BNARO)
        + [10.2.4.1 Rendering a Field with the h:inputText Tag](jsf-page002.htm#BNARR)
        + [10.2.4.2 Rendering a Password Field with the h:inputSecret Tag](jsf-page002.htm#BNARV)
        + [10.2.4.3 Rendering a Label with the h:outputLabel Tag](jsf-page002.htm#BNARS)
        + [10.2.4.4 Rendering a Link with the h:outputLink Tag](jsf-page002.htm#BNART)
        + [10.2.4.5 Displaying a Formatted Message with the h:outputFormat Tag](jsf-page002.htm#BNARU)
      * [10.2.5 Using Command Component Tags for Performing Actions and Navigation](jsf-page002.htm#BNARW)
        + [10.2.5.1 Rendering a Button with the h:commandButton Tag](jsf-page002.htm#BNARX)
        + [10.2.5.2 Rendering a Link with the h:commandLink Tag](jsf-page002.htm#GKBUJ)
      * [10.2.6 Adding Graphics and Images with the h:graphicImage Tag](jsf-page002.htm#BNASB)
      * [10.2.7 Laying Out Components with the h:panelGrid and h:panelGroup Tags](jsf-page002.htm#BNASC)
      * [10.2.8 Displaying Components for Selecting One Value](jsf-page002.htm#BNASE)
        + [10.2.8.1 Displaying a Check Box Using the h:selectBooleanCheckbox Tag](jsf-page002.htm#BNASG)
        + [10.2.8.2 Displaying a Menu Using the h:selectOneMenu Tag](jsf-page002.htm#BNASH)
      * [10.2.9 Displaying Components for Selecting Multiple Values](jsf-page002.htm#BNASI)
      * [10.2.10 Using the f:selectItem and f:selectItems Tags](jsf-page002.htm#BNASK)
        + [10.2.10.1 Using the f:selectItems Tag](jsf-page002.htm#BNASM)
        + [10.2.10.2 Using the f:selectItem Tag](jsf-page002.htm#BNASN)
      * [10.2.11 Displaying the Results from Selection Components](jsf-page002.htm#sthref558)
      * [10.2.12 Using Data-Bound Table Components](jsf-page002.htm#BNARZ)
      * [10.2.13 Displaying Error Messages with the h:message and h:messages Tags](jsf-page002.htm#BNASO)
      * [10.2.14 Creating Bookmarkable URLs with the h:button and h:link Tags](jsf-page002.htm#GIQZD)
      * [10.2.15 Using View Parameters to Configure Bookmarkable URLs](jsf-page002.htm#GIQWQ)
      * [10.2.16 The bookmarks Example Application](jsf-page002.htm#sthref575)
        + [10.2.16.1 To Build, Package, and Deploy the bookmarks Example Using NetBeans IDE](jsf-page002.htm#sthref578)
        + [10.2.16.2 To Build, Package, and Deploy the bookmarks Example Using Maven](jsf-page002.htm#sthref579)
        + [10.2.16.3 To Run the bookmarks Example](jsf-page002.htm#sthref580)
      * [10.2.17 Resource Relocation Using h:outputScript and h:outputStylesheet Tags](jsf-page002.htm#GJGEP)
    - [10.3 Using Core Tags](jsf-page003.htm#BNARC)
  + [11 Using Converters, Listeners, and Validators](jsf-page-core.htm#GJCUT)
    - [11.1 Using the Standard Converters](jsf-page-core001.htm#BNAST)
      * [11.1.1 Converting a Component's Value](jsf-page-core001.htm#BNASU)
      * [11.1.2 Using DateTimeConverter](jsf-page-core001.htm#BNASV)
      * [11.1.3 Using NumberConverter](jsf-page-core001.htm#BNASX)
    - [11.2 Registering Listeners on Components](jsf-page-core002.htm#BNASZ)
      * [11.2.1 Registering a Value-Change Listener on a Component](jsf-page-core002.htm#BNATA)
      * [11.2.2 Registering an Action Listener on a Component](jsf-page-core002.htm#BNATB)
    - [11.3 Using the Standard Validators](jsf-page-core003.htm#BNATC)
      * [11.3.1 Validating a Component's Value](jsf-page-core003.htm#BNATE)
      * [11.3.2 Using Validator Tags](jsf-page-core003.htm#BNATF)
    - [11.4 Referencing a Managed Bean Method](jsf-page-core004.htm#BNATN)
      * [11.4.1 Referencing a Method That Performs Navigation](jsf-page-core004.htm#BNATP)
      * [11.4.2 Referencing a Method That Handles an Action Event](jsf-page-core004.htm#BNATQ)
      * [11.4.3 Referencing a Method That Performs Validation](jsf-page-core004.htm#BNATR)
      * [11.4.4 Referencing a Method That Handles a Value-Change Event](jsf-page-core004.htm#BNATS)
  + [12 Developing with JavaServer Faces Technology](jsf-develop.htm#BNATX)
    - [12.1 Managed Beans in JavaServer Faces Technology](jsf-develop001.htm#BNAQM)
      * [12.1.1 Creating a Managed Bean](jsf-develop001.htm#BNAQN)
      * [12.1.2 Using the EL to Reference Managed Beans](jsf-develop001.htm#BNAQP)
    - [12.2 Writing Bean Properties](jsf-develop002.htm#BNATY)
      * [12.2.1 Writing Properties Bound to Component Values](jsf-develop002.htm#BNATZ)
        + [12.2.1.1 UIInput and UIOutput Properties](jsf-develop002.htm#BNAUB)
        + [12.2.1.2 UIData Properties](jsf-develop002.htm#BNAUC)
        + [12.2.1.3 UISelectBoolean Properties](jsf-develop002.htm#BNAUD)
        + [12.2.1.4 UISelectMany Properties](jsf-develop002.htm#BNAUE)
        + [12.2.1.5 UISelectOne Properties](jsf-develop002.htm#BNAUF)
        + [12.2.1.6 UISelectItem Properties](jsf-develop002.htm#BNAUG)
        + [12.2.1.7 UISelectItems Properties](jsf-develop002.htm#BNAUH)
      * [12.2.2 Writing Properties Bound to Component Instances](jsf-develop002.htm#BNAUK)
      * [12.2.3 Writing Properties Bound to Converters, Listeners, or Validators](jsf-develop002.htm#BNAUL)
    - [12.3 Writing Managed Bean Methods](jsf-develop003.htm#BNAVB)
      * [12.3.1 Writing a Method to Handle Navigation](jsf-develop003.htm#BNAVC)
      * [12.3.2 Writing a Method to Handle an Action Event](jsf-develop003.htm#BNAVD)
      * [12.3.3 Writing a Method to Perform Validation](jsf-develop003.htm#BNAVE)
      * [12.3.4 Writing a Method to Handle a Value-Change Event](jsf-develop003.htm#BNAVF)
  + [13 Using Ajax with JavaServer Faces Technology](jsf-ajax.htm#GKIOW)
    - [13.1 Overview of Ajax](jsf-ajax001.htm#GKIGR)
    - [13.2 Using Ajax Functionality with JavaServer Faces Technology](jsf-ajax002.htm#GKINL)
    - [13.3 Using Ajax with Facelets](jsf-ajax003.htm#GKABR)
      * [13.3.1 Using the f:ajax Tag](jsf-ajax003.htm#GKAFN)
    - [13.4 Sending an Ajax Request](jsf-ajax004.htm#GKACE)
      * [13.4.1 Using the event Attribute](jsf-ajax004.htm#GKHVT)
      * [13.4.2 Using the execute Attribute](jsf-ajax004.htm#GKHUZ)
      * [13.4.3 Using the immediate Attribute](jsf-ajax004.htm#GKHWM)
      * [13.4.4 Using the listener Attribute](jsf-ajax004.htm#GKHZS)
    - [13.5 Monitoring Events on the Client](jsf-ajax005.htm#GKDDF)
    - [13.6 Handling Errors](jsf-ajax006.htm#GKDCB)
    - [13.7 Receiving an Ajax Response](jsf-ajax007.htm#GKDBR)
    - [13.8 Ajax Request Lifecycle](jsf-ajax008.htm#GKUAR)
    - [13.9 Grouping of Components](jsf-ajax009.htm#GKHYH)
    - [13.10 Loading JavaScript as a Resource](jsf-ajax010.htm#GKAAM)
      * [13.10.1 Using JavaScript API in a Facelets Application](jsf-ajax010.htm#GKAFI)
      * [13.10.2 Using the @ResourceDependency Annotation in a Bean Class](jsf-ajax010.htm#GKIPX)
    - [13.11 The ajaxguessnumber Example Application](jsf-ajax011.htm#GKOKB)
      * [13.11.1 The ajaxguessnumber Source Files](jsf-ajax011.htm#GKOIJ)
        + [13.11.1.1 The ajaxgreeting.xhtml Facelets Page](jsf-ajax011.htm#GKOFW)
        + [13.11.1.2 The UserNumberBean Backing Bean](jsf-ajax011.htm#GKOHN)
        + [13.11.1.3 The DukesNumberBean CDI Managed Bean](jsf-ajax011.htm#sthref844)
      * [13.11.2 Running the ajaxguessnumber Example](jsf-ajax011.htm#GKOKE)
        + [13.11.2.1 To Build, Package, and Deploy the ajaxguessnumber Example Using NetBeans IDE](jsf-ajax011.htm#GLHVU)
        + [13.11.2.2 To Build, Package, and Deploy the ajaxguessnumber Example Using Maven](jsf-ajax011.htm#GLHVQ)
        + [13.11.2.3 To Run the ajaxguessnumber Example](jsf-ajax011.htm#GLHWE)
    - [13.12 Further Information about Ajax in JavaServer Faces Technology](jsf-ajax012.htm#GKSDK)
  + [14 Composite Components: Advanced Topics and an Example](jsf-advanced-cc.htm#GKHXA)
    - [14.1 Attributes of a Composite Component](jsf-advanced-cc001.htm#GKHWV)
    - [14.2 Invoking a Managed Bean](jsf-advanced-cc002.htm#GKHUO)
    - [14.3 Validating Composite Component Values](jsf-advanced-cc003.htm#GKHWO)
    - [14.4 The compositecomponentexample Example Application](jsf-advanced-cc004.htm#GKHVN)
      * [14.4.1 The Composite Component File](jsf-advanced-cc004.htm#GKHUU)
      * [14.4.2 The Using Page](jsf-advanced-cc004.htm#GKHVX)
      * [14.4.3 The Managed Bean](jsf-advanced-cc004.htm#GKHVQ)
      * [14.4.4 Running the compositecomponentexample Example](jsf-advanced-cc004.htm#GLECV)
        + [14.4.4.1 To Build, Package, and Deploy the compositecomponentexample Example Using NetBeans IDE](jsf-advanced-cc004.htm#GKHVC)
        + [14.4.4.2 To Build, Package, and Deploy the compositecomponentexample Example Using Maven](jsf-advanced-cc004.htm#GLEAE)
        + [14.4.4.3 To Run the compositecomponentexample Example](jsf-advanced-cc004.htm#GLEEU)
  + [15 Creating Custom UI Components and Other Custom Objects](jsf-custom.htm#BNAVG)
    - [15.1 Determining Whether You Need a Custom Component or Renderer](jsf-custom001.htm#BNAVH)
      * [15.1.1 When to Use a Custom Component](jsf-custom001.htm#BNAVI)
      * [15.1.2 When to Use a Custom Renderer](jsf-custom001.htm#BNAVJ)
      * [15.1.3 Component, Renderer, and Tag Combinations](jsf-custom001.htm#BNAVK)
    - [15.2 Understanding the Image Map Example](jsf-custom002.htm#GLPCB)
      * [15.2.1 Why Use JavaServer Faces Technology to Implement an Image Map?](jsf-custom002.htm#GLPBD)
      * [15.2.2 Understanding the Rendered HTML](jsf-custom002.htm#GLPEM)
      * [15.2.3 Understanding the Facelets Page](jsf-custom002.htm#GLPCD)
      * [15.2.4 Configuring Model Data](jsf-custom002.htm#GLPBO)
      * [15.2.5 Summary of the Image Map Application Classes](jsf-custom002.htm#GLPEL)
    - [15.3 Steps for Creating a Custom Component](jsf-custom003.htm#BNAVT)
    - [15.4 Creating Custom Component Classes](jsf-custom004.htm#BNAVU)
      * [15.4.1 Specifying the Component Family](jsf-custom004.htm#BNAVV)
      * [15.4.2 Performing Encoding](jsf-custom004.htm#BNAVW)
      * [15.4.3 Performing Decoding](jsf-custom004.htm#BNAVX)
      * [15.4.4 Enabling Component Properties to Accept Expressions](jsf-custom004.htm#BNAVY)
      * [15.4.5 Saving and Restoring State](jsf-custom004.htm#BNAVZ)
    - [15.5 Delegating Rendering to a Renderer](jsf-custom005.htm#BNAWA)
      * [15.5.1 Creating the Renderer Class](jsf-custom005.htm#BNAWB)
      * [15.5.2 Identifying the Renderer Type](jsf-custom005.htm#BNAWC)
    - [15.6 Implementing an Event Listener](jsf-custom006.htm#BNAUT)
      * [15.6.1 Implementing Value-Change Listeners](jsf-custom006.htm#BNAUU)
      * [15.6.2 Implementing Action Listeners](jsf-custom006.htm#BNAUV)
    - [15.7 Handling Events for Custom Components](jsf-custom007.htm#BNAWD)
    - [15.8 Defining the Custom Component Tag in a Tag Library Descriptor](jsf-custom008.htm#BNAWN)
    - [15.9 Using a Custom Component](jsf-custom009.htm#BNATT)
    - [15.10 Creating and Using a Custom Converter](jsf-custom010.htm#BNAUS)
      * [15.10.1 Creating a Custom Converter](jsf-custom010.htm#GLPHB)
      * [15.10.2 Using a Custom Converter](jsf-custom010.htm#BNATU)
    - [15.11 Creating and Using a Custom Validator](jsf-custom011.htm#BNAUW)
      * [15.11.1 Implementing the Validator Interface](jsf-custom011.htm#BNAUX)
      * [15.11.2 Specifying a Custom Tag](jsf-custom011.htm#BNAUY)
      * [15.11.3 Using a Custom Validator](jsf-custom011.htm#BNATV)
    - [15.12 Binding Component Values and Instances to Managed Bean Properties](jsf-custom012.htm#BNATG)
      * [15.12.1 Binding a Component Value to a Property](jsf-custom012.htm#BNATI)
      * [15.12.2 Binding a Component Value to an Implicit Object](jsf-custom012.htm#BNATJ)
      * [15.12.3 Binding a Component Instance to a Bean Property](jsf-custom012.htm#BNATL)
    - [15.13 Binding Converters, Listeners, and Validators to Managed Bean Properties](jsf-custom013.htm#BNATM)
  + [16 Configuring JavaServer Faces Applications](jsf-configure.htm#BNAWO)
    - [16.1 Using Annotations to Configure Managed Beans](jsf-configure001.htm#GIRCH)
      * [16.1.1 Using Managed Bean Scopes](jsf-configure001.htm#GIRCR)
    - [16.2 Application Configuration Resource File](jsf-configure002.htm#BNAWP)
      * [16.2.1 Configuring Eager Application-Scoped Managed Beans](jsf-configure002.htm#GIREP)
      * [16.2.2 Ordering of Application Configuration Resource Files](jsf-configure002.htm#GIQCK)
    - [16.3 Using Faces Flows](jsf-configure003.htm#CHDGFCJF)
      * [16.3.1 Packaging Flows in an Application](jsf-configure003.htm#sthref1043)
      * [16.3.2 The Simplest Possible Flow: The simple-flow Example Application](jsf-configure003.htm#sthref1044)
        + [16.3.2.1 To Build, Package, and Deploy the simple-flow Example Using NetBeans IDE](jsf-configure003.htm#sthref1045)
        + [16.3.2.2 To Build, Package, and Deploy the simple-flow Example Using Maven](jsf-configure003.htm#sthref1046)
        + [16.3.2.3 To Run the simple-flow Example](jsf-configure003.htm#sthref1047)
      * [16.3.3 The checkout-module Example Application](jsf-configure003.htm#sthref1048)
        + [16.3.3.1 The Facelets Pages for the checkout-module Example](jsf-configure003.htm#sthref1049)
        + [16.3.3.2 Using a Configuration File to Configure a Flow](jsf-configure003.htm#sthref1050)
        + [16.3.3.3 Using a Java Class to Configure a Flow](jsf-configure003.htm#sthref1051)
        + [16.3.3.4 The Flow-Scoped Managed Beans](jsf-configure003.htm#sthref1052)
        + [16.3.3.5 To Build, Package, and Deploy the checkout-module Example Using NetBeans IDE](jsf-configure003.htm#sthref1053)
        + [16.3.3.6 To Build, Package, and Deploy the checkout-module Example Using Maven](jsf-configure003.htm#sthref1054)
        + [16.3.3.7 To Run the checkout-module Example](jsf-configure003.htm#sthref1055)
    - [16.4 Configuring Managed Beans](jsf-configure004.htm#BNAWQ)
      * [16.4.1 Using the managed-bean Element](jsf-configure004.htm#BNAWR)
      * [16.4.2 Initializing Properties Using the managed-property Element](jsf-configure004.htm#BNAWS)
        + [16.4.2.1 Referencing a Java Enum Type](jsf-configure004.htm#BNAWU)
        + [16.4.2.2 Referencing a Context Initialization Parameter](jsf-configure004.htm#BNAWV)
        + [16.4.2.3 Initializing Map Properties](jsf-configure004.htm#BNAWW)
        + [16.4.2.4 Initializing Array and List Properties](jsf-configure004.htm#BNAWX)
        + [16.4.2.5 Initializing Managed Bean Properties](jsf-configure004.htm#BNAWY)
      * [16.4.3 Initializing Maps and Lists](jsf-configure004.htm#BNAXA)
    - [16.5 Registering Application Messages](jsf-configure005.htm#BNAXB)
      * [16.5.1 Using FacesMessage to Create a Message](jsf-configure005.htm#GKUHG)
      * [16.5.2 Referencing Error Messages](jsf-configure005.htm#BNASS)
    - [16.6 Using Default Validators](jsf-configure006.htm#GIREB)
    - [16.7 Registering a Custom Validator](jsf-configure007.htm#BNAXD)
    - [16.8 Registering a Custom Converter](jsf-configure008.htm#BNAXE)
    - [16.9 Configuring Navigation Rules](jsf-configure009.htm#BNAXF)
    - [16.10 Registering a Custom Renderer with a Render Kit](jsf-configure010.htm#BNAXH)
    - [16.11 Registering a Custom Component](jsf-configure011.htm#BNAXI)
    - [16.12 Basic Requirements of a JavaServer Faces Application](jsf-configure012.htm#BNAXJ)
      * [16.12.1 Configuring an Application with a Web Deployment Descriptor](jsf-configure012.htm#BNAXK)
        + [16.12.1.1 Identifying the Servlet for Lifecycle Processing](jsf-configure012.htm#GLPOO)
        + [16.12.1.2 To Specify a Path to an Application Configuration Resource File](jsf-configure012.htm#BNAXM)
        + [16.12.1.3 To Specify Where State Is Saved](jsf-configure012.htm#BNAXN)
      * [16.12.2 Configuring Project Stage](jsf-configure012.htm#GIQXL)
      * [16.12.3 Including the Classes, Pages, and Other Resources](jsf-configure012.htm#BNAXT)
  + [17 Java Servlet Technology](servlets.htm#BNAFD)
    - [17.1 What Is a Servlet?](servlets001.htm#BNAFE)
    - [17.2 Servlet Lifecycle](servlets002.htm#BNAFI)
      * [17.2.1 Handling Servlet Lifecycle Events](servlets002.htm#BNAFJ)
        + [17.2.1.1 Defining the Listener Class](servlets002.htm#BNAFK)
      * [17.2.2 Handling Servlet Errors](servlets002.htm#BNAFN)
    - [17.3 Sharing Information](servlets003.htm#BNAFO)
      * [17.3.1 Using Scope Objects](servlets003.htm#BNAFP)
      * [17.3.2 Controlling Concurrent Access to Shared Resources](servlets003.htm#BNAFS)
    - [17.4 Creating and Initializing a Servlet](servlets004.htm#BNAFU)
    - [17.5 Writing Service Methods](servlets005.htm#BNAFV)
      * [17.5.1 Getting Information from Requests](servlets005.htm#BNAFW)
      * [17.5.2 Constructing Responses](servlets005.htm#BNAFZ)
    - [17.6 Filtering Requests and Responses](servlets006.htm#BNAGB)
      * [17.6.1 Programming Filters](servlets006.htm#BNAGC)
      * [17.6.2 Programming Customized Requests and Responses](servlets006.htm#BNAGD)
      * [17.6.3 Specifying Filter Mappings](servlets006.htm#BNAGF)
        + [17.6.3.1 To Specify Filter Mappings Using NetBeans IDE](servlets006.htm#GJSLC)
    - [17.7 Invoking Other Web Resources](servlets007.htm#BNAGI)
      * [17.7.1 Including Other Resources in the Response](servlets007.htm#BNAGJ)
      * [17.7.2 Transferring Control to Another Web Component](servlets007.htm#BNAGK)
    - [17.8 Accessing the Web Context](servlets008.htm#BNAGL)
    - [17.9 Maintaining Client State](servlets009.htm#BNAGM)
      * [17.9.1 Accessing a Session](servlets009.htm#BNAGN)
      * [17.9.2 Associating Objects with a Session](servlets009.htm#BNAGO)
      * [17.9.3 Session Management](servlets009.htm#BNAGQ)
        + [17.9.3.1 To Set the Timeout Period Using NetBeans IDE](servlets009.htm#sthref1222)
      * [17.9.4 Session Tracking](servlets009.htm#BNAGR)
    - [17.10 Finalizing a Servlet](servlets010.htm#BNAGS)
      * [17.10.1 Tracking Service Requests](servlets010.htm#BNAGT)
      * [17.10.2 Notifying Methods to Shut Down](servlets010.htm#BNAGU)
      * [17.10.3 Creating Polite Long-Running Methods](servlets010.htm#BNAGV)
    - [17.11 Uploading Files with Java Servlet Technology](servlets011.htm#BABFGCHB)
      * [17.11.1 The @MultipartConfig Annotation](servlets011.htm#sthref1230)
      * [17.11.2 The getParts and getPart Methods](servlets011.htm#sthref1232)
    - [17.12 Asynchronous Processing](servlets012.htm#BEIGCFDF)
      * [17.12.1 Asynchronous Processing in Servlets](servlets012.htm#sthref1236)
      * [17.12.2 Waiting for a Resource](servlets012.htm#sthref1238)
    - [17.13 Nonblocking I/O](servlets013.htm#BEIHICDH)
      * [17.13.1 Reading a Large HTTP POST Request Using Nonblocking I/O](servlets013.htm#sthref1243)
    - [17.14 Protocol Upgrade Processing](servlets014.htm#BEIJHCDJ)
    - [17.15 The mood Example Application](servlets015.htm#GKCPG)
      * [17.15.1 Components of the mood Example Application](servlets015.htm#sthref1247)
      * [17.15.2 Running the mood Example](servlets015.htm#GKCOJ)
        + [17.15.2.1 To Run the mood Example Using NetBeans IDE](servlets015.htm#GKCOB)
        + [17.15.2.2 To Run the mood Example Using Maven](servlets015.htm#GKCPJ)
    - [17.16 The fileupload Example Application](servlets016.htm#BABDGFJJ)
      * [17.16.1 Architecture of the fileupload Example Application](servlets016.htm#sthref1249)
      * [17.16.2 Running the fileupload Example](servlets016.htm#sthref1250)
        + [17.16.2.1 To Build, Package, and Deploy the fileupload Example Using NetBeans IDE](servlets016.htm#sthref1251)
        + [17.16.2.2 To Build, Package, and Deploy the fileupload Example Using Maven](servlets016.htm#sthref1252)
        + [17.16.2.3 To Run the fileupload Example](servlets016.htm#sthref1253)
    - [17.17 The dukeetf Example Application](servlets017.htm#BEIFAIFF)
      * [17.17.1 Architecture of the dukeetf Example Application](servlets017.htm#sthref1254)
        + [17.17.1.1 The Servlet](servlets017.htm#sthref1255)
        + [17.17.1.2 The Enterprise Bean](servlets017.htm#sthref1256)
        + [17.17.1.3 The HTML Page](servlets017.htm#sthref1257)
      * [17.17.2 Running the dukeetf Example Application](servlets017.htm#sthref1258)
        + [17.17.2.1 To Run the dukeetf Example Application Using NetBeans IDE](servlets017.htm#sthref1259)
        + [17.17.2.2 To Run the dukeetf Example Application Using Maven](servlets017.htm#sthref1260)
    - [17.18 Further Information about Java Servlet Technology](servlets018.htm#BNAGW)
  + [18 Java API for WebSocket](websocket.htm#GKJIQ5)
    - [18.1 Introduction to WebSocket](websocket001.htm#BABDABHF)
    - [18.2 Creating WebSocket Applications in the Java EE Platform](websocket002.htm#BABEAEFC)
    - [18.3 Programmatic Endpoints](websocket003.htm#BABGJEIG)
    - [18.4 Annotated Endpoints](websocket004.htm#BABFEBGA)
    - [18.5 Sending and Receiving Messages](websocket005.htm#BABFCGBJ)
      * [18.5.1 Sending Messages](websocket005.htm#sthref1272)
        + [18.5.1.1 Sending Messages to All Peers Connected to an Endpoint](websocket005.htm#BABIFBCG)
      * [18.5.2 Receiving Messages](websocket005.htm#sthref1274)
    - [18.6 Maintaining Client State](websocket006.htm#BABGJCAD)
    - [18.7 Using Encoders and Decoders](websocket007.htm#BABGADFG)
      * [18.7.1 Implementing Encoders to Convert Java Objects into WebSocket Messages](websocket007.htm#sthref1277)
      * [18.7.2 Implementing Decoders to Convert WebSocket Messages into Java Objects](websocket007.htm#sthref1279)
    - [18.8 Path Parameters](websocket008.htm#BABEJIJI)
    - [18.9 Handling Errors](websocket009.htm#BABDEJHB)
    - [18.10 Specifying an Endpoint Configurator Class](websocket010.htm#BABJAIGH)
    - [18.11 The dukeetf2 Example Application](websocket011.htm#BABGCEHE)
      * [18.11.1 Architecture of the dukeetf2 Sample Application](websocket011.htm#sthref1286)
        + [18.11.1.1 The Endpoint](websocket011.htm#sthref1287)
        + [18.11.1.2 The Enterprise Bean](websocket011.htm#sthref1288)
        + [18.11.1.3 The HTML Page](websocket011.htm#sthref1289)
      * [18.11.2 Running the dukeetf2 Example Application](websocket011.htm#sthref1290)
        + [18.11.2.1 To Run the dukeetf2 Example Application Using NetBeans IDE](websocket011.htm#sthref1291)
        + [18.11.2.2 To Run the dukeetf2 Example Application Using Maven](websocket011.htm#sthref1292)
    - [18.12 The websocketbot Example Application](websocket012.htm#BABCDBBC)
      * [18.12.1 Architecture of the websocketbot Example Application](websocket012.htm#sthref1295)
        + [18.12.1.1 The CDI Bean](websocket012.htm#sthref1296)
        + [18.12.1.2 The WebSocket Endpoint](websocket012.htm#sthref1297)
        + [18.12.1.3 The Application Messages](websocket012.htm#sthref1298)
        + [18.12.1.4 The Encoder Classes](websocket012.htm#sthref1299)
        + [18.12.1.5 The Message Decoder](websocket012.htm#sthref1300)
        + [18.12.1.6 The HTML Page](websocket012.htm#sthref1301)
      * [18.12.2 Running the websocketbot Example Application](websocket012.htm#sthref1302)
        + [18.12.2.1 To Run the websocketbot Example Application Using NetBeans IDE](websocket012.htm#sthref1303)
        + [18.12.2.2 To Run the websocketbot Example Application Using Maven](websocket012.htm#sthref1304)
        + [18.12.2.3 To Test the websocketbot Example Application](websocket012.htm#BABDDAAG)
    - [18.13 Further Information about WebSocket](websocket013.htm#BABDFIFD)
  + [19 JSON Processing](jsonp.htm#GLRBB)
    - [19.1 Introduction to JSON](jsonp001.htm#BABEECIB)
      * [19.1.1 JSON Syntax](jsonp001.htm#BABGHEHG)
      * [19.1.2 Uses of JSON](jsonp001.htm#sthref1306)
      * [19.1.3 Generating and Parsing JSON Data](jsonp001.htm#BABJJACI)
    - [19.2 JSON Processing in the Java EE Platform](jsonp002.htm#BABDFHHD)
    - [19.3 Using the Object Model API](jsonp003.htm#BABHAHIA)
      * [19.3.1 Creating an Object Model from JSON Data](jsonp003.htm#BABBHEBA)
      * [19.3.2 Creating an Object Model from Application Code](jsonp003.htm#BABIGIAF)
      * [19.3.3 Navigating an Object Model](jsonp003.htm#BABJHEHG)
      * [19.3.4 Writing an Object Model to a Stream](jsonp003.htm#BABHEJFF)
    - [19.4 Using the Streaming API](jsonp004.htm#BABDBHIA)
      * [19.4.1 Reading JSON Data Using a Parser](jsonp004.htm#BABGCHIG)
      * [19.4.2 Writing JSON Data Using a Generator](jsonp004.htm#BABGJEEF)
    - [19.5 JSON in Java EE RESTful Web Services](jsonp005.htm#BABCFABH)
    - [19.6 The jsonpmodel Example Application](jsonp006.htm#BABEDFCG)
      * [19.6.1 Components of the jsonpmodel Example Application](jsonp006.htm#sthref1309)
      * [19.6.2 Running the jsonpmodel Example Application](jsonp006.htm#sthref1310)
        + [19.6.2.1 To Run the jsonpmodel Example Application Using NetBeans IDE](jsonp006.htm#sthref1311)
        + [19.6.2.2 To Run the jsonpmodel Example Application Using Maven](jsonp006.htm#sthref1312)
    - [19.7 The jsonpstreaming Example Application](jsonp007.htm#BABBJDAC)
      * [19.7.1 Components of the jsonpstreaming Example Application](jsonp007.htm#sthref1313)
      * [19.7.2 Running the jsonpstreaming Example Application](jsonp007.htm#sthref1314)
        + [19.7.2.1 To Run the jsonpstreaming Example Application Using NetBeans IDE](jsonp007.htm#sthref1315)
        + [19.7.2.2 To Run the jsonpstreaming Example Application Using Maven](jsonp007.htm#sthref1316)
    - [19.8 Further Information about the Java API for JSON Processing](jsonp008.htm#BABGAAGB)
  + [20 Internationalizing and Localizing Web Applications](webi18n.htm#BNAXU)
    - [20.1 Java Platform Localization Classes](webi18n001.htm#BNAXV)
    - [20.2 Providing Localized Messages and Labels](webi18n002.htm#BNAXW)
      * [20.2.1 Establishing the Locale](webi18n002.htm#GKUIA)
      * [20.2.2 Setting the Resource Bundle](webi18n002.htm#BNAXY)
      * [20.2.3 Retrieving Localized Messages](webi18n002.htm#GKUFC)
    - [20.3 Date and Number Formatting](webi18n003.htm#BNAYA)
    - [20.4 Character Sets and Encodings](webi18n004.htm#BNAYB)
      * [20.4.1 Character Sets](webi18n004.htm#BNAYC)
      * [20.4.2 Character Encoding](webi18n004.htm#BNAYD)
* [Part IV Bean Validation](partbeanvalidation.htm#sthref1322)
  + [21 Introduction to Bean Validation](bean-validation.htm#CHDGJIIA)
    - [21.1 Using Bean Validation Constraints](bean-validation001.htm#GIRCZ)
    - [21.2 Validating Null and Empty Strings](bean-validation002.htm#GKCRG)
    - [21.3 Validating Constructors and Methods](bean-validation003.htm#CACJIBEJ)
      * [21.3.1 Cross-Parameter Constraints](bean-validation003.htm#sthref1347)
      * [21.3.2 Identifying Parameter Constraint Violations](bean-validation003.htm#sthref1349)
      * [21.3.3 Adding Constraints to Method Return Values](bean-validation003.htm#sthref1353)
    - [21.4 Further Information about Bean Validation](bean-validation004.htm#CACDECFE)
  + [22 Bean Validation: Advanced Topics](bean-validation-advanced.htm#GKAHP)
    - [22.1 Creating Custom Constraints](bean-validation-advanced001.htm#GKFGX)
      * [22.1.1 Using the Built-In Constraints to Make a New Constraint](bean-validation-advanced001.htm#GKAIA)
      * [22.1.2 Removing Ambiguity in Constraint Targets](bean-validation-advanced001.htm#CIHCICAI)
    - [22.2 Customizing Validator Messages](bean-validation-advanced002.htm#GKAHI)
      * [22.2.1 The ValidationMessages Resource Bundle](bean-validation-advanced002.htm#GKAGY)
        + [22.2.1.1 Localizing Validation Messages](bean-validation-advanced002.htm#GKAIQ)
    - [22.3 Grouping Constraints](bean-validation-advanced003.htm#GKAGV)
      * [22.3.1 Customizing Group Validation Order](bean-validation-advanced003.htm#GKAGU)
    - [22.4 Using Method Constraints in Type Hierarchies](bean-validation-advanced004.htm#CIHGJBGI)
      * [22.4.1 Rules for Using Method Constraints in Type Hierarchies](bean-validation-advanced004.htm#sthref1371)
* [Part V Contexts and Dependency Injection for Java EE](partcdi.htm#GJBNR)
  + [23 Introduction to Contexts and Dependency Injection for Java EE](cdi-basic.htm#GIWHB)
    - [23.1 Getting Started](cdi-basic001.htm#BABJDJGA)
    - [23.2 Overview of CDI](cdi-basic002.htm#GIWHL)
    - [23.3 About Beans](cdi-basic003.htm#GJEBJ)
    - [23.4 About CDI Managed Beans](cdi-basic004.htm#GJFZI)
    - [23.5 Beans as Injectable Objects](cdi-basic005.htm#GIZKS)
    - [23.6 Using Qualifiers](cdi-basic006.htm#GJBCK)
    - [23.7 Injecting Beans](cdi-basic007.htm#GJBAN)
    - [23.8 Using Scopes](cdi-basic008.htm#GJBBK)
    - [23.9 Giving Beans EL Names](cdi-basic009.htm#GJBAK)
    - [23.10 Adding Setter and Getter Methods](cdi-basic010.htm#GJBBP)
    - [23.11 Using a Managed Bean in a Facelets Page](cdi-basic011.htm#GJBBU)
    - [23.12 Injecting Objects by Using Producer Methods](cdi-basic012.htm#GJDID)
    - [23.13 Configuring a CDI Application](cdi-basic013.htm#GJBNZ)
    - [23.14 Using the @PostConstruct and @PreDestroy Annotations with CDI Managed Bean Classes](cdi-basic014.htm#BABJFEAI)
      * [23.14.1 To Initialize a Managed Bean Using the @PostConstruct Annotation](cdi-basic014.htm#sthref1405)
      * [23.14.2 To Prepare for the Destruction of a Managed Bean Using the @PreDestroy Annotation](cdi-basic014.htm#sthref1406)
    - [23.15 Further Information about CDI](cdi-basic015.htm#GIWEL)
  + [24 Running the Basic Contexts and Dependency Injection Examples](cdi-basicexamples.htm#GJBLS)
    - [24.1 The simplegreeting CDI Example](cdi-basicexamples001.htm#GJBJU)
      * [24.1.1 The simplegreeting Source Files](cdi-basicexamples001.htm#GJCQS)
      * [24.1.2 The Facelets Template and Page](cdi-basicexamples001.htm#GJDOJ)
      * [24.1.3 Running the simplegreeting Example](cdi-basicexamples001.htm#GJCYM)
        + [24.1.3.1 To Build, Package, and Run the simplegreeting Example Using NetBeans IDE](cdi-basicexamples001.htm#GJCXP)
        + [24.1.3.2 To Build, Package, and Deploy the simplegreeting Example Using Maven](cdi-basicexamples001.htm#GJCZT)
        + [24.1.3.3 To Run the simplegreeting Example](cdi-basicexamples001.htm#GJCZE)
    - [24.2 The guessnumber-cdi CDI Example](cdi-basicexamples002.htm#GJCXV)
      * [24.2.1 The guessnumber-cdi Source Files](cdi-basicexamples002.htm#GJDJU)
        + [24.2.1.1 The @MaxNumber and @Random Qualifier Interfaces](cdi-basicexamples002.htm#GJDJP)
        + [24.2.1.2 The Generator Managed Bean](cdi-basicexamples002.htm#GJDJN)
        + [24.2.1.3 The UserNumberBean Managed Bean](cdi-basicexamples002.htm#GJDHY)
      * [24.2.2 The Facelets Page](cdi-basicexamples002.htm#GJDON)
      * [24.2.3 Running the guessnumber-cdi Example](cdi-basicexamples002.htm#GJDPW)
        + [24.2.3.1 To Build, Package, and Deploy the guessnumber-cdi Example Using NetBeans IDE](cdi-basicexamples002.htm#GJDPS)
        + [24.2.3.2 To Build, Package, and Deploy the guessnumber-cdi Example Using Maven](cdi-basicexamples002.htm#GJDPR)
        + [24.2.3.3 To Run the guessnumber Example](cdi-basicexamples002.htm#GJDQB)
  + [25 Contexts and Dependency Injection for Java EE: Advanced Topics](cdi-adv.htm#GJEHI)
    - [25.1 Packaging CDI Applications](cdi-adv001.htm#CACDCFDE)
    - [25.2 Using Alternatives in CDI Applications](cdi-adv002.htm#GJSDF)
      * [25.2.1 Using Specialization](cdi-adv002.htm#GKHPO)
    - [25.3 Using Producer Methods, Producer Fields, and Disposer Methods in CDI Applications](cdi-adv003.htm#GKGKV)
      * [25.3.1 Using Producer Methods](cdi-adv003.htm#sthref1420)
      * [25.3.2 Using Producer Fields to Generate Resources](cdi-adv003.htm#sthref1421)
      * [25.3.3 Using a Disposer Method](cdi-adv003.htm#sthref1422)
    - [25.4 Using Predefined Beans in CDI Applications](cdi-adv004.htm#CJGHGDBA)
    - [25.5 Using Events in CDI Applications](cdi-adv005.htm#GKHIC)
      * [25.5.1 Defining Events](cdi-adv005.htm#GKHHY)
      * [25.5.2 Using Observer Methods to Handle Events](cdi-adv005.htm#GKHNF)
      * [25.5.3 Firing Events](cdi-adv005.htm#GKHIH)
    - [25.6 Using Interceptors in CDI Applications](cdi-adv006.htm#GKHJX)
    - [25.7 Using Decorators in CDI Applications](cdi-adv007.htm#GKHQF)
    - [25.8 Using Stereotypes in CDI Applications](cdi-adv008.htm#GKHQC)
  + [26 Running the Advanced Contexts and Dependency Injection Examples](cdi-adv-examples.htm#GKHRE)
    - [26.1 The encoder Example: Using Alternatives](cdi-adv-examples001.htm#GKHPU)
      * [26.1.1 The Coder Interface and Implementations](cdi-adv-examples001.htm#GKHQA)
      * [26.1.2 The encoder Facelets Page and Managed Bean](cdi-adv-examples001.htm#GKHPM)
      * [26.1.3 Running the encoder Example](cdi-adv-examples001.htm#GKHQQ)
        + [26.1.3.1 To Build, Package, and Deploy the encoder Example Using NetBeans IDE](cdi-adv-examples001.htm#GKHOW)
        + [26.1.3.2 To Run the encoder Example Using NetBeans IDE](cdi-adv-examples001.htm#GKHQU)
        + [26.1.3.3 To Build, Package, and Deploy the encoder Example Using Maven](cdi-adv-examples001.htm#GKHQL)
        + [26.1.3.4 To Run the encoder Example Using Maven](cdi-adv-examples001.htm#GKHOL)
    - [26.2 The producermethods Example: Using a Producer Method to Choose a Bean Implementation](cdi-adv-examples002.htm#GKHPY)
      * [26.2.1 Components of the producermethods Example](cdi-adv-examples002.htm#GKHRO)
      * [26.2.2 Running the producermethods Example](cdi-adv-examples002.htm#GKHQE)
        + [26.2.2.1 To Build, Package, and Deploy the producermethods Example Using NetBeans IDE](cdi-adv-examples002.htm#GKHPE)
        + [26.2.2.2 To Build, Package, and Deploy the producermethods Example Using Maven](cdi-adv-examples002.htm#GKHPS)
        + [26.2.2.3 To Run the producermethods Example](cdi-adv-examples002.htm#GKHQG)
    - [26.3 The producerfields Example: Using Producer Fields to Generate Resources](cdi-adv-examples003.htm#GKHRG)
      * [26.3.1 The Producer Field for the producerfields Example](cdi-adv-examples003.htm#GKHPP)
      * [26.3.2 The producerfields Entity and Session Bean](cdi-adv-examples003.htm#GKHPD)
      * [26.3.3 The producerfields Facelets Pages and Managed Bean](cdi-adv-examples003.htm#GKHPF)
      * [26.3.4 Running the producerfields Example](cdi-adv-examples003.htm#GKHRH)
        + [26.3.4.1 To Build, Package, and Deploy the producerfields Example Using NetBeans IDE](cdi-adv-examples003.htm#GKHPB)
        + [26.3.4.2 To Build, Package, and Deploy the producerfields Example Using Maven](cdi-adv-examples003.htm#GKHRM)
        + [26.3.4.3 To Run the producerfields Example](cdi-adv-examples003.htm#GKHRR)
    - [26.4 The billpayment Example: Using Events and Interceptors](cdi-adv-examples004.htm#GKHPA)
      * [26.4.1 The PaymentEvent Event Class](cdi-adv-examples004.htm#GKHOK)
      * [26.4.2 The PaymentHandler Event Listener](cdi-adv-examples004.htm#GKHRB)
      * [26.4.3 The billpayment Facelets Pages and Managed Bean](cdi-adv-examples004.htm#GKHRJ)
      * [26.4.4 The LoggedInterceptor Interceptor Class](cdi-adv-examples004.htm#GKHRQ)
      * [26.4.5 Running the billpayment Example](cdi-adv-examples004.htm#GKHPK)
        + [26.4.5.1 To Build, Package, and Deploy the billpayment Example Using NetBeans IDE](cdi-adv-examples004.htm#GKHQS)
        + [26.4.5.2 To Build, Package, and Deploy the billpayment Example Using Maven](cdi-adv-examples004.htm#GKHPX)
        + [26.4.5.3 To Run the billpayment Example](cdi-adv-examples004.htm#GKHPT)
    - [26.5 The decorators Example: Decorating a Bean](cdi-adv-examples005.htm#GKPAX)
      * [26.5.1 Components of the decorators Example](cdi-adv-examples005.htm#GKPAQ)
      * [26.5.2 Running the decorators Example](cdi-adv-examples005.htm#GKPBK)
        + [26.5.2.1 To Build, Package, and Deploy the decorators Example Using NetBeans IDE](cdi-adv-examples005.htm#GKPAG)
        + [26.5.2.2 To Build, Package, and Deploy the decorators Example Using Maven](cdi-adv-examples005.htm#GKPAJ)
        + [26.5.2.3 To Run the decorators Example](cdi-adv-examples005.htm#GKPAN)
* [Part VI Web Services](partwebsvcs.htm#BNAYK)
  + [27 Introduction to Web Services](webservices-intro.htm#GIJTI)
    - [27.1 What Are Web Services?](webservices-intro001.htm#GIJVH)
    - [27.2 Types of Web Services](webservices-intro002.htm#GIQSX)
      * [27.2.1 "Big" Web Services](webservices-intro002.htm#GKCDG)
      * [27.2.2 RESTful Web Services](webservices-intro002.htm#GKCAW)
    - [27.3 Deciding Which Type of Web Service to Use](webservices-intro003.htm#GJBJI)
  + [28 Building Web Services with JAX-WS](jaxws.htm#BNAYL)
    - [28.1 Creating a Simple Web Service and Clients with JAX-WS](jaxws001.htm#BNAYN)
      * [28.1.1 Requirements of a JAX-WS Endpoint](jaxws001.htm#BNAYP)
      * [28.1.2 Coding the Service Endpoint Implementation Class](jaxws001.htm#BNAYQ)
      * [28.1.3 Building, Packaging, and Deploying the Service](jaxws001.htm#BNAYR)
        + [28.1.3.1 To Build, Package, and Deploy the Service Using NetBeans IDE](jaxws001.htm#BNAYS)
        + [28.1.3.2 To Build, Package, and Deploy the Service Using Maven](jaxws001.htm#BNAYT)
      * [28.1.4 Testing the Methods of a Web Service Endpoint](jaxws001.htm#GKAJL)
        + [28.1.4.1 To Test the Service without a Client](jaxws001.htm#BNAYW)
      * [28.1.5 A Simple JAX-WS Application Client](jaxws001.htm#BNAYX)
        + [28.1.5.1 Coding the Application Client](jaxws001.htm#BNAYY)
        + [28.1.5.2 Running the Application Client](jaxws001.htm#BNAYZ)
      * [28.1.6 A Simple JAX-WS Web Client](jaxws001.htm#GJYGB)
        + [28.1.6.1 Coding the Servlet](jaxws001.htm#GJYFL)
        + [28.1.6.2 Running the Web Client](jaxws001.htm#GJYGE)
    - [28.2 Types Supported by JAX-WS](jaxws002.htm#BNAZC)
      * [28.2.1 Schema-to-Java Mapping](jaxws002.htm#BNAZT)
      * [28.2.2 Java-to-Schema Mapping](jaxws002.htm#BNAZW)
    - [28.3 Web Services Interoperability and JAX-WS](jaxws003.htm#BNAZD)
    - [28.4 Further Information about JAX-WS](jaxws004.htm#BNAZE)
  + [29 Building RESTful Web Services with JAX-RS](jaxrs.htm#GIEPU)
    - [29.1 What Are RESTful Web Services?](jaxrs001.htm#GIJQY)
    - [29.2 Creating a RESTful Root Resource Class](jaxrs002.htm#GILIK)
      * [29.2.1 Developing RESTful Web Services with JAX-RS](jaxrs002.htm#GILRU)
      * [29.2.2 Overview of a JAX-RS Application](jaxrs002.htm#GILQB)
      * [29.2.3 The @Path Annotation and URI Path Templates](jaxrs002.htm#GINPW)
      * [29.2.4 Responding to HTTP Methods and Requests](jaxrs002.htm#GIPYS)
        + [29.2.4.1 The Request Method Designator Annotations](jaxrs002.htm#GIPXS)
        + [29.2.4.2 Using Entity Providers to Map HTTP Response and Request Entity Bodies](jaxrs002.htm#GIPZE)
      * [29.2.5 Using @Consumes and @Produces to Customize Requests and Responses](jaxrs002.htm#GIPZH)
        + [29.2.5.1 The @Produces Annotation](jaxrs002.htm#GIPXF)
        + [29.2.5.2 The @Consumes Annotation](jaxrs002.htm#GIPYT)
      * [29.2.6 Extracting Request Parameters](jaxrs002.htm#GIPYW)
      * [29.2.7 Configuring JAX-RS Applications](jaxrs002.htm#sthref1547)
        + [29.2.7.1 Configuring a JAX-RS Application Using a Subclass of Application](jaxrs002.htm#sthref1551)
        + [29.2.7.2 Configuring the Base URI in web.xml](jaxrs002.htm#sthref1552)
    - [29.3 Example Applications for JAX-RS](jaxrs003.htm#GIPZZ)
      * [29.3.1 Creating a Simple RESTful Web Service](jaxrs003.htm#GIPYZ)
        + [29.3.1.1 To Create a RESTful Web Service Using NetBeans IDE](jaxrs003.htm#GIQAA)
      * [29.3.2 The rsvp Example Application](jaxrs003.htm#GJVBC)
        + [29.3.2.1 Components of the rsvp Example Application](jaxrs003.htm#GJVAW)
        + [29.3.2.2 Running the rsvp Example Application](jaxrs003.htm#GKCCA)
      * [29.3.3 Real-World Examples](jaxrs003.htm#GIRCI)
    - [29.4 Further Information about JAX-RS](jaxrs004.htm#GILIZ)
  + [30 Accessing REST Resources with the JAX-RS Client API](jaxrs-client.htm#BABEIGIH)
    - [30.1 Overview of the Client API](jaxrs-client001.htm#BABBIHEJ)
      * [30.1.1 Creating a Basic Client Request Using the Client API](jaxrs-client001.htm#sthref1563)
        + [30.1.1.1 Obtaining the Client Instance](jaxrs-client001.htm#sthref1564)
        + [30.1.1.2 Setting the Client Target](jaxrs-client001.htm#sthref1565)
        + [30.1.1.3 Setting Path Parameters in Targets](jaxrs-client001.htm#sthref1566)
        + [30.1.1.4 Invoking the Request](jaxrs-client001.htm#sthref1568)
    - [30.2 Using the Client API in the JAX-RS Example Applications](jaxrs-client002.htm#BABJCIJC)
      * [30.2.1 The Client API in the rsvp Example Application](jaxrs-client002.htm#BABEDFIG)
      * [30.2.2 The Client API in the customer Example Application](jaxrs-client002.htm#sthref1570)
    - [30.3 Advanced Features of the Client API](jaxrs-client003.htm#BABCDDGH)
      * [30.3.1 Configuring the Client Request](jaxrs-client003.htm#sthref1571)
        + [30.3.1.1 Setting Message Headers in the Client Request](jaxrs-client003.htm#sthref1572)
        + [30.3.1.2 Setting Cookies in the Client Request](jaxrs-client003.htm#sthref1574)
        + [30.3.1.3 Adding Filters to the Client](jaxrs-client003.htm#sthref1577)
      * [30.3.2 Asynchronous Invocations in the Client API](jaxrs-client003.htm#sthref1579)
        + [30.3.2.1 Using Custom Callbacks in Asynchronous Invocations](jaxrs-client003.htm#sthref1581)
  + [31 JAX-RS: Advanced Topics and an Example](jaxrs-advanced.htm#GJJXE)
    - [31.1 Annotations for Field and Bean Properties of Resource Classes](jaxrs-advanced001.htm#GKKRB)
      * [31.1.1 Extracting Path Parameters](jaxrs-advanced001.htm#GKKYA)
      * [31.1.2 Extracting Query Parameters](jaxrs-advanced001.htm#GKKXJ)
      * [31.1.3 Extracting Form Data](jaxrs-advanced001.htm#GKKYC)
      * [31.1.4 Extracting the Java Type of a Request or Response](jaxrs-advanced001.htm#GKLCQ)
    - [31.2 Validating Resource Data with Bean Validation](jaxrs-advanced002.htm#BABCJEDF)
      * [31.2.1 Using Constraint Annotations on Resource Methods](jaxrs-advanced002.htm#sthref1606)
      * [31.2.2 Validating Entity Data](jaxrs-advanced002.htm#sthref1607)
      * [31.2.3 Validation Exception Handling and Response Codes](jaxrs-advanced002.htm#sthref1608)
    - [31.3 Subresources and Runtime Resource Resolution](jaxrs-advanced003.htm#GKNAV)
      * [31.3.1 Subresource Methods](jaxrs-advanced003.htm#GKLAG)
      * [31.3.2 Subresource Locators](jaxrs-advanced003.htm#GKRHR)
    - [31.4 Integrating JAX-RS with EJB Technology and CDI](jaxrs-advanced004.htm#GKNCY)
    - [31.5 Conditional HTTP Requests](jaxrs-advanced005.htm#GKQDA)
    - [31.6 Runtime Content Negotiation](jaxrs-advanced006.htm#GKQBQ)
    - [31.7 Using JAX-RS with JAXB](jaxrs-advanced007.htm#GKKNJ)
      * [31.7.1 Using Java Objects to Model Your Data](jaxrs-advanced007.htm#sthref1635)
      * [31.7.2 Starting from an Existing XML Schema Definition](jaxrs-advanced007.htm#sthref1636)
      * [31.7.3 Using JSON with JAX-RS and JAXB](jaxrs-advanced007.htm#sthref1637)
    - [31.8 The customer Example Application](jaxrs-advanced008.htm#GKOIB)
      * [31.8.1 Overview of the customer Example Application](jaxrs-advanced008.htm#GKOFO)
      * [31.8.2 The Customer and Address Entity Classes](jaxrs-advanced008.htm#sthref1642)
      * [31.8.3 The CustomerService Class](jaxrs-advanced008.htm#GKLGT)
      * [31.8.4 Using the JAX-RS Client in the CustomerBean Classes](jaxrs-advanced008.htm#GKQJQ)
      * [31.8.5 Running the customer Example](jaxrs-advanced008.htm#GKQKV)
        + [31.8.5.1 To Build, Package, and Deploy the customer Example Using NetBeans IDE](jaxrs-advanced008.htm#GKQLY)
        + [31.8.5.2 To Build, Package, and Deploy the customer Example Using Maven](jaxrs-advanced008.htm#GKQJV)
* [Part VII Enterprise Beans](partentbeans.htm#BNBLR)
  + [32 Enterprise Beans](ejb-intro.htm#GIJSZ)
    - [32.1 What Is an Enterprise Bean?](ejb-intro001.htm#GIPMB)
      * [32.1.1 Benefits of Enterprise Beans](ejb-intro001.htm#GIPLK)
      * [32.1.2 When to Use Enterprise Beans](ejb-intro001.htm#GIPKN)
      * [32.1.3 Types of Enterprise Beans](ejb-intro001.htm#GIPNM)
    - [32.2 What Is a Session Bean?](ejb-intro002.htm#GIPJG)
      * [32.2.1 Types of Session Beans](ejb-intro002.htm#GIPKR)
        + [32.2.1.1 Stateful Session Beans](ejb-intro002.htm#GIPNL)
        + [32.2.1.2 Stateless Session Beans](ejb-intro002.htm#GIPIN)
        + [32.2.1.3 Singleton Session Beans](ejb-intro002.htm#GIPIM)
      * [32.2.2 When to Use Session Beans](ejb-intro002.htm#GIPMT)
    - [32.3 What Is a Message-Driven Bean?](ejb-intro003.htm#GIPKO)
      * [32.3.1 What Makes Message-Driven Beans Different from Session Beans?](ejb-intro003.htm#GIPMJ)
      * [32.3.2 When to Use Message-Driven Beans](ejb-intro003.htm#GIPJX)
    - [32.4 Accessing Enterprise Beans](ejb-intro004.htm#GIPJF)
      * [32.4.1 Using Enterprise Beans in Clients](ejb-intro004.htm#GIRFL)
        + [32.4.1.1 Portable JNDI Syntax](ejb-intro004.htm#GIRGN)
      * [32.4.2 Deciding on Remote or Local Access](ejb-intro004.htm#GIPIZ)
      * [32.4.3 Local Clients](ejb-intro004.htm#GIPMZ)
        + [32.4.3.1 Accessing Local Enterprise Beans Using the No-Interface View](ejb-intro004.htm#GIPSC)
        + [32.4.3.2 Accessing Local Enterprise Beans That Implement Business Interfaces](ejb-intro004.htm#GIPSE)
      * [32.4.4 Remote Clients](ejb-intro004.htm#GIPIU)
      * [32.4.5 Web Service Clients](ejb-intro004.htm#GIPKD)
      * [32.4.6 Method Parameters and Access](ejb-intro004.htm#GIPLY)
        + [32.4.6.1 Isolation](ejb-intro004.htm#GIPLX)
        + [32.4.6.2 Granularity of Accessed Data](ejb-intro004.htm#GIPKV)
    - [32.5 The Contents of an Enterprise Bean](ejb-intro005.htm#GIPIO)
    - [32.6 Naming Conventions for Enterprise Beans](ejb-intro006.htm#GIPKS)
    - [32.7 The Lifecycles of Enterprise Beans](ejb-intro007.htm#GIPLJ)
      * [32.7.1 The Lifecycle of a Stateful Session Bean](ejb-intro007.htm#GIPLN)
      * [32.7.2 The Lifecycle of a Stateless Session Bean](ejb-intro007.htm#GIPLM)
      * [32.7.3 The Lifecycle of a Singleton Session Bean](ejb-intro007.htm#GIPRX)
      * [32.7.4 The Lifecycle of a Message-Driven Bean](ejb-intro007.htm#GIPKW)
    - [32.8 Further Information about Enterprise Beans](ejb-intro008.htm#GIPLG)
  + [33 Getting Started with Enterprise Beans](ejb-gettingstarted.htm#GIJRE)
    - [33.1 Creating the Enterprise Bean](ejb-gettingstarted001.htm#GIPSS)
      * [33.1.1 Coding the Enterprise Bean Class](ejb-gettingstarted001.htm#GIPSX)
      * [33.1.2 Creating the converter Web Client](ejb-gettingstarted001.htm#GIPSI)
      * [33.1.3 Running the converter Example](ejb-gettingstarted001.htm#GIPVV)
        + [33.1.3.1 To Run the converter Example Using NetBeans IDE](ejb-gettingstarted001.htm#GIPUM)
        + [33.1.3.2 To Run the converter Example Using Maven](ejb-gettingstarted001.htm#GIPVQ)
    - [33.2 Modifying the Java EE Application](ejb-gettingstarted002.htm#GIPTI)
      * [33.2.1 To Modify a Class File](ejb-gettingstarted002.htm#GIPUK)
  + [34 Running the Enterprise Bean Examples](ejb-basicexamples.htm#GIJRB)
    - [34.1 The cart Example](ejb-basicexamples001.htm#BNBOD)
      * [34.1.1 The Business Interface](ejb-basicexamples001.htm#BNBOE)
      * [34.1.2 Session Bean Class](ejb-basicexamples001.htm#BNBOF)
        + [34.1.2.1 Lifecycle Callback Methods](ejb-basicexamples001.htm#BNBOG)
        + [34.1.2.2 Business Methods](ejb-basicexamples001.htm#BNBOH)
      * [34.1.3 The @Remove Method](ejb-basicexamples001.htm#BNBOI)
      * [34.1.4 Helper Classes](ejb-basicexamples001.htm#BNBOJ)
      * [34.1.5 Running the cart Example](ejb-basicexamples001.htm#BNBOK)
        + [34.1.5.1 To Run the cart Example Using NetBeans IDE](ejb-basicexamples001.htm#BNBOL)
        + [34.1.5.2 To Run the cart Example Using Maven](ejb-basicexamples001.htm#BNBON)
    - [34.2 A Singleton Session Bean Example: counter](ejb-basicexamples002.htm#GIPVI)
      * [34.2.1 Creating a Singleton Session Bean](ejb-basicexamples002.htm#GIPVC)
        + [34.2.1.1 Initializing Singleton Session Beans](ejb-basicexamples002.htm#GIPPQ)
        + [34.2.1.2 Managing Concurrent Access in a Singleton Session Bean](ejb-basicexamples002.htm#GIPSZ)
        + [34.2.1.3 Handling Errors in a Singleton Session Bean](ejb-basicexamples002.htm#GIPVD)
      * [34.2.2 The Architecture of the counter Example](ejb-basicexamples002.htm#GIPXL)
      * [34.2.3 Running the counter Example](ejb-basicexamples002.htm#GIPVL)
        + [34.2.3.1 To Run the counter Example Using NetBeans IDE](ejb-basicexamples002.htm#GIPXT)
        + [34.2.3.2 To Run the counter Example Using Maven](ejb-basicexamples002.htm#GIPZW)
    - [34.3 A Web Service Example: helloservice](ejb-basicexamples003.htm#BNBOR)
      * [34.3.1 The Web Service Endpoint Implementation Class](ejb-basicexamples003.htm#BNBOS)
      * [34.3.2 Stateless Session Bean Implementation Class](ejb-basicexamples003.htm#BNBOT)
      * [34.3.3 Running the helloservice Example](ejb-basicexamples003.htm#BNBOU)
        + [34.3.3.1 To Build, Package, and Deploy the helloservice Example Using NetBeans IDE](ejb-basicexamples003.htm#BNBOV)
        + [34.3.3.2 To Build, Package, and Deploy the helloservice Example Using Maven](ejb-basicexamples003.htm#BNBOW)
        + [34.3.3.3 To Test the Service without a Client](ejb-basicexamples003.htm#BNBOX)
    - [34.4 Using the Timer Service](ejb-basicexamples004.htm#BNBOY)
      * [34.4.1 Creating Calendar-Based Timer Expressions](ejb-basicexamples004.htm#GIQLK)
        + [34.4.1.1 Specifying Multiple Values in Calendar Expressions](ejb-basicexamples004.htm#GIQMX)
      * [34.4.2 Programmatic Timers](ejb-basicexamples004.htm#GIQLT)
        + [34.4.2.1 The @Timeout Method](ejb-basicexamples004.htm#BNBOZ)
        + [34.4.2.2 Creating Programmatic Timers](ejb-basicexamples004.htm#BNBPA)
      * [34.4.3 Automatic Timers](ejb-basicexamples004.htm#GIQMB)
      * [34.4.4 Canceling and Saving Timers](ejb-basicexamples004.htm#BNBPB)
      * [34.4.5 Getting Timer Information](ejb-basicexamples004.htm#BNBPC)
      * [34.4.6 Transactions and Timers](ejb-basicexamples004.htm#BNBPD)
      * [34.4.7 The timersession Example](ejb-basicexamples004.htm#BNBPE)
      * [34.4.8 Running the timersession Example](ejb-basicexamples004.htm#BNBPF)
        + [34.4.8.1 To Run the timersession Example Using NetBeans IDE](ejb-basicexamples004.htm#GIQNI)
        + [34.4.8.2 To Build, Package, and Deploy the timersession Example Using Maven](ejb-basicexamples004.htm#GIQNQ)
        + [34.4.8.3 To Run the Web Client](ejb-basicexamples004.htm#GIQOP)
    - [34.5 Handling Exceptions](ejb-basicexamples005.htm#BNBPJ)
  + [35 Using the Embedded Enterprise Bean Container](ejb-embedded.htm#GKCQZ)
    - [35.1 Overview of the Embedded Enterprise Bean Container](ejb-embedded001.htm#GKFAE)
    - [35.2 Developing Embeddable Enterprise Bean Applications](ejb-embedded002.htm#GKCRR)
      * [35.2.1 Running Embedded Applications](ejb-embedded002.htm#GKCQI)
      * [35.2.2 Creating the Enterprise Bean Container](ejb-embedded002.htm#GKCOV)
        + [35.2.2.1 Explicitly Specifying Enterprise Bean Modules to Be Initialized](ejb-embedded002.htm#GKCRP)
      * [35.2.3 Looking Up Session Bean References](ejb-embedded002.htm#GLHUR)
      * [35.2.4 Shutting Down the Enterprise Bean Container](ejb-embedded002.htm#GKCRE)
    - [35.3 The standalone Example Application](ejb-embedded003.htm#GKCPV)
      * [35.3.1 To Run the standalone Example Application Using NetBeans IDE](ejb-embedded003.htm#GKCQP)
      * [35.3.2 To Run the standalone Example Application Using Maven](ejb-embedded003.htm#sthref1812)
  + [36 Using Asynchronous Method Invocation in Session Beans](ejb-async.htm#GKIDZ)
    - [36.1 Asynchronous Method Invocation](ejb-async001.htm#GKKQG)
      * [36.1.1 Creating an Asynchronous Business Method](ejb-async001.htm#GKIFJ)
      * [36.1.2 Calling Asynchronous Methods from Enterprise Bean Clients](ejb-async001.htm#GKIEM)
        + [36.1.2.1 Retrieving the Final Result from an Asynchronous Method Invocation](ejb-async001.htm#GKICM)
        + [36.1.2.2 Cancelling an Asynchronous Method Invocation](ejb-async001.htm#GKIDB)
        + [36.1.2.3 Checking the Status of an Asynchronous Method Invocation](ejb-async001.htm#GKIEV)
    - [36.2 The async Example Application](ejb-async002.htm#GKIEZ)
      * [36.2.1 Architecture of the async-war Module](ejb-async002.htm#GKIQJ)
      * [36.2.2 Running the async Example](ejb-async002.htm#sthref1823)
        + [36.2.2.1 To Run the async Example Application Using NetBeans IDE](ejb-async002.htm#GKINW)
        + [36.2.2.2 To Run the async Example Application Using Maven](ejb-async002.htm#GKRFB)
* [Part VIII Persistence](partpersist.htm#BNBPY)
  + [37 Introduction to the Java Persistence API](persistence-intro.htm#BNBPZ)
    - [37.1 Entities](persistence-intro001.htm#BNBQA)
      * [37.1.1 Requirements for Entity Classes](persistence-intro001.htm#BNBQB)
      * [37.1.2 Persistent Fields and Properties in Entity Classes](persistence-intro001.htm#BNBQC)
        + [37.1.2.1 Persistent Fields](persistence-intro001.htm#BNBQD)
        + [37.1.2.2 Persistent Properties](persistence-intro001.htm#BNBQE)
        + [37.1.2.3 Using Collections in Entity Fields and Properties](persistence-intro001.htm#GIQVN)
        + [37.1.2.4 Validating Persistent Fields and Properties](persistence-intro001.htm#GKAHQ)
      * [37.1.3 Primary Keys in Entities](persistence-intro001.htm#BNBQF)
      * [37.1.4 Multiplicity in Entity Relationships](persistence-intro001.htm#BNBQH)
      * [37.1.5 Direction in Entity Relationships](persistence-intro001.htm#BNBQI)
        + [37.1.5.1 Bidirectional Relationships](persistence-intro001.htm#BNBQJ)
        + [37.1.5.2 Unidirectional Relationships](persistence-intro001.htm#BNBQK)
        + [37.1.5.3 Queries and Relationship Direction](persistence-intro001.htm#BNBQL)
        + [37.1.5.4 Cascade Operations and Relationships](persistence-intro001.htm#BNBQM)
        + [37.1.5.5 Orphan Removal in Relationships](persistence-intro001.htm#GIQXY)
      * [37.1.6 Embeddable Classes in Entities](persistence-intro001.htm#GJIWZ)
    - [37.2 Entity Inheritance](persistence-intro002.htm#BNBQN)
      * [37.2.1 Abstract Entities](persistence-intro002.htm#BNBQO)
      * [37.2.2 Mapped Superclasses](persistence-intro002.htm#BNBQP)
      * [37.2.3 Non-Entity Superclasses](persistence-intro002.htm#BNBQQ)
      * [37.2.4 Entity Inheritance Mapping Strategies](persistence-intro002.htm#BNBQR)
        + [37.2.4.1 The Single Table per Class Hierarchy Strategy](persistence-intro002.htm#BNBQS)
        + [37.2.4.2 The Table per Concrete Class Strategy](persistence-intro002.htm#BNBQU)
        + [37.2.4.3 The Joined Subclass Strategy](persistence-intro002.htm#BNBQV)
    - [37.3 Managing Entities](persistence-intro003.htm#BNBQW)
      * [37.3.1 The EntityManager Interface](persistence-intro003.htm#BNBQY)
        + [37.3.1.1 Container-Managed Entity Managers](persistence-intro003.htm#BNBQZ)
        + [37.3.1.2 Application-Managed Entity Managers](persistence-intro003.htm#BNBRA)
        + [37.3.1.3 Finding Entities Using the EntityManager](persistence-intro003.htm#BNBRB)
        + [37.3.1.4 Managing an Entity Instance's Lifecycle](persistence-intro003.htm#BNBRC)
        + [37.3.1.5 Persisting Entity Instances](persistence-intro003.htm#BNBRD)
        + [37.3.1.6 Removing Entity Instances](persistence-intro003.htm#BNBRE)
        + [37.3.1.7 Synchronizing Entity Data to the Database](persistence-intro003.htm#BNBRF)
      * [37.3.2 Persistence Units](persistence-intro003.htm#BNBRJ)
    - [37.4 Querying Entities](persistence-intro004.htm#GJISE)
    - [37.5 Database Schema Creation](persistence-intro005.htm#CHDBEGIC)
      * [37.5.1 Configuring an Application to Create or Drop Database Tables](persistence-intro005.htm#sthref1908)
      * [37.5.2 Loading Data Using SQL Scripts](persistence-intro005.htm#sthref1919)
    - [37.6 Further Information about Persistence](persistence-intro006.htm#GKCLC)
  + [38 Running the Persistence Examples](persistence-basicexamples.htm#GIJST)
    - [38.1 The order Application](persistence-basicexamples001.htm#GIQST)
      * [38.1.1 Entity Relationships in the order Application](persistence-basicexamples001.htm#GIQRH)
        + [38.1.1.1 Self-Referential Relationships](persistence-basicexamples001.htm#GIQQR)
        + [38.1.1.2 One-to-One Relationships](persistence-basicexamples001.htm#GIQSR)
        + [38.1.1.3 One-to-Many Relationship Mapped to Overlapping Primary and Foreign Keys](persistence-basicexamples001.htm#GIQTJ)
        + [38.1.1.4 Unidirectional Relationships](persistence-basicexamples001.htm#GIQUD)
      * [38.1.2 Primary Keys in the order Application](persistence-basicexamples001.htm#GIQQY)
        + [38.1.2.1 Generated Primary Keys](persistence-basicexamples001.htm#GIQUV)
        + [38.1.2.2 Compound Primary Keys](persistence-basicexamples001.htm#GIQUF)
      * [38.1.3 Entity Mapped to More Than One Database Table](persistence-basicexamples001.htm#GIQTL)
      * [38.1.4 Cascade Operations in the order Application](persistence-basicexamples001.htm#GIQUE)
      * [38.1.5 BLOB and CLOB Database Types in the order Application](persistence-basicexamples001.htm#GIQSC)
      * [38.1.6 Temporal Types in the order Application](persistence-basicexamples001.htm#GIQUM)
      * [38.1.7 Managing the order Application's Entities](persistence-basicexamples001.htm#GIQQV)
        + [38.1.7.1 Creating Entities](persistence-basicexamples001.htm#GIQRR)
        + [38.1.7.2 Finding Entities](persistence-basicexamples001.htm#GIQQC)
        + [38.1.7.3 Setting Entity Relationships](persistence-basicexamples001.htm#GIQUK)
        + [38.1.7.4 Using Queries](persistence-basicexamples001.htm#GIQSV)
        + [38.1.7.5 Removing Entities](persistence-basicexamples001.htm#GIQTW)
      * [38.1.8 Running the order Example](persistence-basicexamples001.htm#GIQUP)
        + [38.1.8.1 To Run the order Example Using NetBeans IDE](persistence-basicexamples001.htm#GIQSG)
        + [38.1.8.2 To Run the order Example Using Maven](persistence-basicexamples001.htm#GIQTY)
    - [38.2 The roster Application](persistence-basicexamples002.htm#GIQSQ)
      * [38.2.1 Relationships in the roster Application](persistence-basicexamples002.htm#GIQSO)
        + [38.2.1.1 The Many-To-Many Relationship in roster](persistence-basicexamples002.htm#GIQQK)
      * [38.2.2 Entity Inheritance in the roster Application](persistence-basicexamples002.htm#GIQRF)
      * [38.2.3 Criteria Queries in the roster Application](persistence-basicexamples002.htm#GJJFL)
        + [38.2.3.1 Metamodel Classes in the roster Application](persistence-basicexamples002.htm#GJJEX)
        + [38.2.3.2 Obtaining a CriteriaBuilder Instance in RequestBean](persistence-basicexamples002.htm#GJJFN)
        + [38.2.3.3 Creating Criteria Queries in RequestBean's Business Methods](persistence-basicexamples002.htm#GJJFF)
      * [38.2.4 Automatic Table Generation in the roster Application](persistence-basicexamples002.htm#GIQRX)
      * [38.2.5 Running the roster Example](persistence-basicexamples002.htm#GIQUZ)
        + [38.2.5.1 To Run the roster Example Using NetBeans IDE](persistence-basicexamples002.htm#GIQUG)
        + [38.2.5.2 To Run the roster Example Using Maven](persistence-basicexamples002.htm#GIQSJ)
    - [38.3 The address-book Application](persistence-basicexamples003.htm#GKANQ)
      * [38.3.1 Bean Validation Constraints in address-book](persistence-basicexamples003.htm#GKAOJ)
      * [38.3.2 Specifying Error Messages for Constraints in address-book](persistence-basicexamples003.htm#GKANL)
      * [38.3.3 Validating Contact Input from a JavaServer Faces Application](persistence-basicexamples003.htm#GKAON)
      * [38.3.4 Running the address-book Example](persistence-basicexamples003.htm#GKAOP)
        + [38.3.4.1 To Run the address-book Example Using NetBeans IDE](persistence-basicexamples003.htm#GKAOD)
        + [38.3.4.2 To Run the address-book Example Using Maven](persistence-basicexamples003.htm#GKANZ)
  + [39 The Java Persistence Query Language](persistence-querylanguage.htm#BNBTG)
    - [39.1 Query Language Terminology](persistence-querylanguage001.htm#BNBTH)
    - [39.2 Creating Queries Using the Java Persistence Query Language](persistence-querylanguage002.htm#BNBRG)
      * [39.2.1 Named Parameters in Queries](persistence-querylanguage002.htm#BNBRH)
      * [39.2.2 Positional Parameters in Queries](persistence-querylanguage002.htm#BNBRI)
    - [39.3 Simplified Query Language Syntax](persistence-querylanguage003.htm#BNBTI)
      * [39.3.1 Select Statements](persistence-querylanguage003.htm#BNBTJ)
      * [39.3.2 Update and Delete Statements](persistence-querylanguage003.htm#BNBTK)
    - [39.4 Example Queries](persistence-querylanguage004.htm#BNBTL)
      * [39.4.1 Simple Queries](persistence-querylanguage004.htm#BNBTM)
        + [39.4.1.1 A Basic Select Query](persistence-querylanguage004.htm#BNBTN)
        + [39.4.1.2 Eliminating Duplicate Values](persistence-querylanguage004.htm#BNBTO)
        + [39.4.1.3 Using Named Parameters](persistence-querylanguage004.htm#BNBTP)
      * [39.4.2 Queries That Navigate to Related Entities](persistence-querylanguage004.htm#BNBTQ)
        + [39.4.2.1 A Simple Query with Relationships](persistence-querylanguage004.htm#BNBTR)
        + [39.4.2.2 Navigating to Single-Valued Relationship Fields](persistence-querylanguage004.htm#BNBTS)
        + [39.4.2.3 Traversing Relationships with an Input Parameter](persistence-querylanguage004.htm#BNBTT)
        + [39.4.2.4 Traversing Multiple Relationships](persistence-querylanguage004.htm#BNBTU)
        + [39.4.2.5 Navigating According to Related Fields](persistence-querylanguage004.htm#BNBTV)
      * [39.4.3 Queries with Other Conditional Expressions](persistence-querylanguage004.htm#BNBTW)
        + [39.4.3.1 The LIKE Expression](persistence-querylanguage004.htm#BNBTX)
        + [39.4.3.2 The IS NULL Expression](persistence-querylanguage004.htm#BNBTY)
        + [39.4.3.3 The IS EMPTY Expression](persistence-querylanguage004.htm#BNBTZ)
        + [39.4.3.4 The BETWEEN Expression](persistence-querylanguage004.htm#BNBUA)
        + [39.4.3.5 Comparison Operators](persistence-querylanguage004.htm#BNBUB)
      * [39.4.4 Bulk Updates and Deletes](persistence-querylanguage004.htm#BNBUC)
        + [39.4.4.1 Update Queries](persistence-querylanguage004.htm#BNBUD)
        + [39.4.4.2 Delete Queries](persistence-querylanguage004.htm#BNBUE)
    - [39.5 Full Query Language Syntax](persistence-querylanguage005.htm#BNBUF)
      * [39.5.1 BNF Symbols](persistence-querylanguage005.htm#BNBUG)
      * [39.5.2 BNF Grammar of the Java Persistence Query Language](persistence-querylanguage005.htm#BNBUI)
      * [39.5.3 FROM Clause](persistence-querylanguage005.htm#BNBUJ)
        + [39.5.3.1 Identifiers](persistence-querylanguage005.htm#BNBUK)
        + [39.5.3.2 Identification Variables](persistence-querylanguage005.htm#BNBUM)
        + [39.5.3.3 Range Variable Declarations](persistence-querylanguage005.htm#BNBUN)
        + [39.5.3.4 Collection Member Declarations](persistence-querylanguage005.htm#BNBUO)
        + [39.5.3.5 Joins](persistence-querylanguage005.htm#BNBUP)
      * [39.5.4 Path Expressions](persistence-querylanguage005.htm#BNBUQ)
        + [39.5.4.1 Examples of Path Expressions](persistence-querylanguage005.htm#BNBUR)
        + [39.5.4.2 Expression Types](persistence-querylanguage005.htm#BNBUS)
        + [39.5.4.3 Navigation](persistence-querylanguage005.htm#BNBUT)
      * [39.5.5 WHERE Clause](persistence-querylanguage005.htm#BNBUU)
        + [39.5.5.1 Literals](persistence-querylanguage005.htm#BNBUV)
        + [39.5.5.2 Input Parameters](persistence-querylanguage005.htm#BNBVA)
        + [39.5.5.3 Conditional Expressions](persistence-querylanguage005.htm#BNBVB)
        + [39.5.5.4 Operators and Their Precedence](persistence-querylanguage005.htm#BNBVC)
        + [39.5.5.5 BETWEEN Expressions](persistence-querylanguage005.htm#BNBVE)
        + [39.5.5.6 IN Expressions](persistence-querylanguage005.htm#BNBVF)
        + [39.5.5.7 LIKE Expressions](persistence-querylanguage005.htm#BNBVG)
        + [39.5.5.8 NULL Comparison Expressions](persistence-querylanguage005.htm#BNBVI)
        + [39.5.5.9 Empty Collection Comparison Expressions](persistence-querylanguage005.htm#BNBVJ)
        + [39.5.5.10 Collection Member Expressions](persistence-querylanguage005.htm#BNBVK)
        + [39.5.5.11 Subqueries](persistence-querylanguage005.htm#BNBVL)
        + [39.5.5.12 Functional Expressions](persistence-querylanguage005.htm#BNBVO)
        + [39.5.5.13 Case Expressions](persistence-querylanguage005.htm#GJJND)
        + [39.5.5.14 NULL Values](persistence-querylanguage005.htm#BNBVR)
        + [39.5.5.15 Equality Semantics](persistence-querylanguage005.htm#BNBVU)
      * [39.5.6 SELECT Clause](persistence-querylanguage005.htm#BNBVX)
        + [39.5.6.1 Return Types](persistence-querylanguage005.htm#BNBVY)
        + [39.5.6.2 The DISTINCT Keyword](persistence-querylanguage005.htm#BNBWB)
        + [39.5.6.3 Constructor Expressions](persistence-querylanguage005.htm#BNBWC)
      * [39.5.7 ORDER BY Clause](persistence-querylanguage005.htm#BNBWD)
      * [39.5.8 GROUP BY and HAVING Clauses](persistence-querylanguage005.htm#BNBWE)
  + [40 Using the Criteria API to Create Queries](persistence-criteria.htm#GJITV)
    - [40.1 Overview of the Criteria and Metamodel APIs](persistence-criteria001.htm#GJRIJ)
    - [40.2 Using the Metamodel API to Model Entity Classes](persistence-criteria002.htm#GJIUP)
      * [40.2.1 Using Metamodel Classes](persistence-criteria002.htm#GJIVL)
    - [40.3 Using the Criteria API and Metamodel API to Create Basic Typesafe Queries](persistence-criteria003.htm#GJIVM)
      * [40.3.1 Creating a Criteria Query](persistence-criteria003.htm#GJIVS)
      * [40.3.2 Query Roots](persistence-criteria003.htm#GJIVQ)
      * [40.3.3 Querying Relationships Using Joins](persistence-criteria003.htm#GJIUV)
      * [40.3.4 Path Navigation in Criteria Queries](persistence-criteria003.htm#GJIVE)
      * [40.3.5 Restricting Criteria Query Results](persistence-criteria003.htm#GJIVI)
        + [40.3.5.1 The Expression Interface Methods](persistence-criteria003.htm#GJIWN)
        + [40.3.5.2 Expression Methods in the CriteriaBuilder Interface](persistence-criteria003.htm#GJIXA)
      * [40.3.6 Managing Criteria Query Results](persistence-criteria003.htm#GJIXE)
        + [40.3.6.1 Ordering Results](persistence-criteria003.htm#GJIWO)
        + [40.3.6.2 Grouping Results](persistence-criteria003.htm#GJIXG)
      * [40.3.7 Executing Queries](persistence-criteria003.htm#GJIVY)
        + [40.3.7.1 Single-Valued Query Results](persistence-criteria003.htm#GJIUR)
        + [40.3.7.2 Collection-Valued Query Results](persistence-criteria003.htm#GJIVP)
  + [41 Creating and Using String-Based Criteria Queries](persistence-string-queries.htm#GKJIQ)
    - [41.1 Overview of String-Based Criteria API Queries](persistence-string-queries001.htm#GKJIV)
    - [41.2 Creating String-Based Queries](persistence-string-queries002.htm#GKJBQ)
    - [41.3 Executing String-Based Queries](persistence-string-queries003.htm#GKJDB)
  + [42 Controlling Concurrent Access to Entity Data with Locking](persistence-locking.htm#GKJJF)
    - [42.1 Overview of Entity Locking and Concurrency](persistence-locking001.htm#GKJHZ)
      * [42.1.1 Using Optimistic Locking](persistence-locking001.htm#GKJJC)
    - [42.2 Lock Modes](persistence-locking002.htm#GKJIU)
      * [42.2.1 Setting the Lock Mode](persistence-locking002.htm#GKJIK)
      * [42.2.2 Using Pessimistic Locking](persistence-locking002.htm#GKJIL)
        + [42.2.2.1 Pessimistic Locking Timeouts](persistence-locking002.htm#GKJLQ)
  + [43 Creating Fetch Plans with Entity Graphs](persistence-entitygraphs.htm#BABIJIAC)
    - [43.1 Entity Graph Basics](persistence-entitygraphs001.htm#BABCJBCG)
      * [43.1.1 The Default Entity Graph](persistence-entitygraphs001.htm#sthref2176)
      * [43.1.2 Using Entity Graphs in Persistence Operations](persistence-entitygraphs001.htm#sthref2177)
        + [43.1.2.1 Fetch Graphs](persistence-entitygraphs001.htm#sthref2180)
        + [43.1.2.2 Load Graphs](persistence-entitygraphs001.htm#sthref2182)
    - [43.2 Using Named Entity Graphs](persistence-entitygraphs002.htm#BABFIGEI)
      * [43.2.1 Applying Named Entity Graph Annotations to Entity Classes](persistence-entitygraphs002.htm#sthref2186)
      * [43.2.2 Obtaining EntityGraph Instances from Named Entity Graphs](persistence-entitygraphs002.htm#sthref2187)
    - [43.3 Using Entity Graphs in Query Operations](persistence-entitygraphs003.htm#BABGJDAJ)
  + [44 Using a Second-Level Cache with Java Persistence API Applications](persistence-cache.htm#GKJIA)
    - [44.1 Overview of the Second-Level Cache](persistence-cache001.htm#GKJIO)
      * [44.1.1 Controlling whether Entities May Be Cached](persistence-cache001.htm#GKJIW)
    - [44.2 Specifying the Cache Mode Settings to Improve Performance](persistence-cache002.htm#GKJJJ)
      * [44.2.1 Setting the Cache Retrieval and Store Modes](persistence-cache002.htm#GKJDK)
        + [44.2.1.1 Cache Retrieval Mode](persistence-cache002.htm#GKJDR)
        + [44.2.1.2 Cache Store Mode](persistence-cache002.htm#GKJDD)
        + [44.2.1.3 Setting the Cache Retrieval or Store Mode](persistence-cache002.htm#GKJDS)
      * [44.2.2 Controlling the Second-Level Cache Programmatically](persistence-cache002.htm#GKJEB)
        + [44.2.2.1 Checking whether an Entity's Data Is Cached](persistence-cache002.htm#GKJDZ)
        + [44.2.2.2 Removing an Entity from the Cache](persistence-cache002.htm#GKJDQ)
        + [44.2.2.3 Removing All Data from the Cache](persistence-cache002.htm#GKJDA)
* [Part IX Messaging](partmessaging.htm#GFIRP3)
  + [45 Java Message Service Concepts](jms-concepts.htm#BNCDQ)
    - [45.1 Overview of the JMS API](jms-concepts001.htm#BNCDR)
      * [45.1.1 What Is Messaging?](jms-concepts001.htm#BNCDS)
      * [45.1.2 What Is the JMS API?](jms-concepts001.htm#BNCDT)
      * [45.1.3 When Can You Use the JMS API?](jms-concepts001.htm#BNCDU)
      * [45.1.4 How Does the JMS API Work with the Java EE Platform?](jms-concepts001.htm#BNCDW)
    - [45.2 Basic JMS API Concepts](jms-concepts002.htm#BNCDX)
      * [45.2.1 JMS API Architecture](jms-concepts002.htm#BNCDY)
      * [45.2.2 Messaging Styles](jms-concepts002.htm#BNCEA)
        + [45.2.2.1 Point-to-Point Messaging Style](jms-concepts002.htm#BNCEB)
        + [45.2.2.2 Publish/Subscribe Messaging Style](jms-concepts002.htm#BNCED)
      * [45.2.3 Message Consumption](jms-concepts002.htm#BNCEG)
    - [45.3 The JMS API Programming Model](jms-concepts003.htm#BNCEH)
      * [45.3.1 JMS Administered Objects](jms-concepts003.htm#BNCEJ)
        + [45.3.1.1 JMS Connection Factories](jms-concepts003.htm#BNCEK)
        + [45.3.1.2 JMS Destinations](jms-concepts003.htm#BNCEL)
      * [45.3.2 Connections](jms-concepts003.htm#BNCEM)
      * [45.3.3 Sessions](jms-concepts003.htm#BNCEN)
      * [45.3.4 JMSContext Objects](jms-concepts003.htm#BABGDFEA)
      * [45.3.5 JMS Message Producers](jms-concepts003.htm#BNCEO)
      * [45.3.6 JMS Message Consumers](jms-concepts003.htm#BNCEP)
        + [45.3.6.1 JMS Message Listeners](jms-concepts003.htm#BNCEQ)
        + [45.3.6.2 JMS Message Selectors](jms-concepts003.htm#BNCER)
        + [45.3.6.3 Consuming Messages from Topics](jms-concepts003.htm#BABEEJJJ)
        + [45.3.6.4 Creating Durable Subscriptions](jms-concepts003.htm#BNCGD)
        + [45.3.6.5 Creating Shared Subscriptions](jms-concepts003.htm#BABJCIGJ)
      * [45.3.7 JMS Messages](jms-concepts003.htm#BNCES)
        + [45.3.7.1 Message Headers](jms-concepts003.htm#BNCET)
        + [45.3.7.2 Message Properties](jms-concepts003.htm#BNCEV)
        + [45.3.7.3 Message Bodies](jms-concepts003.htm#BNCEW)
      * [45.3.8 JMS Queue Browsers](jms-concepts003.htm#BNCEY)
      * [45.3.9 JMS Exception Handling](jms-concepts003.htm#BNCEZ)
    - [45.4 Using Advanced JMS Features](jms-concepts004.htm#BNCFU)
      * [45.4.1 Controlling Message Acknowledgment](jms-concepts004.htm#BNCFW)
      * [45.4.2 Specifying Options for Sending Messages](jms-concepts004.htm#BNCFV)
        + [45.4.2.1 Specifying Message Persistence](jms-concepts004.htm#BNCFY)
        + [45.4.2.2 Setting Message Priority Levels](jms-concepts004.htm#BNCFZ)
        + [45.4.2.3 Allowing Messages to Expire](jms-concepts004.htm#BNCGA)
        + [45.4.2.4 Specifying a Delivery Delay](jms-concepts004.htm#BABGEADH)
        + [45.4.2.5 Using JMSProducer Method Chaining](jms-concepts004.htm#BABJFIAD)
      * [45.4.3 Creating Temporary Destinations](jms-concepts004.htm#BNCGB)
      * [45.4.4 Using JMS Local Transactions](jms-concepts004.htm#BNCGH)
      * [45.4.5 Sending Messages Asynchronously](jms-concepts004.htm#BABFIFAJ)
    - [45.5 Using the JMS API in Java EE Applications](jms-concepts005.htm#BNCGL)
      * [45.5.1 Creating Resources for Java EE Applications](jms-concepts005.htm#BABHFBDH)
      * [45.5.2 Using Resource Injection in Enterprise Bean or Web Components](jms-concepts005.htm#BNCGM)
        + [45.5.2.1 Injecting a ConnectionFactory, Queue, or Topic](jms-concepts005.htm#sthref2356)
        + [45.5.2.2 Injecting a JMSContext Object](jms-concepts005.htm#BABCJBEE)
      * [45.5.3 Using Java EE Components to Produce and to Synchronously Receive Messages](jms-concepts005.htm#BNCGN)
        + [45.5.3.1 Managing JMS Resources in Web and EJB Components](jms-concepts005.htm#BNCGO)
        + [45.5.3.2 Managing Transactions in Session Beans](jms-concepts005.htm#BNCGP)
      * [45.5.4 Using Message-Driven Beans to Receive Messages Asynchronously](jms-concepts005.htm#BNCGQ)
      * [45.5.5 Managing JTA Transactions](jms-concepts005.htm#BNCGS)
    - [45.6 Further Information about JMS](jms-concepts006.htm#BNCGU)
  + [46 Java Message Service Examples](jms-examples.htm#BNCGV)
    - [46.1 Overview of the JMS Examples](jms-examples001.htm#BABEFBHJ)
    - [46.2 Writing Simple JMS Applications](jms-examples002.htm#BNCFA)
      * [46.2.1 Starting the JMS Provider](jms-examples002.htm#BNCFD)
      * [46.2.2 Creating JMS Administered Objects](jms-examples002.htm#GKTJS)
        + [46.2.2.1 To Create Resources for the Simple Examples](jms-examples002.htm#BABHEFCB)
      * [46.2.3 Building All the Simple Examples](jms-examples002.htm#BABEEABE)
        + [46.2.3.1 To Build All the Simple Examples Using NetBeans IDE](jms-examples002.htm#sthref2386)
        + [46.2.3.2 To Build All the Simple Examples Using Maven](jms-examples002.htm#sthref2387)
      * [46.2.4 Sending Messages](jms-examples002.htm#BABIHCAE)
        + [46.2.4.1 The Producer.java Client](jms-examples002.htm#sthref2390)
        + [46.2.4.2 To Run the Producer Client](jms-examples002.htm#sthref2391)
      * [46.2.5 Receiving Messages Synchronously](jms-examples002.htm#BNCFB)
        + [46.2.5.1 The SynchConsumer.java Client](jms-examples002.htm#BNCFC)
        + [46.2.5.2 To Run the SynchConsumer and Producer Clients](jms-examples002.htm#BNCFG)
      * [46.2.6 Using a Message Listener for Asynchronous Message Delivery](jms-examples002.htm#BNCFH)
        + [46.2.6.1 Writing the AsynchConsumer.java and TextListener.java Clients](jms-examples002.htm#BNCFI)
        + [46.2.6.2 To Run the AsynchConsumer and Producer Clients](jms-examples002.htm#BNCFK)
      * [46.2.7 Browsing Messages on a Queue](jms-examples002.htm#BNCFL)
        + [46.2.7.1 The MessageBrowser.java Client](jms-examples002.htm#BNCFM)
        + [46.2.7.2 To Run the QueueBrowser Client](jms-examples002.htm#BNCFN)
      * [46.2.8 Running Multiple Consumers on the Same Destination](jms-examples002.htm#BABDDHHC)
      * [46.2.9 Acknowledging Messages](jms-examples002.htm#BNCFX)
        + [46.2.9.1 To Run the ClientAckConsumer Client](jms-examples002.htm#GJSCG)
    - [46.3 Writing More Advanced JMS Applications](jms-examples003.htm#GIWFH)
      * [46.3.1 Using Durable Subscriptions](jms-examples003.htm#BNCGG)
        + [46.3.1.1 To Create Resources for the Durable Subscription Example](jms-examples003.htm#sthref2410)
        + [46.3.1.2 To Run the Durable Subscription Example](jms-examples003.htm#GJSCI)
        + [46.3.1.3 To Run the unsubscriber Example](jms-examples003.htm#sthref2411)
      * [46.3.2 Using Local Transactions](jms-examples003.htm#BNCGJ)
        + [46.3.2.1 To Create Resources for the transactedexample Example](jms-examples003.htm#sthref2415)
        + [46.3.2.2 To Run the transactedexample Clients](jms-examples003.htm#GJSHA)
    - [46.4 Writing High Performance and Scalable JMS Applications](jms-examples004.htm#BABGEFHC)
      * [46.4.1 Using Shared Nondurable Subscriptions](jms-examples004.htm#BABIBEAC)
        + [46.4.1.1 Writing the Clients for the Shared Consumer Example](jms-examples004.htm#sthref2416)
        + [46.4.1.2 To Run the SharedConsumer and Producer Clients](jms-examples004.htm#sthref2417)
      * [46.4.2 Using Shared Durable Subscriptions](jms-examples004.htm#BABEJBHA)
        + [46.4.2.1 To Run the SharedDurableConsumer and Producer Clients](jms-examples004.htm#sthref2420)
    - [46.5 Sending and Receiving Messages Using a Simple Web Application](jms-examples005.htm#BABBABFC)
      * [46.5.1 The websimplemessage Facelets Pages](jms-examples005.htm#sthref2426)
      * [46.5.2 The websimplemessage Managed Beans](jms-examples005.htm#sthref2427)
      * [46.5.3 Running the websimplemessage Example](jms-examples005.htm#sthref2428)
        + [46.5.3.1 Creating Resources for the websimplemessage Example](jms-examples005.htm#sthref2429)
        + [46.5.3.2 To Package and Deploy websimplemessage Using NetBeans IDE](jms-examples005.htm#sthref2430)
        + [46.5.3.3 To Package and Deploy websimplemessage Using Maven](jms-examples005.htm#sthref2431)
        + [46.5.3.4 To Run the websimplemessage Example](jms-examples005.htm#sthref2432)
    - [46.6 Receiving Messages Asynchronously Using a Message-Driven Bean](jms-examples006.htm#BNBPK)
      * [46.6.1 Overview of the simplemessage Example](jms-examples006.htm#BNBPL)
      * [46.6.2 The simplemessage Application Client](jms-examples006.htm#BNBPN)
      * [46.6.3 The simplemessage Message-Driven Bean Class](jms-examples006.htm#BNBPO)
        + [46.6.3.1 The onMessage Method](jms-examples006.htm#BNBPP)
      * [46.6.4 Running the simplemessage Example](jms-examples006.htm#BNBPQ)
        + [46.6.4.1 Creating Resources for the simplemessage Example](jms-examples006.htm#BNBPR)
        + [46.6.4.2 To Run the simplemessage Example Using NetBeans IDE](jms-examples006.htm#sthref2449)
        + [46.6.4.3 To Run the simplemessage Example Using Maven](jms-examples006.htm#BNBPT)
    - [46.7 Sending Messages from a Session Bean to an MDB](jms-examples007.htm#BNCGW)
      * [46.7.1 Writing the Application Components for the clientsessionmdb Example](jms-examples007.htm#BNCGX)
        + [46.7.1.1 Coding the Application Client: MyAppClient.java](jms-examples007.htm#BNCGZ)
        + [46.7.1.2 Coding the Publisher Session Bean](jms-examples007.htm#BNCHA)
        + [46.7.1.3 Coding the Message-Driven Bean: MessageBean.java](jms-examples007.htm#BNCHB)
      * [46.7.2 Running the clientsessionmdb Example](jms-examples007.htm#sthref2458)
        + [46.7.2.1 To Run clientsessionmdb Using NetBeans IDE](jms-examples007.htm#sthref2459)
        + [46.7.2.2 To Run clientsessionmdb Using Maven](jms-examples007.htm#sthref2460)
    - [46.8 Using an Entity to Join Messages from Two MDBs](jms-examples008.htm#BNCHF)
      * [46.8.1 Overview of the clientmdbentity Example Application](jms-examples008.htm#BNCHG)
      * [46.8.2 Writing the Application Components for the clientmdbentity Example](jms-examples008.htm#BNCHI)
        + [46.8.2.1 Coding the Application Client: HumanResourceClient.java](jms-examples008.htm#BNCHJ)
        + [46.8.2.2 Coding the Message-Driven Beans for the clientmdbentity Example](jms-examples008.htm#BNCHK)
        + [46.8.2.3 Coding the Entity Class for the clientmdbentity Example](jms-examples008.htm#BNCHL)
      * [46.8.3 Running the clientmdbentity Example](jms-examples008.htm#sthref2471)
        + [46.8.3.1 To Run clientmdbentity Using NetBeans IDE](jms-examples008.htm#sthref2472)
        + [46.8.3.2 To Run clientmdbentity Using Maven](jms-examples008.htm#sthref2473)
        + [46.8.3.3 Viewing the Application Output](jms-examples008.htm#sthref2474)
    - [46.9 Using NetBeans IDE to Create JMS Resources](jms-examples009.htm#BABDFDJC)
      * [46.9.1 To Create JMS Resources Using NetBeans IDE](jms-examples009.htm#sthref2475)
      * [46.9.2 To Delete JMS Resources Using NetBeans IDE](jms-examples009.htm#sthref2480)
* [Part X Security](partsecurity.htm#GIJRP)
  + [47 Introduction to Security in the Java EE Platform](security-intro.htm#BNBWJ)
    - [47.1 Overview of Java EE Security](security-intro001.htm#BNBWK)
      * [47.1.1 A Simple Application Security Walkthrough](security-intro001.htm#BNBWL)
        + [47.1.1.1 Step 1: Initial Request](security-intro001.htm#BNBWM)
        + [47.1.1.2 Step 2: Initial Authentication](security-intro001.htm#BNBWO)
        + [47.1.1.3 Step 3: URL Authorization](security-intro001.htm#BNBWQ)
        + [47.1.1.4 Step 4: Fulfilling the Original Request](security-intro001.htm#BNBWS)
        + [47.1.1.5 Step 5: Invoking Enterprise Bean Business Methods](security-intro001.htm#BNBWU)
      * [47.1.2 Features of a Security Mechanism](security-intro001.htm#BNBWW)
      * [47.1.3 Characteristics of Application Security](security-intro001.htm#BNBWX)
    - [47.2 Security Mechanisms](security-intro002.htm#BNBWY)
      * [47.2.1 Java SE Security Mechanisms](security-intro002.htm#BNBWZ)
      * [47.2.2 Java EE Security Mechanisms](security-intro002.htm#BNBXA)
        + [47.2.2.1 Application-Layer Security](security-intro002.htm#BNBXB)
        + [47.2.2.2 Transport-Layer Security](security-intro002.htm#BNBXC)
        + [47.2.2.3 Message-Layer Security](security-intro002.htm#BNBXD)
    - [47.3 Securing Containers](security-intro003.htm#BNBXE)
      * [47.3.1 Using Annotations to Specify Security Information](security-intro003.htm#BNBXG)
      * [47.3.2 Using Deployment Descriptors for Declarative Security](security-intro003.htm#BNBXF)
      * [47.3.3 Using Programmatic Security](security-intro003.htm#BNBXH)
    - [47.4 Securing GlassFish Server](security-intro004.htm#BNBXI)
    - [47.5 Working with Realms, Users, Groups, and Roles](security-intro005.htm#BNBXJ)
      * [47.5.1 What Are Realms, Users, Groups, and Roles?](security-intro005.htm#BNBXK)
        + [47.5.1.1 What Is a Realm?](security-intro005.htm#BNBXM)
        + [47.5.1.2 What Is a User?](security-intro005.htm#BNBXN)
        + [47.5.1.3 What Is a Group?](security-intro005.htm#BNBXO)
        + [47.5.1.4 What Is a Role?](security-intro005.htm#BNBXP)
        + [47.5.1.5 Some Other Terminology](security-intro005.htm#BNBXQ)
      * [47.5.2 Managing Users and Groups in GlassFish Server](security-intro005.htm#BNBXR)
        + [47.5.2.1 To Add Users to GlassFish Server](security-intro005.htm#BNBXS)
      * [47.5.3 Setting Up Security Roles](security-intro005.htm#BNBXU)
      * [47.5.4 Mapping Roles to Users and Groups](security-intro005.htm#BNBXV)
    - [47.6 Establishing a Secure Connection Using SSL](security-intro006.htm#BNBXW)
      * [47.6.1 Verifying and Configuring SSL Support](security-intro006.htm#BNBXX)
    - [47.7 Further Information about Security](security-intro007.htm#BNBYJ)
  + [48 Getting Started Securing Web Applications](security-webtier.htm#BNCAS)
    - [48.1 Overview of Web Application Security](security-webtier001.htm#BNCAT)
    - [48.2 Securing Web Applications](security-webtier002.htm#GKBAA)
      * [48.2.1 Specifying Security Constraints](security-webtier002.htm#BNCBK)
        + [48.2.1.1 Specifying a Web Resource Collection](security-webtier002.htm#GJJCD)
        + [48.2.1.2 Specifying an Authorization Constraint](security-webtier002.htm#GJJCG)
        + [48.2.1.3 Specifying a Secure Connection](security-webtier002.htm#BNCBM)
        + [48.2.1.4 Specifying Security Constraints for Resources](security-webtier002.htm#BNCBL)
      * [48.2.2 Specifying Authentication Mechanisms](security-webtier002.htm#GKBSA)
        + [48.2.2.1 HTTP Basic Authentication](security-webtier002.htm#BNCBO)
        + [48.2.2.2 Form-Based Authentication](security-webtier002.htm#BNCBQ)
        + [48.2.2.3 Digest Authentication](security-webtier002.htm#BNCBW)
      * [48.2.3 Specifying an Authentication Mechanism in the Deployment Descriptor](security-webtier002.htm#BNCBN)
      * [48.2.4 Declaring Security Roles](security-webtier002.htm#BNCAV)
    - [48.3 Using Programmatic Security with Web Applications](security-webtier003.htm#GJIIE)
      * [48.3.1 Authenticating Users Programmatically](security-webtier003.htm#GIRCJ)
      * [48.3.2 Checking Caller Identity Programmatically](security-webtier003.htm#BNCBA)
      * [48.3.3 Example Code for Programmatic Security](security-webtier003.htm#GJJLQ)
      * [48.3.4 Declaring and Linking Role References](security-webtier003.htm#BNCBB)
    - [48.4 Examples: Securing Web Applications](security-webtier004.htm#BNCBX)
      * [48.4.1 To Set Up Your System for Running the Security Examples](security-webtier004.htm#GJJLK)
      * [48.4.2 The hello2-basicauth Example: Basic Authentication with a Servlet](security-webtier004.htm#BNCCK)
        + [48.4.2.1 Specifying Security for Basic Authentication Using Annotations](security-webtier004.htm#GJRMH)
        + [48.4.2.2 To Build, Package, and Deploy the hello2-basicauth Example Using NetBeans IDE](security-webtier004.htm#GJQYS)
        + [48.4.2.3 To Build, Package, and Deploy the hello2-basicauth Example Using Maven](security-webtier004.htm#GJQZH)
        + [48.4.2.4 To Run the hello2-basicauth Example](security-webtier004.htm#GJQZF)
      * [48.4.3 The hello1-formauth Example: Form-Based Authentication with a JavaServer Faces Application](security-webtier004.htm#BNCBY)
        + [48.4.3.1 Creating the Login Form and the Error Page](security-webtier004.htm#BNCCA)
        + [48.4.3.2 Specifying Security for the Form-Based Authentication Example](security-webtier004.htm#BNCCB)
        + [48.4.3.3 To Build, Package, and Deploy the hello1-formauth Example Using NetBeans IDE](security-webtier004.htm#GJRBA)
        + [48.4.3.4 To Build, Package, and Deploy the hello1-formauth Example Using Maven and the asadmin Command](security-webtier004.htm#GJRAZ)
        + [48.4.3.5 To Run the hello1-formauth Example](security-webtier004.htm#GJRAL)
  + [49 Getting Started Securing Enterprise Applications](security-javaee.htm#BNBYK)
    - [49.1 Basic Security Tasks for Enterprise Applications](security-javaee001.htm#CACGIFHJ)
    - [49.2 Securing Enterprise Beans](security-javaee002.htm#BNBYL)
      * [49.2.1 Securing an Enterprise Bean Using Declarative Security](security-javaee002.htm#GJGDI)
        + [49.2.1.1 Specifying Authorized Users by Declaring Security Roles](security-javaee002.htm#GJGCQ)
        + [49.2.1.2 Specifying an Authentication Mechanism and Secure Connection](security-javaee002.htm#BNBYU)
      * [49.2.2 Securing an Enterprise Bean Programmatically](security-javaee002.htm#GJGCS)
        + [49.2.2.1 Accessing an Enterprise Bean Caller's Security Context](security-javaee002.htm#GJGCR)
      * [49.2.3 Propagating a Security Identity (Run-As)](security-javaee002.htm#BNBYR)
        + [49.2.3.1 Configuring a Component's Propagated Security Identity](security-javaee002.htm#BNBZB)
        + [49.2.3.2 Trust between Containers](security-javaee002.htm#BNBZC)
      * [49.2.4 Deploying Secure Enterprise Beans](security-javaee002.htm#BNBZG)
    - [49.3 Examples: Securing Enterprise Beans](security-javaee003.htm#GKBSZ)
      * [49.3.1 The cart-secure Example: Securing an Enterprise Bean with Declarative Security](security-javaee003.htm#BNBZK)
        + [49.3.1.1 Annotating the Bean](security-javaee003.htm#BNBZL)
        + [49.3.1.2 To Run the cart-secure Example Using NetBeans IDE](security-javaee003.htm#BNBZN)
        + [49.3.1.3 To Run the cart-secure Example Using Maven](security-javaee003.htm#BNBZO)
      * [49.3.2 The converter-secure Example: Securing an Enterprise Bean with Programmatic Security](security-javaee003.htm#BNCAA)
        + [49.3.2.1 Modifying ConverterBean](security-javaee003.htm#BNCAB)
        + [49.3.2.2 Modifying ConverterServlet](security-javaee003.htm#GKBSI)
        + [49.3.2.3 To Run the converter-secure Example Using NetBeans IDE](security-javaee003.htm#BNCAD)
        + [49.3.2.4 To Run the converter-secure Example Using Maven](security-javaee003.htm#BNCAE)
        + [49.3.2.5 To Run the converter-secure Example](security-javaee003.htm#GJTDP)
  + [50 Java EE Security: Advanced Topics](security-advanced.htm#GJJWX)
    - [50.1 Working with Digital Certificates](security-advanced001.htm#BNBYB)
      * [50.1.1 Creating a Server Certificate](security-advanced001.htm#BNBYC)
        + [50.1.1.1 To Use keytool to Create a Server Certificate](security-advanced001.htm#GJRGY)
      * [50.1.2 Adding Users to the Certificate Realm](security-advanced001.htm#GLIFW)
      * [50.1.3 Using a Different Server Certificate with GlassFish Server](security-advanced001.htm#BNBYF)
        + [50.1.3.1 To Specify a Different Server Certificate](security-advanced001.htm#sthref2752)
    - [50.2 Authentication Mechanisms](security-advanced002.htm#GLIEN)
      * [50.2.1 Client Authentication](security-advanced002.htm#GLIEQ)
      * [50.2.2 Mutual Authentication](security-advanced002.htm#GLIEL)
        + [50.2.2.1 Enabling Mutual Authentication over SSL](security-advanced002.htm#BNBYH)
        + [50.2.2.2 Creating a Client Certificate for Mutual Authentication](security-advanced002.htm#BNBYI)
    - [50.3 Using the JDBC Realm for User Authentication](security-advanced003.htm#BABEJJDE)
      * [50.3.1 To Configure a JDBC Authentication Realm](security-advanced003.htm#sthref2774)
    - [50.4 Securing HTTP Resources](security-advanced004.htm#BABGEJJJ)
    - [50.5 Securing Application Clients](security-advanced005.htm#GLIGC)
      * [50.5.1 Using Login Modules](security-advanced005.htm#GLIDW)
      * [50.5.2 Using Programmatic Login](security-advanced005.htm#GLIHQ)
    - [50.6 Securing Enterprise Information Systems Applications](security-advanced006.htm#GLIFD)
      * [50.6.1 Container-Managed Sign-On](security-advanced006.htm#GLIHL)
      * [50.6.2 Component-Managed Sign-On](security-advanced006.htm#GLIDP)
      * [50.6.3 Configuring Resource Adapter Security](security-advanced006.htm#GLIGS)
      * [50.6.4 Mapping an Application Principal to EIS Principals](security-advanced006.htm#GLIGW)
    - [50.7 Configuring Security Using Deployment Descriptors](security-advanced007.htm#GKHRL)
      * [50.7.1 Specifying Security for Basic Authentication in the Deployment Descriptor](security-advanced007.htm#BNCCM)
      * [50.7.2 Specifying Non-Default Principal-to-Role Mapping in the Deployment Descriptor](security-advanced007.htm#GKAFQ)
    - [50.8 Further Information about Advanced Security Topics](security-advanced008.htm#BABBGBBF)
* [Part XI Java EE Supporting Technologies](partsupporttechs.htm#GIJUE)
  + [51 Transactions](transactions.htm#BNCIH)
    - [51.1 Transactions in Java EE Applications](transactions001.htm#GIJRG)
    - [51.2 What Is a Transaction?](transactions002.htm#BNCII)
    - [51.3 Container-Managed Transactions](transactions003.htm#BNCIJ)
      * [51.3.1 Transaction Attributes](transactions003.htm#BNCIK)
        + [51.3.1.1 Required Attribute](transactions003.htm#BNCIM)
        + [51.3.1.2 RequiresNew Attribute](transactions003.htm#BNCIN)
        + [51.3.1.3 Mandatory Attribute](transactions003.htm#BNCIO)
        + [51.3.1.4 NotSupported Attribute](transactions003.htm#BNCIP)
        + [51.3.1.5 Supports Attribute](transactions003.htm#BNCIQ)
        + [51.3.1.6 Never Attribute](transactions003.htm#BNCIR)
        + [51.3.1.7 Summary of Transaction Attributes](transactions003.htm#BNCIS)
        + [51.3.1.8 Setting Transaction Attributes](transactions003.htm#BNCIU)
      * [51.3.2 Rolling Back a Container-Managed Transaction](transactions003.htm#BNCIV)
      * [51.3.3 Synchronizing a Session Bean's Instance Variables](transactions003.htm#BNCIW)
      * [51.3.4 Methods Not Allowed in Container-Managed Transactions](transactions003.htm#BNCIX)
    - [51.4 Bean-Managed Transactions](transactions004.htm#BNCIY)
      * [51.4.1 JTA Transactions](transactions004.htm#BNCIZ)
      * [51.4.2 Returning without Committing](transactions004.htm#BNCJA)
      * [51.4.3 Methods Not Allowed in Bean-Managed Transactions](transactions004.htm#BNCJB)
    - [51.5 Transaction Timeouts](transactions005.htm#BNCJC)
      * [51.5.1 To Set a Transaction Timeout](transactions005.htm#sthref2874)
    - [51.6 Updating Multiple Databases](transactions006.htm#BNCJD)
    - [51.7 Transactions in Web Components](transactions007.htm#BNCJG)
    - [51.8 Further Information about Transactions](transactions008.htm#GKCMI)
  + [52 Resource Adapters and Contracts](resources.htm#BNCJH)
    - [52.1 What Is a Resource Adapter?](resources001.htm#GIPGL)
      * [52.1.1 Management Contracts](resources001.htm#GIPGY)
        + [52.1.1.1 Lifecycle Management](resources001.htm#GIPHT)
        + [52.1.1.2 Work Management Contract](resources001.htm#GIPIG)
      * [52.1.2 Generic Work Context Contract](resources001.htm#GIPMK)
      * [52.1.3 Outbound and Inbound Contracts](resources001.htm#GKCKI)
    - [52.2 Metadata Annotations](resources002.htm#GIRDD)
    - [52.3 Common Client Interface](resources003.htm#GIPJU)
    - [52.4 Using Resource Adapters with Contexts and Dependency Injection for Java EE (CDI)](resources004.htm#CHDJFIGB)
    - [52.5 Further Information about Resource Adapters](resources005.htm#BNCJW)
  + [53 The Resource Adapter Examples](connectorexample.htm#GLODB)
    - [53.1 The trading Example](connectorexample001.htm#CHDFHAID)
      * [53.1.1 Using the Outbound Resource Adapter](connectorexample001.htm#CHDFADJD)
      * [53.1.2 Implementing the Outbound Resource Adapter](connectorexample001.htm#sthref2899)
      * [53.1.3 Running the trading Example](connectorexample001.htm#sthref2902)
        + [53.1.3.1 To Run the trading Example Using NetBeans IDE](connectorexample001.htm#sthref2903)
        + [53.1.3.2 To Run the trading Example Using Maven](connectorexample001.htm#sthref2904)
    - [53.2 The traffic Example](connectorexample002.htm#CHDJEADB)
      * [53.2.1 Using the Inbound Resource Adapter](connectorexample002.htm#sthref2906)
      * [53.2.2 Implementing the Inbound Resource Adapter](connectorexample002.htm#sthref2907)
      * [53.2.3 Running the traffic Example](connectorexample002.htm#sthref2910)
        + [53.2.3.1 To Run the traffic Example Using NetBeans IDE](connectorexample002.htm#sthref2911)
        + [53.2.3.2 To Run the traffic Example Using Maven](connectorexample002.htm#sthref2912)
  + [54 Using Java EE Interceptors](interceptors.htm#GKEED)
    - [54.1 Overview of Interceptors](interceptors001.htm#GKIGQ)
      * [54.1.1 Interceptor Classes](interceptors001.htm#GKECK)
      * [54.1.2 Interceptor Lifecycle](interceptors001.htm#GKEDY)
      * [54.1.3 Interceptors and CDI](interceptors001.htm#GKHSN)
    - [54.2 Using Interceptors](interceptors002.htm#GKEDM)
      * [54.2.1 Intercepting Method Invocations](interceptors002.htm#GKECY)
        + [54.2.1.1 Using Multiple Method Interceptors](interceptors002.htm#GKHMH)
        + [54.2.1.2 Accessing Target Method Parameters from an Interceptor Class](interceptors002.htm#GKHOV)
      * [54.2.2 Intercepting Lifecycle Callback Events](interceptors002.htm#GKECR)
        + [54.2.2.1 Using AroundConstruct Interceptor Methods](interceptors002.htm#sthref2927)
        + [54.2.2.2 Using Multiple Lifecycle Callback Interceptors](interceptors002.htm#GKHNI)
      * [54.2.3 Intercepting Timeout Events](interceptors002.htm#GKEDU)
        + [54.2.3.1 Using Multiple Timeout Interceptors](interceptors002.htm#GKHLA)
      * [54.2.4 Binding Interceptors to Components](interceptors002.htm#sthref2928)
        + [54.2.4.1 Declaring the Interceptor Bindings on an Interceptor Class](interceptors002.htm#sthref2929)
        + [54.2.4.2 Binding a Component to an Interceptor](interceptors002.htm#sthref2930)
      * [54.2.5 Ordering Interceptors](interceptors002.htm#sthref2931)
    - [54.3 The interceptor Example Application](interceptors003.htm#GKECI)
      * [54.3.1 Running the interceptor Example](interceptors003.htm#sthref2938)
        + [54.3.1.1 To Run the interceptor Example Using NetBeans IDE](interceptors003.htm#GKEDF)
        + [54.3.1.2 To Run the interceptor Example Using Maven](interceptors003.htm#GKECT)
  + [55 Batch Processing](batch-processing.htm#GKJIQ6)
    - [55.1 Introduction to Batch Processing](batch-processing001.htm#BCGJDEEH)
      * [55.1.1 Steps in Batch Jobs](batch-processing001.htm#sthref2943)
      * [55.1.2 Parallel Processing](batch-processing001.htm#sthref2946)
      * [55.1.3 Status and Decision Elements](batch-processing001.htm#sthref2947)
      * [55.1.4 Batch Framework Functionality](batch-processing001.htm#sthref2950)
    - [55.2 Batch Processing in Java EE](batch-processing002.htm#BCGGIBHA)
      * [55.2.1 The Batch Processing Framework](batch-processing002.htm#sthref2952)
      * [55.2.2 Creating Batch Applications](batch-processing002.htm#sthref2954)
      * [55.2.3 Elements of a Batch Job](batch-processing002.htm#sthref2956)
      * [55.2.4 Properties and Parameters](batch-processing002.htm#sthref2958)
      * [55.2.5 Job Instances and Job Executions](batch-processing002.htm#sthref2960)
      * [55.2.6 Batch and Exit Status](batch-processing002.htm#sthref2962)
    - [55.3 Simple Use Case](batch-processing003.htm#BCGHBJIG)
      * [55.3.1 Chunk Step](batch-processing003.htm#sthref2967)
      * [55.3.2 Task Step](batch-processing003.htm#sthref2969)
    - [55.4 Using the Job Specification Language](batch-processing004.htm#BCGDDBBG)
      * [55.4.1 The job Element](batch-processing004.htm#sthref2973)
      * [55.4.2 The step Element](batch-processing004.htm#sthref2975)
        + [55.4.2.1 The chunk Element](batch-processing004.htm#sthref2977)
        + [55.4.2.2 The batchlet Element](batch-processing004.htm#sthref2980)
        + [55.4.2.3 The partition Element](batch-processing004.htm#sthref2982)
      * [55.4.3 The flow Element](batch-processing004.htm#sthref2984)
      * [55.4.4 The split Element](batch-processing004.htm#sthref2986)
      * [55.4.5 The decision Element](batch-processing004.htm#sthref2988)
    - [55.5 Creating Batch Artifacts](batch-processing005.htm#BCGHDHGH)
      * [55.5.1 Batch Artifact Interfaces](batch-processing005.htm#sthref2991)
      * [55.5.2 Dependency Injection in Batch Artifacts](batch-processing005.htm#BCGIFJBB)
      * [55.5.3 Using the Context Objects from the Batch Runtime](batch-processing005.htm#BCGCJEEF)
    - [55.6 Submitting Jobs to the Batch Runtime](batch-processing006.htm#BCGCAHCB)
      * [55.6.1 Starting a Job](batch-processing006.htm#sthref2998)
      * [55.6.2 Checking the Status of a Job](batch-processing006.htm#BCGIBGFC)
      * [55.6.3 Invoking the Batch Runtime in Your Application](batch-processing006.htm#sthref3001)
    - [55.7 Packaging Batch Applications](batch-processing007.htm#BCGBBGJI)
    - [55.8 The webserverlog Example Application](batch-processing008.htm#BCGJHEHJ)
      * [55.8.1 Architecture of the webserverlog Example Application](batch-processing008.htm#sthref3005)
        + [55.8.1.1 The Job Definition File](batch-processing008.htm#sthref3006)
        + [55.8.1.2 The LogLine and LogFilteredLine Items](batch-processing008.htm#sthref3007)
        + [55.8.1.3 The Chunk Step Batch Artifacts](batch-processing008.htm#sthref3008)
        + [55.8.1.4 The Listener Batch Artifacts](batch-processing008.htm#BCGCCFAC)
        + [55.8.1.5 The Task Step Batch Artifact](batch-processing008.htm#sthref3009)
        + [55.8.1.6 The JavaServer Faces Pages](batch-processing008.htm#sthref3010)
        + [55.8.1.7 The Managed Bean](batch-processing008.htm#sthref3011)
      * [55.8.2 Running the webserverlog Example Application](batch-processing008.htm#sthref3012)
        + [55.8.2.1 To Run the webserverlog Example Application Using NetBeans IDE](batch-processing008.htm#sthref3013)
        + [55.8.2.2 To Run the webserverlog Example Application Using Maven](batch-processing008.htm#sthref3014)
    - [55.9 The phonebilling Example Application](batch-processing009.htm#BCGFCACD)
      * [55.9.1 Architecture of the phonebilling Example Application](batch-processing009.htm#sthref3017)
        + [55.9.1.1 The Job Definition File](batch-processing009.htm#sthref3018)
        + [55.9.1.2 The CallRecord and PhoneBill Entities](batch-processing009.htm#sthref3019)
        + [55.9.1.3 The Call Records Chunk Step](batch-processing009.htm#sthref3020)
        + [55.9.1.4 The Phone Billing Chunk Step](batch-processing009.htm#BCGGGAHB)
        + [55.9.1.5 The JavaServer Faces Pages](batch-processing009.htm#sthref3021)
        + [55.9.1.6 The Managed Bean](batch-processing009.htm#sthref3022)
      * [55.9.2 Running the phonebilling Example Application](batch-processing009.htm#sthref3023)
        + [55.9.2.1 To Run the phonebilling Example Application Using NetBeans IDE](batch-processing009.htm#sthref3024)
        + [55.9.2.2 To Run the phonebilling Example Application Using Maven](batch-processing009.htm#sthref3025)
    - [55.10 Further Information about Batch Processing](batch-processing010.htm#BCGHCHAJ)
  + [56 Concurrency Utilities for Java EE](concurrency-utilities.htm#GKJIQ8)
    - [56.1 Concurrency Basics](concurrency-utilities001.htm#CIHDFGGG)
      * [56.1.1 Threads and Processes](concurrency-utilities001.htm#sthref3028)
    - [56.2 Main Components of the Concurrency Utilities](concurrency-utilities002.htm#CIHFBCFH)
    - [56.3 Concurrency and Transactions](concurrency-utilities003.htm#CIHIDBDG)
    - [56.4 Concurrency and Security](concurrency-utilities004.htm#CIHCACAA)
    - [56.5 The jobs Concurrency Example](concurrency-utilities005.htm#CIHCGGEG)
      * [56.5.1 Running the jobs Example](concurrency-utilities005.htm#sthref3040)
        + [56.5.1.1 To Configure GlassFish Server for the Basic Concurrency Example](concurrency-utilities005.htm#sthref3041)
        + [56.5.1.2 To Build, Package, and Deploy the jobs Example Using NetBeans IDE](concurrency-utilities005.htm#sthref3042)
        + [56.5.1.3 To Build, Package, and Deploy the jobs Example Using Maven](concurrency-utilities005.htm#sthref3043)
        + [56.5.1.4 To Run the jobs Example and Submit Jobs with Low Priority](concurrency-utilities005.htm#sthref3044)
        + [56.5.1.5 To Run the jobs Example and Submit Jobs with High Priority](concurrency-utilities005.htm#sthref3045)
    - [56.6 The taskcreator Concurrency Example](concurrency-utilities006.htm#CIHBFEAE)
      * [56.6.1 Running the taskcreator Example](concurrency-utilities006.htm#sthref3049)
        + [56.6.1.1 To Build, Package, and Deploy the taskcreator Example Using NetBeans IDE](concurrency-utilities006.htm#sthref3050)
        + [56.6.1.2 To Build, Package, and Deploy the taskcreator Example Using Maven](concurrency-utilities006.htm#sthref3051)
        + [56.6.1.3 To Run the taskcreator Example](concurrency-utilities006.htm#sthref3052)
    - [56.7 Further Information about the Concurrency Utilities](concurrency-utilities007.htm#CHDBIHAA)
* [Part XII Case Studies](partcasestudies.htm#GKGJW)
  + [57 Duke's Bookstore Case Study Example](dukes-bookstore.htm#GLNVI)
    - [57.1 Design and Architecture of Duke's Bookstore](dukes-bookstore001.htm#GLOAW)
    - [57.2 The Duke's Bookstore Interface](dukes-bookstore002.htm#GLQFD)
      * [57.2.1 The Book Java Persistence API Entity](dukes-bookstore002.htm#GLQER)
      * [57.2.2 Enterprise Beans Used in Duke's Bookstore](dukes-bookstore002.htm#GLQEU)
      * [57.2.3 Facelets Pages and Managed Beans Used in Duke's Bookstore](dukes-bookstore002.htm#GLQDP)
      * [57.2.4 Custom Components and Other Custom Objects Used in Duke's Bookstore](dukes-bookstore002.htm#GLQDX)
      * [57.2.5 Properties Files Used in Duke's Bookstore](dukes-bookstore002.htm#GLQDG)
      * [57.2.6 Deployment Descriptors Used in Duke's Bookstore](dukes-bookstore002.htm#GLQED)
    - [57.3 Running the Duke's Bookstore Case Study Application](dukes-bookstore003.htm#GLPPQ)
      * [57.3.1 To Build and Deploy Duke's Bookstore Using NetBeans IDE](dukes-bookstore003.htm#GLPQG)
      * [57.3.2 To Build and Deploy Duke's Bookstore Using Maven](dukes-bookstore003.htm#GLPQN)
      * [57.3.3 To Run Duke's Bookstore](dukes-bookstore003.htm#sthref3054)
  + [58 Duke's Tutoring Case Study Example](dukes-tutoring.htm#GKAEE)
    - [58.1 Design and Architecture of Duke's Tutoring](dukes-tutoring001.htm#GKAEI)
    - [58.2 Main Interface](dukes-tutoring002.htm#GKAFH)
      * [58.2.1 Java Persistence API Entities Used in the Main Interface](dukes-tutoring002.htm#GKAFJ)
      * [58.2.2 Enterprise Beans Used in the Main Interface](dukes-tutoring002.htm#GKAFC)
      * [58.2.3 WebSocket Endpoint Used in the Main Interface](dukes-tutoring002.htm#sthref3063)
      * [58.2.4 Facelets Files Used in the Main Interface](dukes-tutoring002.htm#GKAET)
      * [58.2.5 Helper Classes Used in the Main Interface](dukes-tutoring002.htm#GKADH)
      * [58.2.6 Properties Files](dukes-tutoring002.htm#GKADA)
      * [58.2.7 Deployment Descriptors Used in Duke's Tutoring](dukes-tutoring002.htm#GKAEV)
    - [58.3 Administration Interface](dukes-tutoring003.htm#GKAFW)
      * [58.3.1 Enterprise Beans Used in the Administration Interface](dukes-tutoring003.htm#GKAEN)
      * [58.3.2 Facelets Files Used in the Administration Interface](dukes-tutoring003.htm#GKACB)
      * [58.3.3 CDI Managed Beans Used in the Administration Interface](dukes-tutoring003.htm#sthref3067)
      * [58.3.4 Helper Classes Used in the Administration Interface](dukes-tutoring003.htm#sthref3068)
    - [58.4 Running the Duke's Tutoring Case Study Application](dukes-tutoring004.htm#GKJNN)
      * [58.4.1 Running Duke's Tutoring](dukes-tutoring004.htm#GKJOA)
        + [58.4.1.1 To Build and Deploy Duke's Tutoring Using NetBeans IDE](dukes-tutoring004.htm#GKJNR)
        + [58.4.1.2 To Build and Deploy Duke's Tutoring Using Maven](dukes-tutoring004.htm#GKJOG)
        + [58.4.1.3 Using Duke's Tutoring](dukes-tutoring004.htm#GKJOC)
  + [59 Duke's Forest Case Study Example](dukes-forest.htm#GLNPW)
    - [59.1 Design and Architecture of Duke's Forest](dukes-forest001.htm#GLNRJ)
      * [59.1.1 The events Project](dukes-forest001.htm#CIHHJEGA)
      * [59.1.2 The entities Project](dukes-forest001.htm#CIHFCIAC)
      * [59.1.3 The dukes-payment Project](dukes-forest001.htm#sthref3074)
      * [59.1.4 The dukes-resources Project](dukes-forest001.htm#sthref3075)
      * [59.1.5 The Duke's Store Project](dukes-forest001.htm#sthref3076)
        + [59.1.5.1 Enterprise Beans Used in Duke's Store](dukes-forest001.htm#sthref3077)
        + [59.1.5.2 Facelets Files Used in the Main Interface of Duke's Store](dukes-forest001.htm#sthref3078)
        + [59.1.5.3 Facelets Files Used in the Administration Interface of Duke's Store](dukes-forest001.htm#CIHHDHIH)
        + [59.1.5.4 Managed Beans Used in Duke's Store](dukes-forest001.htm#sthref3079)
        + [59.1.5.5 Helper Classes Used in Duke's Store](dukes-forest001.htm#sthref3080)
        + [59.1.5.6 Qualifiers Used in Duke's Store](dukes-forest001.htm#CIHEBAFD)
        + [59.1.5.7 Event Handlers Used in Duke's Store](dukes-forest001.htm#sthref3081)
        + [59.1.5.8 Deployment Descriptors Used in Duke's Store](dukes-forest001.htm#sthref3082)
      * [59.1.6 The Duke's Shipment Project](dukes-forest001.htm#sthref3083)
        + [59.1.6.1 Enterprise Beans Used in Duke's Shipment](dukes-forest001.htm#sthref3084)
        + [59.1.6.2 Facelets Files Used in Duke's Shipment](dukes-forest001.htm#sthref3085)
        + [59.1.6.3 Managed Beans Used in Duke's Shipment](dukes-forest001.htm#sthref3086)
        + [59.1.6.4 Helper Class Used in Duke's Shipment](dukes-forest001.htm#sthref3087)
        + [59.1.6.5 Qualifier Used in Duke's Shipment](dukes-forest001.htm#sthref3088)
        + [59.1.6.6 Deployment Descriptors Used in Duke's Shipment](dukes-forest001.htm#sthref3089)
    - [59.2 Building and Deploying the Duke's Forest Case Study Application](dukes-forest002.htm#GLNQP)
      * [59.2.1 To Build and Deploy the Duke's Forest Application Using NetBeans IDE](dukes-forest002.htm#sthref3090)
      * [59.2.2 To Build and Deploy the Duke's Forest Application Using Maven](dukes-forest002.htm#sthref3091)
    - [59.3 Running the Duke's Forest Application](dukes-forest003.htm#GLNSX)
      * [59.3.1 To Register as a Duke's Store Customer](dukes-forest003.htm#sthref3092)
      * [59.3.2 To Purchase Products](dukes-forest003.htm#sthref3093)
      * [59.3.3 To Approve Shipment of a Product](dukes-forest003.htm#sthref3094)
      * [59.3.4 To Create a New Product](dukes-forest003.htm#sthref3095)

[Previous Page](jsf-facelets009.htm "Previous Page")[Top of Page](#top "Top of Page")[Next Page](jsf-el001.htm "Next Page")

[Tweet](https://twitter.com/share)

Copyright © 2014, Oracle and/or its affiliates. All rights reserved. [Legal Notices](../assets/cpyr.htm)



=== Content from github.com_e73d0806_20250110_200000.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2F28479f743a9d0aab6d0e963fc07f3dd98e8c8236)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2F28479f743a9d0aab6d0e963fc07f3dd98e8c8236)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=dropwizard%2Fdropwizard)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dropwizard](/dropwizard)
/
**[dropwizard](/dropwizard/dropwizard)**
Public

* [Notifications](/login?return_to=%2Fdropwizard%2Fdropwizard) You must be signed in to change notification settings
* [Fork
  3.4k](/login?return_to=%2Fdropwizard%2Fdropwizard)
* [Star
   8.5k](/login?return_to=%2Fdropwizard%2Fdropwizard)

* [Code](/dropwizard/dropwizard)
* [Issues
  10](/dropwizard/dropwizard/issues)
* [Pull requests
  5](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

Additional navigation options

* [Code](/dropwizard/dropwizard)
* [Issues](/dropwizard/dropwizard/issues)
* [Pull requests](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

## Commit

[Permalink](/dropwizard/dropwizard/commit/28479f743a9d0aab6d0e963fc07f3dd98e8c8236)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Escape EL expressions in ViolationCollector ([#3160](https://github.com/dropwizard/dropwizard/pull/3160))

[Browse files](/dropwizard/dropwizard/tree/28479f743a9d0aab6d0e963fc07f3dd98e8c8236)
Browse the repository at this point in the history

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
(cherry picked from commit [d87d1e4](https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634))
```

* Loading branch information

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

[joschi](/dropwizard/dropwizard/commits?author=joschi "View all commits by joschi")
authored
Feb 20, 2020

1 parent
[809f31c](/dropwizard/dropwizard/commit/809f31c02f81031c0161a73e9cda860a1e21cc56)

commit 28479f7

 Show file tree

 Hide file tree

Showing
**2 changed files**
with
**124 additions**
and
**21 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* dropwizard-validation/src

  + main/java/io/dropwizard/validation/selfvalidating

    - dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java
      [ViolationCollector.java](#diff-60f14d8abd144634265d91ff7488172de8a78dc2c7b4464af23847cdd57bb353)
  + test/java/io/dropwizard/validation

    - dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java
      [SelfValidationTest.java](#diff-b7170e91fbcccf596bfe268895ba7a6e22d78efe24510db68f1746bfdaadfd4b)

## There are no files selected for viewing

80 changes: 75 additions & 5 deletions

80
[...-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java](#diff-60f14d8abd144634265d91ff7488172de8a78dc2c7b4464af23847cdd57bb353 "dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java")

Show comments

[View file](/dropwizard/dropwizard/blob/28479f743a9d0aab6d0e963fc07f3dd98e8c8236/dropwizard-validation/src/main/java/io/dropwizard/validation/selfvalidating/ViolationCollector.java)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
|  |  | @@ -1,12 +1,16 @@ |
|  |  | package io.dropwizard.validation.selfvalidating; |
|  |  |  |
|  |  | import javax.annotation.Nullable; |
|  |  | import javax.validation.ConstraintValidatorContext; |
|  |  | import java.util.regex.Matcher; |
|  |  | import java.util.regex.Pattern; |
|  |  |  |
|  |  | /\*\* |
|  |  | \* This class is a simple wrapper around the ConstraintValidatorContext of hibernate validation. |
|  |  | \* It collects all the violations of the SelfValidation methods of an object. |
|  |  | \*/ |
|  |  | public class ViolationCollector { |
|  |  | private static final Pattern ESCAPE\_PATTERN = Pattern.compile("\\$\\{"); |
|  |  |  |
|  |  | private boolean violationOccurred = false; |
|  |  | private ConstraintValidatorContext context; |
| Expand All | | @@ -17,14 +21,80 @@ public ViolationCollector(ConstraintValidatorContext context) { |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets violationOccurred to true. |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param msg the message of the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \*/ |
|  |  | public void addViolation(String msg) { |
|  |  | public void addViolation(String message) { |
|  |  | violationOccurred = true; |
|  |  | context.buildConstraintViolationWithTemplate(msg) |
|  |  | .addConstraintViolation(); |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 1.3.19 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property with the violation |
|  |  | \* @param index the index of the element with the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 1.3.19 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, Integer index, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addBeanNode().inIterable().atIndex(index) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
|  |  | \* Adds a new violation to this collector. This also sets {@code violationOccurred} to {@code true}. |
|  |  | \* |
|  |  | \* @param propertyName the name of the property with the violation |
|  |  | \* @param key the key of the element with the violation |
|  |  | \* @param message the message of the violation (any EL expression will be escaped and not parsed) |
|  |  | \* @since 1.3.19 |
|  |  | \*/ |
|  |  | public void addViolation(String propertyName, String key, String message) { |
|  |  | violationOccurred = true; |
|  |  | String messageTemplate = escapeEl(message); |
|  |  | context.buildConstraintViolationWithTemplate(messageTemplate) |
|  |  | .addPropertyNode(propertyName) |
|  |  | .addBeanNode().inIterable().atKey(key) |
|  |  | .addConstraintViolation(); |
|  |  | } |
|  |  |  |
|  |  | @Nullable |
|  |  | private String escapeEl(@Nullable String s) { |
|  |  | if (s == null || s.isEmpty()) { |
|  |  | return s; |
|  |  | } |
|  |  |  |
|  |  | final Matcher m = ESCAPE\_PATTERN.matcher(s); |
|  |  | final StringBuffer sb = new StringBuffer(s.length() + 16); |
|  |  | while (m.find()) { |
|  |  | m.appendReplacement(sb, "\\\\\\${"); |
|  |  | } |
|  |  | m.appendTail(sb); |
|  |  |  |
|  |  | return sb.toString(); |
|  |  | } |
|  |  |  |
|  |  | /\*\* |
| Expand Down | |  |

65 changes: 49 additions & 16 deletions

65
[dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java](#diff-b7170e91fbcccf596bfe268895ba7a6e22d78efe24510db68f1746bfdaadfd4b "dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java")

Show comments

[View file](/dropwizard/dropwizard/blob/28479f743a9d0aab6d0e963fc07f3dd98e8c8236/dropwizard-validation/src/test/java/io/dropwizard/validation/SelfValidationTest.java)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -10,11 +10,11 @@ |
|  |  | import static org.assertj.core.api.Assertions.assertThat; |
|  |  |  |
|  |  | public class SelfValidationTest { |
|  |  |  |
|  |  | private static final String FAILED = "failed"; |
|  |  |  |
|  |  | @SelfValidating |
|  |  | public static class FailingExample { |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail(ViolationCollector col) { |
|  |  | col.addViolation(FAILED); |
| Expand All | | @@ -23,6 +23,7 @@ public void validateFail(ViolationCollector col) { |
|  |  |  |
|  |  | @SelfValidating |
|  |  | public static class DirectContextExample { |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail(ViolationCollector col) { |
|  |  | col.getContext().buildConstraintViolationWithTemplate(FAILED).addConstraintViolation(); |
| Expand Down  Expand Up | | @@ -51,34 +52,44 @@ public void validateFailAdditionalParameters(ViolationCollector col, int a) { |
|  |  | col.addViolation(FAILED); |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public boolean validateFailReturn(ViolationCollector col) { |
|  |  | col.addViolation(FAILED); |
|  |  | return true; |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | private void validateFailPrivate(ViolationCollector col) { |
|  |  | col.addViolation(FAILED); |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  |  |
|  |  | @SelfValidating |
|  |  | public static class ComplexExample { |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail1(ViolationCollector col) { |
|  |  | col.addViolation(FAILED + "1"); |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail2(ViolationCollector col) { |
|  |  | col.addViolation(FAILED + "2"); |
|  |  | col.addViolation("p2", FAILED); |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail3(ViolationCollector col) { |
|  |  | col.addViolation(FAILED + "3"); |
|  |  | col.addViolation("p", 3, FAILED); |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail4(ViolationCollector col) { |
|  |  | col.addViolation("p", "four", FAILED); |
|  |  | } |
|  |  |  |
|  |  | @SuppressWarnings("unused") |
| Expand All | | @@ -91,42 +102,54 @@ public void validateCorrect(ViolationCollector col) { |
|  |  | public static class NoValidations { |
|  |  | } |
|  |  |  |
|  |  | @SelfValidating |
|  |  | public static class InjectionExample { |
|  |  | @SuppressWarnings("unused") |
|  |  | @SelfValidation |
|  |  | public void validateFail(ViolationCollector col) { |
|  |  | col.addViolation("${'value'}"); |
|  |  | col.addViolation("${'property'}", "${'value'}"); |
|  |  | col.addViolation("${'property'}", 1, "${'value'}"); |
|  |  | col.addViolation("${'property'}", "${'key'}", "${'value'}"); |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | private final Validator validator = BaseValidator.newValidator(); |
|  |  |  |
|  |  | @Test |
|  |  | public void failingExample() throws Exception { |
|  |  | public void failingExample() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new FailingExample()))) |
|  |  | .containsOnly(" " + FAILED); |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void correctExample() throws Exception { |
|  |  | public void correctExample() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new CorrectExample()))) |
|  |  | .isEmpty(); |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void multipleTestingOfSameClass() throws Exception { |
|  |  | public void multipleTestingOfSameClass() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new CorrectExample()))) |
|  |  | .isEmpty(); |
|  |  | .isEmpty(); |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new CorrectExample()))) |
|  |  | .isEmpty(); |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void testDirectContextUsage() throws Exception { |
|  |  | public void testDirectContextUsage() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new DirectContextExample()))) |
|  |  | .containsOnly(" " + FAILED); |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void complexExample() throws Exception { |
|  |  | public void complexExample() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new ComplexExample()))) |
|  |  | .containsOnly( |
|  |  | " " + FAILED + "1", |
|  |  | " " + FAILED + "2", |
|  |  | " " + FAILED + "3" |
|  |  | ); |
|  |  | .containsExactly( |
|  |  | " failed1", |
|  |  | "p2 failed", |
|  |  | "p[3] failed", |
|  |  | "p[four] failed"); |
|  |  | } |
|  |  |  |
|  |  | @Test |
| Expand All | | @@ -136,8 +159,18 @@ public void invalidExample() throws Exception { |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void giveWarningIfNoValidationMethods() throws Exception { |
|  |  | public void giveWarningIfNoValidationMethods() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new NoValidations()))) |
|  |  | .isEmpty(); |
|  |  | } |
|  |  |  |
|  |  | @Test |
|  |  | public void violationMessagesAreEscaped() { |
|  |  | assertThat(ConstraintViolations.format(validator.validate(new InjectionExample()))).containsExactly( |
|  |  | " ${'value'}", |
|  |  | "${'property'} ${'value'}", |
|  |  | "${'property'}[${'key'}] ${'value'}", |
|  |  | "${'property'}[1] ${'value'}" |
|  |  | ); |
|  |  | } |
|  |  | } |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `28479f7`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fcommit%2F28479f743a9d0aab6d0e963fc07f3dd98e8c8236) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_40bd752f_20250110_200003.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3160)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3160)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fpull_requests_fragments%2Fpull_request_layout&source=header-repo&source_repo=dropwizard%2Fdropwizard)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dropwizard](/dropwizard)
/
**[dropwizard](/dropwizard/dropwizard)**
Public

* [Notifications](/login?return_to=%2Fdropwizard%2Fdropwizard) You must be signed in to change notification settings
* [Fork
  3.4k](/login?return_to=%2Fdropwizard%2Fdropwizard)
* [Star
   8.5k](/login?return_to=%2Fdropwizard%2Fdropwizard)

* [Code](/dropwizard/dropwizard)
* [Issues
  10](/dropwizard/dropwizard/issues)
* [Pull requests
  5](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

Additional navigation options

* [Code](/dropwizard/dropwizard)
* [Issues](/dropwizard/dropwizard/issues)
* [Pull requests](/dropwizard/dropwizard/pulls)
* [Discussions](/dropwizard/dropwizard/discussions)
* [Actions](/dropwizard/dropwizard/actions)
* [Wiki](/dropwizard/dropwizard/wiki)
* [Security](/dropwizard/dropwizard/security)
* [Insights](/dropwizard/dropwizard/pulse)

New issue

**Have a question about this project?** Sign up for a free GitHub account to open an issue and contact its maintainers and the community.

 [Sign up for GitHub](/signup?return_to=%2Fdropwizard%2Fdropwizard%2Fissues%2Fnew%2Fchoose)

By clicking “Sign up for GitHub”, you agree to our [terms of service](https://docs.github.com/terms) and
[privacy statement](https://docs.github.com/privacy). We’ll occasionally send you account related emails.

Already on GitHub?
[Sign in](/login?return_to=%2Fdropwizard%2Fdropwizard%2Fissues%2Fnew%2Fchoose)
to your account

[Jump to bottom](#issue-comment-box)

# Escape EL expressions in ViolationCollector #3160

 Merged

[joschi](/joschi)
merged 1 commit into
[release/1.3.x](/dropwizard/dropwizard/tree/release/1.3.x "dropwizard/dropwizard:release/1.3.x")
from
[issue-3153-1.3](/dropwizard/dropwizard/tree/issue-3153-1.3 "dropwizard/dropwizard:issue-3153-1.3")

Feb 20, 2020

 Merged

# [Escape EL expressions in ViolationCollector](#top) #3160

[joschi](/joschi)
merged 1 commit into
[release/1.3.x](/dropwizard/dropwizard/tree/release/1.3.x "dropwizard/dropwizard:release/1.3.x")
from
[issue-3153-1.3](/dropwizard/dropwizard/tree/issue-3153-1.3 "dropwizard/dropwizard:issue-3153-1.3")

Feb 20, 2020

[Conversation
0](/dropwizard/dropwizard/pull/3160)
[Commits
1](/dropwizard/dropwizard/pull/3160/commits)
[Checks
0](/dropwizard/dropwizard/pull/3160/checks)
[Files changed](/dropwizard/dropwizard/pull/3160/files)

## Conversation

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

[![joschi](https://avatars.githubusercontent.com/u/43951?s=60&v=4)](/joschi)

Copy link

Member

### @joschi **[joschi](/joschi)** commented [Feb 20, 2020](#issue-567996964)

Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)

Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)

(cherry picked from commit [d87d1e4](https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634))

Sorry, something went wrong.

All reactions

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)

`[Escape EL expressions in ViolationCollector](/dropwizard/dropwizard/pull/3160/commits/aa9ae9689d7d215f6115efb5850160e0a8cd35e5 "Escape EL expressions in ViolationCollector

Fixes #3153
Refs #3157
(cherry picked from commit d87d1e4f8e20f6494c0232bf8560c961b46db634)")`
 …

`[aa9ae96](/dropwizard/dropwizard/pull/3160/commits/aa9ae9689d7d215f6115efb5850160e0a8cd35e5)`

```
Fixes [#3153](https://github.com/dropwizard/dropwizard/issues/3153)
Refs [#3157](https://github.com/dropwizard/dropwizard/pull/3157)
(cherry picked from commit [d87d1e4](https://github.com/dropwizard/dropwizard/commit/d87d1e4f8e20f6494c0232bf8560c961b46db634))
```

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
added
the
[security](/dropwizard/dropwizard/labels/security)
label
[Feb 20, 2020](#event-3054062780)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
added this to the [1.3.19](/dropwizard/dropwizard/milestone/55) milestone
[Feb 20, 2020](#event-3054062790)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
self-assigned this
[Feb 20, 2020](#event-3054062797)

 [![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
requested a review
from [pkwarren](/pkwarren)
[February 20, 2020 01:46](#event-3054066051)

[![pkwarren](https://avatars.githubusercontent.com/u/398111?s=60&v=4)](/pkwarren)

**[pkwarren](/pkwarren)**
approved these changes
[Feb 20, 2020](#pullrequestreview-361585502)

 [View reviewed changes](/dropwizard/dropwizard/pull/3160/files/aa9ae9689d7d215f6115efb5850160e0a8cd35e5)

[![jplock](https://avatars.githubusercontent.com/u/49093?s=60&v=4)](/jplock)

**[jplock](/jplock)**
approved these changes
[Feb 20, 2020](#pullrequestreview-361585567)

 [View reviewed changes](/dropwizard/dropwizard/pull/3160/files/aa9ae9689d7d215f6115efb5850160e0a8cd35e5)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
merged commit [`28479f7`](/dropwizard/dropwizard/commit/28479f743a9d0aab6d0e963fc07f3dd98e8c8236)
into
release/1.3.x

[Feb 20, 2020](https://github.com/dropwizard/dropwizard/pull/3160#event-3054104716)

 [![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
deleted the
issue-3153-1.3

branch
[February 20, 2020 02:09](#event-3054104798)

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi)
[joschi](/joschi)
linked an issue
[Feb 20, 2020](#event-3055912669)
that may be
closed
by this pull request

[Security issue
#3153](/dropwizard/dropwizard/issues/3153)

Closed

[![@dtanedo](https://avatars.githubusercontent.com/u/16568535?s=40&v=4)](/dtanedo)
[dtanedo](/dtanedo)
mentioned this pull request
[Mar 12, 2020](#ref-issue-579761372)

[False Positive on simpleclient\_dropwizard-0.6.0.jar
jeremylong/DependencyCheck#2523](/jeremylong/DependencyCheck/issues/2523)

Closed

[Sign up for free](/join?source=comment-repo)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgithub.com%2Fdropwizard%2Fdropwizard%2Fpull%2F3160)

Reviewers

[![@pkwarren](https://avatars.githubusercontent.com/u/398111?s=40&v=4)](/pkwarren) [pkwarren](/pkwarren)

pkwarren approved these changes

[![@jplock](https://avatars.githubusercontent.com/u/49093?s=40&v=4)](/jplock) [jplock](/jplock)

jplock approved these changes

Assignees

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=40&v=4)](/joschi) [joschi](/joschi)

Labels

[security](/dropwizard/dropwizard/labels/security)

Projects

None yet

Milestone

 [**1.3.19**](/dropwizard/dropwizard/milestone/55 "1.3.19")

Development

Successfully merging this pull request may close these issues.

 [Security issue](https://github.com/dropwizard/dropwizard/issues/3153)

3 participants

[![@joschi](https://avatars.githubusercontent.com/u/43951?s=52&v=4)](/joschi) [![@jplock](https://avatars.githubusercontent.com/u/49093?s=52&v=4)](/jplock) [![@pkwarren](https://avatars.githubusercontent.com/u/398111?s=52&v=4)](/pkwarren)

Add this suggestion to a batch that can be applied as a single commit.
This suggestion is invalid because no changes were made to the code.
Suggestions cannot be applied while the pull request is closed.
Suggestions cannot be applied while viewing a subset of changes.
Only one suggestion per line can be applied in a batch.
Add this suggestion to a batch that can be applied as a single commit.
Applying suggestions on deleted lines is not supported.
You must change the existing code in this line in order to create a valid suggestion.
Outdated suggestions cannot be applied.
This suggestion has been applied or marked resolved.
Suggestions cannot be applied from pending reviews.
Suggestions cannot be applied on multi-line comments.
Suggestions cannot be applied while the pull request is queued to merge.
Suggestion cannot be applied right now. Please check back later.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


