```
{
  "CVE-2024-26671": {
    "Description": "In blk_mq_mark_tag_wait(), __add_wait_queue() may be re-ordered with the following blk_mq_get_driver_tag() in case of getting driver tag failure. Then in __sbitmap_queue_wake_up(), waitqueue_active() may not observe the added waiter in blk_mq_mark_tag_wait() and wake up nothing, meantime blk_mq_mark_tag_wait() can't get driver tag successfully.",
    "Root cause": "Race condition in the ordering of adding a wait queue and getting a driver tag in `blk_mq_mark_tag_wait()` function. Due to the lack of memory barrier, `__add_wait_queue()` may be reordered with the subsequent `blk_mq_get_driver_tag()` when getting a driver tag fails.",
    "Weaknesses": [
      "Incorrect memory ordering",
      "Race condition"
    ],
    "Impact": "IO hang due to a deadlock where a task is waiting for a wakeup signal that will never arrive. This happens when a tag cannot be acquired and the wakeup mechanism fails to register the waiter.",
    "Attack vectors": "Triggering a scenario where the driver tag allocation fails while performing block IO operations.",
      "Required attacker capabilities/position": "The attacker must be able to initiate IO operations on a block device that stresses the tag allocation mechanism of blk-mq. It requires the ability to create multiple concurrent IO requests."
  }
}
```