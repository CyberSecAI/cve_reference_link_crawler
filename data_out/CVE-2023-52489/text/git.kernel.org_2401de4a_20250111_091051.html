

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Charan Teja Kalla <quic\_charante@quicinc.com> | 2023-10-13 18:34:27 +0530 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-31 16:18:56 -0800 |
| commit | [70064241f2229f7ba7b9599a98f68d9142e81a97](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=70064241f2229f7ba7b9599a98f68d9142e81a97) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)) | |
| tree | [731f7468bee90b6a1d8625634dcd351035f114b6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=70064241f2229f7ba7b9599a98f68d9142e81a97) | |
| parent | [62efb1e656f4e1d018e37a26490dd29e5d7c7e90](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=62efb1e656f4e1d018e37a26490dd29e5d7c7e90) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=70064241f2229f7ba7b9599a98f68d9142e81a97&id2=62efb1e656f4e1d018e37a26490dd29e5d7c7e90)) | |
| download | [linux-70064241f2229f7ba7b9599a98f68d9142e81a97.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-70064241f2229f7ba7b9599a98f68d9142e81a97.tar.gz) | |

mm/sparsemem: fix race in accessing memory\_section->usagecommit 5ec8e8ea8b7783fab150cf86404fc38cb4db8800 upstream.
The below race is observed on a PFN which falls into the device memory
region with the system memory configuration where PFN's are such that
[ZONE\_NORMAL ZONE\_DEVICE ZONE\_NORMAL]. Since normal zone start and end
pfn contains the device memory PFN's as well, the compaction triggered
will try on the device memory PFN's too though they end up in NOP(because
pfn\_to\_online\_page() returns NULL for ZONE\_DEVICE memory sections). When
from other core, the section mappings are being removed for the
ZONE\_DEVICE region, that the PFN in question belongs to, on which
compaction is currently being operated is resulting into the kernel crash
with CONFIG\_SPASEMEM\_VMEMAP enabled. The crash logs can be seen at [1].
compact\_zone() memunmap\_pages
------------- ---------------
\_\_pageblock\_pfn\_to\_page
......
(a)pfn\_valid():
valid\_section()//return true
(b)\_\_remove\_pages()->
sparse\_remove\_section()->
section\_deactivate():
[Free the array ms->usage and set
ms->usage = NULL]
pfn\_section\_valid()
[Access ms->usage which
is NULL]
NOTE: From the above it can be said that the race is reduced to between
the pfn\_valid()/pfn\_section\_valid() and the section deactivate with
SPASEMEM\_VMEMAP enabled.
The commit b943f045a9af("mm/sparse: fix kernel crash with
pfn\_section\_valid check") tried to address the same problem by clearing
the SECTION\_HAS\_MEM\_MAP with the expectation of valid\_section() returns
false thus ms->usage is not accessed.
Fix this issue by the below steps:
a) Clear SECTION\_HAS\_MEM\_MAP before freeing the ->usage.
b) RCU protected read side critical section will either return NULL
when SECTION\_HAS\_MEM\_MAP is cleared or can successfully access ->usage.
c) Free the ->usage with kfree\_rcu() and set ms->usage = NULL. No
attempt will be made to access ->usage after this as the
SECTION\_HAS\_MEM\_MAP is cleared thus valid\_section() return false.
Thanks to David/Pavan for their inputs on this patch.
[1] https://lore.kernel.org/linux-mm/994410bb-89aa-d987-1f50-f514903c55aa@quicinc.com/
On Snapdragon SoC, with the mentioned memory configuration of PFN's as
[ZONE\_NORMAL ZONE\_DEVICE ZONE\_NORMAL], we are able to see bunch of
issues daily while testing on a device farm.
For this particular issue below is the log. Though the below log is
not directly pointing to the pfn\_section\_valid(){ ms->usage;}, when we
loaded this dump on T32 lauterbach tool, it is pointing.
[ 540.578056] Unable to handle kernel NULL pointer dereference at
virtual address 0000000000000000
[ 540.578068] Mem abort info:
[ 540.578070] ESR = 0x0000000096000005
[ 540.578073] EC = 0x25: DABT (current EL), IL = 32 bits
[ 540.578077] SET = 0, FnV = 0
[ 540.578080] EA = 0, S1PTW = 0
[ 540.578082] FSC = 0x05: level 1 translation fault
[ 540.578085] Data abort info:
[ 540.578086] ISV = 0, ISS = 0x00000005
[ 540.578088] CM = 0, WnR = 0
[ 540.579431] pstate: 82400005 (Nzcv daif +PAN -UAO +TCO -DIT -SSBSBTYPE=--)
[ 540.579436] pc : \_\_pageblock\_pfn\_to\_page+0x6c/0x14c
[ 540.579454] lr : compact\_zone+0x994/0x1058
[ 540.579460] sp : ffffffc03579b510
[ 540.579463] x29: ffffffc03579b510 x28: 0000000000235800 x27:000000000000000c
[ 540.579470] x26: 0000000000235c00 x25: 0000000000000068 x24:ffffffc03579b640
[ 540.579477] x23: 0000000000000001 x22: ffffffc03579b660 x21:0000000000000000
[ 540.579483] x20: 0000000000235bff x19: ffffffdebf7e3940 x18:ffffffdebf66d140
[ 540.579489] x17: 00000000739ba063 x16: 00000000739ba063 x15:00000000009f4bff
[ 540.579495] x14: 0000008000000000 x13: 0000000000000000 x12:0000000000000001
[ 540.579501] x11: 0000000000000000 x10: 0000000000000000 x9 :ffffff897d2cd440
[ 540.579507] x8 : 0000000000000000 x7 : 0000000000000000 x6 :ffffffc03579b5b4
[ 540.579512] x5 : 0000000000027f25 x4 : ffffffc03579b5b8 x3 :0000000000000001
[ 540.579518] x2 : ffffffdebf7e3940 x1 : 0000000000235c00 x0 :0000000000235800
[ 540.579524] Call trace:
[ 540.579527] \_\_pageblock\_pfn\_to\_page+0x6c/0x14c
[ 540.579533] compact\_zone+0x994/0x1058
[ 540.579536] try\_to\_compact\_pages+0x128/0x378
[ 540.579540] \_\_alloc\_pages\_direct\_compact+0x80/0x2b0
[ 540.579544] \_\_alloc\_pages\_slowpath+0x5c0/0xe10
[ 540.579547] \_\_alloc\_pages+0x250/0x2d0
[ 540.579550] \_\_iommu\_dma\_alloc\_noncontiguous+0x13c/0x3fc
[ 540.579561] iommu\_dma\_alloc+0xa0/0x320
[ 540.579565] dma\_alloc\_attrs+0xd4/0x108
[quic\_charante@quicinc.com: use kfree\_rcu() in place of synchronize\_rcu(), per David]
Link: https://lkml.kernel.org/r/1698403778-20938-1-git-send-email-quic\_charante@quicinc.com
Link: [https://lkml.kernel.org/r/1697202267-23600-1-git-send-email-quic\_charante@quicinc.com](https://lkml.kernel.org/r/1697202267-23600-1-git-send-email-quic_charante%40quicinc.com)
Fixes: f46edbd1b151 ("mm/sparsemem: add helpers track active portions of a section at boot")
Signed-off-by: Charan Teja Kalla <quic\_charante@quicinc.com>
Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: Mel Gorman <mgorman@techsingularity.net>
Cc: Oscar Salvador <osalvador@suse.de>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=70064241f2229f7ba7b9599a98f68d9142e81a97)

| -rw-r--r-- | [include/linux/mmzone.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/mmzone.h?id=70064241f2229f7ba7b9599a98f68d9142e81a97) | 14 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/sparse.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/sparse.c?id=70064241f2229f7ba7b9599a98f68d9142e81a97) | 17 | |  |  |  | | --- | --- | --- | |

2 files changed, 20 insertions, 11 deletions

| diff --git a/include/linux/mmzone.h b/include/linux/mmzone.hindex b6b688b229ea9b..f43a1cdcc6e75a 100644--- a/[include/linux/mmzone.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/mmzone.h?id=62efb1e656f4e1d018e37a26490dd29e5d7c7e90)+++ b/[include/linux/mmzone.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/mmzone.h?id=70064241f2229f7ba7b9599a98f68d9142e81a97)@@ -1774,6 +1774,7 @@ static inline unsigned long section\_nr\_to\_pfn(unsigned long sec) #define SUBSECTION\_ALIGN\_DOWN(pfn) ((pfn) & PAGE\_SUBSECTION\_MASK)  struct mem\_section\_usage {+ struct rcu\_head rcu; #ifdef CONFIG\_SPARSEMEM\_VMEMMAP DECLARE\_BITMAP(subsection\_map, SUBSECTIONS\_PER\_SECTION); #endif@@ -1967,7 +1968,7 @@ static inline int pfn\_section\_valid(struct mem\_section \*ms, unsigned long pfn) { int idx = subsection\_map\_index(pfn); - return test\_bit(idx, ms->usage->subsection\_map);+ return test\_bit(idx, READ\_ONCE(ms->usage)->subsection\_map); } #else static inline int pfn\_section\_valid(struct mem\_section \*ms, unsigned long pfn)@@ -1991,6 +1992,7 @@ static inline int pfn\_section\_valid(struct mem\_section \*ms, unsigned long pfn) static inline int pfn\_valid(unsigned long pfn) { struct mem\_section \*ms;+ int ret;  /\* \* Ensure the upper PAGE\_SHIFT bits are clear in the@@ -2004,13 +2006,19 @@ static inline int pfn\_valid(unsigned long pfn) if (pfn\_to\_section\_nr(pfn) >= NR\_MEM\_SECTIONS) return 0; ms = \_\_pfn\_to\_section(pfn);- if (!valid\_section(ms))+ rcu\_read\_lock();+ if (!valid\_section(ms)) {+ rcu\_read\_unlock(); return 0;+ } /\* \* Traditionally early sections always returned pfn\_valid() for \* the entire section-sized span. \*/- return early\_section(ms) || pfn\_section\_valid(ms, pfn);+ ret = early\_section(ms) || pfn\_section\_valid(ms, pfn);+ rcu\_read\_unlock();++ return ret; } #endif diff --git a/mm/sparse.c b/mm/sparse.cindex 77d91e565045ca..338cf946dee8de 100644--- a/[mm/sparse.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/sparse.c?id=62efb1e656f4e1d018e37a26490dd29e5d7c7e90)+++ b/[mm/sparse.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/sparse.c?id=70064241f2229f7ba7b9599a98f68d9142e81a97)@@ -792,6 +792,13 @@ static void section\_deactivate(unsigned long pfn, unsigned long nr\_pages, unsigned long section\_nr = pfn\_to\_section\_nr(pfn);  /\*+ \* Mark the section invalid so that valid\_section()+ \* return false. This prevents code from dereferencing+ \* ms->usage array.+ \*/+ ms->section\_mem\_map &= ~SECTION\_HAS\_MEM\_MAP;++ /\* \* When removing an early section, the usage map is kept (as the \* usage maps of other sections fall into the same page). It \* will be re-used when re-adding the section - which is then no@@ -799,16 +806,10 @@ static void section\_deactivate(unsigned long pfn, unsigned long nr\_pages, \* was allocated during boot. \*/ if (!PageReserved(virt\_to\_page(ms->usage))) {- kfree(ms->usage);- ms->usage = NULL;+ kfree\_rcu(ms->usage, rcu);+ WRITE\_ONCE(ms->usage, NULL); } memmap = sparse\_decode\_mem\_map(ms->section\_mem\_map, section\_nr);- /\*- \* Mark the section invalid so that valid\_section()- \* return false. This prevents code from dereferencing- \* ms->usage array.- \*/- ms->section\_mem\_map &= ~SECTION\_HAS\_MEM\_MAP; }  /\* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 09:09:28 +0000

