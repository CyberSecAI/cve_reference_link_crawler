<!DOCTYPE html>
<html lang='en'>
<head>
<title>aio: fix use-after-free due to missing POLLFREE handling - kernel/git/stable/linux.git - Linux kernel stable tree</title>
<meta name='generator' content='cgit 1.2.3-korg'/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<script type='text/javascript' src='/cgit-data/cgit.js'></script>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/stable/linux.git' title='kernel/git/stable/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a href='/pub/scm/linux/kernel/git/stable/linux.git/'>kernel/git/stable/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='321fba81ec034f88aea4898993c1bf15605c023f'/><select name='h' onchange='this.form.submit();'>
<option value='linux-2.6.11.y'>linux-2.6.11.y</option>
<option value='linux-2.6.12.y'>linux-2.6.12.y</option>
<option value='linux-2.6.13.y'>linux-2.6.13.y</option>
<option value='linux-2.6.14.y'>linux-2.6.14.y</option>
<option value='linux-2.6.15.y'>linux-2.6.15.y</option>
<option value='linux-2.6.16.y'>linux-2.6.16.y</option>
<option value='linux-2.6.17.y'>linux-2.6.17.y</option>
<option value='linux-2.6.18.y'>linux-2.6.18.y</option>
<option value='linux-2.6.19.y'>linux-2.6.19.y</option>
<option value='linux-2.6.20.y'>linux-2.6.20.y</option>
<option value='linux-2.6.21.y'>linux-2.6.21.y</option>
<option value='linux-2.6.22.y'>linux-2.6.22.y</option>
<option value='linux-2.6.23.y'>linux-2.6.23.y</option>
<option value='linux-2.6.24.y'>linux-2.6.24.y</option>
<option value='linux-2.6.25.y'>linux-2.6.25.y</option>
<option value='linux-2.6.26.y'>linux-2.6.26.y</option>
<option value='linux-2.6.27.y'>linux-2.6.27.y</option>
<option value='linux-2.6.28.y'>linux-2.6.28.y</option>
<option value='linux-2.6.29.y'>linux-2.6.29.y</option>
<option value='linux-2.6.30.y'>linux-2.6.30.y</option>
<option value='linux-2.6.31.y'>linux-2.6.31.y</option>
<option value='linux-2.6.32.y'>linux-2.6.32.y</option>
<option value='linux-2.6.33.y'>linux-2.6.33.y</option>
<option value='linux-2.6.34.y'>linux-2.6.34.y</option>
<option value='linux-2.6.35.y'>linux-2.6.35.y</option>
<option value='linux-2.6.36.y'>linux-2.6.36.y</option>
<option value='linux-2.6.37.y'>linux-2.6.37.y</option>
<option value='linux-2.6.38.y'>linux-2.6.38.y</option>
<option value='linux-2.6.39.y'>linux-2.6.39.y</option>
<option value='linux-3.0.y'>linux-3.0.y</option>
<option value='linux-3.1.y'>linux-3.1.y</option>
<option value='linux-3.10.y'>linux-3.10.y</option>
<option value='linux-3.11.y'>linux-3.11.y</option>
<option value='linux-3.12.y'>linux-3.12.y</option>
<option value='linux-3.13.y'>linux-3.13.y</option>
<option value='linux-3.14.y'>linux-3.14.y</option>
<option value='linux-3.15.y'>linux-3.15.y</option>
<option value='linux-3.16.y'>linux-3.16.y</option>
<option value='linux-3.17.y'>linux-3.17.y</option>
<option value='linux-3.18.y'>linux-3.18.y</option>
<option value='linux-3.19.y'>linux-3.19.y</option>
<option value='linux-3.2.y'>linux-3.2.y</option>
<option value='linux-3.3.y'>linux-3.3.y</option>
<option value='linux-3.4.y'>linux-3.4.y</option>
<option value='linux-3.5.y'>linux-3.5.y</option>
<option value='linux-3.6.y'>linux-3.6.y</option>
<option value='linux-3.7.y'>linux-3.7.y</option>
<option value='linux-3.8.y'>linux-3.8.y</option>
<option value='linux-3.9.y'>linux-3.9.y</option>
<option value='linux-4.0.y'>linux-4.0.y</option>
<option value='linux-4.1.y'>linux-4.1.y</option>
<option value='linux-4.10.y'>linux-4.10.y</option>
<option value='linux-4.11.y'>linux-4.11.y</option>
<option value='linux-4.12.y'>linux-4.12.y</option>
<option value='linux-4.13.y'>linux-4.13.y</option>
<option value='linux-4.14.y'>linux-4.14.y</option>
<option value='linux-4.15.y'>linux-4.15.y</option>
<option value='linux-4.16.y'>linux-4.16.y</option>
<option value='linux-4.17.y'>linux-4.17.y</option>
<option value='linux-4.18.y'>linux-4.18.y</option>
<option value='linux-4.19.y'>linux-4.19.y</option>
<option value='linux-4.2.y'>linux-4.2.y</option>
<option value='linux-4.20.y'>linux-4.20.y</option>
<option value='linux-4.3.y'>linux-4.3.y</option>
<option value='linux-4.4.y'>linux-4.4.y</option>
<option value='linux-4.5.y'>linux-4.5.y</option>
<option value='linux-4.6.y'>linux-4.6.y</option>
<option value='linux-4.7.y'>linux-4.7.y</option>
<option value='linux-4.8.y'>linux-4.8.y</option>
<option value='linux-4.9.y'>linux-4.9.y</option>
<option value='linux-5.0.y'>linux-5.0.y</option>
<option value='linux-5.1.y'>linux-5.1.y</option>
<option value='linux-5.10.y'>linux-5.10.y</option>
<option value='linux-5.11.y'>linux-5.11.y</option>
<option value='linux-5.12.y'>linux-5.12.y</option>
<option value='linux-5.13.y'>linux-5.13.y</option>
<option value='linux-5.14.y'>linux-5.14.y</option>
<option value='linux-5.15.y'>linux-5.15.y</option>
<option value='linux-5.16.y'>linux-5.16.y</option>
<option value='linux-5.17.y'>linux-5.17.y</option>
<option value='linux-5.18.y'>linux-5.18.y</option>
<option value='linux-5.19.y'>linux-5.19.y</option>
<option value='linux-5.2.y'>linux-5.2.y</option>
<option value='linux-5.3.y'>linux-5.3.y</option>
<option value='linux-5.4.y'>linux-5.4.y</option>
<option value='linux-5.5.y'>linux-5.5.y</option>
<option value='linux-5.6.y'>linux-5.6.y</option>
<option value='linux-5.7.y'>linux-5.7.y</option>
<option value='linux-5.8.y'>linux-5.8.y</option>
<option value='linux-5.9.y'>linux-5.9.y</option>
<option value='linux-6.0.y'>linux-6.0.y</option>
<option value='linux-6.1.y'>linux-6.1.y</option>
<option value='linux-6.10.y'>linux-6.10.y</option>
<option value='linux-6.11.y'>linux-6.11.y</option>
<option value='linux-6.12.y'>linux-6.12.y</option>
<option value='linux-6.2.y'>linux-6.2.y</option>
<option value='linux-6.3.y'>linux-6.3.y</option>
<option value='linux-6.4.y'>linux-6.4.y</option>
<option value='linux-6.5.y'>linux-6.5.y</option>
<option value='linux-6.6.y'>linux-6.6.y</option>
<option value='linux-6.7.y'>linux-6.7.y</option>
<option value='linux-6.8.y'>linux-6.8.y</option>
<option value='linux-6.9.y'>linux-6.9.y</option>
<option value='linux-rolling-lts'>linux-rolling-lts</option>
<option value='linux-rolling-stable'>linux-rolling-stable</option>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel stable tree</td><td class='sub right'>Stable Group</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/stable/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=321fba81ec034f88aea4898993c1bf15605c023f'>refs</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=321fba81ec034f88aea4898993c1bf15605c023f'>tree</a><a class='active' href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=321fba81ec034f88aea4898993c1bf15605c023f'>commit</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=321fba81ec034f88aea4898993c1bf15605c023f'>diff</a><a href='/pub/scm/linux/kernel/git/stable/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/stable/linux.git/log/'>
<input type='hidden' name='id' value='321fba81ec034f88aea4898993c1bf15605c023f'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='321fba81ec034f88aea4898993c1bf15605c023f'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><table summary='commit info' class='commit-info'>
<tr><th>author</th><td>Eric Biggers &lt;ebiggers@google.com&gt;</td><td class='right'>2021-12-10 15:53:12 -0800</td></tr>
<tr><th>committer</th><td>Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</td><td class='right'>2021-12-14 10:18:07 +0100</td></tr>
<tr><th>commit</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=321fba81ec034f88aea4898993c1bf15605c023f'>321fba81ec034f88aea4898993c1bf15605c023f</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=321fba81ec034f88aea4898993c1bf15605c023f'>patch</a>)</td></tr>
<tr><th>tree</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=321fba81ec034f88aea4898993c1bf15605c023f'>26370f10e2a7c30bf82292ec9094814ca2f9a5a2</a></td></tr>
<tr><th>parent</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=580c7e023303ce3a187adcaa40868bfc740725d2'>580c7e023303ce3a187adcaa40868bfc740725d2</a> (<a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=321fba81ec034f88aea4898993c1bf15605c023f&amp;id2=580c7e023303ce3a187adcaa40868bfc740725d2'>diff</a>)</td></tr><tr><th>download</th><td colspan='2' class='oid'><a href='/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-321fba81ec034f88aea4898993c1bf15605c023f.tar.gz'>linux-321fba81ec034f88aea4898993c1bf15605c023f.tar.gz</a><br/></td></tr></table>
<div class='commit-subject'>aio: fix use-after-free due to missing POLLFREE handling</div><div class='commit-msg'>commit 50252e4b5e989ce64555c7aef7516bdefc2fea72 upstream.

signalfd_poll() and binder_poll() are special in that they use a
waitqueue whose lifetime is the current task, rather than the struct
file as is normally the case.  This is okay for blocking polls, since a
blocking poll occurs within one task; however, non-blocking polls
require another solution.  This solution is for the queue to be cleared
before it is freed, by sending a POLLFREE notification to all waiters.

Unfortunately, only eventpoll handles POLLFREE.  A second type of
non-blocking poll, aio poll, was added in kernel v4.18, and it doesn't
handle POLLFREE.  This allows a use-after-free to occur if a signalfd or
binder fd is polled with aio poll, and the waitqueue gets freed.

Fix this by making aio poll handle POLLFREE.

A patch by Ramji Jiyani &lt;ramjiyani@google.com&gt;
(https://lore.kernel.org/r/20211027011834.2497484-1-ramjiyani@google.com)
tried to do this by making aio_poll_wake() always complete the request
inline if POLLFREE is seen.  However, that solution had two bugs.
First, it introduced a deadlock, as it unconditionally locked the aio
context while holding the waitqueue lock, which inverts the normal
locking order.  Second, it didn't consider that POLLFREE notifications
are missed while the request has been temporarily de-queued.

The second problem was solved by my previous patch.  This patch then
properly fixes the use-after-free by handling POLLFREE in a
deadlock-free way.  It does this by taking advantage of the fact that
freeing of the waitqueue is RCU-delayed, similar to what eventpoll does.

Fixes: 2c14fa838cbe ("aio: implement IOCB_CMD_POLL")
Cc: &lt;stable@vger.kernel.org&gt; # v4.18+
Link: <a href="https://lore.kernel.org/r/20211209010455.42744-6-ebiggers@kernel.org">https://lore.kernel.org/r/20211209010455.42744-6-ebiggers@kernel.org</a>
Signed-off-by: Eric Biggers &lt;ebiggers@google.com&gt;
Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
</div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=321fba81ec034f88aea4898993c1bf15605c023f'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/aio.c?id=321fba81ec034f88aea4898993c1bf15605c023f'>fs/aio.c</a></td><td class='right'>137</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 77.4%;'/><td class='rem' style='width: 22.6%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/stable/linux.git/diff/include/uapi/asm-generic/poll.h?id=321fba81ec034f88aea4898993c1bf15605c023f'>include/uapi/asm-generic/poll.h</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.7%;'/><td class='rem' style='width: 0.7%;'/><td class='none' style='width: 98.5%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>2 files changed, 107 insertions, 32 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/fs/aio.c b/fs/aio.c<br/>index 7c623ca0207718..9635c29b83da17 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/aio.c?id=580c7e023303ce3a187adcaa40868bfc740725d2'>fs/aio.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/aio.c?id=321fba81ec034f88aea4898993c1bf15605c023f'>fs/aio.c</a></div><div class='hunk'>@@ -1617,6 +1617,51 @@ static void aio_poll_put_work(struct work_struct *work)</div><div class='ctx'> 	iocb_put(iocb);</div><div class='ctx'> }</div><div class='ctx'> </div><div class='add'>+/*</div><div class='add'>+ * Safely lock the waitqueue which the request is on, synchronizing with the</div><div class='add'>+ * case where the -&gt;poll() provider decides to free its waitqueue early.</div><div class='add'>+ *</div><div class='add'>+ * Returns true on success, meaning that req-&gt;head-&gt;lock was locked, req-&gt;wait</div><div class='add'>+ * is on req-&gt;head, and an RCU read lock was taken.  Returns false if the</div><div class='add'>+ * request was already removed from its waitqueue (which might no longer exist).</div><div class='add'>+ */</div><div class='add'>+static bool poll_iocb_lock_wq(struct poll_iocb *req)</div><div class='add'>+{</div><div class='add'>+	wait_queue_head_t *head;</div><div class='add'>+</div><div class='add'>+	/*</div><div class='add'>+	 * While we hold the waitqueue lock and the waitqueue is nonempty,</div><div class='add'>+	 * wake_up_pollfree() will wait for us.  However, taking the waitqueue</div><div class='add'>+	 * lock in the first place can race with the waitqueue being freed.</div><div class='add'>+	 *</div><div class='add'>+	 * We solve this as eventpoll does: by taking advantage of the fact that</div><div class='add'>+	 * all users of wake_up_pollfree() will RCU-delay the actual free.  If</div><div class='add'>+	 * we enter rcu_read_lock() and see that the pointer to the queue is</div><div class='add'>+	 * non-NULL, we can then lock it without the memory being freed out from</div><div class='add'>+	 * under us, then check whether the request is still on the queue.</div><div class='add'>+	 *</div><div class='add'>+	 * Keep holding rcu_read_lock() as long as we hold the queue lock, in</div><div class='add'>+	 * case the caller deletes the entry from the queue, leaving it empty.</div><div class='add'>+	 * In that case, only RCU prevents the queue memory from being freed.</div><div class='add'>+	 */</div><div class='add'>+	rcu_read_lock();</div><div class='add'>+	head = smp_load_acquire(&amp;req-&gt;head);</div><div class='add'>+	if (head) {</div><div class='add'>+		spin_lock(&amp;head-&gt;lock);</div><div class='add'>+		if (!list_empty(&amp;req-&gt;wait.entry))</div><div class='add'>+			return true;</div><div class='add'>+		spin_unlock(&amp;head-&gt;lock);</div><div class='add'>+	}</div><div class='add'>+	rcu_read_unlock();</div><div class='add'>+	return false;</div><div class='add'>+}</div><div class='add'>+</div><div class='add'>+static void poll_iocb_unlock_wq(struct poll_iocb *req)</div><div class='add'>+{</div><div class='add'>+	spin_unlock(&amp;req-&gt;head-&gt;lock);</div><div class='add'>+	rcu_read_unlock();</div><div class='add'>+}</div><div class='add'>+</div><div class='ctx'> static void aio_poll_complete_work(struct work_struct *work)</div><div class='ctx'> {</div><div class='ctx'> 	struct poll_iocb *req = container_of(work, struct poll_iocb, work);</div><div class='hunk'>@@ -1636,24 +1681,25 @@ static void aio_poll_complete_work(struct work_struct *work)</div><div class='ctx'> 	 * avoid further branches in the fast path.</div><div class='ctx'> 	 */</div><div class='ctx'> 	spin_lock_irq(&amp;ctx-&gt;ctx_lock);</div><div class='del'>-	spin_lock(&amp;req-&gt;head-&gt;lock);</div><div class='del'>-	if (!mask &amp;&amp; !READ_ONCE(req-&gt;cancelled)) {</div><div class='del'>-		/*</div><div class='del'>-		 * The request isn't actually ready to be completed yet.</div><div class='del'>-		 * Reschedule completion if another wakeup came in.</div><div class='del'>-		 */</div><div class='del'>-		if (req-&gt;work_need_resched) {</div><div class='del'>-			schedule_work(&amp;req-&gt;work);</div><div class='del'>-			req-&gt;work_need_resched = false;</div><div class='del'>-		} else {</div><div class='del'>-			req-&gt;work_scheduled = false;</div><div class='add'>+	if (poll_iocb_lock_wq(req)) {</div><div class='add'>+		if (!mask &amp;&amp; !READ_ONCE(req-&gt;cancelled)) {</div><div class='add'>+			/*</div><div class='add'>+			 * The request isn't actually ready to be completed yet.</div><div class='add'>+			 * Reschedule completion if another wakeup came in.</div><div class='add'>+			 */</div><div class='add'>+			if (req-&gt;work_need_resched) {</div><div class='add'>+				schedule_work(&amp;req-&gt;work);</div><div class='add'>+				req-&gt;work_need_resched = false;</div><div class='add'>+			} else {</div><div class='add'>+				req-&gt;work_scheduled = false;</div><div class='add'>+			}</div><div class='add'>+			poll_iocb_unlock_wq(req);</div><div class='add'>+			spin_unlock_irq(&amp;ctx-&gt;ctx_lock);</div><div class='add'>+			return;</div><div class='ctx'> 		}</div><div class='del'>-		spin_unlock(&amp;req-&gt;head-&gt;lock);</div><div class='del'>-		spin_unlock_irq(&amp;ctx-&gt;ctx_lock);</div><div class='del'>-		return;</div><div class='del'>-	}</div><div class='del'>-	list_del_init(&amp;req-&gt;wait.entry);</div><div class='del'>-	spin_unlock(&amp;req-&gt;head-&gt;lock);</div><div class='add'>+		list_del_init(&amp;req-&gt;wait.entry);</div><div class='add'>+		poll_iocb_unlock_wq(req);</div><div class='add'>+	} /* else, POLLFREE has freed the waitqueue, so we must complete */</div><div class='ctx'> 	list_del_init(&amp;iocb-&gt;ki_list);</div><div class='ctx'> 	iocb-&gt;ki_res.res = mangle_poll(mask);</div><div class='ctx'> 	spin_unlock_irq(&amp;ctx-&gt;ctx_lock);</div><div class='hunk'>@@ -1667,13 +1713,14 @@ static int aio_poll_cancel(struct kiocb *iocb)</div><div class='ctx'> 	struct aio_kiocb *aiocb = container_of(iocb, struct aio_kiocb, rw);</div><div class='ctx'> 	struct poll_iocb *req = &amp;aiocb-&gt;poll;</div><div class='ctx'> </div><div class='del'>-	spin_lock(&amp;req-&gt;head-&gt;lock);</div><div class='del'>-	WRITE_ONCE(req-&gt;cancelled, true);</div><div class='del'>-	if (!req-&gt;work_scheduled) {</div><div class='del'>-		schedule_work(&amp;aiocb-&gt;poll.work);</div><div class='del'>-		req-&gt;work_scheduled = true;</div><div class='del'>-	}</div><div class='del'>-	spin_unlock(&amp;req-&gt;head-&gt;lock);</div><div class='add'>+	if (poll_iocb_lock_wq(req)) {</div><div class='add'>+		WRITE_ONCE(req-&gt;cancelled, true);</div><div class='add'>+		if (!req-&gt;work_scheduled) {</div><div class='add'>+			schedule_work(&amp;aiocb-&gt;poll.work);</div><div class='add'>+			req-&gt;work_scheduled = true;</div><div class='add'>+		}</div><div class='add'>+		poll_iocb_unlock_wq(req);</div><div class='add'>+	} /* else, the request was force-cancelled by POLLFREE already */</div><div class='ctx'> </div><div class='ctx'> 	return 0;</div><div class='ctx'> }</div><div class='hunk'>@@ -1725,7 +1772,8 @@ static int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,</div><div class='ctx'> 		 *</div><div class='ctx'> 		 * Don't remove the request from the waitqueue here, as it might</div><div class='ctx'> 		 * not actually be complete yet (we won't know until vfs_poll()</div><div class='del'>-		 * is called), and we must not miss any wakeups.</div><div class='add'>+		 * is called), and we must not miss any wakeups.  POLLFREE is an</div><div class='add'>+		 * exception to this; see below.</div><div class='ctx'> 		 */</div><div class='ctx'> 		if (req-&gt;work_scheduled) {</div><div class='ctx'> 			req-&gt;work_need_resched = true;</div><div class='hunk'>@@ -1733,6 +1781,28 @@ static int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,</div><div class='ctx'> 			schedule_work(&amp;req-&gt;work);</div><div class='ctx'> 			req-&gt;work_scheduled = true;</div><div class='ctx'> 		}</div><div class='add'>+</div><div class='add'>+		/*</div><div class='add'>+		 * If the waitqueue is being freed early but we can't complete</div><div class='add'>+		 * the request inline, we have to tear down the request as best</div><div class='add'>+		 * we can.  That means immediately removing the request from its</div><div class='add'>+		 * waitqueue and preventing all further accesses to the</div><div class='add'>+		 * waitqueue via the request.  We also need to schedule the</div><div class='add'>+		 * completion work (done above).  Also mark the request as</div><div class='add'>+		 * cancelled, to potentially skip an unneeded call to -&gt;poll().</div><div class='add'>+		 */</div><div class='add'>+		if (mask &amp; POLLFREE) {</div><div class='add'>+			WRITE_ONCE(req-&gt;cancelled, true);</div><div class='add'>+			list_del_init(&amp;req-&gt;wait.entry);</div><div class='add'>+</div><div class='add'>+			/*</div><div class='add'>+			 * Careful: this *must* be the last step, since as soon</div><div class='add'>+			 * as req-&gt;head is NULL'ed out, the request can be</div><div class='add'>+			 * completed and freed, since aio_poll_complete_work()</div><div class='add'>+			 * will no longer need to take the waitqueue lock.</div><div class='add'>+			 */</div><div class='add'>+			smp_store_release(&amp;req-&gt;head, NULL);</div><div class='add'>+		}</div><div class='ctx'> 	}</div><div class='ctx'> 	return 1;</div><div class='ctx'> }</div><div class='hunk'>@@ -1740,6 +1810,7 @@ static int aio_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,</div><div class='ctx'> struct aio_poll_table {</div><div class='ctx'> 	struct poll_table_struct	pt;</div><div class='ctx'> 	struct aio_kiocb		*iocb;</div><div class='add'>+	bool				queued;</div><div class='ctx'> 	int				error;</div><div class='ctx'> };</div><div class='ctx'> </div><div class='hunk'>@@ -1750,11 +1821,12 @@ aio_poll_queue_proc(struct file *file, struct wait_queue_head *head,</div><div class='ctx'> 	struct aio_poll_table *pt = container_of(p, struct aio_poll_table, pt);</div><div class='ctx'> </div><div class='ctx'> 	/* multiple wait queues per file are not supported */</div><div class='del'>-	if (unlikely(pt-&gt;iocb-&gt;poll.head)) {</div><div class='add'>+	if (unlikely(pt-&gt;queued)) {</div><div class='ctx'> 		pt-&gt;error = -EINVAL;</div><div class='ctx'> 		return;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='add'>+	pt-&gt;queued = true;</div><div class='ctx'> 	pt-&gt;error = 0;</div><div class='ctx'> 	pt-&gt;iocb-&gt;poll.head = head;</div><div class='ctx'> 	add_wait_queue(head, &amp;pt-&gt;iocb-&gt;poll.wait);</div><div class='hunk'>@@ -1786,6 +1858,7 @@ static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)</div><div class='ctx'> 	apt.pt._qproc = aio_poll_queue_proc;</div><div class='ctx'> 	apt.pt._key = req-&gt;events;</div><div class='ctx'> 	apt.iocb = aiocb;</div><div class='add'>+	apt.queued = false;</div><div class='ctx'> 	apt.error = -EINVAL; /* same as no support for IOCB_CMD_POLL */</div><div class='ctx'> </div><div class='ctx'> 	/* initialized the list so that we can do list_empty checks */</div><div class='hunk'>@@ -1794,9 +1867,10 @@ static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)</div><div class='ctx'> </div><div class='ctx'> 	mask = vfs_poll(req-&gt;file, &amp;apt.pt) &amp; req-&gt;events;</div><div class='ctx'> 	spin_lock_irq(&amp;ctx-&gt;ctx_lock);</div><div class='del'>-	if (likely(req-&gt;head)) {</div><div class='del'>-		spin_lock(&amp;req-&gt;head-&gt;lock);</div><div class='del'>-		if (list_empty(&amp;req-&gt;wait.entry) || req-&gt;work_scheduled) {</div><div class='add'>+	if (likely(apt.queued)) {</div><div class='add'>+		bool on_queue = poll_iocb_lock_wq(req);</div><div class='add'>+</div><div class='add'>+		if (!on_queue || req-&gt;work_scheduled) {</div><div class='ctx'> 			/*</div><div class='ctx'> 			 * aio_poll_wake() already either scheduled the async</div><div class='ctx'> 			 * completion work, or completed the request inline.</div><div class='hunk'>@@ -1812,7 +1886,7 @@ static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)</div><div class='ctx'> 		} else if (cancel) {</div><div class='ctx'> 			/* Cancel if possible (may be too late though). */</div><div class='ctx'> 			WRITE_ONCE(req-&gt;cancelled, true);</div><div class='del'>-		} else if (!list_empty(&amp;req-&gt;wait.entry)) {</div><div class='add'>+		} else if (on_queue) {</div><div class='ctx'> 			/*</div><div class='ctx'> 			 * Actually waiting for an event, so add the request to</div><div class='ctx'> 			 * active_reqs so that it can be cancelled if needed.</div><div class='hunk'>@@ -1820,7 +1894,8 @@ static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)</div><div class='ctx'> 			list_add_tail(&amp;aiocb-&gt;ki_list, &amp;ctx-&gt;active_reqs);</div><div class='ctx'> 			aiocb-&gt;ki_cancel = aio_poll_cancel;</div><div class='ctx'> 		}</div><div class='del'>-		spin_unlock(&amp;req-&gt;head-&gt;lock);</div><div class='add'>+		if (on_queue)</div><div class='add'>+			poll_iocb_unlock_wq(req);</div><div class='ctx'> 	}</div><div class='ctx'> 	if (mask) { /* no async, we'd stolen it */</div><div class='ctx'> 		aiocb-&gt;ki_res.res = mangle_poll(mask);</div><div class='head'>diff --git a/include/uapi/asm-generic/poll.h b/include/uapi/asm-generic/poll.h<br/>index 41b509f410bf9b..f9c520ce4bf4e4 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/asm-generic/poll.h?id=580c7e023303ce3a187adcaa40868bfc740725d2'>include/uapi/asm-generic/poll.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/asm-generic/poll.h?id=321fba81ec034f88aea4898993c1bf15605c023f'>include/uapi/asm-generic/poll.h</a></div><div class='hunk'>@@ -29,7 +29,7 @@</div><div class='ctx'> #define POLLRDHUP       0x2000</div><div class='ctx'> #endif</div><div class='ctx'> </div><div class='del'>-#define POLLFREE	(__force __poll_t)0x4000	/* currently only for epoll */</div><div class='add'>+#define POLLFREE	(__force __poll_t)0x4000</div><div class='ctx'> </div><div class='ctx'> #define POLL_BUSY_LOOP	(__force __poll_t)0x8000</div><div class='ctx'> </div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit 1.2.3-korg</a> (<a href='https://git-scm.com/'>git 2.43.0</a>) at 2025-01-10 11:21:22 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
