NEW![Sonar has entered a definitive agreement to acquire Tidelift! Read the press release.](/company/press-releases/sonar-to-acquire-tidelift/) [![](data:image/svg+xml;charset=utf-8...)![sonar logo ](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/8e59bcad-6e39-41dc-abd9-a0e251e8d63f/Sonar%20%282%29.svg?w=128&h=32&auto=format&fit=clip)![sonar logo ](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/8e59bcad-6e39-41dc-abd9-a0e251e8d63f/Sonar%20%282%29.svg?w=128&h=32&auto=format&fit=clip)](/ "Home")

* Solutions

  Use Cases

  [AI-assisted & quality-assured codeEnsure code generated by AI assistants is of the highest quality](/solutions/ai/)[DevOps transformationHarness the full potential of DevOps by reducing roll backs and improving quality of releases](/solutions/devops-transformation/)[Code coverageEnsure code quality and security by facilitating faster debugging through clear visibility of coverage gaps.](/solutions/code-coverage/) [Reduce & manage technical debtMaximize innovation by proactively managing technical debt](/solutions/reduce-technical-debt/)[Secure by designIntegrate code security in compliance with NIST Secure Software Development Framework](/solutions/secure-by-design-code/)[All Use CasesRead more about Sonar Use cases with blog articles, technical articles and developer guides](/solutions/use-cases/)

  Clean Code

  [What is clean codeA detailed definition of Clean Code](/solutions/clean-code/)[Power of clean codeBusiness success built on Clean Code](/solutions/power-of-clean-code/)[Security starts with Clean CodeStatic Application Security Testing with Sonar](/solutions/security/)[Clean as You CodeOur unique approach to Clean Code](/solutions/our-unique-approach/)

  Something For Everyone

  [For DevelopersFind and fix issues as you code](/solutions/for-developers/)[For DevOpsBuild your apps on Clean Code foundations](/solutions/infrastructure-as-code/)[For EnterpriseClean Code delivery from development to production](/solutions/for-enterprise/)[For the Public SectorClean Code for the public sector](/solutions/public-sector/)
* Products

  Industry Leading Products

  [![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/aa3b1f02-f1b0-448f-a3f2-a1bd32923a08/SQ_Logo_Cloud_Light%20Backgrounds.svg?w=176&h=48&auto=format&fit=crop)Formerly SonarCloudCloud-based static analysis tool for your CI/CD workflows](/products/sonarcloud/)[![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/bdac1871-464e-4051-88db-7df20c3bfffa/SQ_Logo_Server_Light%20Backgrounds.svg?w=176&h=48&auto=format&fit=crop)Formerly SonarQubeSelf-managed static analysis tool for continuous codebase inspection](/products/sonarqube/)[![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/49f23af2-a29b-4d0f-95d7-ffd361f375e1/SQ_Logo_IDE_Light%20Backgrounds.svg?w=176&h=48&auto=format&fit=crop)Formerly SonarLintFree IDE extension that provides on-the-fly analysis and coding guidance](/products/sonarlint/)

  Languages and Frameworks

  [Java](/knowledge/languages/java/)[JavaScript](/knowledge/languages/js/)[TypeScript](/knowledge/languages/ts/)[Python](/knowledge/languages/python/)[C#](/knowledge/languages/csharp/)[C++](/knowledge/languages/cpp/)[C](/knowledge/languages/c/)[PHP](/knowledge/languages/php/)[Kotlin](/knowledge/languages/kotlin/)[See All](/lp/knowledge/languages/)
* Resources

  Learn About Clean Code

  [BlogStay connected with our latest development news and articles](/blog/)[Events hubLet's meet up online or in person - browse our conferences and webinars, or watch previous talks](/resources/events/)[Customer StoriesCheck out Sonar implementation success stories](/resources/customer-stories/)[White PapersFind in-depth articles on clean code](/resources/white-papers/)[LearnDeveloper learning hub - covering essential topics](/learn/)[Solution BriefsOur library of solution briefs](/resources/solution-briefs/)

  Go In Depth

  [SonarQube Server DocumentationFind more information on the technical details of SonarQube Server](https://docs.sonarsource.com/sonarqube/latest/)[SonarQube Cloud DocumentationFind more information on the technical details of SonarQube Cloud](https://docs.sonarsource.com/sonarcloud/)[SonarQube for IDE DocumentationFind more information on the technical details of SonarQube IDE](https://docs.sonarsource.com/sonarlint/)[Explore SonarpediaExplore our publicly available multi-language rules database](https://rules.sonarsource.com/)[LanguagesSee our multi-language coverage](/knowledge/languages/)
* Company

  Deliver Better Software

  [About UsSonar’s industry leading solution enables developers to write clean code and remediate existing code organically](/company/about/)[CareersJoin our growing team](/company/careers/)[Commitment to open sourceOur commitment to transparency, security, and continuous improvement](/solutions/commitment-to-open-source/)[CommunityGet latest updates, suggest features, and share your knowledge](https://community.sonarsource.com/)[PartnersSonar partners with the best resellers to bring Clean Code closer to you](/company/partners/)[Contact usHave questions? Get in touch](/company/contact/)

  Media

  [NewsroomNews announcements, media coverage, and more](/company/newsroom/)[CoverageFind articles about Sonar in the news](/company/coverage/)[Press ReleasesThe latest Sonar updates](/company/press-releases/)[CustomersAn overview of customers using Sonar by industry](/company/customers/)[Press KitExecutive headshots, quick stats, customer logos, and more](/company/press-kit/)
[Start for free](/open-source-editions/)[Explore pricing](/plans-and-pricing/)
Search modal toggle button[Start for free](/open-source-editions/)[Explore pricing](/plans-and-pricing/)Mobile menu toggle button

Blog post

# Checkmk: Remote Code Execution by Chaining Multiple Bugs (1/3)

![](data:image/svg+xml;charset=utf-8...)![Stefan Schiller photo]()![Stefan Schiller photo](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/bfd8cc06-d437-4ab4-9039-66ec3affeeea/stefan.jpg?w=800&h=800&auto=format&fit=crop)

Stefan Schiller

Vulnerability Researcher

November 1, 2022

Date

* [Security](/blog/tag/security/)
![](data:image/svg+xml;charset=utf-8...)![We discovered multiple vulnerabilities in Checkmk, which can be chained together by an unauthenticated, remote attacker to fully take over a vulnerable server.](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/cec5521f-04da-46d8-a88f-82721c81c0f6/cover-b6ff7f15-3036-4275-b486-fe8beb0f33a7_CheckMK%2BRCE%2BChain_Blog_1200x627-2.png?w=2400&h=1254&auto=format&fit=crop)![We discovered multiple vulnerabilities in Checkmk, which can be chained together by an unauthenticated, remote attacker to fully take over a vulnerable server.](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/cec5521f-04da-46d8-a88f-82721c81c0f6/cover-b6ff7f15-3036-4275-b486-fe8beb0f33a7_CheckMK%2BRCE%2BChain_Blog_1200x627-2.png?w=2400&h=1254&auto=format&fit=crop)

Checkmk is a modern IT infrastructure monitoring solution developed in Python and C++. According to the vendor’s website, more than 2,000 customers rely on Checkmk. Due to its purpose, Checkmk is a central component usually deployed at a privileged position in a company’s network. This makes it a high-profile target for threat actors.

In our effort to help secure the open-source world, we decided to look at the open-source edition of Checkmk, which is based on a Nagios monitoring core and seamlessly integrates NagVis to visualize status data on maps and diagrams. During our research, we identified multiple vulnerabilities in Checkmk and its NagVis integration, which can be chained together by an unauthenticated, remote attacker to fully take over the server running a vulnerable version of Checkmk.

In this first article, in a series of three, we start by getting an overview of all identified vulnerabilities and a basic understanding of the Checkmk architecture. Furthermore, we determine the disastrous impact of chaining the identified vulnerabilities together. We also dive deep into the technical details of the first two vulnerabilities, which pave the way for an unauthenticated attacker to gain remote code execution.

## Impact

We discovered multiple vulnerabilities in Checkmk and its NagVis integration with the following CVSS scores assigned by the vendor:

* CVSS 9.1: Code Injection in watolib’s auth.php (CVE-2022-46836)
* CVSS 9.1: Arbitrary File Read in NagVis (CVE-2022-46945)
* CVSS 6.8: Line Feed Injection in ajax\_graph\_images.py (CVE-2022-47909)
* CVSS 5.0: Server-Side Request Forgery in agent-receiver (CVE-2022-48321)

These vulnerabilities can be chained together by an unauthenticated, remote attacker to gain code execution on the server running Checkmk version 2.1.0p10 and lower:

We verified the exploitation for the open-source Raw Edition by leveraging a specific feature of its monitoring core. It is likely that an attacker can use similar techniques to exploit a server running an Enterprise Editions.

All of these issues are fixed with Checkmk version 2.1.0p12. We strongly recommend updating any instance with a version before this release.

## Technical Details

In this section, we start by looking at the basic architecture of Checkmk and its components. Based on this, we outline how the identified vulnerabilities can be chained together by an attacker and deep dive into the technical details of the first two vulnerabilities, which are the beginning of a full chain to gain unauthenticated, remote code execution.

### Background

Checkmk is an IT infrastructure monitoring solution similar to Zabbix or Icinga. The configuration and monitoring of servers, networks, applications, etc., is done via a web interface. This user-facing component is developed in Python and is called Checkmk GUI.

In order to retrieve additional information from the monitored systems, it is possible to deploy a monitoring agent on these systems. The component responsible for registering agents and receiving data from these agents is called the agent-receiver.

The following picture outlines the basic architecture of Checkmk:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/ae791816-c5a1-4c21-9755-c1936717d1b5/body-56ba7506-82d9-4b1f-98ea-dd5aff445ab0_checkmk-architecture.png?w=950&h=396&auto=format&fit=crop)

Checkmk exposes two ports on the external network interface by default:

* TCP port 80: actual web interface
* TCP port 8000: agent-receiver

The first component of the web interface is an Apache web server running on TCP port 80, which serves as a reverse proxy. It is possible to run multiple Checkmk instances on a single host. These instances are called monitoring sites or simply sites. For each site, a dedicated, internal Apache server is spawned. The purpose of the outer reverse proxy is to map requests for a specific site to the corresponding internal Apache server dedicated to the requested site. In the picture above, the site `monitoring` is mapped to the Apache server running on TCP port 5000. From the outside, this Apache server can only be reached via the reverse proxy because it only listens on localhost.

The site-dedicated Apache server forwards requests to either the actual Checkmk GUI, a Python WSGI application, or via FCGI to a PHP wrapper in order to integrate the NagVis PHP component.

The heart of Checkmk is the monitoring core, which is responsible for initiating checks, collecting data, detecting state changes, and providing information to the GUI. While the Checkmk Enterprise Editions have their own monitoring core, the open-source Raw Edition uses a Nagios monitoring core. To retrieve data from it, the core provides an interface called Livestatus, which is implemented as a C++ Nagios broker module called `livestatus.o`. This interface uses a proprietary protocol called Livestatus Query Language (LQL), which is similar to both HTTP and SQL. For example, a query to retrieve the name and IP address of all monitored hosts, which are in `DOWN` (`1`) or `UNREACH` (`2`) state, looks like this:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/370c1d0d-b6b5-4081-93d3-3926b2bcdff0/body-c8c4d41f-6c49-4f93-b107-4581c88947b5_checkmk-lql01.png?w=184&h=96&auto=format&fit=crop)

The response may look like this:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/918bfc87-0ea1-4e2d-9a08-09762001f068/body-2bdbf195-1413-46f6-ae01-fae0a3e84331_checkmk-lql02.png?w=462&h=16&auto=format&fit=crop)

More advanced queries can be built by using additional headers. Whenever the GUI needs some data from the core, it sends an LQL query to it, and the core responds with the requested data.

The second component directly reachable via the external interface is the `agent-receiver`. The agent-receiver is a FastAPI web server listening on TCP port 8000, which provides different routes for registering agents and collecting data from these agents.

With this basic understanding of Checkmk’s components, let’s see how an unauthenticated attacker would be able to chain the identified code vulnerabilities together in order to gain remote code execution.

### Exploitation Chain

Some of the identified vulnerabilities have limited practical impact on their own. However, a malicious attacker can chain them together to achieve remote code execution.

The following picture summarizes what abilities the exploitation of an individual vulnerability yields and how an attacker can build on this ability to leverage the following vulnerability to further increase control, which finally results in unauthenticated, remote code execution:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/513dbea0-f520-4135-9136-fdd6f4284af6/body-fee129ee-2bd1-496a-9e34-2cbabbf0e3b2_checkmk-chain-all.png?w=695&h=537&auto=format&fit=crop)

The exploitation chain starts with a Server-Side Request Forgery in the agent-receiver (1), which can be leveraged by an attacker to access an endpoint only reachable from localhost. This endpoint is vulnerable to a Line Feed Injection (2). This gives an attacker the ability to forge arbitrary LQL queries, which are used by the Checkmk GUI to retrieve data from the monitoring core. An attacker can take advantage of this ability to delete arbitrary files, which can further be leveraged to bypass the authentication mechanism in the NagVis component.

Once an attacker has gained access to the NagVis component, an authenticated Arbitrary File Read vulnerability (3) in NagVis can be leveraged to read a special Checkmk configuration file called `automation.secret`. With access to the contents of this file, an attacker can gain access to the Checkmk GUI in the context of the automation user. This access can further be turned into remote code execution by exploiting a Code Injection vulnerability (4) in a Checkmk GUI subcomponent called `watolib`, which generates a file named `auth.php` required for the NagVis integration.

After this rough overview of the exploitation chain, let’s dive into the technical details of the first two code vulnerabilities:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/cabcbae5-c8fc-4c9d-8b75-a71530f6fea6/body-0be46e6a-d02d-432c-bd7b-65086e8da82e_checkmk-chain-01.png?w=545&h=295&auto=format&fit=crop)
### Server-Side Request Forgery in agent-receiver (CVE-2022-48321)

The Checkmk agent-receiver is a FastAPI web server, which is by default exposed on TCP port 8000. Most of the provided endpoints forward requests to the Checkmk REST API, which is part of the Checkmk GUI exposed on TCP port 80.

The endpoint called `/register_with_hostname` expects a POST request with credentials provided via HTTP Basic authentication as well as the two JSON-encoded parameters `uuid` and `host_name` in the body. The endpoint handler itself only verifies that any credentials are provided and that the two parameters are present.

In order to retrieve and validate the host configuration of the host identified by the `host_name` parameter, the function `host_configuration` is called:

**checkmk/agent-receiver/agent-receiver/endpoints.py**

```
@agent_receiver_app.post(
   "/register_with_hostname",
   status_code=HTTP_204_NO_CONTENT,
)
async def register_with_hostname(
   *,
   credentials: HTTPBasicCredentials = Depends(security),
   registration_body: RegistrationWithHNBody,
) -> Response:
   _validate_registration_request(
       host_configuration(
           credentials,
           registration_body.host_name,
       )
   )
```

The `host_configuration` function forwards the request to the Checkmk REST API by calling the function `_forward_get`. The user-provided parameter `host_name` is appended to the target URL without any sanitization or encoding:

**checkmk/agent-receiver/agent-receiver/checkmk\_rest\_api.py**

```
def host_configuration(
   credentials: HTTPBasicCredentials,
   host_name: str,
) -> HostConfiguration:
   if (
       response := _forward_get(
           f"objects/host_config_internal/{host_name}",
           credentials,
       )
   ).status_code == HTTPStatus.OK:
```

This lack of sanitization and encoding leads to a limited Server-Side Request Forgery (SSRF) vulnerability.

At first, the impact of this vulnerability does not seem to be very high because the SSRF is limited to a GET request to the hostname and port of the Checkmk GUI, and an attacker cannot even read the response. However, this gives an attacker the essential ability to exploit a second vulnerability. Let’s have a look at it.

### Line Feed Injection in ajax\_graph\_images.py (CVE-2022-47909)

The Checkmk GUI only provides a minimal number of unauthenticated endpoints. This greatly reduces the attack surface. One of the unauthenticated endpoints is called `/ajax_graph_images.py`, whose endpoint handler is implemented in the function `ajax_graph_images_for_notifications`. The purpose of this endpoint is to generate an image with performance data for a given host or service.

Although this endpoint can be accessed unauthenticated, access is restricted by only allowing requests, which originate from localhost (`127.0.0.1` or `::1`):

**checkmk/cmk/gui/plugins/metrics/graph\_images.py**

```
def ajax_graph_images_for_notifications(
   resolve_combined_single_metric_spec: Callable[
       [CombinedGraphSpec], Sequence[CombinedGraphMetricSpec]
   ],
) -> None:
   """Registered as `noauth:ajax_graph_images`."""
   if request.remote_ip not in ["127.0.0.1", "::1"]:
       raise MKUnauthenticatedException(
           _("You are not allowed to access this page (%s).") % request.remote_ip
       )

   with SuperUserContext():
       _answer_graph_image_request(resolve_combined_single_metric_spec)
```

After verifying that the request originates from localhost, the function `_answer_graph_image_request` is called. This function validates that a `host` GET parameter is provided and then calls `get_graph_data_from_livestatus`:

**checkmk/cmk/gui/plugins/metrics/graph\_images.py**

```
def _answer_graph_image_request(
   resolve_combined_single_metric_spec: Callable[
       [CombinedGraphSpec], Sequence[CombinedGraphMetricSpec]
   ],
) -> None:
   try:
       host_name = request.get_ascii_input_mandatory("host")
       if not host_name:
           raise MKGeneralException(_('Missing mandatory "host" parameter'))
       ...
       try:
           row = get_graph_data_from_livestatus(site, host_name, service_description)
```

The function `get_graph_data_from_livestatus` retrieves performance data for the given host via the Livestatus Query Language (LQL) interface. When inspecting all invoked functions within the call stack, the `_ensure_connected` function caught our attention:

**checkmk/cmk/gui/sites.py**

```
def _ensure_connected(user: Optional[LoggedInUser], force_authuser: Optional[UserId]) -> None:
   ...
   if force_authuser is None:
       request_force_authuser = request.get_str_input("force_authuser")
       force_authuser = UserId(request_force_authuser) if request_force_authuser else None
   ...
   _set_livestatus_auth(user, force_authuser)
```

Although this is an internal function part of the code responsible for querying the LQL interface, a GET parameter called `force_authuser` is accessed. Further inspecting the call stack reveals that this GET parameter is inserted into the `AuthUser` header of the LQL query without any sanitization:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/7825f82a-64fc-4f61-9a7f-a904d193fa41/body-e318ed88-2801-4022-8008-52278c807470_checkmk-call-chain.png?w=671&h=533&auto=format&fit=crop)

The `AuthUser` header is used to restrict the response to data that the specified user is allowed to see. However, this is not essential for our considerations. The important aspect is that the above `AuthUser` string contains the value of the GET parameter `force_authuser` and this string is inserted into the final LQL query sent to the monitoring core. Since the GET parameter `force_authuser` is not sanitized, it is also possible to insert line feed characters (`0x0a`) into the LQL query.

Usually, an external attacker cannot reach the vulnerable endpoint `/ajax_graph_images.py` because it is restricted to localhost only. When combined with the SSRF vulnerability in the agent-receiver this assumption is not valid anymore. The SSRF can for example be used to trigger a request with the following GET parameter:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/cb4aa71c-c800-4238-b104-2143a02744a2/body-e60362bc-c948-4f30-a479-13361f2d6f0b_checkmk-lql03.png?w=157&h=14&auto=format&fit=crop)

This request results in the following LQL query sent to the core:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/f99c493c-2621-4db0-9f45-9afd1a1c48e0/body-9c478387-d0cc-447c-a268-3b2642531ada_checkmk-lql04.png?w=272&h=194&auto=format&fit=crop)

By using a line feed character in the `force_authuser` parameter, additional headers can be injected into the LQL query:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/d986d7f6-c177-48fa-b6e3-2a89da050952/body-ca7068d7-f018-4ce8-a73e-af5d1afbe4f8_checkmk-lql05.png?w=350&h=14&auto=format&fit=crop)

The resulting LQL query contains the additional header:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/53cdfe7b-d1cd-4ad7-92e2-9a4b55446755/body-c0bf8765-7219-410b-afe4-acb30c23fda7_checkmk-lql06.png?w=351&h=194&auto=format&fit=crop)

The ability to inject a whole new query in order to use other tables or commands would increase the attack surface even more. An attacker could try to add two line feed characters and insert a new query after these:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/0990d946-c8e1-437d-b469-c1e7d45a53fd/body-6f87ff83-4563-44d8-a7e7-914755d75e4b_checkmk-lql07.png?w=332&h=14&auto=format&fit=crop)

However, the LQL interface terminates the connection by default if two subsequent line feed characters are read, which form the end of a single query. Thus the second query is not evaluated:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/012c2ca4-069e-4d7e-8033-f1196ef32b0e/body-5d27877e-3e24-4941-ae23-0e06e20b52f9_checkmk-lql08.png?w=359&h=133&auto=format&fit=crop)

This behavior can be altered by leveraging the `KeepAlive` header. When this header is set to `on`, the connection will be kept alive. This way whole new LQL queries can be injected:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/91965d31-1d7b-4942-955e-d455eacee56b/body-4e5a78ae-76c4-4aae-a4ea-04dc51a0166d_checkmk-lql09.png?w=694&h=16&auto=format&fit=crop)

This results in three distinct LQL queries, which are processed separately.

Query 1:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/70a8ca1f-1ae1-493b-96f3-69a81c3c9147/body-02382b7a-8857-4dbb-bdc3-8e0b6798a7b4_checkmk-lql10.png?w=351&h=96&auto=format&fit=crop)

Query 2:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/15083dab-a18a-4d20-9463-191a46264108/body-3f34cb05-829c-4e03-9e54-5d39416a999f_checkmk-lql11.png?w=123&h=13&auto=format&fit=crop)

Query 3:

![](data:image/svg+xml;charset=utf-8...)![]()![](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/e0e965b2-9cb7-4a20-8321-096be8f6c9c5/body-0e888fc8-99ac-4952-9cb2-946cf15a2e44_checkmk-lql12.png?w=202&h=114&auto=format&fit=crop)

The second query can be fully controlled by an attacker.

With this ability, an attacker has literally made it to the core of Checkmk. Within the next article of this series, we will explore the LQL interface as a new attack surface and see how some minor differences in a developer’s implementation can prevent or enable an attacker to bypass authentication mechanisms.

### Patch

Checkmk patched the [limited SSRF](https://checkmk.com/werk/14385 "limited SSRF") in the agent-receiver in version 2.1.0p12 ([commit](https://github.com/tribe29/checkmk/commit/2a384409a17c33422964f9d61327aaf49da069e7 "commit")). According to our recommendations, the endpoint handler for `/register_with_hostname` now URL-encodes the `host_name` parameter before inserting it into the URL:

**checkmk/agent-receiver/agent-receiver/checkmk\_rest\_api.py**

```
from urllib.parse import quote
...

def _url_encode_hostname(host_name: str) -> str:
    ...
    return quote(host_name, safe="")  # '/' is not "safe" here
...

def host_configuration(...):
   ...
       response := _forward_get(
           f"objects/host_config_internal/{_url_encode_hostname(
host_name)}", ...)
   ...
```

This prevents an attacker from accessing other endpoints than the intended one when the request is forwarded to the Checkmk REST API.

The [Line Feed Injection vulnerability](https://checkmk.com/werk/14384 "Line Feed Injection vulnerability") was also patched with version 2.1.0p12 ([commit](https://github.com/tribe29/checkmk/commit/2e8cf315be262df7a749c55f205ff21f895a84db "commit")) by validating the value provided for the `AuthUser` header:

**checkmk/livestatus/api/python/livestatus.py**

```
# Pattern for allowed UserId values
validate_user_id_regex = re.compile(r"^[\w_][-\w.@_]*$")
...
   # Set user to be used in certain authorization domain
   def set_auth_user(self, domain: str, user: UserId) -> None:
       # Prevent setting AuthUser to values that would be rejected later. See Werk 14384.
       # Empty value is allowed and used to delete from auth_users dict.
       if user and validate_user_id_regex.match(user) is None:
           raise ValueError("Invalid user ID")
```

Also, an additional check for injected line feed characters was introduced:

**checkmk/livestatus/api/python/livestatus.py**

```
def build_query(self, query_obj: Query, add_headers: str) -> str:
       # Prevent injection of further livestatus commands inside AuthUser header.
       if "\n" in self.auth_header[:-1]:
           raise MKLivestatusQueryError("Refusing to build query with invalid AuthUser header.")
```

These patches effectively prevent an attacker from injecting line feed characters in the `force_authuser` parameter.

## Timeline

| **Date** | **Action** |
| --- | --- |
| 2022-08-22 | We report all issues to Checkmk. |
| 2022-08-23 | Vendor confirms all issues. |
| 2022-09-15 | Vendor releases patched version 2.1.0p12. |

## Summary

In this first article in a series of three, we briefly introduced the Checkmk architecture and outlined the vulnerabilities we identified including the serious impact of chaining these together. We also did a technical deep dive into the first two vulnerabilities, which enable an external attacker to send arbitrary LQL queries to the monitoring core.

The root cause of most vulnerabilities is the lack of sanitization of user-controlled data. This is also true for both of the vulnerabilities we looked at. The Line Feed Injection vulnerability is somehow hard to spot because the user-controlled data is accessed by a function deep down in the call stack and not directly in the endpoint handler. This is generally a bad pattern and should be prevented.

In the next article in this series, we will have a more detailed look at the LQL interface and derive the impact of an attacker’s ability to forge arbitrary queries. We will also look at Checkmk’s NagVis integration and how the aforementioned ability can be leveraged to bypass the authentication of NagVis due to some specific implementation details.

Finally, we would like to thank the Checkmk team very much for quickly responding to our report, handling each issue with absolute transparency, and providing a comprehensive patch for all reported vulnerabilities.

## Related Blog Posts

* [Checkmk: Remote Code Execution by Chaining Multiple Bugs (2/3)](https://www.sonarsource.com/blog/checkmk-rce-chain-2/ "Checkmk: Remote Code Execution by Chaining Multiple Bugs (2/3)")
* [Checkmk: Remote Code Execution by Chaining Multiple Bugs (3/3)](https://www.sonarsource.com/blog/checkmk-rce-chain-3/ "Checkmk: Remote Code Execution by Chaining Multiple Bugs (3/3)")
* [Zabbix - A Case Study of Unsafe Session Storage](https://www.sonarsource.com/blog/zabbix-case-study-of-unsafe-session-storage/ "Zabbix - A Case Study of Unsafe Session Storage")
* [Path Traversal Vulnerabilities in Icinga Web](https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/ "Path Traversal Vulnerabilities in Icinga Web")
#### SHARE

[twitter](https://twitter.com/share?text=undefined)[facebook](https://www.facebook.com/sharer/sharer.php?u=undefined)[linkedin](https://www.linkedin.com/sharing/share-offsite/?url=undefined)mail[Go to SonarSource homepage![](data:image/svg+xml;charset=utf-8...)![sonar logo ]()![sonar logo ](https://assets-eu-01.kc-usercontent.com:443/7630306f-9a2f-018d-2726-3ef76ef712f4/8e59bcad-6e39-41dc-abd9-a0e251e8d63f/Sonar%20%282%29.svg?w=160&h=40&auto=format&fit=crop)](/)

* **Sonar Solutions**
  + [SAST](/solutions/security/)
  + [What is clean code](/solutions/clean-code/)
  + [Power of clean code](/solutions/power-of-clean-code/)
  + [Clean as you code](/solutions/our-unique-approach/)
  + [AI-assisted & quality-assured code](/solutions/ai/)
  + [DevOps transformation](/solutions/devops-transformation/)
  + [Outsourcing software development](/solutions/reduce-outsourcing-software-development-risk/)
  + [Reduce & manage technical debt](/solutions/reduce-technical-debt/)
  + [Secure by design](/solutions/secure-by-design-code/)
  + [Code coverage](/solutions/code-coverage/)
  + [Code review](/solutions/code-review/)
  + [For developers](/solutions/for-developers/)
  + [For enterprise](/solutions/for-enterprise/)
  + [Infrastructure as code](/solutions/infrastructure-as-code/)
  + [Public sector](/solutions/public-sector/)
* **Products**
  + [SonarQube for IDE](/products/sonarlint/)
  + [SonarQube Server](/products/sonarqube/)
  + [SonarQube Cloud](/products/sonarcloud/)**Pricing**
  + [Start for free](/open-source-editions/)
  + [Explore pricing](/plans-and-pricing/)
* **Company**
  + [About](/company/about/)
  + [Careers](/company/careers/)
  + [Commitment to open source](/solutions/commitment-to-open-source/)
  + [Customers](/company/customers/)
  + [Partners](/company/partners/)
  + [Contact us](/company/contact/)
  + [Accessibility](/accessibility/)
  + [NEW! Brand identity](/brand-identity/)**Media**
  + [Coverage](/company/coverage/)
  + [Press releases](/company/press-releases/)
* **Resources**
  + [Events hub](/resources/events/)
  + [Customer stories](/resources/customer-stories/)
  + [White papers](/resources/white-papers/)
  + [Learn](/learn/guide/)
  + [Community](https://community.sonarsource.com/)
  + [Support](/support/)
* **Knowledge**
  + [Explore Sonarpedia](https://rules.sonarsource.com/)
  + [Blog](/blog/)
  + [Languages](/knowledge/languages/)
  + [SonarQube Server Documentation](https://docs.sonarsource.com/sonarqube/latest/)
  + [SonarQube Cloud Documentation](https://docs.sonarsource.com/sonarcloud/)
  + [SonarQube for IDE Documentation](https://docs.sonarsource.com/sonarlint/)

* [Legal documentation](/legal/)
* [Trust center](/trust-center/)

* [Follow SonarSource on Twitter](https://twitter.com/sonarsource)
* [Follow SonarSource on Linkedin](https://www.linkedin.com/company/sonarsource/)

© 2008-2025 SonarSource SA. All rights reserved. SONAR, SONARSOURCE, SONARQUBE, and CLEAN AS YOU CODE are trademarks of SonarSource SA.

