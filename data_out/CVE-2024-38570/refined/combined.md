=== Content from git.kernel.org_3ff473bf_20250110_184314.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andreas Gruenbacher <agruenba@redhat.com> | 2024-04-10 04:50:18 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-30 09:49:14 +0200 |
| commit | [e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)) | |
| tree | [886a0502ed8ffe1dbdcf2af06cfec5ccc4712df3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | |
| parent | [027fd5c39dfef00db89cc02ad62def008b4a7a7a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0&id2=027fd5c39dfef00db89cc02ad62def008b4a7a7a)) | |
| download | [linux-e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0.tar.gz) | |

gfs2: Fix potential glock use-after-free on unmount[ Upstream commit d98779e687726d8f8860f1c54b5687eec5f63a73 ]
When a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically. Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace. This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.
To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd\_dead\_glocks list, release
the lockspace, and only then free those glocks.
As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.
Fixes: fb6791d100d1b ("GFS2: skip dlm\_unlock calls in unmount")
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Cc: David Teigland <teigland@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)

| -rw-r--r-- | [fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.h?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/incore.h?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/lock_dlm.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/ops_fstype.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/super.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 57 insertions, 16 deletions

| diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.cindex 5d5b3235d4e591..1bf0d751ece0ac 100644--- a/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -166,18 +166,45 @@ static bool glock\_blocked\_by\_withdraw(struct gfs2\_glock \*gl) return true; } -void gfs2\_glock\_free(struct gfs2\_glock \*gl)+static void \_\_gfs2\_glock\_free(struct gfs2\_glock \*gl) {- struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;- rhashtable\_remove\_fast(&gl\_hash\_table, &gl->gl\_node, ht\_parms); smp\_mb(); wake\_up\_glock(gl); call\_rcu(&gl->gl\_rcu, gfs2\_glock\_dealloc);+}++void gfs2\_glock\_free(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ \_\_gfs2\_glock\_free(gl); if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal)) wake\_up(&sdp->sd\_kill\_wait); } +void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ spin\_lock(&lru\_lock);+ list\_add(&gl->gl\_lru, &sdp->sd\_dead\_glocks);+ spin\_unlock(&lru\_lock);+ if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal))+ wake\_up(&sdp->sd\_kill\_wait);+}++static void gfs2\_free\_dead\_glocks(struct gfs2\_sbd \*sdp)+{+ struct list\_head \*list = &sdp->sd\_dead\_glocks;++ while(!list\_empty(list)) {+ struct gfs2\_glock \*gl;++ gl = list\_first\_entry(list, struct gfs2\_glock, gl\_lru);+ list\_del\_init(&gl->gl\_lru);+ \_\_gfs2\_glock\_free(gl);+ }+}+ /\*\* \* gfs2\_glock\_hold() - increment reference count on glock \* @gl: The glock to hold@@ -2226,6 +2253,8 @@ void gfs2\_gl\_hash\_clear(struct gfs2\_sbd \*sdp) wait\_event\_timeout(sdp->sd\_kill\_wait, atomic\_read(&sdp->sd\_glock\_disposal) == 0, HZ \* 600);+ gfs2\_lm\_unmount(sdp);+ gfs2\_free\_dead\_glocks(sdp); glock\_hash\_walk(dump\_glock\_func, sdp); } diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.hindex 0114f3e0ebe017..86987a59a05806 100644--- a/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -252,6 +252,7 @@ void gfs2\_gl\_dq\_holders(struct gfs2\_sbd \*sdp); void gfs2\_glock\_thaw(struct gfs2\_sbd \*sdp); void gfs2\_glock\_add\_to\_lru(struct gfs2\_glock \*gl); void gfs2\_glock\_free(struct gfs2\_glock \*gl);+void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl);  int \_\_init gfs2\_glock\_init(void); void gfs2\_glock\_exit(void);diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.hindex 95a334d64da2a3..60abd7050c9983 100644--- a/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -838,6 +838,7 @@ struct gfs2\_sbd { /\* For quiescing the filesystem \*/ struct gfs2\_holder sd\_freeze\_gh; struct mutex sd\_freeze\_mutex;+ struct list\_head sd\_dead\_glocks;  char sd\_fsname[GFS2\_FSNAME\_LEN + 3 \* sizeof(int) + 2]; char sd\_table\_name[GFS2\_FSNAME\_LEN];diff --git a/fs/gfs2/lock\_dlm.c b/fs/gfs2/lock\_dlm.cindex d1ac5d0679ea6a..e028e55e67d95f 100644--- a/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -121,6 +121,11 @@ static void gdlm\_ast(void \*arg) struct gfs2\_glock \*gl = arg; unsigned ret = gl->gl\_state; + /\* If the glock is dead, we only react to a dlm\_unlock() reply. \*/+ if (\_\_lockref\_is\_dead(&gl->gl\_lockref) &&+ gl->gl\_lksb.sb\_status != -DLM\_EUNLOCK)+ return;+ gfs2\_update\_reply\_times(gl); BUG\_ON(gl->gl\_lksb.sb\_flags & DLM\_SBF\_DEMOTED); @@ -171,6 +176,9 @@ static void gdlm\_bast(void \*arg, int mode) { struct gfs2\_glock \*gl = arg; + if (\_\_lockref\_is\_dead(&gl->gl\_lockref))+ return;+ switch (mode) { case DLM\_LOCK\_EX: gfs2\_glock\_cb(gl, LM\_ST\_UNLOCKED);@@ -291,8 +299,12 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) struct lm\_lockstruct \*ls = &sdp->sd\_lockstruct; int error; - if (gl->gl\_lksb.sb\_lkid == 0)- goto out\_free;+ BUG\_ON(!\_\_lockref\_is\_dead(&gl->gl\_lockref));++ if (gl->gl\_lksb.sb\_lkid == 0) {+ gfs2\_glock\_free(gl);+ return;+ }  clear\_bit(GLF\_BLOCKING, &gl->gl\_flags); gfs2\_glstats\_inc(gl, GFS2\_LKS\_DCOUNT);@@ -300,13 +312,17 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) gfs2\_update\_request\_times(gl);  /\* don't want to call dlm if we've unmounted the lock protocol \*/- if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags))- goto out\_free;+ if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags)) {+ gfs2\_glock\_free(gl);+ return;+ } /\* don't want to skip dlm\_unlock writing the lvb when lock has one \*/  if (test\_bit(SDF\_SKIP\_DLM\_UNLOCK, &sdp->sd\_flags) &&- !gl->gl\_lksb.sb\_lvbptr)- goto out\_free;+ !gl->gl\_lksb.sb\_lvbptr) {+ gfs2\_glock\_free\_later(gl);+ return;+ }  again: error = dlm\_unlock(ls->ls\_dlm, gl->gl\_lksb.sb\_lkid, DLM\_LKF\_VALBLK,@@ -321,10 +337,6 @@ again: gl->gl\_name.ln\_type, (unsigned long long)gl->gl\_name.ln\_number, error); }- return;--out\_free:- gfs2\_glock\_free(gl); }  static void gdlm\_cancel(struct gfs2\_glock \*gl)diff --git a/fs/gfs2/ops\_fstype.c b/fs/gfs2/ops\_fstype.cindex 1281e60be63900..db0df091a6a76c 100644--- a/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -136,6 +136,7 @@ static struct gfs2\_sbd \*init\_sbd(struct super\_block \*sb) atomic\_set(&sdp->sd\_log\_in\_flight, 0); init\_waitqueue\_head(&sdp->sd\_log\_flush\_wait); mutex\_init(&sdp->sd\_freeze\_mutex);+ INIT\_LIST\_HEAD(&sdp->sd\_dead\_glocks);  return sdp; diff --git a/fs/gfs2/super.c b/fs/gfs2/super.cindex e5f79466340d2a..2d780b4701a23b 100644--- a/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=027fd5c39dfef00db89cc02ad62def008b4a7a7a)+++ b/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=e42e8a24d7f02d28763d16ca7ec5fc6d1f142af0)@@ -646,10 +646,7 @@ restart: gfs2\_gl\_hash\_clear(sdp); truncate\_inode\_pages\_final(&sdp->sd\_aspace); gfs2\_delete\_debugfs\_file(sdp);- /\* Unmount the locking protocol \*/- gfs2\_lm\_unmount(sdp); - /\* At this point, we're through participating in the lockspace \*/ gfs2\_sys\_fs\_del(sdp); free\_sbd(sdp); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 18:41:52 +0000



=== Content from git.kernel.org_86f0f215_20250110_184313.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andreas Gruenbacher <agruenba@redhat.com> | 2024-04-10 04:50:18 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-30 09:44:24 +0200 |
| commit | [501cd8fabf621d10bd4893e37f6ce6c20523c8ca](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)) | |
| tree | [5d19ee90afffc4d3f62f90d0e7631d5f1ce911fc](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | |
| parent | [666a7a9b6ddafe7802ae6a53f513d17e790056a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca&id2=666a7a9b6ddafe7802ae6a53f513d17e790056a0)) | |
| download | [linux-501cd8fabf621d10bd4893e37f6ce6c20523c8ca.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-501cd8fabf621d10bd4893e37f6ce6c20523c8ca.tar.gz) | |

gfs2: Fix potential glock use-after-free on unmount[ Upstream commit d98779e687726d8f8860f1c54b5687eec5f63a73 ]
When a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically. Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace. This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.
To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd\_dead\_glocks list, release
the lockspace, and only then free those glocks.
As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.
Fixes: fb6791d100d1b ("GFS2: skip dlm\_unlock calls in unmount")
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Cc: David Teigland <teigland@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)

| -rw-r--r-- | [fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.h?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/incore.h?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/lock_dlm.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/ops_fstype.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/super.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 57 insertions, 16 deletions

| diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.cindex 5d5b3235d4e591..1bf0d751ece0ac 100644--- a/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -166,18 +166,45 @@ static bool glock\_blocked\_by\_withdraw(struct gfs2\_glock \*gl) return true; } -void gfs2\_glock\_free(struct gfs2\_glock \*gl)+static void \_\_gfs2\_glock\_free(struct gfs2\_glock \*gl) {- struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;- rhashtable\_remove\_fast(&gl\_hash\_table, &gl->gl\_node, ht\_parms); smp\_mb(); wake\_up\_glock(gl); call\_rcu(&gl->gl\_rcu, gfs2\_glock\_dealloc);+}++void gfs2\_glock\_free(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ \_\_gfs2\_glock\_free(gl); if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal)) wake\_up(&sdp->sd\_kill\_wait); } +void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ spin\_lock(&lru\_lock);+ list\_add(&gl->gl\_lru, &sdp->sd\_dead\_glocks);+ spin\_unlock(&lru\_lock);+ if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal))+ wake\_up(&sdp->sd\_kill\_wait);+}++static void gfs2\_free\_dead\_glocks(struct gfs2\_sbd \*sdp)+{+ struct list\_head \*list = &sdp->sd\_dead\_glocks;++ while(!list\_empty(list)) {+ struct gfs2\_glock \*gl;++ gl = list\_first\_entry(list, struct gfs2\_glock, gl\_lru);+ list\_del\_init(&gl->gl\_lru);+ \_\_gfs2\_glock\_free(gl);+ }+}+ /\*\* \* gfs2\_glock\_hold() - increment reference count on glock \* @gl: The glock to hold@@ -2226,6 +2253,8 @@ void gfs2\_gl\_hash\_clear(struct gfs2\_sbd \*sdp) wait\_event\_timeout(sdp->sd\_kill\_wait, atomic\_read(&sdp->sd\_glock\_disposal) == 0, HZ \* 600);+ gfs2\_lm\_unmount(sdp);+ gfs2\_free\_dead\_glocks(sdp); glock\_hash\_walk(dump\_glock\_func, sdp); } diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.hindex 0114f3e0ebe017..86987a59a05806 100644--- a/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -252,6 +252,7 @@ void gfs2\_gl\_dq\_holders(struct gfs2\_sbd \*sdp); void gfs2\_glock\_thaw(struct gfs2\_sbd \*sdp); void gfs2\_glock\_add\_to\_lru(struct gfs2\_glock \*gl); void gfs2\_glock\_free(struct gfs2\_glock \*gl);+void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl);  int \_\_init gfs2\_glock\_init(void); void gfs2\_glock\_exit(void);diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.hindex 95a334d64da2a3..60abd7050c9983 100644--- a/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -838,6 +838,7 @@ struct gfs2\_sbd { /\* For quiescing the filesystem \*/ struct gfs2\_holder sd\_freeze\_gh; struct mutex sd\_freeze\_mutex;+ struct list\_head sd\_dead\_glocks;  char sd\_fsname[GFS2\_FSNAME\_LEN + 3 \* sizeof(int) + 2]; char sd\_table\_name[GFS2\_FSNAME\_LEN];diff --git a/fs/gfs2/lock\_dlm.c b/fs/gfs2/lock\_dlm.cindex d1ac5d0679ea6a..e028e55e67d95f 100644--- a/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -121,6 +121,11 @@ static void gdlm\_ast(void \*arg) struct gfs2\_glock \*gl = arg; unsigned ret = gl->gl\_state; + /\* If the glock is dead, we only react to a dlm\_unlock() reply. \*/+ if (\_\_lockref\_is\_dead(&gl->gl\_lockref) &&+ gl->gl\_lksb.sb\_status != -DLM\_EUNLOCK)+ return;+ gfs2\_update\_reply\_times(gl); BUG\_ON(gl->gl\_lksb.sb\_flags & DLM\_SBF\_DEMOTED); @@ -171,6 +176,9 @@ static void gdlm\_bast(void \*arg, int mode) { struct gfs2\_glock \*gl = arg; + if (\_\_lockref\_is\_dead(&gl->gl\_lockref))+ return;+ switch (mode) { case DLM\_LOCK\_EX: gfs2\_glock\_cb(gl, LM\_ST\_UNLOCKED);@@ -291,8 +299,12 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) struct lm\_lockstruct \*ls = &sdp->sd\_lockstruct; int error; - if (gl->gl\_lksb.sb\_lkid == 0)- goto out\_free;+ BUG\_ON(!\_\_lockref\_is\_dead(&gl->gl\_lockref));++ if (gl->gl\_lksb.sb\_lkid == 0) {+ gfs2\_glock\_free(gl);+ return;+ }  clear\_bit(GLF\_BLOCKING, &gl->gl\_flags); gfs2\_glstats\_inc(gl, GFS2\_LKS\_DCOUNT);@@ -300,13 +312,17 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) gfs2\_update\_request\_times(gl);  /\* don't want to call dlm if we've unmounted the lock protocol \*/- if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags))- goto out\_free;+ if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags)) {+ gfs2\_glock\_free(gl);+ return;+ } /\* don't want to skip dlm\_unlock writing the lvb when lock has one \*/  if (test\_bit(SDF\_SKIP\_DLM\_UNLOCK, &sdp->sd\_flags) &&- !gl->gl\_lksb.sb\_lvbptr)- goto out\_free;+ !gl->gl\_lksb.sb\_lvbptr) {+ gfs2\_glock\_free\_later(gl);+ return;+ }  again: error = dlm\_unlock(ls->ls\_dlm, gl->gl\_lksb.sb\_lkid, DLM\_LKF\_VALBLK,@@ -321,10 +337,6 @@ again: gl->gl\_name.ln\_type, (unsigned long long)gl->gl\_name.ln\_number, error); }- return;--out\_free:- gfs2\_glock\_free(gl); }  static void gdlm\_cancel(struct gfs2\_glock \*gl)diff --git a/fs/gfs2/ops\_fstype.c b/fs/gfs2/ops\_fstype.cindex 572d58e86296f9..cde7118599abbd 100644--- a/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -136,6 +136,7 @@ static struct gfs2\_sbd \*init\_sbd(struct super\_block \*sb) atomic\_set(&sdp->sd\_log\_in\_flight, 0); init\_waitqueue\_head(&sdp->sd\_log\_flush\_wait); mutex\_init(&sdp->sd\_freeze\_mutex);+ INIT\_LIST\_HEAD(&sdp->sd\_dead\_glocks);  return sdp; diff --git a/fs/gfs2/super.c b/fs/gfs2/super.cindex e5f79466340d2a..2d780b4701a23b 100644--- a/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=666a7a9b6ddafe7802ae6a53f513d17e790056a0)+++ b/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=501cd8fabf621d10bd4893e37f6ce6c20523c8ca)@@ -646,10 +646,7 @@ restart: gfs2\_gl\_hash\_clear(sdp); truncate\_inode\_pages\_final(&sdp->sd\_aspace); gfs2\_delete\_debugfs\_file(sdp);- /\* Unmount the locking protocol \*/- gfs2\_lm\_unmount(sdp); - /\* At this point, we're through participating in the lockspace \*/ gfs2\_sys\_fs\_del(sdp); free\_sbd(sdp); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 18:41:50 +0000



=== Content from git.kernel.org_f605278f_20250110_184314.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andreas Gruenbacher <agruenba@redhat.com> | 2024-04-10 04:50:18 +0200 |
| --- | --- | --- |
| committer | Andreas Gruenbacher <agruenba@redhat.com> | 2024-04-24 19:48:20 +0200 |
| commit | [d98779e687726d8f8860f1c54b5687eec5f63a73](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d98779e687726d8f8860f1c54b5687eec5f63a73) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)) | |
| tree | [ec9679324d2b371de147127d779ccec7a4f7bfa6](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | |
| parent | [59f60005797b4018d7b46620037e0c53d690795e](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59f60005797b4018d7b46620037e0c53d690795e) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d98779e687726d8f8860f1c54b5687eec5f63a73&id2=59f60005797b4018d7b46620037e0c53d690795e)) | |
| download | [linux-d98779e687726d8f8860f1c54b5687eec5f63a73.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-d98779e687726d8f8860f1c54b5687eec5f63a73.tar.gz) | |

gfs2: Fix potential glock use-after-free on unmountWhen a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically. Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace. This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.
To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd\_dead\_glocks list, release
the lockspace, and only then free those glocks.
As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.
Fixes: fb6791d100d1b ("GFS2: skip dlm\_unlock calls in unmount")
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Cc: David Teigland <teigland@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=d98779e687726d8f8860f1c54b5687eec5f63a73)

| -rw-r--r-- | [fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.h?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/incore.h?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/lock_dlm.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/ops_fstype.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/super.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 57 insertions, 16 deletions

| diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.cindex bf7538274985cb..4cf8971ce8ee02 100644--- a/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -166,18 +166,45 @@ static bool glock\_blocked\_by\_withdraw(struct gfs2\_glock \*gl) return true; } -void gfs2\_glock\_free(struct gfs2\_glock \*gl)+static void \_\_gfs2\_glock\_free(struct gfs2\_glock \*gl) {- struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;- rhashtable\_remove\_fast(&gl\_hash\_table, &gl->gl\_node, ht\_parms); smp\_mb(); wake\_up\_glock(gl); call\_rcu(&gl->gl\_rcu, gfs2\_glock\_dealloc);+}++void gfs2\_glock\_free(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ \_\_gfs2\_glock\_free(gl); if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal)) wake\_up(&sdp->sd\_kill\_wait); } +void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ spin\_lock(&lru\_lock);+ list\_add(&gl->gl\_lru, &sdp->sd\_dead\_glocks);+ spin\_unlock(&lru\_lock);+ if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal))+ wake\_up(&sdp->sd\_kill\_wait);+}++static void gfs2\_free\_dead\_glocks(struct gfs2\_sbd \*sdp)+{+ struct list\_head \*list = &sdp->sd\_dead\_glocks;++ while(!list\_empty(list)) {+ struct gfs2\_glock \*gl;++ gl = list\_first\_entry(list, struct gfs2\_glock, gl\_lru);+ list\_del\_init(&gl->gl\_lru);+ \_\_gfs2\_glock\_free(gl);+ }+}+ /\*\* \* gfs2\_glock\_hold() - increment reference count on glock \* @gl: The glock to hold@@ -2233,6 +2260,8 @@ void gfs2\_gl\_hash\_clear(struct gfs2\_sbd \*sdp) wait\_event\_timeout(sdp->sd\_kill\_wait, atomic\_read(&sdp->sd\_glock\_disposal) == 0, HZ \* 600);+ gfs2\_lm\_unmount(sdp);+ gfs2\_free\_dead\_glocks(sdp); glock\_hash\_walk(dump\_glock\_func, sdp); } diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.hindex 2c697674a86fa5..19aef6d53267b6 100644--- a/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -252,6 +252,7 @@ void gfs2\_gl\_dq\_holders(struct gfs2\_sbd \*sdp); void gfs2\_glock\_thaw(struct gfs2\_sbd \*sdp); void gfs2\_glock\_add\_to\_lru(struct gfs2\_glock \*gl); void gfs2\_glock\_free(struct gfs2\_glock \*gl);+void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl);  int \_\_init gfs2\_glock\_init(void); void gfs2\_glock\_exit(void);diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.hindex 95a334d64da2a3..60abd7050c9983 100644--- a/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -838,6 +838,7 @@ struct gfs2\_sbd { /\* For quiescing the filesystem \*/ struct gfs2\_holder sd\_freeze\_gh; struct mutex sd\_freeze\_mutex;+ struct list\_head sd\_dead\_glocks;  char sd\_fsname[GFS2\_FSNAME\_LEN + 3 \* sizeof(int) + 2]; char sd\_table\_name[GFS2\_FSNAME\_LEN];diff --git a/fs/gfs2/lock\_dlm.c b/fs/gfs2/lock\_dlm.cindex d1ac5d0679ea6a..e028e55e67d95f 100644--- a/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -121,6 +121,11 @@ static void gdlm\_ast(void \*arg) struct gfs2\_glock \*gl = arg; unsigned ret = gl->gl\_state; + /\* If the glock is dead, we only react to a dlm\_unlock() reply. \*/+ if (\_\_lockref\_is\_dead(&gl->gl\_lockref) &&+ gl->gl\_lksb.sb\_status != -DLM\_EUNLOCK)+ return;+ gfs2\_update\_reply\_times(gl); BUG\_ON(gl->gl\_lksb.sb\_flags & DLM\_SBF\_DEMOTED); @@ -171,6 +176,9 @@ static void gdlm\_bast(void \*arg, int mode) { struct gfs2\_glock \*gl = arg; + if (\_\_lockref\_is\_dead(&gl->gl\_lockref))+ return;+ switch (mode) { case DLM\_LOCK\_EX: gfs2\_glock\_cb(gl, LM\_ST\_UNLOCKED);@@ -291,8 +299,12 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) struct lm\_lockstruct \*ls = &sdp->sd\_lockstruct; int error; - if (gl->gl\_lksb.sb\_lkid == 0)- goto out\_free;+ BUG\_ON(!\_\_lockref\_is\_dead(&gl->gl\_lockref));++ if (gl->gl\_lksb.sb\_lkid == 0) {+ gfs2\_glock\_free(gl);+ return;+ }  clear\_bit(GLF\_BLOCKING, &gl->gl\_flags); gfs2\_glstats\_inc(gl, GFS2\_LKS\_DCOUNT);@@ -300,13 +312,17 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) gfs2\_update\_request\_times(gl);  /\* don't want to call dlm if we've unmounted the lock protocol \*/- if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags))- goto out\_free;+ if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags)) {+ gfs2\_glock\_free(gl);+ return;+ } /\* don't want to skip dlm\_unlock writing the lvb when lock has one \*/  if (test\_bit(SDF\_SKIP\_DLM\_UNLOCK, &sdp->sd\_flags) &&- !gl->gl\_lksb.sb\_lvbptr)- goto out\_free;+ !gl->gl\_lksb.sb\_lvbptr) {+ gfs2\_glock\_free\_later(gl);+ return;+ }  again: error = dlm\_unlock(ls->ls\_dlm, gl->gl\_lksb.sb\_lkid, DLM\_LKF\_VALBLK,@@ -321,10 +337,6 @@ again: gl->gl\_name.ln\_type, (unsigned long long)gl->gl\_name.ln\_number, error); }- return;--out\_free:- gfs2\_glock\_free(gl); }  static void gdlm\_cancel(struct gfs2\_glock \*gl)diff --git a/fs/gfs2/ops\_fstype.c b/fs/gfs2/ops\_fstype.cindex 1281e60be63900..db0df091a6a76c 100644--- a/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -136,6 +136,7 @@ static struct gfs2\_sbd \*init\_sbd(struct super\_block \*sb) atomic\_set(&sdp->sd\_log\_in\_flight, 0); init\_waitqueue\_head(&sdp->sd\_log\_flush\_wait); mutex\_init(&sdp->sd\_freeze\_mutex);+ INIT\_LIST\_HEAD(&sdp->sd\_dead\_glocks);  return sdp; diff --git a/fs/gfs2/super.c b/fs/gfs2/super.cindex d481db9510ac4d..32a37daaccbecd 100644--- a/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=59f60005797b4018d7b46620037e0c53d690795e)+++ b/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=d98779e687726d8f8860f1c54b5687eec5f63a73)@@ -650,10 +650,7 @@ restart: gfs2\_gl\_hash\_clear(sdp); truncate\_inode\_pages\_final(&sdp->sd\_aspace); gfs2\_delete\_debugfs\_file(sdp);- /\* Unmount the locking protocol \*/- gfs2\_lm\_unmount(sdp); - /\* At this point, we're through participating in the lockspace \*/ gfs2\_sys\_fs\_del(sdp); free\_sbd(sdp); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 18:41:51 +0000



=== Content from git.kernel.org_42795785_20250110_184312.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0636b34b44589b142700ac137b5f69802cfe2e37)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0636b34b44589b142700ac137b5f69802cfe2e37)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0636b34b44589b142700ac137b5f69802cfe2e37)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0636b34b44589b142700ac137b5f69802cfe2e37)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andreas Gruenbacher <agruenba@redhat.com> | 2024-04-10 04:50:18 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-12 11:11:44 +0200 |
| commit | [0636b34b44589b142700ac137b5f69802cfe2e37](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0636b34b44589b142700ac137b5f69802cfe2e37) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0636b34b44589b142700ac137b5f69802cfe2e37)) | |
| tree | [456c08a6e11546bd643bb0122bb08adfaa310545](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0636b34b44589b142700ac137b5f69802cfe2e37) | |
| parent | [18dfb29644a41862de09c7f5126f8ea2d615c11f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=18dfb29644a41862de09c7f5126f8ea2d615c11f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0636b34b44589b142700ac137b5f69802cfe2e37&id2=18dfb29644a41862de09c7f5126f8ea2d615c11f)) | |
| download | [linux-0636b34b44589b142700ac137b5f69802cfe2e37.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0636b34b44589b142700ac137b5f69802cfe2e37.tar.gz) | |

gfs2: Fix potential glock use-after-free on unmount[ Upstream commit d98779e687726d8f8860f1c54b5687eec5f63a73 ]
When a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically. Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace. This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.
To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd\_dead\_glocks list, release
the lockspace, and only then free those glocks.
As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.
Fixes: fb6791d100d1b ("GFS2: skip dlm\_unlock calls in unmount")
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
Cc: David Teigland <teigland@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0636b34b44589b142700ac137b5f69802cfe2e37)

| -rw-r--r-- | [fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.c?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 35 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/glock.h?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/incore.h?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/lock_dlm.c?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 32 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/ops_fstype.c?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/gfs2/super.c?id=0636b34b44589b142700ac137b5f69802cfe2e37) | 3 | |  |  |  | | --- | --- | --- | |

6 files changed, 57 insertions, 16 deletions

| diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.cindex a2a1935e2eede7..c195244d21dfdd 100644--- a/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/glock.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.c?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -166,18 +166,45 @@ static bool glock\_blocked\_by\_withdraw(struct gfs2\_glock \*gl) return true; } -void gfs2\_glock\_free(struct gfs2\_glock \*gl)+static void \_\_gfs2\_glock\_free(struct gfs2\_glock \*gl) {- struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;- rhashtable\_remove\_fast(&gl\_hash\_table, &gl->gl\_node, ht\_parms); smp\_mb(); wake\_up\_glock(gl); call\_rcu(&gl->gl\_rcu, gfs2\_glock\_dealloc);+}++void gfs2\_glock\_free(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ \_\_gfs2\_glock\_free(gl); if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal)) wake\_up(&sdp->sd\_kill\_wait); } +void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl) {+ struct gfs2\_sbd \*sdp = gl->gl\_name.ln\_sbd;++ spin\_lock(&lru\_lock);+ list\_add(&gl->gl\_lru, &sdp->sd\_dead\_glocks);+ spin\_unlock(&lru\_lock);+ if (atomic\_dec\_and\_test(&sdp->sd\_glock\_disposal))+ wake\_up(&sdp->sd\_kill\_wait);+}++static void gfs2\_free\_dead\_glocks(struct gfs2\_sbd \*sdp)+{+ struct list\_head \*list = &sdp->sd\_dead\_glocks;++ while(!list\_empty(list)) {+ struct gfs2\_glock \*gl;++ gl = list\_first\_entry(list, struct gfs2\_glock, gl\_lru);+ list\_del\_init(&gl->gl\_lru);+ \_\_gfs2\_glock\_free(gl);+ }+}+ /\*\* \* gfs2\_glock\_hold() - increment reference count on glock \* @gl: The glock to hold@@ -2194,6 +2221,8 @@ void gfs2\_gl\_hash\_clear(struct gfs2\_sbd \*sdp) wait\_event\_timeout(sdp->sd\_kill\_wait, atomic\_read(&sdp->sd\_glock\_disposal) == 0, HZ \* 600);+ gfs2\_lm\_unmount(sdp);+ gfs2\_free\_dead\_glocks(sdp); glock\_hash\_walk(dump\_glock\_func, sdp); } diff --git a/fs/gfs2/glock.h b/fs/gfs2/glock.hindex 7a11d5d4de4960..f7ee9ca948eeea 100644--- a/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/glock.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/glock.h?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -266,6 +266,7 @@ void gfs2\_gl\_dq\_holders(struct gfs2\_sbd \*sdp); void gfs2\_glock\_thaw(struct gfs2\_sbd \*sdp); void gfs2\_glock\_add\_to\_lru(struct gfs2\_glock \*gl); void gfs2\_glock\_free(struct gfs2\_glock \*gl);+void gfs2\_glock\_free\_later(struct gfs2\_glock \*gl);  int \_\_init gfs2\_glock\_init(void); void gfs2\_glock\_exit(void);diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.hindex 95a334d64da2a3..60abd7050c9983 100644--- a/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/incore.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/incore.h?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -838,6 +838,7 @@ struct gfs2\_sbd { /\* For quiescing the filesystem \*/ struct gfs2\_holder sd\_freeze\_gh; struct mutex sd\_freeze\_mutex;+ struct list\_head sd\_dead\_glocks;  char sd\_fsname[GFS2\_FSNAME\_LEN + 3 \* sizeof(int) + 2]; char sd\_table\_name[GFS2\_FSNAME\_LEN];diff --git a/fs/gfs2/lock\_dlm.c b/fs/gfs2/lock\_dlm.cindex 59ab18c798890f..0bde45fb496306 100644--- a/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/lock\_dlm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/lock_dlm.c?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -121,6 +121,11 @@ static void gdlm\_ast(void \*arg) struct gfs2\_glock \*gl = arg; unsigned ret = gl->gl\_state; + /\* If the glock is dead, we only react to a dlm\_unlock() reply. \*/+ if (\_\_lockref\_is\_dead(&gl->gl\_lockref) &&+ gl->gl\_lksb.sb\_status != -DLM\_EUNLOCK)+ return;+ gfs2\_update\_reply\_times(gl); BUG\_ON(gl->gl\_lksb.sb\_flags & DLM\_SBF\_DEMOTED); @@ -171,6 +176,9 @@ static void gdlm\_bast(void \*arg, int mode) { struct gfs2\_glock \*gl = arg; + if (\_\_lockref\_is\_dead(&gl->gl\_lockref))+ return;+ switch (mode) { case DLM\_LOCK\_EX: gfs2\_glock\_cb(gl, LM\_ST\_UNLOCKED);@@ -291,8 +299,12 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) struct lm\_lockstruct \*ls = &sdp->sd\_lockstruct; int error; - if (gl->gl\_lksb.sb\_lkid == 0)- goto out\_free;+ BUG\_ON(!\_\_lockref\_is\_dead(&gl->gl\_lockref));++ if (gl->gl\_lksb.sb\_lkid == 0) {+ gfs2\_glock\_free(gl);+ return;+ }  clear\_bit(GLF\_BLOCKING, &gl->gl\_flags); gfs2\_glstats\_inc(gl, GFS2\_LKS\_DCOUNT);@@ -300,13 +312,17 @@ static void gdlm\_put\_lock(struct gfs2\_glock \*gl) gfs2\_update\_request\_times(gl);  /\* don't want to call dlm if we've unmounted the lock protocol \*/- if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags))- goto out\_free;+ if (test\_bit(DFL\_UNMOUNT, &ls->ls\_recover\_flags)) {+ gfs2\_glock\_free(gl);+ return;+ } /\* don't want to skip dlm\_unlock writing the lvb when lock has one \*/  if (test\_bit(SDF\_SKIP\_DLM\_UNLOCK, &sdp->sd\_flags) &&- !gl->gl\_lksb.sb\_lvbptr)- goto out\_free;+ !gl->gl\_lksb.sb\_lvbptr) {+ gfs2\_glock\_free\_later(gl);+ return;+ }  again: error = dlm\_unlock(ls->ls\_dlm, gl->gl\_lksb.sb\_lkid, DLM\_LKF\_VALBLK,@@ -321,10 +337,6 @@ again: gl->gl\_name.ln\_type, (unsigned long long)gl->gl\_name.ln\_number, error); }- return;--out\_free:- gfs2\_glock\_free(gl); }  static void gdlm\_cancel(struct gfs2\_glock \*gl)diff --git a/fs/gfs2/ops\_fstype.c b/fs/gfs2/ops\_fstype.cindex 547e279f5f9e65..fc7bc1e59748f8 100644--- a/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/ops\_fstype.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/ops_fstype.c?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -136,6 +136,7 @@ static struct gfs2\_sbd \*init\_sbd(struct super\_block \*sb) atomic\_set(&sdp->sd\_log\_in\_flight, 0); init\_waitqueue\_head(&sdp->sd\_log\_flush\_wait); mutex\_init(&sdp->sd\_freeze\_mutex);+ INIT\_LIST\_HEAD(&sdp->sd\_dead\_glocks);  return sdp; diff --git a/fs/gfs2/super.c b/fs/gfs2/super.cindex ab095198b627f9..2b47a4119591fb 100644--- a/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=18dfb29644a41862de09c7f5126f8ea2d615c11f)+++ b/[fs/gfs2/super.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/gfs2/super.c?id=0636b34b44589b142700ac137b5f69802cfe2e37)@@ -646,10 +646,7 @@ restart: gfs2\_gl\_hash\_clear(sdp); truncate\_inode\_pages\_final(&sdp->sd\_aspace); gfs2\_delete\_debugfs\_file(sdp);- /\* Unmount the locking protocol \*/- gfs2\_lm\_unmount(sdp); - /\* At this point, we're through participating in the lockspace \*/ gfs2\_sys\_fs\_del(sdp); free\_sbd(sdp); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 18:41:50 +0000


