=== Content from github.com_e084b7d5_20250110_142838.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-33227)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FDriverHunter%2FWin-Driver-EXP%2Ftree%2Fmain%2FCVE-2024-33227)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=DriverHunter%2FWin-Driver-EXP)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[DriverHunter](/DriverHunter)
/
**[Win-Driver-EXP](/DriverHunter/Win-Driver-EXP)**
Public

* [Notifications](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)
* [Star
   20](/login?return_to=%2FDriverHunter%2FWin-Driver-EXP)

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues
  0](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests
  0](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects
  0](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

Additional navigation options

* [Code](/DriverHunter/Win-Driver-EXP)
* [Issues](/DriverHunter/Win-Driver-EXP/issues)
* [Pull requests](/DriverHunter/Win-Driver-EXP/pulls)
* [Actions](/DriverHunter/Win-Driver-EXP/actions)
* [Projects](/DriverHunter/Win-Driver-EXP/projects)
* [Security](/DriverHunter/Win-Driver-EXP/security)
* [Insights](/DriverHunter/Win-Driver-EXP/pulse)

## Files

 main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-33227

/
## Directory actions

## More options

## Directory actions

## More options

## Latest commit

## History

[History](/DriverHunter/Win-Driver-EXP/commits/main/CVE-2024-33227) main
## Breadcrumbs

1. [Win-Driver-EXP](/DriverHunter/Win-Driver-EXP/tree/main)
/
# CVE-2024-33227

/Top
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| parent directory[..](/DriverHunter/Win-Driver-EXP/tree/main) | | |
| [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33227/README.md "README.md") | | [README.md](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33227/README.md "README.md") |  |  |
| [ddcdrv.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33227/ddcdrv.sys "ddcdrv.sys") | | [ddcdrv.sys](/DriverHunter/Win-Driver-EXP/blob/main/CVE-2024-33227/ddcdrv.sys "ddcdrv.sys") |  |  |
| View all files | | |

## [README.md](#readme)

# Vulnerable Driver ddcdrv.sys in Nicomsoft WinI2C/DDC v3.7.4.0

---

ddcdrv.sys in Nicomsoft WinI2C/DDC v3.7.4.0 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.

## version

3.7.4.0

## Vulnerability causes

ddcdrv.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

```
__int64 __fastcall ioctler(__int64 a1, IRP *a2)
{
  __int64 v2; // r12
  unsigned int v4; // esi
  NTSTATUS v5; // ebx
  struct _IO_STACK_LOCATION *CurrentStackLocation; // r11
  unsigned int Options; // edx
  unsigned int LowPart; // eax
  unsigned int Length; // r13d
  struct _IRP *MasterIrp; // rdi
  unsigned int v11; // eax
  int v12; // ebp
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  CSHORT v19; // ax
  int v20; // eax
  unsigned __int8 v21; // al
  unsigned __int32 v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned __int32 v29; // eax
  unsigned int v30; // r8d
  unsigned __int32 v31; // eax
  __int64 v32; // rax
  __int64 v33; // rdi
  __int64 v34; // rcx
  __int64 v35; // rax
  LARGE_INTEGER MdlAddress; // rdx
  LARGE_INTEGER v37; // rcx
  bool v38; // cf
  PVOID v39; // r13
  _QWORD *v40; // rbp
  __int64 v41; // rax
  _QWORD *Pool; // rax
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  void *SectionHandle; // [rsp+50h] [rbp-A8h] BYREF
  LARGE_INTEGER BusAddress; // [rsp+58h] [rbp-A0h] BYREF
  ULONG_PTR ViewSize; // [rsp+60h] [rbp-98h] BYREF
  PVOID Object; // [rsp+68h] [rbp-90h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+70h] [rbp-88h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-78h] BYREF
  ULONG AddressSpace; // [rsp+100h] [rbp+8h] BYREF
  LARGE_INTEGER TranslatedAddress; // [rsp+108h] [rbp+10h] BYREF
  PVOID BaseAddress; // [rsp+110h] [rbp+18h] BYREF
  LARGE_INTEGER v56; // [rsp+118h] [rbp+20h] BYREF

  v2 = *(_QWORD *)(a1 + 64);
  v4 = 0;
  v5 = 0;
  KeWaitForSingleObject((PVOID)(v2 + 192), Executive, 0, 0, 0i64);
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  Options = CurrentStackLocation->Parameters.Create.Options;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  Length = CurrentStackLocation->Parameters.Read.Length;
  if ( Options || LowPart == 2236424 || LowPart == 2236432 || LowPart == 2236436 )
  {
    MasterIrp = a2->AssociatedIrp.MasterIrp;
    if ( LowPart > 0x222020 )
    {
      v24 = LowPart - 0x222024;
      if ( !v24 )
      {
        v45 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v45) = TranslatedAddress.LowPart;
        }
        __outbyte(v45, (unsigned __int8)MasterIrp->MdlAddress);// out byte primitive  IOCTL CODE 0x222024
        goto LABEL_91;
      }
      v25 = v24 - 4;
      if ( !v25 )
      {
        v44 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v44) = TranslatedAddress.LowPart;
        }
        __outword(v44, (unsigned __int16)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x222028
        goto LABEL_91;
      }
      v26 = v25 - 4;
      if ( !v26 )
      {
        v43 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v43) = TranslatedAddress.LowPart;
        }
        __outdword(v43, (unsigned int)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x22202c
        goto LABEL_91;
      }
      v27 = v26 - 4;
      if ( v27 )
      {
        v28 = v27 - 4;
        if ( !v28 )
        {
          v32 = *(_QWORD *)&MasterIrp->Type;
          v33 = *(_QWORD *)(v2 + 176);
          v34 = 0i64;
          while ( v33 )
          {
            if ( *(_QWORD *)v33 == v32 )
            {
              v35 = *(_QWORD *)(v33 + 16);
              if ( v34 )
                *(_QWORD *)(v34 + 16) = v35;
              else
                *(_QWORD *)(v2 + 176) = v35;
              ZwUnmapViewOfSection(*(HANDLE *)(v33 + 8), *(PVOID *)v33);
              ZwClose(*(HANDLE *)(v33 + 8));
              ExFreePoolWithTag((PVOID)v33, 0);
              --*(_DWORD *)(v2 + 184);
              goto LABEL_91;
            }
            v34 = v33;
            v33 = *(_QWORD *)(v33 + 16);
          }
          goto LABEL_91;
        }
        if ( v28 == 4 )
        {
          if ( Length >= 4 && Options >= 4 )
          {
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            v29 = __indword(0xCFCu);
            v30 = v29;
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            __outdword(0xCFCu, 0xFFFFFFFF);
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            v31 = __indword(0xCFCu);
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            __outdword(0xCFCu, v30);
            v4 = 4;
            *(_DWORD *)&MasterIrp->Type = v31;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        goto LABEL_48;
      }
      if ( Length >= 4 )                        // map primitive IOCTL CODE 0x222030
      {
        MdlAddress = (LARGE_INTEGER)MasterIrp->MdlAddress;
        v37.QuadPart = MdlAddress.QuadPart + MasterIrp->Flags;
        v38 = *(_DWORD *)&MasterIrp->Type < 0xFFu;
        v56 = MdlAddress;
        BusAddress = v37;
        if ( v38 )
        {
          AddressSpace = 0;
          if ( !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, MdlAddress, &AddressSpace, &v56)
            || !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, BusAddress, &AddressSpace, &BusAddress) )
          {
            goto LABEL_36;
          }
          MdlAddress.LowPart = v56.LowPart;
          v37.LowPart = BusAddress.LowPart;
        }
        if ( v37.LowPart == MdlAddress.LowPart )
        {
          v5 = 0xC0000001;
        }
        else
        {
          RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
          ObjectAttributes.ObjectName = &DestinationString;
          ObjectAttributes.Length = 48;
          ObjectAttributes.RootDirectory = 0i64;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0i64;
          ObjectAttributes.SecurityQualityOfService = 0i64;
          if ( ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes) >= 0 )
          {
            Object = 0i64;
            ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
            BaseAddress = 0i64;
            TranslatedAddress = v56;
            ViewSize = MasterIrp->Flags;
            v5 = ZwMapViewOfSection(
                   SectionHandle,
                   (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                   &BaseAddress,
                   0i64,
                   MasterIrp->Flags,
                   &TranslatedAddress,
                   &ViewSize,
                   ViewShare,
                   0,
                   0x204u);
            if ( v5 >= 0 )
            {
              MasterIrp->Flags = ViewSize;
              BaseAddress = (char *)BaseAddress + v56.QuadPart - TranslatedAddress.QuadPart;
              ZwClose(SectionHandle);
              v39 = BaseAddress;
              v40 = (_QWORD *)(v2 + 176);
              v41 = *(_QWORD *)(v2 + 176);
              if ( v41 )
              {
                while ( *(_QWORD *)(v41 + 16) )
                  v41 = *(_QWORD *)(v41 + 16);
                v40 = (_QWORD *)(v41 + 16);
              }
              Pool = ExAllocatePool(NonPagedPool, 0x18ui64);
              if ( Pool )
              {
                Pool[1] = -1i64;
                Pool[2] = 0i64;
                *Pool = v39;
                *v40 = Pool;
                ++*(_DWORD *)(v2 + 184);
              }
              v4 = 8;
              *(_QWORD *)&MasterIrp->Type = BaseAddress;
            }
            else
            {
              ZwClose(SectionHandle);
            }
          }
          else
          {
            v5 = 0xC0000008;
          }
        }
        goto LABEL_91;
      }
LABEL_36:
      v5 = -1073741811;
      goto LABEL_91;
    }
    if ( LowPart == 0x222020 )
    {
      v12 = 4;
      if ( Length < 4 )
        goto LABEL_36;
      v23 = *(_DWORD *)(&MasterIrp->Size + 1);
      if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
      {
        AddressSpace = 1;
        if ( !HalTranslateBusAddress(
                PCIBus,
                *(_DWORD *)&MasterIrp->Type,
                (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                &AddressSpace,
                &TranslatedAddress) )
          goto LABEL_36;
        LOWORD(v23) = TranslatedAddress.LowPart;
      }
      v22 = __indword(v23);                     // in dword primitive IOCTL CODE 0X222020
    }
    else
    {
      v11 = LowPart - 0x222004;
      if ( !v11 )
      {
        v12 = 280;
        if ( Length < 0x118 || Options < 0x118 )
          goto LABEL_36;
        v5 = sub_11534(v2, (__int64)a2->AssociatedIrp.MasterIrp);
LABEL_35:
        v4 = v12;
        goto LABEL_91;
      }
      v12 = 4;
      v13 = v11 - 4;
      if ( v13 )
      {
        v14 = v13 - 4;
        if ( !v14 )
        {
          if ( Options >= 4 )
          {
            *(_DWORD *)(v2 + 188) = *(_DWORD *)&MasterIrp->Type;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 )
          {
            sub_1104C(v2);
            goto LABEL_91;
          }
          v17 = v16 - 4;
          if ( v17 )
          {
            if ( v17 == 4 )
            {
              if ( Length >= 2 )
              {
                v18 = *(_DWORD *)(&MasterIrp->Size + 1);
                if ( *(_DWORD *)&MasterIrp->Type >= 0xFFu )
                {
LABEL_19:
                  v19 = __inword(v18);          // in word primitive IOCTL CODE 0X22201C
                  MasterIrp->Type = v19;
                  v4 = 2;
LABEL_91:
                  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
                  a2->IoStatus.Information = v4;
                  goto LABEL_92;
                }
                AddressSpace = 1;
                if ( HalTranslateBusAddress(
                       PCIBus,
                       *(_DWORD *)&MasterIrp->Type,
                       (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                       &AddressSpace,
                       &TranslatedAddress) )
                {
                  LOWORD(v18) = TranslatedAddress.LowPart;
                  goto LABEL_19;
                }
              }
              goto LABEL_36;
            }
LABEL_48:
            v5 = -1073741808;
            goto LABEL_91;
          }
          if ( Length )
          {
            v20 = *(_DWORD *)(&MasterIrp->Size + 1);
            if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
            {
              AddressSpace = 1;
              if ( !HalTranslateBusAddress(
                      PCIBus,
                      *(_DWORD *)&MasterIrp->Type,
                      (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                      &AddressSpace,
                      &TranslatedAddress) )
                goto LABEL_36;
              LOWORD(v20) = TranslatedAddress.LowPart;
            }
            v21 = __inbyte(v20);                // in byte primitive IOCTL CODE 0X222018
            LOBYTE(MasterIrp->Type) = v21;
            v4 = 1;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        sub_110C4(v2);
      }
      if ( Length < 4 )
        goto LABEL_36;
      v22 = *(_DWORD *)(v2 + 168);
    }
    *(_DWORD *)&MasterIrp->Type = v22;
    goto LABEL_35;
  }
  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
  v5 = -1073741808;
  a2->IoStatus.Information = 0i64;
LABEL_92:
  a2->IoStatus.Status = v5;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v5;
}
```

### IOCTL 0x222024(out byte), 0x222028(out word), 0x22202c(out dword)

This IOCTL code triggers port out operation as blow.

```
   if ( LowPart > 0x222020 )
    {
      v24 = LowPart - 0x222024;
      if ( !v24 )
      {
        v45 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v45) = TranslatedAddress.LowPart;
        }
        __outbyte(v45, (unsigned __int8)MasterIrp->MdlAddress);// out byte primitive  IOCTL CODE 0x222024
        goto LABEL_91;
      }
      v25 = v24 - 4;
      if ( !v25 )
      {
        v44 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v44) = TranslatedAddress.LowPart;
        }
        __outword(v44, (unsigned __int16)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x222028
        goto LABEL_91;
      }
      v26 = v25 - 4;
      if ( !v26 )
      {
        v43 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v43) = TranslatedAddress.LowPart;
        }
        __outdword(v43, (unsigned int)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x22202c
        goto LABEL_91;
      }
```

### IOCTL 0x222030

This IOCTL code triggers memory mapping operation as blow.

```
     if ( Length >= 4 )                        // map primitive IOCTL CODE 0x222030
      {
        MdlAddress = (LARGE_INTEGER)MasterIrp->MdlAddress;
        v37.QuadPart = MdlAddress.QuadPart + MasterIrp->Flags;
        v38 = *(_DWORD *)&MasterIrp->Type < 0xFFu;
        v56 = MdlAddress;
        BusAddress = v37;
        if ( v38 )
        {
          AddressSpace = 0;
          if ( !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, MdlAddress, &AddressSpace, &v56)
            || !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, BusAddress, &AddressSpace, &BusAddress) )
          {
            goto LABEL_36;
          }
          MdlAddress.LowPart = v56.LowPart;
          v37.LowPart = BusAddress.LowPart;
        }
        if ( v37.LowPart == MdlAddress.LowPart )
        {
          v5 = 0xC0000001;
        }
        else
        {
          RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
          ObjectAttributes.ObjectName = &DestinationString;
          ObjectAttributes.Length = 48;
          ObjectAttributes.RootDirectory = 0i64;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0i64;
          ObjectAttributes.SecurityQualityOfService = 0i64;
          if ( ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes) >= 0 )
          {
            Object = 0i64;
            ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
            BaseAddress = 0i64;
            TranslatedAddress = v56;
            ViewSize = MasterIrp->Flags;
            v5 = ZwMapViewOfSection(
                   SectionHandle,
                   (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                   &BaseAddress,
                   0i64,
                   MasterIrp->Flags,
                   &TranslatedAddress,
                   &ViewSize,
                   ViewShare,
                   0,
                   0x204u);
            if ( v5 >= 0 )
            {
              MasterIrp->Flags = ViewSize;
              BaseAddress = (char *)BaseAddress + v56.QuadPart - TranslatedAddress.QuadPart;
              ZwClose(SectionHandle);
              v39 = BaseAddress;
              v40 = (_QWORD *)(v2 + 176);
              v41 = *(_QWORD *)(v2 + 176);
              if ( v41 )
              {
                while ( *(_QWORD *)(v41 + 16) )
                  v41 = *(_QWORD *)(v41 + 16);
                v40 = (_QWORD *)(v41 + 16);
              }
              Pool = ExAllocatePool(NonPagedPool, 0x18ui64);
              if ( Pool )
              {
                Pool[1] = -1i64;
                Pool[2] = 0i64;
                *Pool = v39;
                *v40 = Pool;
                ++*(_DWORD *)(v2 + 184);
              }
              v4 = 8;
              *(_QWORD *)&MasterIrp->Type = BaseAddress;
            }
            else
            {
              ZwClose(SectionHandle);
            }
          }
          else
          {
            v5 = 0xC0000008;
          }
        }
        goto LABEL_91;
      }
```

### IOCTL 0x222018(in byte),0x22201C(in word), 0x222020(in dword)

This IOCTL code triggers port in operation as blow.

```
   if ( LowPart == 0x222020 )
    {
      v12 = 4;
      if ( Length < 4 )
        goto LABEL_36;
      v23 = *(_DWORD *)(&MasterIrp->Size + 1);
      if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
      {
        AddressSpace = 1;
        if ( !HalTranslateBusAddress(
                PCIBus,
                *(_DWORD *)&MasterIrp->Type,
                (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                &AddressSpace,
                &TranslatedAddress) )
          goto LABEL_36;
        LOWORD(v23) = TranslatedAddress.LowPart;
      }
      v22 = __indword(v23);                     // in dword primitive IOCTL CODE 0X222020
    }
    else
    {
      v11 = LowPart - 0x222004;
      if ( !v11 )
      {
        v12 = 280;
        if ( Length < 0x118 || Options < 0x118 )
          goto LABEL_36;
        v5 = sub_11534(v2, (__int64)a2->AssociatedIrp.MasterIrp);
LABEL_35:
        v4 = v12;
        goto LABEL_91;
      }
      v12 = 4;
      v13 = v11 - 4;
      if ( v13 )
      {
        v14 = v13 - 4;
        if ( !v14 )
        {
          if ( Options >= 4 )
          {
            *(_DWORD *)(v2 + 188) = *(_DWORD *)&MasterIrp->Type;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 )
          {
            sub_1104C(v2);
            goto LABEL_91;
          }
          v17 = v16 - 4;
          if ( v17 )
          {
            if ( v17 == 4 )
            {
              if ( Length >= 2 )
              {
                v18 = *(_DWORD *)(&MasterIrp->Size + 1);
                if ( *(_DWORD *)&MasterIrp->Type >= 0xFFu )
                {
LABEL_19:
                  v19 = __inword(v18);          // in word primitive IOCTL CODE 0X22201C
                  MasterIrp->Type = v19;
                  v4 = 2;
LABEL_91:
                  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
                  a2->IoStatus.Information = v4;
                  goto LABEL_92;
                }
                AddressSpace = 1;
                if ( HalTranslateBusAddress(
                       PCIBus,
                       *(_DWORD *)&MasterIrp->Type,
                       (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                       &AddressSpace,
                       &TranslatedAddress) )
                {
                  LOWORD(v18) = TranslatedAddress.LowPart;
                  goto LABEL_19;
                }
              }
              goto LABEL_36;
            }
LABEL_48:
            v5 = -1073741808;
            goto LABEL_91;
          }
          if ( Length )
          {
            v20 = *(_DWORD *)(&MasterIrp->Size + 1);
            if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
            {
              AddressSpace = 1;
              if ( !HalTranslateBusAddress(
                      PCIBus,
                      *(_DWORD *)&MasterIrp->Type,
                      (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                      &AddressSpace,
                      &TranslatedAddress) )
                goto LABEL_36;
              LOWORD(v20) = TranslatedAddress.LowPart;
            }
            v21 = __inbyte(v20);                // in byte primitive IOCTL CODE 0X222018
            LOBYTE(MasterIrp->Type) = v21;
            v4 = 1;
            goto LABEL_91;
          }
```

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


