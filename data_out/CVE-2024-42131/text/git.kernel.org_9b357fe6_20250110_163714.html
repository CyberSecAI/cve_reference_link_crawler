

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jan Kara <jack@suse.cz> | 2024-06-21 16:42:38 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-19 05:32:07 +0200 |
| commit | [2b2d2b8766db028bd827af34075f221ae9e9efff](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2b2d2b8766db028bd827af34075f221ae9e9efff) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)) | |
| tree | [0ab5dda1b610389662437e7eb2a361f68ee5d25c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2b2d2b8766db028bd827af34075f221ae9e9efff) | |
| parent | [70db2c84631f50e02e6b32b543700699dd395803](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=70db2c84631f50e02e6b32b543700699dd395803) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2b2d2b8766db028bd827af34075f221ae9e9efff&id2=70db2c84631f50e02e6b32b543700699dd395803)) | |
| download | [linux-2b2d2b8766db028bd827af34075f221ae9e9efff.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2b2d2b8766db028bd827af34075f221ae9e9efff.tar.gz) | |

mm: avoid overflows in dirty throttling logic[ Upstream commit 385d838df280eba6c8680f9777bfa0d0bfe7e8b2 ]
The dirty throttling logic is interspersed with assumptions that dirty
limits in PAGE\_SIZE units fit into 32-bit (so that various multiplications
fit into 64-bits). If limits end up being larger, we will hit overflows,
possible divisions by 0 etc. Fix these problems by never allowing so
large dirty limits as they have dubious practical value anyway. For
dirty\_bytes / dirty\_background\_bytes interfaces we can just refuse to set
so large limits. For dirty\_ratio / dirty\_background\_ratio it isn't so
simple as the dirty limit is computed from the amount of available memory
which can change due to memory hotplug etc. So when converting dirty
limits from ratios to numbers of pages, we just don't allow the result to
exceed UINT\_MAX.
This is root-only triggerable problem which occurs when the operator
sets dirty limits to >16 TB.
Link: [https://lkml.kernel.org/r/20240621144246.11148-2-jack@suse.cz](https://lkml.kernel.org/r/20240621144246.11148-2-jack%40suse.cz)
Signed-off-by: Jan Kara <jack@suse.cz>
Reported-by: Zach O'Keefe <zokeefe@google.com>
Reviewed-By: Zach O'Keefe <zokeefe@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2b2d2b8766db028bd827af34075f221ae9e9efff)

| -rw-r--r-- | [mm/page-writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/page-writeback.c?id=2b2d2b8766db028bd827af34075f221ae9e9efff) | 30 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 26 insertions, 4 deletions

| diff --git a/mm/page-writeback.c b/mm/page-writeback.cindex 078f1461e07463..ed19e580144a60 100644--- a/[mm/page-writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/page-writeback.c?id=70db2c84631f50e02e6b32b543700699dd395803)+++ b/[mm/page-writeback.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/page-writeback.c?id=2b2d2b8766db028bd827af34075f221ae9e9efff)@@ -432,13 +432,20 @@ static void domain\_dirty\_limits(struct dirty\_throttle\_control \*dtc) else bg\_thresh = (bg\_ratio \* available\_memory) / PAGE\_SIZE; - if (bg\_thresh >= thresh)- bg\_thresh = thresh / 2; tsk = current; if (tsk->flags & PF\_LESS\_THROTTLE || rt\_task(tsk)) { bg\_thresh += bg\_thresh / 4 + global\_wb\_domain.dirty\_limit / 32; thresh += thresh / 4 + global\_wb\_domain.dirty\_limit / 32; }+ /\*+ \* Dirty throttling logic assumes the limits in page units fit into+ \* 32-bits. This gives 16TB dirty limits max which is hopefully enough.+ \*/+ if (thresh > UINT\_MAX)+ thresh = UINT\_MAX;+ /\* This makes sure bg\_thresh is within 32-bits as well \*/+ if (bg\_thresh >= thresh)+ bg\_thresh = thresh / 2; dtc->thresh = thresh; dtc->bg\_thresh = bg\_thresh; @@ -488,7 +495,11 @@ static unsigned long node\_dirty\_limit(struct pglist\_data \*pgdat) if (tsk->flags & PF\_LESS\_THROTTLE || rt\_task(tsk)) dirty += dirty / 4; - return dirty;+ /\*+ \* Dirty throttling logic assumes the limits in page units fit into+ \* 32-bits. This gives 16TB dirty limits max which is hopefully enough.+ \*/+ return min\_t(unsigned long, dirty, UINT\_MAX); }  /\*\*@@ -527,10 +538,17 @@ int dirty\_background\_bytes\_handler(struct ctl\_table \*table, int write, loff\_t \*ppos) { int ret;+ unsigned long old\_bytes = dirty\_background\_bytes;  ret = proc\_doulongvec\_minmax(table, write, buffer, lenp, ppos);- if (ret == 0 && write)+ if (ret == 0 && write) {+ if (DIV\_ROUND\_UP(dirty\_background\_bytes, PAGE\_SIZE) >+ UINT\_MAX) {+ dirty\_background\_bytes = old\_bytes;+ return -ERANGE;+ } dirty\_background\_ratio = 0;+ } return ret; } @@ -558,6 +576,10 @@ int dirty\_bytes\_handler(struct ctl\_table \*table, int write,  ret = proc\_doulongvec\_minmax(table, write, buffer, lenp, ppos); if (ret == 0 && write && vm\_dirty\_bytes != old\_bytes) {+ if (DIV\_ROUND\_UP(vm\_dirty\_bytes, PAGE\_SIZE) > UINT\_MAX) {+ vm\_dirty\_bytes = old\_bytes;+ return -ERANGE;+ } writeback\_set\_ratelimit(); vm\_dirty\_ratio = 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 16:17:03 +0000

