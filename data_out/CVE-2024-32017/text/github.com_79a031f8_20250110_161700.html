
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fdns.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fdns.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  384](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# dns.c

 Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/master/sys/net/application_layer/gcoap/dns.c)767 lines (706 loc) · 22.9 KB master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# dns.c

Top
## File metadata and controls

* Code
* Blame

767 lines (706 loc) · 22.9 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/refs/heads/master/sys/net/application_layer/gcoap/dns.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767/\* \* Copyright (C) 2021 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Martine Lenders <m.lenders@fu-berlin.de> \*/
#include <assert.h>#include <errno.h>#include <stdbool.h>
#include "fmt.h"#include "log.h"#include "mutex.h"#include "net/credman.h"#include "net/gcoap.h"#include "net/af.h"#include "net/dns/cache.h"#include "net/ipv4/addr.h"#include "net/ipv6/addr.h"#include "net/sock/dns.h"#include "net/sock/udp.h"#include "net/sock/util.h"#include "random.h"#include "string\_utils.h"#include "uri\_parser.h"#include "ut\_process.h"
#include "net/gcoap/dns.h"
#define ENABLE\_DEBUG 0#include "debug.h"
/\*\* \* @brief Context for a DNS query-response-pair. \*/typedef struct { /\*\* \* @brief Synchronization mutex to wait for response \*/ mutex\_t resp\_wait; /\*\* \* @brief The CoAP request packet \* \* Only needs to have coap\_pkt\_t::payload and coap\_pkt\_t::payload\_len \* initialized. \*/ coap\_pkt\_t \*pkt;#if IS\_USED(MODULE\_DNS\_CACHE) || defined(DOXYGEN) /\*\* \* @brief The queried hostname \* \* Only required for DNS caching and thus only available with module @ref net\_dns\_cache \*/ const char \*domain\_name;#endif void \*dns\_buf; /\*\*< The buffer for the DNS message exchange \*/ void \*addr\_out; /\*\*< Pointer to the resulting address \*/ /\*\* \* @brief Status for the DNS message exchange \* \* - length of \_req\_ctx\_t::addr\_out in bytes on success \* - -EBADMSG, when receiving erroneous response or response containing \* - -EDESTADDRREQ, if CoAP response was received from an unexpected remote. \* - -EINVAL, when block-wise transfer can not be completed. \* - -ENOBUFS, if length of received CoAP body is greater than \* @ref CONFIG\_DNS\_MSG\_LEN. \* - -ENOMSG, if CoAP response did not contain a DNS response. \* - -ETIMEDOUT, if CoAP request timed out. \*/ int res; uint8\_t dns\_buf\_len; /\*\*< Length of \_req\_ctx\_t::dns\_buf \*/ int8\_t family; /\*\*< Address family to resolve \*/ /\*\* \* @brief The current block number for block-wise transfer \* \* Leave unset on function call. \*/ uint8\_t cur\_blk\_num;#if IS\_USED(MODULE\_GCOAP\_DTLS) || defined(DOXYGEN) /\*\* \* @brief Request tag to rule out potential request reordering attacks \*/ uint16\_t req\_tag;#endif} \_req\_ctx\_t;
typedef struct { credman\_type\_t type; /\*\*< Type of the credential \*/ credman\_tag\_t tag; /\*\*< Tag of the credential \*/} \_cred\_t;
static mutex\_t \_client\_mutex = MUTEX\_INIT;static char \_uri[CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN];static char \_proxy[CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN];static uri\_parser\_result\_t \_uri\_comp;static sock\_udp\_ep\_t \_remote;#if IS\_USED(MODULE\_GCOAP\_DTLS)static \_cred\_t \_creds[CONFIG\_GCOAP\_DNS\_CREDS\_MAX] = { 0 };#endifstatic uint16\_t \_req\_tag;
static inline bool \_dns\_server\_uri\_isset(void);#if IS\_USED(MODULE\_GCOAP\_DTLS)static void \_remove\_cred(sock\_dtls\_t \*sock, \_cred\_t \*cred);#else#define \_remove\_cred(sock, cred) (void)(sock); (void)(cred)#endifstatic inline bool \_is\_proxied(void);static int \_add\_init\_block2\_opt(coap\_pkt\_t \*pdu);static int \_add\_remaining\_options(coap\_pkt\_t \*pdu, const char \*proxy\_uri, \_req\_ctx\_t \*context);static int \_dns\_query(const char \*domain\_name, \_req\_ctx\_t \*req\_ctx);static ssize\_t \_send(const void \*buf, size\_t len, const sock\_udp\_ep\_t \*remote, bool lock\_resp\_wait, \_req\_ctx\_t \*context, gcoap\_socket\_type\_t tl\_type);
int gcoap\_dns\_query(const char \*domain\_name, void \*addr\_out, int family){ int res;
 if ((res = dns\_cache\_query(domain\_name, addr\_out, family)) > 0) { return res; }
 static uint8\_t coap\_buf[CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE]; static uint8\_t dns\_buf[CONFIG\_DNS\_MSG\_LEN]; coap\_pkt\_t pdu; \_req\_ctx\_t req\_ctx = { .resp\_wait = MUTEX\_INIT, .pkt = &pdu, .dns\_buf = dns\_buf, .addr\_out = addr\_out, .family = family, }; mutex\_lock(&\_client\_mutex); pdu.payload = coap\_buf; pdu.payload\_len = sizeof(coap\_buf); res = \_dns\_query(domain\_name, &req\_ctx); if (res > 0) { /\* wait for req\_ctx.addr\_out to be set \*/ mutex\_lock(&req\_ctx.resp\_wait); res = req\_ctx.res; } mutex\_unlock(&\_client\_mutex); return res;}
int gcoap\_dns\_server\_uri\_set(const char \*uri){ int res;
 if (!uri) { mutex\_lock(&\_client\_mutex); \_uri[0] = '\0'; mutex\_unlock(&\_client\_mutex); return 0; } if (IS\_USED(MODULE\_GCOAP\_DTLS)) { /\* reinitialize request tag \*/ \_req\_tag = (uint16\_t)random\_uint32(); } if ((strncmp(uri, "coap:", sizeof("coap:") - 1) != 0) && /\* if gcoap\_dtls is used, URIs not starting with coaps: are also invalid \*/ (!IS\_USED(MODULE\_GCOAP\_DTLS) || (strncmp(uri, "coaps:", sizeof("coaps:") - 1) != 0))) { return -EINVAL; } res = strlen(uri); if ((((unsigned)res + 1) >= CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN)) { return -ENOBUFS; } mutex\_lock(&\_client\_mutex); strcpy(\_uri, uri); if (uri\_parser\_process(&\_uri\_comp, \_uri, res) < 0) { res = -EINVAL; \_uri[0] = '\0'; } mutex\_unlock(&\_client\_mutex); return res;}
bool gcoap\_dns\_server\_uri\_is\_set(void){ mutex\_lock(&\_client\_mutex); bool res = \_dns\_server\_uri\_isset(); mutex\_unlock(&\_client\_mutex); return res;}
ssize\_t gcoap\_dns\_server\_uri\_get(char \*uri, size\_t uri\_len){ ssize\_t res = 0; mutex\_lock(&\_client\_mutex); if (\_dns\_server\_uri\_isset()) { res = strlen(\_uri); if ((size\_t)(res + 1) > uri\_len) { /\* account for trailing \0 \*/ res = -ENOBUFS; } else { strcpy(uri, \_uri); } } mutex\_unlock(&\_client\_mutex); return res;}
void gcoap\_dns\_cred\_reset(void){#if IS\_USED(MODULE\_GCOAP\_DTLS) sock\_dtls\_t \*sock = gcoap\_get\_sock\_dtls(); for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if (\_creds[i].type != CREDMAN\_TYPE\_EMPTY) { \_remove\_cred(sock, &\_creds[i]); } }#endif}
int gcoap\_dns\_cred\_add(credman\_credential\_t \*creds){ \_cred\_t \*c = NULL;
 if (!IS\_USED(MODULE\_GCOAP\_DTLS)) { return -ENOTSUP; } assert(creds != NULL);#if IS\_USED(MODULE\_GCOAP\_DTLS) for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if (!c && (((\_creds[i].type == creds->type) && (\_creds[i].tag == creds->tag)) || (\_creds[i].type == CREDMAN\_TYPE\_EMPTY))) { c = &\_creds[i]; break; } }#endif if (c == NULL) { DEBUG("gcoap\_dns: no space to store credential tag\n"); return -ENOMEM; } int res = credman\_add(creds); if ((res < 0) && (res != CREDMAN\_EXIST)) { /\* ignore duplicate credentials \*/ DEBUG("gcoap\_dns: cannot add credential to system: %d\n", res); return -EBADF; } if (res == CREDMAN\_OK) {#if IS\_USED(MODULE\_GCOAP\_DTLS) /\* functions used in here are only available with module gcoap\_dtls, so guard this \* section \*/ sock\_dtls\_t \*gcoap\_sock\_dtls = gcoap\_get\_sock\_dtls();
 res = sock\_dtls\_add\_credential(gcoap\_sock\_dtls, creds->tag); if (res < 0) { DEBUG("gcoap\_dns: cannot add credential to GCoAPs DTLS sock\n"); return -EBADF; }#endif c->tag = creds->tag; c->type = creds->type; } return 0;}
void gcoap\_dns\_cred\_remove(credman\_tag\_t tag, credman\_type\_t type){#if IS\_USED(MODULE\_GCOAP\_DTLS) sock\_dtls\_t \*sock = gcoap\_get\_sock\_dtls(); for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if ((\_creds[i].tag == tag) && (\_creds[i].type == type)) { \_remove\_cred(sock, &\_creds[i]); break; } }#else (void)tag; (void)type;#endif}
void gcoap\_dns\_server\_proxy\_reset(void){ if (IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED)) { mutex\_lock(&\_client\_mutex); \_proxy[0] = '\0'; mutex\_unlock(&\_client\_mutex); }}
int gcoap\_dns\_server\_proxy\_set(const char \*proxy){ int res;
 if (!IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED)) { return -ENOTSUP; } res = strlen(proxy);
 if ((unsigned)(res + 1) >= CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN) { return -EINVAL; } mutex\_lock(&\_client\_mutex); strcpy(\_proxy, proxy); mutex\_unlock(&\_client\_mutex); return res;}
ssize\_t gcoap\_dns\_server\_proxy\_get(char \*proxy, size\_t proxy\_len){ ssize\_t res = 0; mutex\_lock(&\_client\_mutex); if (\_dns\_server\_uri\_isset()) { res = strscpy(proxy, \_proxy, proxy\_len); if (res == -E2BIG) { res = -ENOBUFS; } } mutex\_unlock(&\_client\_mutex); return res;}
static inline bool \_dns\_server\_uri\_isset(void){ return \_uri[0] != '\0';}
#if IS\_USED(MODULE\_GCOAP\_DTLS)static void \_remove\_cred(sock\_dtls\_t \*sock, \_cred\_t \*cred){ sock\_dtls\_remove\_credential(sock, cred->tag); credman\_delete(cred->tag, cred->type); cred->type = CREDMAN\_TYPE\_EMPTY; cred->tag = CREDMAN\_TAG\_EMPTY;}#endif
static inline bool \_is\_proxied(void){ return IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED) && \_proxy[0] != '\0';}
static int \_add\_init\_block2\_opt(coap\_pkt\_t \*pdu){ if (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE < CONFIG\_DNS\_MSG\_LEN) { /\* If our largest DNS message fits in the DNS PDU BUF, there is no point in sending Block2 \* in the initial message---a huge response might still overwhelm our PDU buffer, but if \* that happens we could not have processed it as a DNS message if it came in in fragments \* either. \*/ coap\_block1\_t block;
 coap\_block\_object\_init(&block, 0, CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE, 0); return coap\_opt\_add\_block2\_control(pdu, &block); } return 0;}
static int \_add\_proxy\_uri\_opt(coap\_pkt\_t \*pdu, const char \*proxy\_uri){ if (\_is\_proxied()) { return coap\_opt\_add\_proxy\_uri(pdu, proxy\_uri); } return 0;}
static int \_add\_req\_tag\_opt(coap\_pkt\_t \*pdu, \_req\_ctx\_t \*context){#if IS\_USED(MODULE\_GCOAP\_DTLS) if (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE < CONFIG\_DNS\_MSG\_LEN) { return coap\_opt\_add\_opaque(pdu, 292, (uint8\_t \*)&context->req\_tag, sizeof(context->req\_tag)); }#else (void)pdu; (void)context;#endif return 0;}
static int \_add\_remaining\_options(coap\_pkt\_t \*pdu, const char \*proxy\_uri, \_req\_ctx\_t \*context){ if (\_add\_proxy\_uri\_opt(pdu, proxy\_uri) < 0) { DEBUG("gcoap\_dns: unable to add Proxy-URI option to request\n"); return -ENOBUFS; } /\* add request tag to distinguish multiple blockwise requests on-the-air \*/ if (\_add\_req\_tag\_opt(pdu, context) < 0) { DEBUG("gcoap\_dns: unable to add Request-Tag option to request"); return -ENOBUFS; } return 0;}
static size\_t \_dns\_msg\_compose(void \*dns\_buf, const char \*domain\_name, int family){ return dns\_msg\_compose\_query(dns\_buf, domain\_name, 0, family);}
static int \_set\_remote(const uri\_parser\_result\_t \*uri\_comp, sock\_udp\_ep\_t \*remote) { assert(uri\_comp->host != NULL); memset(remote, 0, sizeof(\*remote));
 if (uri\_comp->ipv6addr != NULL) { if (ipv6\_addr\_from\_buf((ipv6\_addr\_t \*)remote->addr.ipv6, uri\_comp->ipv6addr, uri\_comp->ipv6addr\_len) == NULL) { DEBUG("gcoap\_dns: unable to parse IPv6 address %\*.s\n", uri\_comp->ipv6addr\_len, uri\_comp->ipv6addr); return -EINVAL; } remote->family = AF\_INET6; if (uri\_comp->zoneid != NULL) { netif\_t \*netif = netif\_get\_by\_name\_buffer(uri\_comp->zoneid, uri\_comp->zoneid\_len); if (netif == NULL) { DEBUG("gcoap\_dns: unable to interpret zoneid %\*.s\n", uri\_comp->zoneid\_len, uri\_comp->zoneid); return -ENOENT; } remote->netif = netif\_get\_id(netif); } else { remote->netif = SOCK\_ADDR\_ANY\_NETIF; } } else if (ipv4\_addr\_from\_buf((ipv4\_addr\_t \*)remote->addr.ipv4, uri\_comp->host, uri\_comp->host\_len) != NULL) { remote->family = AF\_INET; } else if (IS\_USED(MODULE\_SOCK\_DNS)) { char hostname[uri\_comp->host\_len + 1];
 strncpy(hostname, uri\_comp->host, uri\_comp->host\_len); hostname[uri\_comp->host\_len] = '\0'; int res = sock\_dns\_query(hostname, remote->addr.ipv6, AF\_UNSPEC); if (res < 0) { DEBUG("gcoap\_dns: unable to resolve hostname %s for remote\n", hostname); return -EHOSTUNREACH; } if (res == sizeof(remote->addr.ipv4)) { remote->family = AF\_INET; } else if (res == sizeof(remote->addr.ipv6)) { remote->family = AF\_INET6; } else { DEBUG("gcoap\_dns: Unable to determine address family of hostname %s.\n", hostname); return -EHOSTUNREACH; } } else { DEBUG("gcoap\_dns: unable to resolve hostname in URI %s for remote\n", \_uri); return -EHOSTUNREACH; } if (uri\_comp->port == 0) { if (strncmp(\_uri, "coap:", sizeof("coap:") - 1) == 0) { remote->port = CONFIG\_GCOAP\_PORT; } else { remote->port = CONFIG\_GCOAPS\_PORT; } } else { remote->port = uri\_comp->port; } return 0;}
static int \_gen\_uri(uri\_parser\_result\_t \*uri\_comp){ const char \*uri = (\_is\_proxied()) ? \_proxy : \_uri; int res = uri\_parser\_process\_string(uri\_comp, uri);
 if (res < 0) { return -EINVAL; } return strlen(uri);}
static ssize\_t \_req\_init(coap\_pkt\_t \*pdu, uri\_parser\_result\_t \*uri\_comp, bool con){ gcoap\_req\_init\_path\_buffer(pdu, pdu->payload, pdu->payload\_len, COAP\_METHOD\_FETCH, uri\_comp->path, uri\_comp->path\_len); if (con) { coap\_hdr\_set\_type(pdu->hdr, COAP\_TYPE\_CON); }
 if (coap\_opt\_add\_format(pdu, COAP\_FORMAT\_DNS\_MESSAGE) < 0) { DEBUG("gcoap\_dns: unable to add Content-Format option to request\n"); } if (coap\_opt\_add\_accept(pdu, COAP\_FORMAT\_DNS\_MESSAGE) < 0) { DEBUG("gcoap\_dns: unable to add Accept option to request\n"); } if (IS\_USED(MODULE\_GCOAP\_DTLS) && (uri\_comp->scheme\_len == (sizeof("coaps") - 1)) && (strncmp(uri\_comp->scheme, "coaps", uri\_comp->scheme\_len) == 0)) { return GCOAP\_SOCKET\_TYPE\_DTLS; } return GCOAP\_SOCKET\_TYPE\_UDP;}
static int \_do\_block(coap\_pkt\_t \*pdu, const sock\_udp\_ep\_t \*remote, \_req\_ctx\_t \*context){ gcoap\_socket\_type\_t tl\_type; ssize\_t len; bool more; coap\_block\_slicer\_t slicer;
 coap\_block\_slicer\_init(&slicer, context->cur\_blk\_num++, CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE); tl\_type = \_req\_init(pdu, &\_uri\_comp, true); if (tl\_type == GCOAP\_SOCKET\_TYPE\_UNDEF) { return -EINVAL; } more = (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE >= CONFIG\_DNS\_MSG\_LEN) || (slicer.end < context->dns\_buf\_len); if (!more && (\_add\_init\_block2\_opt(pdu) < 0)) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); return -ENOBUFS; } if (coap\_opt\_add\_block1(pdu, &slicer, context->dns\_buf\_len > CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE) < 0) { DEBUG("gcoap\_dns: unable to add Block1 option to request\n"); return -ENOBUFS; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { return -ENOBUFS; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_PAYLOAD);
 len += coap\_blockwise\_put\_bytes(&slicer, pdu->payload, context->dns\_buf, context->dns\_buf\_len);
 coap\_block1\_finish(&slicer);
 if ((len = \_send(pdu->hdr, len, remote, slicer.start == 0, context, tl\_type)) <= 0) { DEBUG("gcoap\_dns: msg send failed: %" PRIdSIZE "\n", len); return len; } return len;}
static ssize\_t \_req(\_req\_ctx\_t \*context){ coap\_pkt\_t \*pdu = context->pkt; ssize\_t len;
 if ((len = \_gen\_uri(&\_uri\_comp)) < 0) { DEBUG("gcoap\_dns: unable to parse URI\n"); return len; } if ((len = \_set\_remote(&\_uri\_comp, &\_remote)) < 0) { return len; } if (context->dns\_buf\_len > CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE) { context->cur\_blk\_num = 0U; return \_do\_block(pdu, &\_remote, context); } else { gcoap\_socket\_type\_t tl\_type = \_req\_init(pdu, &\_uri\_comp, true); if (tl\_type == GCOAP\_SOCKET\_TYPE\_UNDEF) { return -EINVAL; } if (\_add\_init\_block2\_opt(pdu) < 0) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); return -ENOBUFS; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { DEBUG("gcoap\_dns: unable to add Proxy-URI option to request\n"); return -ENOBUFS; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_PAYLOAD); memcpy(pdu->payload, context->dns\_buf, context->dns\_buf\_len); return \_send(pdu->hdr, len + context->dns\_buf\_len, &\_remote, true, context, tl\_type); }}
static int \_dns\_query(const char \*domain\_name, \_req\_ctx\_t \*req\_ctx){ int res;
 assert(domain\_name != NULL); if (!\_dns\_server\_uri\_isset()) { DEBUG("gcoap\_dns: no URI template provided\n"); return -ECONNREFUSED; } req\_ctx->dns\_buf\_len = \_dns\_msg\_compose( req\_ctx->dns\_buf, domain\_name, req\_ctx->family );#if IS\_USED(MODULE\_DNS\_CACHE) req\_ctx->domain\_name = domain\_name;#endif#if IS\_USED(MODULE\_GCOAP\_DTLS) req\_ctx->req\_tag = \_req\_tag++;#endif res = \_req(req\_ctx); if (res <= 0) { DEBUG("gcoap\_dns: unable to send request\n"); if (res == 0) { res = -ENOTRECOVERABLE; } } return res;}
static const char \*\_domain\_name\_from\_ctx(\_req\_ctx\_t \*context){#if IS\_USED(MODULE\_DNS\_CACHE) return context->domain\_name;#else (void)context; return NULL;#endif}
static void \_resp\_handler(const gcoap\_request\_memo\_t \*memo, coap\_pkt\_t \*pdu, const sock\_udp\_ep\_t \*remote){ coap\_block1\_t block; \_req\_ctx\_t \*context = memo->context; void \*data; size\_t data\_len; int family = context->family;
 if (memo->state == GCOAP\_MEMO\_TIMEOUT) { DEBUG("gcoap\_dns: CoAP request timed out\n"); context->res = -ETIMEDOUT; goto unlock; } else if (memo->state != GCOAP\_MEMO\_RESP) { DEBUG("gcoap\_dns: error in response\n"); context->res = -EBADMSG; goto unlock; }
 if ((remote->port != \_remote.port) || (remote->family != \_remote.family) || (!ipv6\_addr\_is\_unspecified((ipv6\_addr\_t \*)\_remote.addr.ipv6) && (memcmp(remote->addr.ipv6, \_remote.addr.ipv6, sizeof(\_remote.addr.ipv6)) != 0))) { DEBUG("gcoap\_dns: unexpected remote for reply\n"); context->res = -EDESTADDRREQ; goto unlock; } if (coap\_get\_code\_class(pdu) != COAP\_CLASS\_SUCCESS) { DEBUG("gcoap\_dns: unsuccessful response: %1u.%02u\n", coap\_get\_code\_class(pdu), coap\_get\_code\_detail(pdu)); context->res = -EBADMSG; goto unlock; } if (coap\_get\_code\_raw(pdu) == COAP\_CODE\_CONTINUE) { int res = \_do\_block(pdu, remote, context);
 if (res < 0) { context->res = res; goto unlock; } return; } if (coap\_get\_block2(pdu, &block)) { uint8\_t \*dns\_buf = context->dns\_buf;
 if ((block.offset + pdu->payload\_len) > CONFIG\_DNS\_MSG\_LEN) { DEBUG("gcoap\_dns: No buffer space for block-wise transfer " "(%" PRIuSIZE " + %u) > %u\n", block.offset, pdu->payload\_len, CONFIG\_DNS\_MSG\_LEN); context->res = -ENOBUFS; goto unlock; } memcpy(&dns\_buf[block.offset], pdu->payload, pdu->payload\_len); if (block.blknum == 0) { context->dns\_buf\_len = pdu->payload\_len; if (block.more && strlen(\_uri) == 0) { DEBUG("gcoap\_dns: Cannot complete block-wise\n"); context->res = -EINVAL; goto unlock; } } else { context->dns\_buf\_len += pdu->payload\_len; } if (block.more) { gcoap\_socket\_type\_t tl\_type; unsigned msg\_type = coap\_get\_type(pdu); int len;
 pdu->payload = (uint8\_t \*)pdu->hdr; pdu->payload\_len = CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE; tl\_type = \_req\_init(pdu, &\_uri\_comp, msg\_type == COAP\_TYPE\_ACK); block.blknum++; if (coap\_opt\_add\_block2\_control(pdu, &block) < 0) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); context->res = -ENOBUFS; goto unlock; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { context->res = -ENOBUFS; goto unlock; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); if ((len = \_send((uint8\_t \*)pdu->hdr, len, remote, false, context, tl\_type)) <= 0) { DEBUG("gcoap\_dns: Unable to request next block: %d\n", len); context->res = len; goto unlock; } return; } data = context->dns\_buf; data\_len = context->dns\_buf\_len; } else { data = pdu->payload; data\_len = pdu->payload\_len; } switch (coap\_get\_content\_type(pdu)) { case COAP\_FORMAT\_DNS\_MESSAGE: case COAP\_FORMAT\_NONE: { uint32\_t ttl = 0;
 context->res = dns\_msg\_parse\_reply(data, data\_len, family, context->addr\_out, &ttl); if (IS\_USED(MODULE\_DNS\_CACHE) && (context->res > 0)) { uint32\_t max\_age;
 if (coap\_opt\_get\_uint(pdu, COAP\_OPT\_MAX\_AGE, &max\_age) < 0) { max\_age = 60; } ttl += max\_age; dns\_cache\_add(\_domain\_name\_from\_ctx(context), context->addr\_out, context->res, ttl); } else if (ENABLE\_DEBUG && (context->res < 0)) { DEBUG("gcoap\_dns: Unable to parse DNS reply: %d\n", context->res); } break; } default: context->res = -ENOMSG; break; }unlock: mutex\_unlock(&context->resp\_wait);}
static ssize\_t \_send(const void \*buf, size\_t len, const sock\_udp\_ep\_t \*remote, bool lock\_resp\_wait, \_req\_ctx\_t \*context, gcoap\_socket\_type\_t tl\_type){ if (lock\_resp\_wait) { mutex\_lock(&context->resp\_wait); } return gcoap\_req\_send(buf, len, remote, NULL, \_resp\_handler, context, tl\_type);}/\*\* @} \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

