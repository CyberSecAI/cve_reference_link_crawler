
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fforward_proxy.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fforward_proxy.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  384](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# forward\_proxy.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/master/sys/net/application_layer/gcoap/forward_proxy.c)590 lines (506 loc) · 19.5 KB master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# forward\_proxy.c

Top
## File metadata and controls

* Code
* Blame

590 lines (506 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/refs/heads/master/sys/net/application_layer/gcoap/forward_proxy.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590/\* \* Copyright (C) 2020 HAW Hamburg \* Copyright (C) 2022 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Cenk Gündoğan <cenk.guendogan@haw-hamburg.de> \* @author Martine S. Lenders <m.lenders@fu-berlin.de> \*/
#include <stdbool.h>
#include "event.h"#include "kernel\_defines.h"#include "net/gcoap.h"#include "net/gcoap/forward\_proxy.h"#include "uri\_parser.h"#include "net/nanocoap/cache.h"#include "ztimer.h"
#include "forward\_proxy\_internal.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define CLIENT\_EP\_FLAGS\_IN\_USE 0x80#define CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK 0x30#define CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS 4U#define CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK 0x0f#define CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS 0U
extern kernel\_pid\_t forward\_proxy\_pid;
extern uint16\_t gcoap\_next\_msg\_id(void);extern void gcoap\_forward\_proxy\_post\_event(void \*arg);
static uint8\_t proxy\_req\_buf[CONFIG\_GCOAP\_PDU\_BUF\_SIZE];static client\_ep\_t \_client\_eps[CONFIG\_GCOAP\_REQ\_WAITING\_MAX];
static int \_request\_matcher\_forward\_proxy(gcoap\_listener\_t \*listener, const coap\_resource\_t \*\*resource, coap\_pkt\_t \*pdu);static ssize\_t \_forward\_proxy\_handler(coap\_pkt\_t\* pdu, uint8\_t \*buf, size\_t len, coap\_request\_ctx\_t \*ctx);static bool \_cep\_in\_use(client\_ep\_t \*cep);static void \_cep\_set\_in\_use(client\_ep\_t \*cep);static uint8\_t \_cep\_get\_response\_type(client\_ep\_t \*cep);static void \_cep\_set\_response\_type(client\_ep\_t \*cep, uint8\_t resp\_type);static uint8\_t \_cep\_get\_req\_etag\_len(client\_ep\_t \*cep);
/\*\* \* @brief Store the given ETag in the given client endpoint \* @param[out] cep client endpoint to store the ETag in \* @param[in] etag ETag to store \* @param[in] etag\_len length of @p etag in bytes \*/static void \_cep\_set\_req\_etag(client\_ep\_t \*cep, const void \*etag, uint8\_t etag\_len);
const coap\_resource\_t forward\_proxy\_resources[] = { { "/", COAP\_IGNORE, \_forward\_proxy\_handler, NULL },};
gcoap\_listener\_t forward\_proxy\_listener = { &forward\_proxy\_resources[0], ARRAY\_SIZE(forward\_proxy\_resources), GCOAP\_SOCKET\_TYPE\_UDP, NULL, NULL, \_request\_matcher\_forward\_proxy};
static void \_cep\_set\_timeout(client\_ep\_t \*cep, ztimer\_t \*timer, uint32\_t timeout\_ms, event\_handler\_t handler){ assert(!ztimer\_is\_set(ZTIMER\_MSEC, timer)); timer->callback = gcoap\_forward\_proxy\_post\_event; timer->arg = &cep->event; cep->event.handler = handler; ztimer\_set(ZTIMER\_MSEC, timer, timeout\_ms);}
void gcoap\_forward\_proxy\_init(void){ gcoap\_register\_listener(&forward\_proxy\_listener); if (IS\_ACTIVE(MODULE\_GCOAP\_FORWARD\_PROXY\_THREAD)) { gcoap\_forward\_proxy\_thread\_init(); }}
static client\_ep\_t \*\_allocate\_client\_ep(const sock\_udp\_ep\_t \*ep){ client\_ep\_t \*cep; for (cep = \_client\_eps; cep < (\_client\_eps + CONFIG\_GCOAP\_REQ\_WAITING\_MAX); cep++) { if (!\_cep\_in\_use(cep)) { \_cep\_set\_in\_use(cep); \_cep\_set\_req\_etag(cep, NULL, 0); memcpy(&cep->ep, ep, sizeof(\*ep)); DEBUG("Client\_ep is allocated %p\n", (void \*)cep); return cep; } } return NULL;}
static void \_free\_client\_ep(client\_ep\_t \*cep){ ztimer\_remove(ZTIMER\_MSEC, &cep->empty\_ack\_timer); /\* timer removed but event could be queued \*/ cep->flags = 0; DEBUG("Client\_ep is freed %p\n", (void \*)cep);}
static int \_request\_matcher\_forward\_proxy(gcoap\_listener\_t \*listener, const coap\_resource\_t \*\*resource, coap\_pkt\_t \*pdu){ (void) listener;
 char \*offset;
 if (coap\_get\_proxy\_uri(pdu, &offset) > 0) { \*resource = &listener->resources[0]; return GCOAP\_RESOURCE\_FOUND; }
 return GCOAP\_RESOURCE\_NO\_PATH;}
static ssize\_t \_forward\_proxy\_handler(coap\_pkt\_t \*pdu, uint8\_t \*buf, size\_t len, coap\_request\_ctx\_t \*ctx){ int pdu\_len; const sock\_udp\_ep\_t \*remote = coap\_request\_ctx\_get\_remote\_udp(ctx); const sock\_udp\_ep\_t \*local = coap\_request\_ctx\_get\_local\_udp(ctx);
 pdu\_len = gcoap\_forward\_proxy\_request\_process(pdu, remote, local);
 /\* Out of memory, reply with 5.00 \*/ if (pdu\_len == -ENOMEM) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_INTERNAL\_SERVER\_ERROR); } /\* Proxy-Uri malformed, reply with 4.02 \*/ else if (pdu\_len == -EINVAL) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_BAD\_OPTION); } /\* scheme not supported \*/ else if (pdu\_len == -EPERM) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_PROXYING\_NOT\_SUPPORTED); }
 return pdu\_len;}
static bool \_parse\_endpoint(sock\_udp\_ep\_t \*remote, uri\_parser\_result\_t \*urip){ char scratch[8]; ipv6\_addr\_t addr; remote->family = AF\_INET6;
 /\* support IPv6 only for now \*/ if (!urip->ipv6addr) { return false; }
 /\* check for interface \*/ if (urip->zoneid) { /\* only works with integer based zoneids \*/
 if (urip->zoneid\_len > (ARRAY\_SIZE(scratch) - 1)) { return false; }
 memcpy(scratch, urip->zoneid, urip->zoneid\_len);
 scratch[urip->zoneid\_len] = '\0';
 int pid = atoi(scratch);
 if (gnrc\_netif\_get\_by\_pid(pid) == NULL) { return false; } remote->netif = pid; } /\* no interface present \*/ else { if (gnrc\_netif\_numof() == 1) { /\* assign the single interface found in gnrc\_netif\_numof() \*/ remote->netif = (uint16\_t)gnrc\_netif\_iter(NULL)->pid; } else { remote->netif = SOCK\_ADDR\_ANY\_NETIF; } }
 /\* parse destination address \*/ if (ipv6\_addr\_from\_buf(&addr, urip->ipv6addr, urip->ipv6addr\_len) == NULL) { return false; } if ((remote->netif == SOCK\_ADDR\_ANY\_NETIF) && ipv6\_addr\_is\_link\_local(&addr)) { return false; } memcpy(&remote->addr.ipv6[0], &addr.u8[0], sizeof(addr.u8));
 if (urip->port != 0) { remote->port = urip->port; } else if (!strncmp(urip->scheme, "coaps", 5)) { remote->port = COAPS\_PORT; } else { remote->port = COAP\_PORT; }
 return true;}
static ssize\_t \_dispatch\_msg(const void \*buf, size\_t len, sock\_udp\_ep\_t \*remote, const sock\_udp\_ep\_t \*local){ /\* Yes it's not a request -- but turns out there is nothing in \* gcoap\_req\_send that is actually request specific, especially if we \* don't assign a callback. \*/ ssize\_t res = gcoap\_req\_send(buf, len, remote, local, NULL, NULL, GCOAP\_SOCKET\_TYPE\_UDP); if (res <= 0) { DEBUG("gcoap\_forward\_proxy: unable to dispatch message: %d\n", (int)-res); } return res;}
static void \_send\_empty\_ack(event\_t \*event){ coap\_hdr\_t buf; client\_ep\_t \*cep = container\_of(event, client\_ep\_t, event);
 if (\_cep\_get\_response\_type(cep) != COAP\_TYPE\_ACK) { return; } \_cep\_set\_response\_type(cep, COAP\_TYPE\_CON);
 /\* Flipping byte order as unlike in the other places where mid is \* used, coap\_build\_hdr would actually flip it back \*/ coap\_build\_hdr(&buf, COAP\_TYPE\_ACK, NULL, 0, 0, ntohs(cep->mid)); \_dispatch\_msg(&buf, sizeof(buf), &cep->ep, &cep->proxy\_ep);}
static void \_set\_response\_type(coap\_pkt\_t \*pdu, uint8\_t resp\_type){ coap\_hdr\_set\_type(pdu->hdr, resp\_type); if (resp\_type == COAP\_TYPE\_CON) { pdu->hdr->id = htons(gcoap\_next\_msg\_id()); }}
static void \_forward\_resp\_handler(const gcoap\_request\_memo\_t \*memo, coap\_pkt\_t\* pdu, const sock\_udp\_ep\_t \*remote){ (void) remote; /\* this is the origin server \*/ client\_ep\_t \*cep = (client\_ep\_t \*)memo->context; size\_t buf\_len;
 /\* No harm done in removing a timer that's not active \*/ ztimer\_remove(ZTIMER\_MSEC, &cep->empty\_ack\_timer); buf\_len = coap\_get\_total\_len(pdu); assert(memo->state == GCOAP\_MEMO\_RESP || memo->state == GCOAP\_MEMO\_RESP\_TRUNC || memo->state == GCOAP\_MEMO\_TIMEOUT); if (memo->state == GCOAP\_MEMO\_RESP) { uint8\_t req\_etag\_len = \_cep\_get\_req\_etag\_len(cep);
 if (req\_etag\_len > 0) { /\* req\_tag in cep is pre-processor guarded so we need to as well \*/#if IS\_USED(MODULE\_NANOCOAP\_CACHE) uint8\_t \*resp\_etag;
 /\* check if we can just send 2.03 Valid instead \*/ if ((req\_etag\_len == coap\_opt\_get\_opaque(pdu, COAP\_OPT\_ETAG, &resp\_etag)) && (memcmp(cep->req\_etag, resp\_etag, req\_etag\_len) == 0)) { uint32\_t max\_age;
 if (coap\_opt\_get\_uint(pdu, COAP\_OPT\_MAX\_AGE, &max\_age) < 0) { /\* use default, \* see https://datatracker.ietf.org/doc/html/rfc7252#section-5.10.5 \*/ max\_age = 60U; } gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_VALID); coap\_opt\_add\_opaque(pdu, COAP\_OPT\_ETAG, cep->req\_etag, req\_etag\_len); if (max\_age != 60U) { /\* only include Max-Age option if it is not the default value \*/ coap\_opt\_add\_uint(pdu, COAP\_OPT\_MAX\_AGE, max\_age); } coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); }#endif } \_set\_response\_type(pdu, \_cep\_get\_response\_type(cep)); /\* we do not need to check if valid came from upstream as this is already automatically \* converted by the client-side to the cached response \*/ /\* else forward the response packet as-is to the client \*/ } else if (memo->state == GCOAP\_MEMO\_RESP\_TRUNC) { /\* the response was truncated, so there should be enough space \* to allocate an empty error message instead (with a potential Observe option) if not, \* \_listen\_buf is \_way\_ too short ;-) \*/ assert(buf\_len >= (sizeof(\*pdu->hdr) + 4U)); gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_INTERNAL\_SERVER\_ERROR); coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); \_set\_response\_type(pdu, \_cep\_get\_response\_type(cep)); } else if (memo->state == GCOAP\_MEMO\_TIMEOUT) { /\* send RST \*/ gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_EMPTY); coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); } /\* don't use buf\_len here, in case the above `gcoap\_resp\_init`s changed `pdu` \*/ \_dispatch\_msg(pdu->hdr, coap\_get\_total\_len(pdu), &cep->ep, &cep->proxy\_ep); \_free\_client\_ep(cep);}
static int \_gcoap\_forward\_proxy\_add\_uri\_path(coap\_pkt\_t \*pkt, uri\_parser\_result\_t \*urip){ ssize\_t res = coap\_opt\_add\_chars(pkt, COAP\_OPT\_URI\_PATH, urip->path, urip->path\_len, '/'); if (res < 0) { return -EINVAL; }
 if (urip->query) { res = coap\_opt\_add\_chars(pkt, COAP\_OPT\_URI\_QUERY, urip->query, urip->query\_len, '&'); if (res < 0) { return -EINVAL; } }
 return 0;}
static int \_gcoap\_forward\_proxy\_copy\_options(coap\_pkt\_t \*pkt, coap\_pkt\_t \*client\_pkt, client\_ep\_t \*cep, uri\_parser\_result\_t \*urip){ /\* copy all options from client\_pkt to pkt \*/ coap\_optpos\_t opt = {0, 0}; uint8\_t \*value; bool uri\_path\_added = false; bool etag\_added = false;
 for (uint16\_t i = 0; i < client\_pkt->options\_len; i++) { ssize\_t optlen = coap\_opt\_get\_next(client\_pkt, &opt, &value, !i); /\* wrt to ETag option slack: we always have at least the Proxy-URI option in the client\_pkt, \* so we should hit at least once (and it's opt\_num is also >= COAP\_OPT\_ETAG) \*/ if (optlen >= 0) { if (IS\_USED(MODULE\_NANOCOAP\_CACHE) && !etag\_added && (opt.opt\_num >= COAP\_OPT\_ETAG)) { static const uint8\_t tmp[COAP\_ETAG\_LENGTH\_MAX] = { 0 }; /\* add slack to maybe add an ETag on stale cache hit later, as is done in \* gcoap\_req\_send() (which we circumvented in \_gcoap\_forward\_proxy\_via\_coap()) \*/ if (coap\_opt\_add\_opaque(pkt, COAP\_OPT\_ETAG, tmp, sizeof(tmp))) { etag\_added = true; } } if (IS\_USED(MODULE\_NANOCOAP\_CACHE) && opt.opt\_num == COAP\_OPT\_ETAG) { if (\_cep\_get\_req\_etag\_len(cep) == 0) { /\* TODO: what to do on multiple ETags? \*/ \_cep\_set\_req\_etag(cep, value, optlen); } /\* skip original ETag of request, otherwise we might accidentally fill the cache \* with 2.03 Valid responses which would require additional handling. \* For upstream validation, gcoap\_req\_send() will add an ETag, if the response \* was in cache \*/ continue; } /\* add URI-PATH before any larger opt num \*/ if (!uri\_path\_added && (opt.opt\_num > COAP\_OPT\_URI\_PATH)) { if (\_gcoap\_forward\_proxy\_add\_uri\_path(pkt, urip) == -EINVAL) { return -EINVAL; } uri\_path\_added = true; } /\* skip PROXY-URI in new packet \*/ if (opt.opt\_num == COAP\_OPT\_PROXY\_URI) { continue; } /\* the actual copy operation \*/ coap\_opt\_add\_opaque(pkt, opt.opt\_num, value, optlen); } }
 ssize\_t len = coap\_opt\_finish(pkt, (client\_pkt->payload\_len ? COAP\_OPT\_FINISH\_PAYLOAD : COAP\_OPT\_FINISH\_NONE));
 /\* copy payload from client\_pkt to pkt \*/ memcpy(pkt->payload, client\_pkt->payload, client\_pkt->payload\_len); pkt->payload\_len = client\_pkt->payload\_len; len += client\_pkt->payload\_len;
 return len;}
int gcoap\_forward\_proxy\_req\_send(client\_ep\_t \*cep){ int len; if ((len = gcoap\_req\_send((uint8\_t \*)cep->pdu.hdr, coap\_get\_total\_len(&cep->pdu), &cep->server\_ep, NULL, \_forward\_resp\_handler, cep, GCOAP\_SOCKET\_TYPE\_UNDEF)) <= 0) { DEBUG("gcoap\_forward\_proxy\_req\_send(): gcoap\_req\_send failed %d\n", len); \_free\_client\_ep(cep); } return len;}
static int \_gcoap\_forward\_proxy\_via\_coap(coap\_pkt\_t \*client\_pkt, client\_ep\_t \*client\_ep, uri\_parser\_result\_t \*urip){ ssize\_t len; gcoap\_request\_memo\_t \*memo = NULL;
 if (!\_parse\_endpoint(&client\_ep->server\_ep, urip)) { \_free\_client\_ep(client\_ep); return -EINVAL; }
 /\* do not forward requests if they already exist, e.g., due to CON and retransmissions. In the future, the proxy should set an empty ACK message to stop the retransmissions of a client \*/ gcoap\_forward\_proxy\_find\_req\_memo(&memo, client\_pkt, &client\_ep->server\_ep); if (memo) { DEBUG("gcoap\_forward\_proxy: request already exists, ignore!\n"); \_free\_client\_ep(client\_ep); return 0; }
 if (coap\_get\_type(client\_pkt) == COAP\_TYPE\_CON) { \_cep\_set\_timeout(client\_ep, &client\_ep->empty\_ack\_timer, CONFIG\_GCOAP\_FORWARD\_PROXY\_EMPTY\_ACK\_MS, \_send\_empty\_ack); }
 unsigned token\_len = coap\_get\_token\_len(client\_pkt);
 coap\_pkt\_init(&client\_ep->pdu, proxy\_req\_buf, CONFIG\_GCOAP\_PDU\_BUF\_SIZE, sizeof(coap\_hdr\_t) + token\_len);
 client\_ep->pdu.hdr->ver\_t\_tkl = client\_pkt->hdr->ver\_t\_tkl; client\_ep->pdu.hdr->code = client\_pkt->hdr->code; client\_ep->pdu.hdr->id = client\_pkt->hdr->id;
 if (token\_len) { memcpy(coap\_get\_token(&client\_ep->pdu), coap\_get\_token(client\_pkt), token\_len); }
 /\* copy all options from client\_pkt to pkt \*/ len = \_gcoap\_forward\_proxy\_copy\_options(&client\_ep->pdu, client\_pkt, client\_ep, urip);
 if (len < 0) { \_free\_client\_ep(client\_ep); return -EINVAL; } if (IS\_USED(MODULE\_GCOAP\_FORWARD\_PROXY\_THREAD)) { /\* WORKAROUND: DTLS communication is blocking the gcoap thread, \* therefore the communication should be handled in the proxy thread \*/
 msg\_t msg = { .type = GCOAP\_FORWARD\_PROXY\_MSG\_SEND, .content.ptr = client\_ep }; msg\_send(&msg, forward\_proxy\_pid); } else { len = gcoap\_forward\_proxy\_req\_send(client\_ep); }
 return len;}
int gcoap\_forward\_proxy\_request\_process(coap\_pkt\_t \*pkt, const sock\_udp\_ep\_t \*client, const sock\_udp\_ep\_t \*local) { char \*uri; uri\_parser\_result\_t urip; ssize\_t optlen = 0;
 client\_ep\_t \*cep = \_allocate\_client\_ep(client); cep->proxy\_ep = local ? \*local : (sock\_udp\_ep\_t){ 0 }; if (!cep) { return -ENOMEM; }
 cep->mid = pkt->hdr->id; \_cep\_set\_response\_type( cep, (coap\_get\_type(pkt) == COAP\_TYPE\_CON) ? COAP\_TYPE\_ACK : COAP\_TYPE\_NON );
 optlen = coap\_get\_proxy\_uri(pkt, &uri);
 if (optlen < 0) { /\* -ENOENT, -EINVAL \*/ \_free\_client\_ep(cep); return optlen; }
 int ures = uri\_parser\_process(&urip, (const char \*) uri, optlen);
 /\* cannot parse Proxy-URI option, or URI is relative \*/ if (ures || (!uri\_parser\_is\_absolute((const char \*) uri, optlen))) { \_free\_client\_ep(cep); return -EINVAL; }
 /\* target is using CoAP \*/ if (!strncmp("coap", urip.scheme, urip.scheme\_len) || !strncmp("coaps", urip.scheme, urip.scheme\_len)) { /\* client context ownership is passed to gcoap\_forward\_proxy\_req\_send() \*/ int res = \_gcoap\_forward\_proxy\_via\_coap(pkt, cep, &urip); if (res < 0) { return -EINVAL; } } /\* no other scheme supported for now \*/ else { \_free\_client\_ep(cep); return -EPERM; }
 return 0;}
static bool \_cep\_in\_use(client\_ep\_t \*cep){ return cep->flags & CLIENT\_EP\_FLAGS\_IN\_USE;}
static void \_cep\_set\_in\_use(client\_ep\_t \*cep){ cep->flags |= CLIENT\_EP\_FLAGS\_IN\_USE;}
static uint8\_t \_cep\_get\_response\_type(client\_ep\_t \*cep){ return (cep->flags & CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK) >> CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS;}
static void \_cep\_set\_response\_type(client\_ep\_t \*cep, uint8\_t resp\_type){ cep->flags &= ~CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK; cep->flags |= (resp\_type << CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS) & CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK;}
static uint8\_t \_cep\_get\_req\_etag\_len(client\_ep\_t \*cep){ if (IS\_USED(MODULE\_NANOCOAP\_CACHE)) { return (cep->flags & CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK) >> CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS; } return 0;}
static void \_cep\_set\_req\_etag(client\_ep\_t \*cep, const void \*etag, uint8\_t etag\_len){ (void)cep; (void)etag; (void)etag\_len;#if MODULE\_NANOCOAP\_CACHE if (etag\_len <= COAP\_ETAG\_LENGTH\_MAX) { cep->flags &= ~CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK; cep->flags |= (etag\_len << CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS) & CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK; memcpy(cep->req\_etag, etag, etag\_len); }#endif}
/\*\* @} \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

