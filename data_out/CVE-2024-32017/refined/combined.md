=== Content from github.com_b06b9490_20250110_161701.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fforward_proxy.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fforward_proxy.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  384](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# forward\_proxy.c

Copy path Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/master/sys/net/application_layer/gcoap/forward_proxy.c)590 lines (506 loc) · 19.5 KB master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# forward\_proxy.c

Top
## File metadata and controls

* Code
* Blame

590 lines (506 loc) · 19.5 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/refs/heads/master/sys/net/application_layer/gcoap/forward_proxy.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590/\* \* Copyright (C) 2020 HAW Hamburg \* Copyright (C) 2022 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Cenk Gündoğan <cenk.guendogan@haw-hamburg.de> \* @author Martine S. Lenders <m.lenders@fu-berlin.de> \*/
#include <stdbool.h>
#include "event.h"#include "kernel\_defines.h"#include "net/gcoap.h"#include "net/gcoap/forward\_proxy.h"#include "uri\_parser.h"#include "net/nanocoap/cache.h"#include "ztimer.h"
#include "forward\_proxy\_internal.h"
#define ENABLE\_DEBUG 0#include "debug.h"
#define CLIENT\_EP\_FLAGS\_IN\_USE 0x80#define CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK 0x30#define CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS 4U#define CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK 0x0f#define CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS 0U
extern kernel\_pid\_t forward\_proxy\_pid;
extern uint16\_t gcoap\_next\_msg\_id(void);extern void gcoap\_forward\_proxy\_post\_event(void \*arg);
static uint8\_t proxy\_req\_buf[CONFIG\_GCOAP\_PDU\_BUF\_SIZE];static client\_ep\_t \_client\_eps[CONFIG\_GCOAP\_REQ\_WAITING\_MAX];
static int \_request\_matcher\_forward\_proxy(gcoap\_listener\_t \*listener, const coap\_resource\_t \*\*resource, coap\_pkt\_t \*pdu);static ssize\_t \_forward\_proxy\_handler(coap\_pkt\_t\* pdu, uint8\_t \*buf, size\_t len, coap\_request\_ctx\_t \*ctx);static bool \_cep\_in\_use(client\_ep\_t \*cep);static void \_cep\_set\_in\_use(client\_ep\_t \*cep);static uint8\_t \_cep\_get\_response\_type(client\_ep\_t \*cep);static void \_cep\_set\_response\_type(client\_ep\_t \*cep, uint8\_t resp\_type);static uint8\_t \_cep\_get\_req\_etag\_len(client\_ep\_t \*cep);
/\*\* \* @brief Store the given ETag in the given client endpoint \* @param[out] cep client endpoint to store the ETag in \* @param[in] etag ETag to store \* @param[in] etag\_len length of @p etag in bytes \*/static void \_cep\_set\_req\_etag(client\_ep\_t \*cep, const void \*etag, uint8\_t etag\_len);
const coap\_resource\_t forward\_proxy\_resources[] = { { "/", COAP\_IGNORE, \_forward\_proxy\_handler, NULL },};
gcoap\_listener\_t forward\_proxy\_listener = { &forward\_proxy\_resources[0], ARRAY\_SIZE(forward\_proxy\_resources), GCOAP\_SOCKET\_TYPE\_UDP, NULL, NULL, \_request\_matcher\_forward\_proxy};
static void \_cep\_set\_timeout(client\_ep\_t \*cep, ztimer\_t \*timer, uint32\_t timeout\_ms, event\_handler\_t handler){ assert(!ztimer\_is\_set(ZTIMER\_MSEC, timer)); timer->callback = gcoap\_forward\_proxy\_post\_event; timer->arg = &cep->event; cep->event.handler = handler; ztimer\_set(ZTIMER\_MSEC, timer, timeout\_ms);}
void gcoap\_forward\_proxy\_init(void){ gcoap\_register\_listener(&forward\_proxy\_listener); if (IS\_ACTIVE(MODULE\_GCOAP\_FORWARD\_PROXY\_THREAD)) { gcoap\_forward\_proxy\_thread\_init(); }}
static client\_ep\_t \*\_allocate\_client\_ep(const sock\_udp\_ep\_t \*ep){ client\_ep\_t \*cep; for (cep = \_client\_eps; cep < (\_client\_eps + CONFIG\_GCOAP\_REQ\_WAITING\_MAX); cep++) { if (!\_cep\_in\_use(cep)) { \_cep\_set\_in\_use(cep); \_cep\_set\_req\_etag(cep, NULL, 0); memcpy(&cep->ep, ep, sizeof(\*ep)); DEBUG("Client\_ep is allocated %p\n", (void \*)cep); return cep; } } return NULL;}
static void \_free\_client\_ep(client\_ep\_t \*cep){ ztimer\_remove(ZTIMER\_MSEC, &cep->empty\_ack\_timer); /\* timer removed but event could be queued \*/ cep->flags = 0; DEBUG("Client\_ep is freed %p\n", (void \*)cep);}
static int \_request\_matcher\_forward\_proxy(gcoap\_listener\_t \*listener, const coap\_resource\_t \*\*resource, coap\_pkt\_t \*pdu){ (void) listener;
 char \*offset;
 if (coap\_get\_proxy\_uri(pdu, &offset) > 0) { \*resource = &listener->resources[0]; return GCOAP\_RESOURCE\_FOUND; }
 return GCOAP\_RESOURCE\_NO\_PATH;}
static ssize\_t \_forward\_proxy\_handler(coap\_pkt\_t \*pdu, uint8\_t \*buf, size\_t len, coap\_request\_ctx\_t \*ctx){ int pdu\_len; const sock\_udp\_ep\_t \*remote = coap\_request\_ctx\_get\_remote\_udp(ctx); const sock\_udp\_ep\_t \*local = coap\_request\_ctx\_get\_local\_udp(ctx);
 pdu\_len = gcoap\_forward\_proxy\_request\_process(pdu, remote, local);
 /\* Out of memory, reply with 5.00 \*/ if (pdu\_len == -ENOMEM) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_INTERNAL\_SERVER\_ERROR); } /\* Proxy-Uri malformed, reply with 4.02 \*/ else if (pdu\_len == -EINVAL) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_BAD\_OPTION); } /\* scheme not supported \*/ else if (pdu\_len == -EPERM) { return gcoap\_response(pdu, buf, len, COAP\_CODE\_PROXYING\_NOT\_SUPPORTED); }
 return pdu\_len;}
static bool \_parse\_endpoint(sock\_udp\_ep\_t \*remote, uri\_parser\_result\_t \*urip){ char scratch[8]; ipv6\_addr\_t addr; remote->family = AF\_INET6;
 /\* support IPv6 only for now \*/ if (!urip->ipv6addr) { return false; }
 /\* check for interface \*/ if (urip->zoneid) { /\* only works with integer based zoneids \*/
 if (urip->zoneid\_len > (ARRAY\_SIZE(scratch) - 1)) { return false; }
 memcpy(scratch, urip->zoneid, urip->zoneid\_len);
 scratch[urip->zoneid\_len] = '\0';
 int pid = atoi(scratch);
 if (gnrc\_netif\_get\_by\_pid(pid) == NULL) { return false; } remote->netif = pid; } /\* no interface present \*/ else { if (gnrc\_netif\_numof() == 1) { /\* assign the single interface found in gnrc\_netif\_numof() \*/ remote->netif = (uint16\_t)gnrc\_netif\_iter(NULL)->pid; } else { remote->netif = SOCK\_ADDR\_ANY\_NETIF; } }
 /\* parse destination address \*/ if (ipv6\_addr\_from\_buf(&addr, urip->ipv6addr, urip->ipv6addr\_len) == NULL) { return false; } if ((remote->netif == SOCK\_ADDR\_ANY\_NETIF) && ipv6\_addr\_is\_link\_local(&addr)) { return false; } memcpy(&remote->addr.ipv6[0], &addr.u8[0], sizeof(addr.u8));
 if (urip->port != 0) { remote->port = urip->port; } else if (!strncmp(urip->scheme, "coaps", 5)) { remote->port = COAPS\_PORT; } else { remote->port = COAP\_PORT; }
 return true;}
static ssize\_t \_dispatch\_msg(const void \*buf, size\_t len, sock\_udp\_ep\_t \*remote, const sock\_udp\_ep\_t \*local){ /\* Yes it's not a request -- but turns out there is nothing in \* gcoap\_req\_send that is actually request specific, especially if we \* don't assign a callback. \*/ ssize\_t res = gcoap\_req\_send(buf, len, remote, local, NULL, NULL, GCOAP\_SOCKET\_TYPE\_UDP); if (res <= 0) { DEBUG("gcoap\_forward\_proxy: unable to dispatch message: %d\n", (int)-res); } return res;}
static void \_send\_empty\_ack(event\_t \*event){ coap\_hdr\_t buf; client\_ep\_t \*cep = container\_of(event, client\_ep\_t, event);
 if (\_cep\_get\_response\_type(cep) != COAP\_TYPE\_ACK) { return; } \_cep\_set\_response\_type(cep, COAP\_TYPE\_CON);
 /\* Flipping byte order as unlike in the other places where mid is \* used, coap\_build\_hdr would actually flip it back \*/ coap\_build\_hdr(&buf, COAP\_TYPE\_ACK, NULL, 0, 0, ntohs(cep->mid)); \_dispatch\_msg(&buf, sizeof(buf), &cep->ep, &cep->proxy\_ep);}
static void \_set\_response\_type(coap\_pkt\_t \*pdu, uint8\_t resp\_type){ coap\_hdr\_set\_type(pdu->hdr, resp\_type); if (resp\_type == COAP\_TYPE\_CON) { pdu->hdr->id = htons(gcoap\_next\_msg\_id()); }}
static void \_forward\_resp\_handler(const gcoap\_request\_memo\_t \*memo, coap\_pkt\_t\* pdu, const sock\_udp\_ep\_t \*remote){ (void) remote; /\* this is the origin server \*/ client\_ep\_t \*cep = (client\_ep\_t \*)memo->context; size\_t buf\_len;
 /\* No harm done in removing a timer that's not active \*/ ztimer\_remove(ZTIMER\_MSEC, &cep->empty\_ack\_timer); buf\_len = coap\_get\_total\_len(pdu); assert(memo->state == GCOAP\_MEMO\_RESP || memo->state == GCOAP\_MEMO\_RESP\_TRUNC || memo->state == GCOAP\_MEMO\_TIMEOUT); if (memo->state == GCOAP\_MEMO\_RESP) { uint8\_t req\_etag\_len = \_cep\_get\_req\_etag\_len(cep);
 if (req\_etag\_len > 0) { /\* req\_tag in cep is pre-processor guarded so we need to as well \*/#if IS\_USED(MODULE\_NANOCOAP\_CACHE) uint8\_t \*resp\_etag;
 /\* check if we can just send 2.03 Valid instead \*/ if ((req\_etag\_len == coap\_opt\_get\_opaque(pdu, COAP\_OPT\_ETAG, &resp\_etag)) && (memcmp(cep->req\_etag, resp\_etag, req\_etag\_len) == 0)) { uint32\_t max\_age;
 if (coap\_opt\_get\_uint(pdu, COAP\_OPT\_MAX\_AGE, &max\_age) < 0) { /\* use default, \* see https://datatracker.ietf.org/doc/html/rfc7252#section-5.10.5 \*/ max\_age = 60U; } gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_VALID); coap\_opt\_add\_opaque(pdu, COAP\_OPT\_ETAG, cep->req\_etag, req\_etag\_len); if (max\_age != 60U) { /\* only include Max-Age option if it is not the default value \*/ coap\_opt\_add\_uint(pdu, COAP\_OPT\_MAX\_AGE, max\_age); } coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); }#endif } \_set\_response\_type(pdu, \_cep\_get\_response\_type(cep)); /\* we do not need to check if valid came from upstream as this is already automatically \* converted by the client-side to the cached response \*/ /\* else forward the response packet as-is to the client \*/ } else if (memo->state == GCOAP\_MEMO\_RESP\_TRUNC) { /\* the response was truncated, so there should be enough space \* to allocate an empty error message instead (with a potential Observe option) if not, \* \_listen\_buf is \_way\_ too short ;-) \*/ assert(buf\_len >= (sizeof(\*pdu->hdr) + 4U)); gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_INTERNAL\_SERVER\_ERROR); coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); \_set\_response\_type(pdu, \_cep\_get\_response\_type(cep)); } else if (memo->state == GCOAP\_MEMO\_TIMEOUT) { /\* send RST \*/ gcoap\_resp\_init(pdu, (uint8\_t \*)pdu->hdr, buf\_len, COAP\_CODE\_EMPTY); coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); } /\* don't use buf\_len here, in case the above `gcoap\_resp\_init`s changed `pdu` \*/ \_dispatch\_msg(pdu->hdr, coap\_get\_total\_len(pdu), &cep->ep, &cep->proxy\_ep); \_free\_client\_ep(cep);}
static int \_gcoap\_forward\_proxy\_add\_uri\_path(coap\_pkt\_t \*pkt, uri\_parser\_result\_t \*urip){ ssize\_t res = coap\_opt\_add\_chars(pkt, COAP\_OPT\_URI\_PATH, urip->path, urip->path\_len, '/'); if (res < 0) { return -EINVAL; }
 if (urip->query) { res = coap\_opt\_add\_chars(pkt, COAP\_OPT\_URI\_QUERY, urip->query, urip->query\_len, '&'); if (res < 0) { return -EINVAL; } }
 return 0;}
static int \_gcoap\_forward\_proxy\_copy\_options(coap\_pkt\_t \*pkt, coap\_pkt\_t \*client\_pkt, client\_ep\_t \*cep, uri\_parser\_result\_t \*urip){ /\* copy all options from client\_pkt to pkt \*/ coap\_optpos\_t opt = {0, 0}; uint8\_t \*value; bool uri\_path\_added = false; bool etag\_added = false;
 for (uint16\_t i = 0; i < client\_pkt->options\_len; i++) { ssize\_t optlen = coap\_opt\_get\_next(client\_pkt, &opt, &value, !i); /\* wrt to ETag option slack: we always have at least the Proxy-URI option in the client\_pkt, \* so we should hit at least once (and it's opt\_num is also >= COAP\_OPT\_ETAG) \*/ if (optlen >= 0) { if (IS\_USED(MODULE\_NANOCOAP\_CACHE) && !etag\_added && (opt.opt\_num >= COAP\_OPT\_ETAG)) { static const uint8\_t tmp[COAP\_ETAG\_LENGTH\_MAX] = { 0 }; /\* add slack to maybe add an ETag on stale cache hit later, as is done in \* gcoap\_req\_send() (which we circumvented in \_gcoap\_forward\_proxy\_via\_coap()) \*/ if (coap\_opt\_add\_opaque(pkt, COAP\_OPT\_ETAG, tmp, sizeof(tmp))) { etag\_added = true; } } if (IS\_USED(MODULE\_NANOCOAP\_CACHE) && opt.opt\_num == COAP\_OPT\_ETAG) { if (\_cep\_get\_req\_etag\_len(cep) == 0) { /\* TODO: what to do on multiple ETags? \*/ \_cep\_set\_req\_etag(cep, value, optlen); } /\* skip original ETag of request, otherwise we might accidentally fill the cache \* with 2.03 Valid responses which would require additional handling. \* For upstream validation, gcoap\_req\_send() will add an ETag, if the response \* was in cache \*/ continue; } /\* add URI-PATH before any larger opt num \*/ if (!uri\_path\_added && (opt.opt\_num > COAP\_OPT\_URI\_PATH)) { if (\_gcoap\_forward\_proxy\_add\_uri\_path(pkt, urip) == -EINVAL) { return -EINVAL; } uri\_path\_added = true; } /\* skip PROXY-URI in new packet \*/ if (opt.opt\_num == COAP\_OPT\_PROXY\_URI) { continue; } /\* the actual copy operation \*/ coap\_opt\_add\_opaque(pkt, opt.opt\_num, value, optlen); } }
 ssize\_t len = coap\_opt\_finish(pkt, (client\_pkt->payload\_len ? COAP\_OPT\_FINISH\_PAYLOAD : COAP\_OPT\_FINISH\_NONE));
 /\* copy payload from client\_pkt to pkt \*/ memcpy(pkt->payload, client\_pkt->payload, client\_pkt->payload\_len); pkt->payload\_len = client\_pkt->payload\_len; len += client\_pkt->payload\_len;
 return len;}
int gcoap\_forward\_proxy\_req\_send(client\_ep\_t \*cep){ int len; if ((len = gcoap\_req\_send((uint8\_t \*)cep->pdu.hdr, coap\_get\_total\_len(&cep->pdu), &cep->server\_ep, NULL, \_forward\_resp\_handler, cep, GCOAP\_SOCKET\_TYPE\_UNDEF)) <= 0) { DEBUG("gcoap\_forward\_proxy\_req\_send(): gcoap\_req\_send failed %d\n", len); \_free\_client\_ep(cep); } return len;}
static int \_gcoap\_forward\_proxy\_via\_coap(coap\_pkt\_t \*client\_pkt, client\_ep\_t \*client\_ep, uri\_parser\_result\_t \*urip){ ssize\_t len; gcoap\_request\_memo\_t \*memo = NULL;
 if (!\_parse\_endpoint(&client\_ep->server\_ep, urip)) { \_free\_client\_ep(client\_ep); return -EINVAL; }
 /\* do not forward requests if they already exist, e.g., due to CON and retransmissions. In the future, the proxy should set an empty ACK message to stop the retransmissions of a client \*/ gcoap\_forward\_proxy\_find\_req\_memo(&memo, client\_pkt, &client\_ep->server\_ep); if (memo) { DEBUG("gcoap\_forward\_proxy: request already exists, ignore!\n"); \_free\_client\_ep(client\_ep); return 0; }
 if (coap\_get\_type(client\_pkt) == COAP\_TYPE\_CON) { \_cep\_set\_timeout(client\_ep, &client\_ep->empty\_ack\_timer, CONFIG\_GCOAP\_FORWARD\_PROXY\_EMPTY\_ACK\_MS, \_send\_empty\_ack); }
 unsigned token\_len = coap\_get\_token\_len(client\_pkt);
 coap\_pkt\_init(&client\_ep->pdu, proxy\_req\_buf, CONFIG\_GCOAP\_PDU\_BUF\_SIZE, sizeof(coap\_hdr\_t) + token\_len);
 client\_ep->pdu.hdr->ver\_t\_tkl = client\_pkt->hdr->ver\_t\_tkl; client\_ep->pdu.hdr->code = client\_pkt->hdr->code; client\_ep->pdu.hdr->id = client\_pkt->hdr->id;
 if (token\_len) { memcpy(coap\_get\_token(&client\_ep->pdu), coap\_get\_token(client\_pkt), token\_len); }
 /\* copy all options from client\_pkt to pkt \*/ len = \_gcoap\_forward\_proxy\_copy\_options(&client\_ep->pdu, client\_pkt, client\_ep, urip);
 if (len < 0) { \_free\_client\_ep(client\_ep); return -EINVAL; } if (IS\_USED(MODULE\_GCOAP\_FORWARD\_PROXY\_THREAD)) { /\* WORKAROUND: DTLS communication is blocking the gcoap thread, \* therefore the communication should be handled in the proxy thread \*/
 msg\_t msg = { .type = GCOAP\_FORWARD\_PROXY\_MSG\_SEND, .content.ptr = client\_ep }; msg\_send(&msg, forward\_proxy\_pid); } else { len = gcoap\_forward\_proxy\_req\_send(client\_ep); }
 return len;}
int gcoap\_forward\_proxy\_request\_process(coap\_pkt\_t \*pkt, const sock\_udp\_ep\_t \*client, const sock\_udp\_ep\_t \*local) { char \*uri; uri\_parser\_result\_t urip; ssize\_t optlen = 0;
 client\_ep\_t \*cep = \_allocate\_client\_ep(client); cep->proxy\_ep = local ? \*local : (sock\_udp\_ep\_t){ 0 }; if (!cep) { return -ENOMEM; }
 cep->mid = pkt->hdr->id; \_cep\_set\_response\_type( cep, (coap\_get\_type(pkt) == COAP\_TYPE\_CON) ? COAP\_TYPE\_ACK : COAP\_TYPE\_NON );
 optlen = coap\_get\_proxy\_uri(pkt, &uri);
 if (optlen < 0) { /\* -ENOENT, -EINVAL \*/ \_free\_client\_ep(cep); return optlen; }
 int ures = uri\_parser\_process(&urip, (const char \*) uri, optlen);
 /\* cannot parse Proxy-URI option, or URI is relative \*/ if (ures || (!uri\_parser\_is\_absolute((const char \*) uri, optlen))) { \_free\_client\_ep(cep); return -EINVAL; }
 /\* target is using CoAP \*/ if (!strncmp("coap", urip.scheme, urip.scheme\_len) || !strncmp("coaps", urip.scheme, urip.scheme\_len)) { /\* client context ownership is passed to gcoap\_forward\_proxy\_req\_send() \*/ int res = \_gcoap\_forward\_proxy\_via\_coap(pkt, cep, &urip); if (res < 0) { return -EINVAL; } } /\* no other scheme supported for now \*/ else { \_free\_client\_ep(cep); return -EPERM; }
 return 0;}
static bool \_cep\_in\_use(client\_ep\_t \*cep){ return cep->flags & CLIENT\_EP\_FLAGS\_IN\_USE;}
static void \_cep\_set\_in\_use(client\_ep\_t \*cep){ cep->flags |= CLIENT\_EP\_FLAGS\_IN\_USE;}
static uint8\_t \_cep\_get\_response\_type(client\_ep\_t \*cep){ return (cep->flags & CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK) >> CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS;}
static void \_cep\_set\_response\_type(client\_ep\_t \*cep, uint8\_t resp\_type){ cep->flags &= ~CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK; cep->flags |= (resp\_type << CLIENT\_EP\_FLAGS\_RESP\_TYPE\_POS) & CLIENT\_EP\_FLAGS\_RESP\_TYPE\_MASK;}
static uint8\_t \_cep\_get\_req\_etag\_len(client\_ep\_t \*cep){ if (IS\_USED(MODULE\_NANOCOAP\_CACHE)) { return (cep->flags & CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK) >> CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS; } return 0;}
static void \_cep\_set\_req\_etag(client\_ep\_t \*cep, const void \*etag, uint8\_t etag\_len){ (void)cep; (void)etag; (void)etag\_len;#if MODULE\_NANOCOAP\_CACHE if (etag\_len <= COAP\_ETAG\_LENGTH\_MAX) { cep->flags &= ~CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK; cep->flags |= (etag\_len << CLIENT\_EP\_FLAGS\_ETAG\_LEN\_POS) & CLIENT\_EP\_FLAGS\_ETAG\_LEN\_MASK; memcpy(cep->req\_etag, etag, etag\_len); }#endif}
/\*\* @} \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from seclists.org_4af27886_20250110_161658.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![fulldisclosure logo](/images/fulldisclosure-logo.png)](/fulldisclosure/)
## [Full Disclosure](/fulldisclosure/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](6)
[By Date](date.html#7)
[![Next](/images/right-icon-16x16.png)](8)

[![Previous](/images/left-icon-16x16.png)](6)
[By Thread](index.html#7)
[![Next](/images/right-icon-16x16.png)](8)

![](/shared/images/nst-icons.svg#search)

# HNS-2024-07 - HN Security Advisory - Multiple vulnerabilities in RIOT OS

---

*From*: Marco Ivaldi <raptor () 0xdeadbeef info>

*Date*: Tue, 7 May 2024 10:57:02 +0200

---

```
Hi,

Please find attached a security advisory that describes multiple
vulnerabilities we discovered in RIOT OS.

* Title: Multiple vulnerabilities in RIOT OS
* OS: RIOT <= 2024.01
* Author: Marco Ivaldi <marco.ivaldi () hnsecurity it>
* Date: 2024-05-07
* CVE ID and severity:
  * CVE-2024-31225 - High
  * CVE-2024-32017 - Critical
  * CVE-2024-32018 - High
  (low-severity vulnerabilities were not assigned a CVE ID)
* Vendor URL: <https://www.riot-os.org/>
* Advisory URLs:
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-2572-7q7c-3965>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-v97j-w9m6-c4h3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-899m-q6pp-hmp3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-x3j5-hfrr-5x6q>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-pw2r-pp35-xfmj>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-c4p4-vv7v-3hx8>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-r87w-9vw9-f7cx>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-2hx7-c324-3rxv>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-frp5-4gfp-84j3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-x27v-gqp4-7jq3>

The advisory is also available at:
<https://github.com/hnsecurity/vulns/blob/main/HNS-2024-07-riot.txt>

For additional information, please refer to our vulnerability writeup:
<https://security.humanativaspa.it/multiple-vulnerabilities-in-riot-os/>

Regards,

--
Marco Ivaldi
<https://0xdeadbeef.info/>
"When cryptography is outlawed, bayl bhgynjf jvyy unir cevinpl."

```

**Attachment:
[HNS-2024-07-riot.txt](att-7/HNS-2024-07-riot.txt)**

*Description:*

```
_______________________________________________
Sent through the Full Disclosure mailing list
<https://nmap.org/mailman/listinfo/fulldisclosure>
Web Archives & RSS: <https://seclists.org/fulldisclosure/>
```

---

[![Previous](/images/left-icon-16x16.png)](6)
[By Date](date.html#7)
[![Next](/images/right-icon-16x16.png)](8)

[![Previous](/images/left-icon-16x16.png)](6)
[By Thread](index.html#7)
[![Next](/images/right-icon-16x16.png)](8)

### Current thread:

* **HNS-2024-07 - HN Security Advisory - Multiple vulnerabilities in RIOT OS** *Marco Ivaldi (May 14)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from github.com_fc39e580_20250110_161702.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-v97j-w9m6-c4h3)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fsecurity%2Fadvisories%2FGHSA-v97j-w9m6-c4h3)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  384](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

# Buffer overflows in RIOT /sys/net/application\_layer/gcoap/

Critical

[Teufelchen1](/Teufelchen1)
published
GHSA-v97j-w9m6-c4h3
Apr 30, 2024

## Package

RIOT

## Affected versions

<= 2023.10

## Patched versions

None

## Description

### Summary

I spotted a typo in a size check that may lead to a buffer overflow in RIOT source code at:

<https://github.com/RIOT-OS/RIOT/blob/master/sys/net/application_layer/gcoap/dns.c#L319-L325>

I also spotted another potential buffer overflow in RIOT source code at:

<https://github.com/RIOT-OS/RIOT/blob/master/sys/net/application_layer/gcoap/forward_proxy.c#L352>

### Details

The size check in the `gcoap_dns_server_proxy_get()` function contains a small typo that may lead to a buffer overflow in the subsequent `strcpy()`. In detail, the length of the `_uri` string is checked instead of the length of the `_proxy` string.

Please refer to the marked lines below:

```
ssize_t gcoap_dns_server_proxy_get(char *proxy, size_t proxy_len)
{
    ssize_t res = 0;
    mutex_lock(&_client_mutex);
    if (_dns_server_uri_isset()) {
        res = strlen(_uri); // VULN: typo, should be strlen(_proxy)
        if (((size_t)res + 1) > proxy_len) {
            /* account for trailing \0 */
            res = -ENOBUFS;
        }
        else {
            strcpy(proxy, _proxy); // VULN: potential buffer overflow
        }
    }
    mutex_unlock(&_client_mutex);
    return res;
}
```

The `_gcoap_forward_proxy_copy_options()` function does not implement an explicit size check before copying data to the `cep->req_etag` buffer that is `COAP_ETAG_LENGTH_MAX` bytes long. If an attacker can craft input so that `optlen` becomes larger than `COAP_ETAG_LENGTH_MAX`, they can cause a buffer overflow.

Please refer to the marked line below:

```
static int _gcoap_forward_proxy_copy_options(coap_pkt_t *pkt,
                                             coap_pkt_t *client_pkt,
                                             client_ep_t *cep,
                                             uri_parser_result_t *urip)
{
    /* copy all options from client_pkt to pkt */
    coap_optpos_t opt = {0, 0};
    uint8_t *value;
    bool uri_path_added = false;
    bool etag_added = false;

    for (int i = 0; i < client_pkt->options_len; i++) {
        ssize_t optlen = coap_opt_get_next(client_pkt, &opt, &value, !i);
        /* wrt to ETag option slack: we always have at least the Proxy-URI option in the client_pkt,
         * so we should hit at least once (and it's opt_num is also >= COAP_OPT_ETAG) */
        if (optlen >= 0) {
            if (IS_USED(MODULE_NANOCOAP_CACHE) && !etag_added && (opt.opt_num >= COAP_OPT_ETAG)) {
                static const uint8_t tmp[COAP_ETAG_LENGTH_MAX] = { 0 };
                /* add slack to maybe add an ETag on stale cache hit later, as is done in
                 * gcoap_req_send() (which we circumvented in _gcoap_forward_proxy_via_coap()) */
                if (coap_opt_add_opaque(pkt, COAP_OPT_ETAG, tmp, sizeof(tmp))) {
                    etag_added = true;
                }
            }
            if (IS_USED(MODULE_NANOCOAP_CACHE) && opt.opt_num == COAP_OPT_ETAG) {
                if (_cep_get_req_etag_len(cep) == 0) {
                    /* TODO: what to do on multiple ETags? */
                    _cep_set_req_etag_len(cep, (uint8_t)optlen);
#if IS_USED(MODULE_NANOCOAP_CACHE)
                    /* req_tag in cep is pre-processor guarded so we need to as well */
                    memcpy(cep->req_etag, value, optlen); // VULN: potential buffer overflow if optlen can become larger than COAP_ETAG_LENGTH_MAX
#endif
...
```
### Impact

If the input above is attacker-controlled and crosses a security boundary, the impact of the buffer overflow vulnerabilities could range from denial of service to arbitrary code execution.

### Severity

Critical

### CVE ID

CVE-2024-32017

### Weaknesses

[CWE-120](/advisories?query=cwe%3A120)

### Credits

* [![@0xdea](https://avatars.githubusercontent.com/u/30093440?s=40&v=4)](/0xdea)
  [0xdea](/0xdea)
  Reporter

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_79a031f8_20250110_161700.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fdns.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FRIOT-OS%2FRIOT%2Fblob%2Fmaster%2Fsys%2Fnet%2Fapplication_layer%2Fgcoap%2Fdns.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=RIOT-OS%2FRIOT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[RIOT-OS](/RIOT-OS)
/
**[RIOT](/RIOT-OS/RIOT)**
Public

* [Notifications](/login?return_to=%2FRIOT-OS%2FRIOT) You must be signed in to change notification settings
* [Fork
  2k](/login?return_to=%2FRIOT-OS%2FRIOT)
* [Star
   5.4k](/login?return_to=%2FRIOT-OS%2FRIOT)

* [Code](/RIOT-OS/RIOT)
* [Issues
  382](/RIOT-OS/RIOT/issues)
* [Pull requests
  384](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects
  0](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

Additional navigation options

* [Code](/RIOT-OS/RIOT)
* [Issues](/RIOT-OS/RIOT/issues)
* [Pull requests](/RIOT-OS/RIOT/pulls)
* [Actions](/RIOT-OS/RIOT/actions)
* [Projects](/RIOT-OS/RIOT/projects)
* [Wiki](/RIOT-OS/RIOT/wiki)
* [Security](/RIOT-OS/RIOT/security)
* [Insights](/RIOT-OS/RIOT/pulse)

## Files

 master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# dns.c

 Blame  Blame
## Latest commit

## History

[History](/RIOT-OS/RIOT/commits/master/sys/net/application_layer/gcoap/dns.c)767 lines (706 loc) · 22.9 KB master
## Breadcrumbs

1. [RIOT](/RIOT-OS/RIOT/tree/master)
2. /[sys](/RIOT-OS/RIOT/tree/master/sys)
3. /[net](/RIOT-OS/RIOT/tree/master/sys/net)
4. /[application\_layer](/RIOT-OS/RIOT/tree/master/sys/net/application_layer)
5. /[gcoap](/RIOT-OS/RIOT/tree/master/sys/net/application_layer/gcoap)
/
# dns.c

Top
## File metadata and controls

* Code
* Blame

767 lines (706 loc) · 22.9 KB[Raw](https://github.com/RIOT-OS/RIOT/raw/refs/heads/master/sys/net/application_layer/gcoap/dns.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767/\* \* Copyright (C) 2021 Freie Universität Berlin \* \* This file is subject to the terms and conditions of the GNU Lesser \* General Public License v2.1. See the file LICENSE in the top level \* directory for more details. \*/
/\*\* \* @{ \* \* @file \* @author Martine Lenders <m.lenders@fu-berlin.de> \*/
#include <assert.h>#include <errno.h>#include <stdbool.h>
#include "fmt.h"#include "log.h"#include "mutex.h"#include "net/credman.h"#include "net/gcoap.h"#include "net/af.h"#include "net/dns/cache.h"#include "net/ipv4/addr.h"#include "net/ipv6/addr.h"#include "net/sock/dns.h"#include "net/sock/udp.h"#include "net/sock/util.h"#include "random.h"#include "string\_utils.h"#include "uri\_parser.h"#include "ut\_process.h"
#include "net/gcoap/dns.h"
#define ENABLE\_DEBUG 0#include "debug.h"
/\*\* \* @brief Context for a DNS query-response-pair. \*/typedef struct { /\*\* \* @brief Synchronization mutex to wait for response \*/ mutex\_t resp\_wait; /\*\* \* @brief The CoAP request packet \* \* Only needs to have coap\_pkt\_t::payload and coap\_pkt\_t::payload\_len \* initialized. \*/ coap\_pkt\_t \*pkt;#if IS\_USED(MODULE\_DNS\_CACHE) || defined(DOXYGEN) /\*\* \* @brief The queried hostname \* \* Only required for DNS caching and thus only available with module @ref net\_dns\_cache \*/ const char \*domain\_name;#endif void \*dns\_buf; /\*\*< The buffer for the DNS message exchange \*/ void \*addr\_out; /\*\*< Pointer to the resulting address \*/ /\*\* \* @brief Status for the DNS message exchange \* \* - length of \_req\_ctx\_t::addr\_out in bytes on success \* - -EBADMSG, when receiving erroneous response or response containing \* - -EDESTADDRREQ, if CoAP response was received from an unexpected remote. \* - -EINVAL, when block-wise transfer can not be completed. \* - -ENOBUFS, if length of received CoAP body is greater than \* @ref CONFIG\_DNS\_MSG\_LEN. \* - -ENOMSG, if CoAP response did not contain a DNS response. \* - -ETIMEDOUT, if CoAP request timed out. \*/ int res; uint8\_t dns\_buf\_len; /\*\*< Length of \_req\_ctx\_t::dns\_buf \*/ int8\_t family; /\*\*< Address family to resolve \*/ /\*\* \* @brief The current block number for block-wise transfer \* \* Leave unset on function call. \*/ uint8\_t cur\_blk\_num;#if IS\_USED(MODULE\_GCOAP\_DTLS) || defined(DOXYGEN) /\*\* \* @brief Request tag to rule out potential request reordering attacks \*/ uint16\_t req\_tag;#endif} \_req\_ctx\_t;
typedef struct { credman\_type\_t type; /\*\*< Type of the credential \*/ credman\_tag\_t tag; /\*\*< Tag of the credential \*/} \_cred\_t;
static mutex\_t \_client\_mutex = MUTEX\_INIT;static char \_uri[CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN];static char \_proxy[CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN];static uri\_parser\_result\_t \_uri\_comp;static sock\_udp\_ep\_t \_remote;#if IS\_USED(MODULE\_GCOAP\_DTLS)static \_cred\_t \_creds[CONFIG\_GCOAP\_DNS\_CREDS\_MAX] = { 0 };#endifstatic uint16\_t \_req\_tag;
static inline bool \_dns\_server\_uri\_isset(void);#if IS\_USED(MODULE\_GCOAP\_DTLS)static void \_remove\_cred(sock\_dtls\_t \*sock, \_cred\_t \*cred);#else#define \_remove\_cred(sock, cred) (void)(sock); (void)(cred)#endifstatic inline bool \_is\_proxied(void);static int \_add\_init\_block2\_opt(coap\_pkt\_t \*pdu);static int \_add\_remaining\_options(coap\_pkt\_t \*pdu, const char \*proxy\_uri, \_req\_ctx\_t \*context);static int \_dns\_query(const char \*domain\_name, \_req\_ctx\_t \*req\_ctx);static ssize\_t \_send(const void \*buf, size\_t len, const sock\_udp\_ep\_t \*remote, bool lock\_resp\_wait, \_req\_ctx\_t \*context, gcoap\_socket\_type\_t tl\_type);
int gcoap\_dns\_query(const char \*domain\_name, void \*addr\_out, int family){ int res;
 if ((res = dns\_cache\_query(domain\_name, addr\_out, family)) > 0) { return res; }
 static uint8\_t coap\_buf[CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE]; static uint8\_t dns\_buf[CONFIG\_DNS\_MSG\_LEN]; coap\_pkt\_t pdu; \_req\_ctx\_t req\_ctx = { .resp\_wait = MUTEX\_INIT, .pkt = &pdu, .dns\_buf = dns\_buf, .addr\_out = addr\_out, .family = family, }; mutex\_lock(&\_client\_mutex); pdu.payload = coap\_buf; pdu.payload\_len = sizeof(coap\_buf); res = \_dns\_query(domain\_name, &req\_ctx); if (res > 0) { /\* wait for req\_ctx.addr\_out to be set \*/ mutex\_lock(&req\_ctx.resp\_wait); res = req\_ctx.res; } mutex\_unlock(&\_client\_mutex); return res;}
int gcoap\_dns\_server\_uri\_set(const char \*uri){ int res;
 if (!uri) { mutex\_lock(&\_client\_mutex); \_uri[0] = '\0'; mutex\_unlock(&\_client\_mutex); return 0; } if (IS\_USED(MODULE\_GCOAP\_DTLS)) { /\* reinitialize request tag \*/ \_req\_tag = (uint16\_t)random\_uint32(); } if ((strncmp(uri, "coap:", sizeof("coap:") - 1) != 0) && /\* if gcoap\_dtls is used, URIs not starting with coaps: are also invalid \*/ (!IS\_USED(MODULE\_GCOAP\_DTLS) || (strncmp(uri, "coaps:", sizeof("coaps:") - 1) != 0))) { return -EINVAL; } res = strlen(uri); if ((((unsigned)res + 1) >= CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN)) { return -ENOBUFS; } mutex\_lock(&\_client\_mutex); strcpy(\_uri, uri); if (uri\_parser\_process(&\_uri\_comp, \_uri, res) < 0) { res = -EINVAL; \_uri[0] = '\0'; } mutex\_unlock(&\_client\_mutex); return res;}
bool gcoap\_dns\_server\_uri\_is\_set(void){ mutex\_lock(&\_client\_mutex); bool res = \_dns\_server\_uri\_isset(); mutex\_unlock(&\_client\_mutex); return res;}
ssize\_t gcoap\_dns\_server\_uri\_get(char \*uri, size\_t uri\_len){ ssize\_t res = 0; mutex\_lock(&\_client\_mutex); if (\_dns\_server\_uri\_isset()) { res = strlen(\_uri); if ((size\_t)(res + 1) > uri\_len) { /\* account for trailing \0 \*/ res = -ENOBUFS; } else { strcpy(uri, \_uri); } } mutex\_unlock(&\_client\_mutex); return res;}
void gcoap\_dns\_cred\_reset(void){#if IS\_USED(MODULE\_GCOAP\_DTLS) sock\_dtls\_t \*sock = gcoap\_get\_sock\_dtls(); for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if (\_creds[i].type != CREDMAN\_TYPE\_EMPTY) { \_remove\_cred(sock, &\_creds[i]); } }#endif}
int gcoap\_dns\_cred\_add(credman\_credential\_t \*creds){ \_cred\_t \*c = NULL;
 if (!IS\_USED(MODULE\_GCOAP\_DTLS)) { return -ENOTSUP; } assert(creds != NULL);#if IS\_USED(MODULE\_GCOAP\_DTLS) for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if (!c && (((\_creds[i].type == creds->type) && (\_creds[i].tag == creds->tag)) || (\_creds[i].type == CREDMAN\_TYPE\_EMPTY))) { c = &\_creds[i]; break; } }#endif if (c == NULL) { DEBUG("gcoap\_dns: no space to store credential tag\n"); return -ENOMEM; } int res = credman\_add(creds); if ((res < 0) && (res != CREDMAN\_EXIST)) { /\* ignore duplicate credentials \*/ DEBUG("gcoap\_dns: cannot add credential to system: %d\n", res); return -EBADF; } if (res == CREDMAN\_OK) {#if IS\_USED(MODULE\_GCOAP\_DTLS) /\* functions used in here are only available with module gcoap\_dtls, so guard this \* section \*/ sock\_dtls\_t \*gcoap\_sock\_dtls = gcoap\_get\_sock\_dtls();
 res = sock\_dtls\_add\_credential(gcoap\_sock\_dtls, creds->tag); if (res < 0) { DEBUG("gcoap\_dns: cannot add credential to GCoAPs DTLS sock\n"); return -EBADF; }#endif c->tag = creds->tag; c->type = creds->type; } return 0;}
void gcoap\_dns\_cred\_remove(credman\_tag\_t tag, credman\_type\_t type){#if IS\_USED(MODULE\_GCOAP\_DTLS) sock\_dtls\_t \*sock = gcoap\_get\_sock\_dtls(); for (unsigned i = 0; i < ARRAY\_SIZE(\_creds); i++) { if ((\_creds[i].tag == tag) && (\_creds[i].type == type)) { \_remove\_cred(sock, &\_creds[i]); break; } }#else (void)tag; (void)type;#endif}
void gcoap\_dns\_server\_proxy\_reset(void){ if (IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED)) { mutex\_lock(&\_client\_mutex); \_proxy[0] = '\0'; mutex\_unlock(&\_client\_mutex); }}
int gcoap\_dns\_server\_proxy\_set(const char \*proxy){ int res;
 if (!IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED)) { return -ENOTSUP; } res = strlen(proxy);
 if ((unsigned)(res + 1) >= CONFIG\_GCOAP\_DNS\_SERVER\_URI\_LEN) { return -EINVAL; } mutex\_lock(&\_client\_mutex); strcpy(\_proxy, proxy); mutex\_unlock(&\_client\_mutex); return res;}
ssize\_t gcoap\_dns\_server\_proxy\_get(char \*proxy, size\_t proxy\_len){ ssize\_t res = 0; mutex\_lock(&\_client\_mutex); if (\_dns\_server\_uri\_isset()) { res = strscpy(proxy, \_proxy, proxy\_len); if (res == -E2BIG) { res = -ENOBUFS; } } mutex\_unlock(&\_client\_mutex); return res;}
static inline bool \_dns\_server\_uri\_isset(void){ return \_uri[0] != '\0';}
#if IS\_USED(MODULE\_GCOAP\_DTLS)static void \_remove\_cred(sock\_dtls\_t \*sock, \_cred\_t \*cred){ sock\_dtls\_remove\_credential(sock, cred->tag); credman\_delete(cred->tag, cred->type); cred->type = CREDMAN\_TYPE\_EMPTY; cred->tag = CREDMAN\_TAG\_EMPTY;}#endif
static inline bool \_is\_proxied(void){ return IS\_USED(MODULE\_GCOAP\_DNS\_PROXIED) && \_proxy[0] != '\0';}
static int \_add\_init\_block2\_opt(coap\_pkt\_t \*pdu){ if (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE < CONFIG\_DNS\_MSG\_LEN) { /\* If our largest DNS message fits in the DNS PDU BUF, there is no point in sending Block2 \* in the initial message---a huge response might still overwhelm our PDU buffer, but if \* that happens we could not have processed it as a DNS message if it came in in fragments \* either. \*/ coap\_block1\_t block;
 coap\_block\_object\_init(&block, 0, CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE, 0); return coap\_opt\_add\_block2\_control(pdu, &block); } return 0;}
static int \_add\_proxy\_uri\_opt(coap\_pkt\_t \*pdu, const char \*proxy\_uri){ if (\_is\_proxied()) { return coap\_opt\_add\_proxy\_uri(pdu, proxy\_uri); } return 0;}
static int \_add\_req\_tag\_opt(coap\_pkt\_t \*pdu, \_req\_ctx\_t \*context){#if IS\_USED(MODULE\_GCOAP\_DTLS) if (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE < CONFIG\_DNS\_MSG\_LEN) { return coap\_opt\_add\_opaque(pdu, 292, (uint8\_t \*)&context->req\_tag, sizeof(context->req\_tag)); }#else (void)pdu; (void)context;#endif return 0;}
static int \_add\_remaining\_options(coap\_pkt\_t \*pdu, const char \*proxy\_uri, \_req\_ctx\_t \*context){ if (\_add\_proxy\_uri\_opt(pdu, proxy\_uri) < 0) { DEBUG("gcoap\_dns: unable to add Proxy-URI option to request\n"); return -ENOBUFS; } /\* add request tag to distinguish multiple blockwise requests on-the-air \*/ if (\_add\_req\_tag\_opt(pdu, context) < 0) { DEBUG("gcoap\_dns: unable to add Request-Tag option to request"); return -ENOBUFS; } return 0;}
static size\_t \_dns\_msg\_compose(void \*dns\_buf, const char \*domain\_name, int family){ return dns\_msg\_compose\_query(dns\_buf, domain\_name, 0, family);}
static int \_set\_remote(const uri\_parser\_result\_t \*uri\_comp, sock\_udp\_ep\_t \*remote) { assert(uri\_comp->host != NULL); memset(remote, 0, sizeof(\*remote));
 if (uri\_comp->ipv6addr != NULL) { if (ipv6\_addr\_from\_buf((ipv6\_addr\_t \*)remote->addr.ipv6, uri\_comp->ipv6addr, uri\_comp->ipv6addr\_len) == NULL) { DEBUG("gcoap\_dns: unable to parse IPv6 address %\*.s\n", uri\_comp->ipv6addr\_len, uri\_comp->ipv6addr); return -EINVAL; } remote->family = AF\_INET6; if (uri\_comp->zoneid != NULL) { netif\_t \*netif = netif\_get\_by\_name\_buffer(uri\_comp->zoneid, uri\_comp->zoneid\_len); if (netif == NULL) { DEBUG("gcoap\_dns: unable to interpret zoneid %\*.s\n", uri\_comp->zoneid\_len, uri\_comp->zoneid); return -ENOENT; } remote->netif = netif\_get\_id(netif); } else { remote->netif = SOCK\_ADDR\_ANY\_NETIF; } } else if (ipv4\_addr\_from\_buf((ipv4\_addr\_t \*)remote->addr.ipv4, uri\_comp->host, uri\_comp->host\_len) != NULL) { remote->family = AF\_INET; } else if (IS\_USED(MODULE\_SOCK\_DNS)) { char hostname[uri\_comp->host\_len + 1];
 strncpy(hostname, uri\_comp->host, uri\_comp->host\_len); hostname[uri\_comp->host\_len] = '\0'; int res = sock\_dns\_query(hostname, remote->addr.ipv6, AF\_UNSPEC); if (res < 0) { DEBUG("gcoap\_dns: unable to resolve hostname %s for remote\n", hostname); return -EHOSTUNREACH; } if (res == sizeof(remote->addr.ipv4)) { remote->family = AF\_INET; } else if (res == sizeof(remote->addr.ipv6)) { remote->family = AF\_INET6; } else { DEBUG("gcoap\_dns: Unable to determine address family of hostname %s.\n", hostname); return -EHOSTUNREACH; } } else { DEBUG("gcoap\_dns: unable to resolve hostname in URI %s for remote\n", \_uri); return -EHOSTUNREACH; } if (uri\_comp->port == 0) { if (strncmp(\_uri, "coap:", sizeof("coap:") - 1) == 0) { remote->port = CONFIG\_GCOAP\_PORT; } else { remote->port = CONFIG\_GCOAPS\_PORT; } } else { remote->port = uri\_comp->port; } return 0;}
static int \_gen\_uri(uri\_parser\_result\_t \*uri\_comp){ const char \*uri = (\_is\_proxied()) ? \_proxy : \_uri; int res = uri\_parser\_process\_string(uri\_comp, uri);
 if (res < 0) { return -EINVAL; } return strlen(uri);}
static ssize\_t \_req\_init(coap\_pkt\_t \*pdu, uri\_parser\_result\_t \*uri\_comp, bool con){ gcoap\_req\_init\_path\_buffer(pdu, pdu->payload, pdu->payload\_len, COAP\_METHOD\_FETCH, uri\_comp->path, uri\_comp->path\_len); if (con) { coap\_hdr\_set\_type(pdu->hdr, COAP\_TYPE\_CON); }
 if (coap\_opt\_add\_format(pdu, COAP\_FORMAT\_DNS\_MESSAGE) < 0) { DEBUG("gcoap\_dns: unable to add Content-Format option to request\n"); } if (coap\_opt\_add\_accept(pdu, COAP\_FORMAT\_DNS\_MESSAGE) < 0) { DEBUG("gcoap\_dns: unable to add Accept option to request\n"); } if (IS\_USED(MODULE\_GCOAP\_DTLS) && (uri\_comp->scheme\_len == (sizeof("coaps") - 1)) && (strncmp(uri\_comp->scheme, "coaps", uri\_comp->scheme\_len) == 0)) { return GCOAP\_SOCKET\_TYPE\_DTLS; } return GCOAP\_SOCKET\_TYPE\_UDP;}
static int \_do\_block(coap\_pkt\_t \*pdu, const sock\_udp\_ep\_t \*remote, \_req\_ctx\_t \*context){ gcoap\_socket\_type\_t tl\_type; ssize\_t len; bool more; coap\_block\_slicer\_t slicer;
 coap\_block\_slicer\_init(&slicer, context->cur\_blk\_num++, CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE); tl\_type = \_req\_init(pdu, &\_uri\_comp, true); if (tl\_type == GCOAP\_SOCKET\_TYPE\_UNDEF) { return -EINVAL; } more = (CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE >= CONFIG\_DNS\_MSG\_LEN) || (slicer.end < context->dns\_buf\_len); if (!more && (\_add\_init\_block2\_opt(pdu) < 0)) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); return -ENOBUFS; } if (coap\_opt\_add\_block1(pdu, &slicer, context->dns\_buf\_len > CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE) < 0) { DEBUG("gcoap\_dns: unable to add Block1 option to request\n"); return -ENOBUFS; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { return -ENOBUFS; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_PAYLOAD);
 len += coap\_blockwise\_put\_bytes(&slicer, pdu->payload, context->dns\_buf, context->dns\_buf\_len);
 coap\_block1\_finish(&slicer);
 if ((len = \_send(pdu->hdr, len, remote, slicer.start == 0, context, tl\_type)) <= 0) { DEBUG("gcoap\_dns: msg send failed: %" PRIdSIZE "\n", len); return len; } return len;}
static ssize\_t \_req(\_req\_ctx\_t \*context){ coap\_pkt\_t \*pdu = context->pkt; ssize\_t len;
 if ((len = \_gen\_uri(&\_uri\_comp)) < 0) { DEBUG("gcoap\_dns: unable to parse URI\n"); return len; } if ((len = \_set\_remote(&\_uri\_comp, &\_remote)) < 0) { return len; } if (context->dns\_buf\_len > CONFIG\_GCOAP\_DNS\_BLOCK\_SIZE) { context->cur\_blk\_num = 0U; return \_do\_block(pdu, &\_remote, context); } else { gcoap\_socket\_type\_t tl\_type = \_req\_init(pdu, &\_uri\_comp, true); if (tl\_type == GCOAP\_SOCKET\_TYPE\_UNDEF) { return -EINVAL; } if (\_add\_init\_block2\_opt(pdu) < 0) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); return -ENOBUFS; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { DEBUG("gcoap\_dns: unable to add Proxy-URI option to request\n"); return -ENOBUFS; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_PAYLOAD); memcpy(pdu->payload, context->dns\_buf, context->dns\_buf\_len); return \_send(pdu->hdr, len + context->dns\_buf\_len, &\_remote, true, context, tl\_type); }}
static int \_dns\_query(const char \*domain\_name, \_req\_ctx\_t \*req\_ctx){ int res;
 assert(domain\_name != NULL); if (!\_dns\_server\_uri\_isset()) { DEBUG("gcoap\_dns: no URI template provided\n"); return -ECONNREFUSED; } req\_ctx->dns\_buf\_len = \_dns\_msg\_compose( req\_ctx->dns\_buf, domain\_name, req\_ctx->family );#if IS\_USED(MODULE\_DNS\_CACHE) req\_ctx->domain\_name = domain\_name;#endif#if IS\_USED(MODULE\_GCOAP\_DTLS) req\_ctx->req\_tag = \_req\_tag++;#endif res = \_req(req\_ctx); if (res <= 0) { DEBUG("gcoap\_dns: unable to send request\n"); if (res == 0) { res = -ENOTRECOVERABLE; } } return res;}
static const char \*\_domain\_name\_from\_ctx(\_req\_ctx\_t \*context){#if IS\_USED(MODULE\_DNS\_CACHE) return context->domain\_name;#else (void)context; return NULL;#endif}
static void \_resp\_handler(const gcoap\_request\_memo\_t \*memo, coap\_pkt\_t \*pdu, const sock\_udp\_ep\_t \*remote){ coap\_block1\_t block; \_req\_ctx\_t \*context = memo->context; void \*data; size\_t data\_len; int family = context->family;
 if (memo->state == GCOAP\_MEMO\_TIMEOUT) { DEBUG("gcoap\_dns: CoAP request timed out\n"); context->res = -ETIMEDOUT; goto unlock; } else if (memo->state != GCOAP\_MEMO\_RESP) { DEBUG("gcoap\_dns: error in response\n"); context->res = -EBADMSG; goto unlock; }
 if ((remote->port != \_remote.port) || (remote->family != \_remote.family) || (!ipv6\_addr\_is\_unspecified((ipv6\_addr\_t \*)\_remote.addr.ipv6) && (memcmp(remote->addr.ipv6, \_remote.addr.ipv6, sizeof(\_remote.addr.ipv6)) != 0))) { DEBUG("gcoap\_dns: unexpected remote for reply\n"); context->res = -EDESTADDRREQ; goto unlock; } if (coap\_get\_code\_class(pdu) != COAP\_CLASS\_SUCCESS) { DEBUG("gcoap\_dns: unsuccessful response: %1u.%02u\n", coap\_get\_code\_class(pdu), coap\_get\_code\_detail(pdu)); context->res = -EBADMSG; goto unlock; } if (coap\_get\_code\_raw(pdu) == COAP\_CODE\_CONTINUE) { int res = \_do\_block(pdu, remote, context);
 if (res < 0) { context->res = res; goto unlock; } return; } if (coap\_get\_block2(pdu, &block)) { uint8\_t \*dns\_buf = context->dns\_buf;
 if ((block.offset + pdu->payload\_len) > CONFIG\_DNS\_MSG\_LEN) { DEBUG("gcoap\_dns: No buffer space for block-wise transfer " "(%" PRIuSIZE " + %u) > %u\n", block.offset, pdu->payload\_len, CONFIG\_DNS\_MSG\_LEN); context->res = -ENOBUFS; goto unlock; } memcpy(&dns\_buf[block.offset], pdu->payload, pdu->payload\_len); if (block.blknum == 0) { context->dns\_buf\_len = pdu->payload\_len; if (block.more && strlen(\_uri) == 0) { DEBUG("gcoap\_dns: Cannot complete block-wise\n"); context->res = -EINVAL; goto unlock; } } else { context->dns\_buf\_len += pdu->payload\_len; } if (block.more) { gcoap\_socket\_type\_t tl\_type; unsigned msg\_type = coap\_get\_type(pdu); int len;
 pdu->payload = (uint8\_t \*)pdu->hdr; pdu->payload\_len = CONFIG\_GCOAP\_DNS\_PDU\_BUF\_SIZE; tl\_type = \_req\_init(pdu, &\_uri\_comp, msg\_type == COAP\_TYPE\_ACK); block.blknum++; if (coap\_opt\_add\_block2\_control(pdu, &block) < 0) { DEBUG("gcoap\_dns: unable to add Block2 option to request\n"); context->res = -ENOBUFS; goto unlock; } if (\_add\_remaining\_options(pdu, \_uri, context) < 0) { context->res = -ENOBUFS; goto unlock; } len = coap\_opt\_finish(pdu, COAP\_OPT\_FINISH\_NONE); if ((len = \_send((uint8\_t \*)pdu->hdr, len, remote, false, context, tl\_type)) <= 0) { DEBUG("gcoap\_dns: Unable to request next block: %d\n", len); context->res = len; goto unlock; } return; } data = context->dns\_buf; data\_len = context->dns\_buf\_len; } else { data = pdu->payload; data\_len = pdu->payload\_len; } switch (coap\_get\_content\_type(pdu)) { case COAP\_FORMAT\_DNS\_MESSAGE: case COAP\_FORMAT\_NONE: { uint32\_t ttl = 0;
 context->res = dns\_msg\_parse\_reply(data, data\_len, family, context->addr\_out, &ttl); if (IS\_USED(MODULE\_DNS\_CACHE) && (context->res > 0)) { uint32\_t max\_age;
 if (coap\_opt\_get\_uint(pdu, COAP\_OPT\_MAX\_AGE, &max\_age) < 0) { max\_age = 60; } ttl += max\_age; dns\_cache\_add(\_domain\_name\_from\_ctx(context), context->addr\_out, context->res, ttl); } else if (ENABLE\_DEBUG && (context->res < 0)) { DEBUG("gcoap\_dns: Unable to parse DNS reply: %d\n", context->res); } break; } default: context->res = -ENOMSG; break; }unlock: mutex\_unlock(&context->resp\_wait);}
static ssize\_t \_send(const void \*buf, size\_t len, const sock\_udp\_ep\_t \*remote, bool lock\_resp\_wait, \_req\_ctx\_t \*context, gcoap\_socket\_type\_t tl\_type){ if (lock\_resp\_wait) { mutex\_lock(&context->resp\_wait); } return gcoap\_req\_send(buf, len, remote, NULL, \_resp\_handler, context, tl\_type);}/\*\* @} \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.openwall.com_7d2efbe7_20250110_161658.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](2) [[next>]](4) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <CAM+3YVrhBBfX_9=q_otAJQi=cP0qcdXsc9qy7s1WNSa=aNGy3A@mail.gmail.com>
Date: Tue, 7 May 2024 10:57:02 +0200
From: Marco Ivaldi <raptor@...eadbeef.info>
To: fulldisclosure@...lists.org, oss-security@...ts.openwall.com,
	submissions@...ketstormsecurity.com
Subject: HNS-2024-07 - HN Security Advisory - Multiple vulnerabilities in RIOT OS

Hi,

Please find attached a security advisory that describes multiple
vulnerabilities we discovered in RIOT OS.

* Title: Multiple vulnerabilities in RIOT OS
* OS: RIOT <= 2024.01
* Author: Marco Ivaldi <marco.ivaldi@...ecurity.it>
* Date: 2024-05-07
* CVE ID and severity:
  * CVE-2024-31225 - High
  * CVE-2024-32017 - Critical
  * CVE-2024-32018 - High
  (low-severity vulnerabilities were not assigned a CVE ID)
* Vendor URL: <https://www.riot-os.org/>
* Advisory URLs:
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-2572-7q7c-3965>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-v97j-w9m6-c4h3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-899m-q6pp-hmp3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-x3j5-hfrr-5x6q>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-pw2r-pp35-xfmj>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-c4p4-vv7v-3hx8>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-r87w-9vw9-f7cx>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-2hx7-c324-3rxv>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-frp5-4gfp-84j3>
  * <https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-x27v-gqp4-7jq3>

The advisory is also available at:
<https://github.com/hnsecurity/vulns/blob/main/HNS-2024-07-riot.txt>

For additional information, please refer to our vulnerability writeup:
<https://security.humanativaspa.it/multiple-vulnerabilities-in-riot-os/>

Regards,

--
Marco Ivaldi
<https://0xdeadbeef.info/>
"When cryptography is outlawed, bayl bhgynjf jvyy unir cevinpl."

View attachment "[HNS-2024-07-riot.txt](3/1)" of type "text/plain" (33540 bytes)

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).


