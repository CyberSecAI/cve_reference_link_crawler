
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpypa%2Fsetuptools%2Fblob%2Ffe8a98e696241487ba6ac9f91faa38ade939ec5d%2Fsetuptools%2Fpackage_index.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpypa%2Fsetuptools%2Fblob%2Ffe8a98e696241487ba6ac9f91faa38ade939ec5d%2Fsetuptools%2Fpackage_index.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=pypa%2Fsetuptools)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[pypa](/pypa)
/
**[setuptools](/pypa/setuptools)**
Public

* [Notifications](/login?return_to=%2Fpypa%2Fsetuptools) You must be signed in to change notification settings
* [Fork
  1.2k](/login?return_to=%2Fpypa%2Fsetuptools)
* [Star
   2.6k](/login?return_to=%2Fpypa%2Fsetuptools)

* [Code](/pypa/setuptools)
* [Issues
  595](/pypa/setuptools/issues)
* [Pull requests
  42](/pypa/setuptools/pulls)
* [Discussions](/pypa/setuptools/discussions)
* [Actions](/pypa/setuptools/actions)
* [Projects
  0](/pypa/setuptools/projects)
* [Wiki](/pypa/setuptools/wiki)
* [Security](/pypa/setuptools/security)
* [Insights](/pypa/setuptools/pulse)

Additional navigation options

* [Code](/pypa/setuptools)
* [Issues](/pypa/setuptools/issues)
* [Pull requests](/pypa/setuptools/pulls)
* [Discussions](/pypa/setuptools/discussions)
* [Actions](/pypa/setuptools/actions)
* [Projects](/pypa/setuptools/projects)
* [Wiki](/pypa/setuptools/wiki)
* [Security](/pypa/setuptools/security)
* [Insights](/pypa/setuptools/pulse)

## Files

 fe8a98e
## Breadcrumbs

1. [setuptools](/pypa/setuptools/tree/fe8a98e696241487ba6ac9f91faa38ade939ec5d)
2. /[setuptools](/pypa/setuptools/tree/fe8a98e696241487ba6ac9f91faa38ade939ec5d/setuptools)
/
# package\_index.py

 Blame  Blame
## Latest commit

## History

[History](/pypa/setuptools/commits/fe8a98e696241487ba6ac9f91faa38ade939ec5d/setuptools/package_index.py)1126 lines (946 loc) · 39.1 KB fe8a98e
## Breadcrumbs

1. [setuptools](/pypa/setuptools/tree/fe8a98e696241487ba6ac9f91faa38ade939ec5d)
2. /[setuptools](/pypa/setuptools/tree/fe8a98e696241487ba6ac9f91faa38ade939ec5d/setuptools)
/
# package\_index.py

Top
## File metadata and controls

* Code
* Blame

1126 lines (946 loc) · 39.1 KB[Raw](https://github.com/pypa/setuptools/raw/fe8a98e696241487ba6ac9f91faa38ade939ec5d/setuptools/package_index.py)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000"""PyPI and direct package downloading"""import sysimport osimport reimport ioimport shutilimport socketimport base64import hashlibimport itertoolsimport warningsimport configparserimport htmlimport http.clientimport urllib.parseimport urllib.requestimport urllib.errorfrom functools import wraps
import setuptoolsfrom pkg\_resources import ( CHECKOUT\_DIST, Distribution, BINARY\_DIST, normalize\_path, SOURCE\_DIST, Environment, find\_distributions, safe\_name, safe\_version, to\_filename, Requirement, DEVELOP\_DIST, EGG\_DIST, parse\_version,)from distutils import logfrom distutils.errors import DistutilsErrorfrom fnmatch import translatefrom setuptools.wheel import Wheelfrom setuptools.extern.more\_itertools import unique\_everseen
EGG\_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9\_.+!]+)$')HREF = re.compile(r"""href\s\*=\s\*['"]?([^'"> ]+)""", re.I)PYPI\_MD5 = re.compile( r'<a href="([^"#]+)">([^<]+)</a>\n\s+\(<a (?:title="MD5 hash"\n\s+)' r'href="[^?]+\?:action=show\_md5&amp;digest=([0-9a-f]{32})">md5</a>\)')URL\_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).matchEXTENSIONS = ".tar.gz .tar.bz2 .tar .zip .tgz".split()
\_\_all\_\_ = [ 'PackageIndex', 'distros\_for\_url', 'parse\_bdist\_wininst', 'interpret\_distro\_name',]
\_SOCKET\_TIMEOUT = 15
\_tmpl = "setuptools/{setuptools.\_\_version\_\_} Python-urllib/{py\_major}"user\_agent = \_tmpl.format( py\_major='{}.{}'.format(\*sys.version\_info), setuptools=setuptools)
def parse\_requirement\_arg(spec): try: return Requirement.parse(spec) except ValueError as e: raise DistutilsError( "Not a URL, existing file, or requirement spec: %r" % (spec,) ) from e
def parse\_bdist\_wininst(name): """Return (base,pyversion) or (None,None) for possible .exe name"""
 lower = name.lower() base, py\_ver, plat = None, None, None
 if lower.endswith('.exe'): if lower.endswith('.win32.exe'): base = name[:-10] plat = 'win32' elif lower.startswith('.win32-py', -16): py\_ver = name[-7:-4] base = name[:-16] plat = 'win32' elif lower.endswith('.win-amd64.exe'): base = name[:-14] plat = 'win-amd64' elif lower.startswith('.win-amd64-py', -20): py\_ver = name[-7:-4] base = name[:-20] plat = 'win-amd64' return base, py\_ver, plat
def egg\_info\_for\_url(url): parts = urllib.parse.urlparse(url) scheme, server, path, parameters, query, fragment = parts base = urllib.parse.unquote(path.split('/')[-1]) if server == 'sourceforge.net' and base == 'download': # XXX Yuck base = urllib.parse.unquote(path.split('/')[-2]) if '#' in base: base, fragment = base.split('#', 1) return base, fragment
def distros\_for\_url(url, metadata=None): """Yield egg or source distribution objects that might be found at a URL""" base, fragment = egg\_info\_for\_url(url) for dist in distros\_for\_location(url, base, metadata): yield dist if fragment: match = EGG\_FRAGMENT.match(fragment) if match: for dist in interpret\_distro\_name( url, match.group(1), metadata, precedence=CHECKOUT\_DIST ): yield dist
def distros\_for\_location(location, basename, metadata=None): """Yield egg or source distribution objects based on basename""" if basename.endswith('.egg.zip'): basename = basename[:-4] # strip the .zip if basename.endswith('.egg') and '-' in basename: # only one, unambiguous interpretation return [Distribution.from\_location(location, basename, metadata)] if basename.endswith('.whl') and '-' in basename: wheel = Wheel(basename) if not wheel.is\_compatible(): return [] return [Distribution( location=location, project\_name=wheel.project\_name, version=wheel.version, # Increase priority over eggs. precedence=EGG\_DIST + 1, )] if basename.endswith('.exe'): win\_base, py\_ver, platform = parse\_bdist\_wininst(basename) if win\_base is not None: return interpret\_distro\_name( location, win\_base, metadata, py\_ver, BINARY\_DIST, platform ) # Try source distro extensions (.zip, .tgz, etc.) # for ext in EXTENSIONS: if basename.endswith(ext): basename = basename[:-len(ext)] return interpret\_distro\_name(location, basename, metadata) return [] # no extension matched
def distros\_for\_filename(filename, metadata=None): """Yield possible egg or source distribution objects based on a filename""" return distros\_for\_location( normalize\_path(filename), os.path.basename(filename), metadata )
def interpret\_distro\_name( location, basename, metadata, py\_version=None, precedence=SOURCE\_DIST, platform=None): """Generate alternative interpretations of a source distro name
 Note: if `location` is a filesystem filename, you should call ``pkg\_resources.normalize\_path()`` on it before passing it to this routine! """ # Generate alternative interpretations of a source distro name # Because some packages are ambiguous as to name/versions split # e.g. "adns-python-1.1.0", "egenix-mx-commercial", etc. # So, we generate each possible interpretation (e.g. "adns, python-1.1.0" # "adns-python, 1.1.0", and "adns-python-1.1.0, no version"). In practice, # the spurious interpretations should be ignored, because in the event # there's also an "adns" package, the spurious "python-1.1.0" version will # compare lower than any numeric version number, and is therefore unlikely # to match a request for it. It's still a potential problem, though, and # in the long run PyPI and the distutils should go for "safe" names and # versions in distribution archive names (sdist and bdist).
 parts = basename.split('-') if not py\_version and any(re.match(r'py\d\.\d$', p) for p in parts[2:]): # it is a bdist\_dumb, not an sdist -- bail out return
 for p in range(1, len(parts) + 1): yield Distribution( location, metadata, '-'.join(parts[:p]), '-'.join(parts[p:]), py\_version=py\_version, precedence=precedence, platform=platform )
def unique\_values(func): """ Wrap a function returning an iterable such that the resulting iterable only ever yields unique items. """
 @wraps(func) def wrapper(\*args, \*\*kwargs): return unique\_everseen(func(\*args, \*\*kwargs))
 return wrapper
REL = re.compile(r"""<([^>]\*\srel\s\*=\s\*['"]?([^'">]+)[^>]\*)>""", re.I)# this line is here to fix emacs' cruddy broken syntax highlighting
@unique\_valuesdef find\_external\_links(url, page): """Find rel="homepage" and rel="download" links in `page`, yielding URLs"""
 for match in REL.finditer(page): tag, rel = match.groups() rels = set(map(str.strip, rel.lower().split(','))) if 'homepage' in rels or 'download' in rels: for match in HREF.finditer(tag): yield urllib.parse.urljoin(url, htmldecode(match.group(1)))
 for tag in ("<th>Home Page", "<th>Download URL"): pos = page.find(tag) if pos != -1: match = HREF.search(page, pos) if match: yield urllib.parse.urljoin(url, htmldecode(match.group(1)))
class ContentChecker: """ A null content checker that defines the interface for checking content """
 def feed(self, block): """ Feed a block of data to the hash. """ return
 def is\_valid(self): """ Check the hash. Return False if validation fails. """ return True
 def report(self, reporter, template): """ Call reporter with information about the checker (hash name) substituted into the template. """ return
class HashChecker(ContentChecker): pattern = re.compile( r'(?P<hash\_name>sha1|sha224|sha384|sha256|sha512|md5)=' r'(?P<expected>[a-f0-9]+)' )
 def \_\_init\_\_(self, hash\_name, expected): self.hash\_name = hash\_name self.hash = hashlib.new(hash\_name) self.expected = expected
 @classmethod def from\_url(cls, url): "Construct a (possibly null) ContentChecker from a URL" fragment = urllib.parse.urlparse(url)[-1] if not fragment: return ContentChecker() match = cls.pattern.search(fragment) if not match: return ContentChecker() return cls(\*\*match.groupdict())
 def feed(self, block): self.hash.update(block)
 def is\_valid(self): return self.hash.hexdigest() == self.expected
 def report(self, reporter, template): msg = template % self.hash\_name return reporter(msg)
class PackageIndex(Environment): """A distribution index that scans web pages for download URLs"""
 def \_\_init\_\_( self, index\_url="https://pypi.org/simple/", hosts=('\*',), ca\_bundle=None, verify\_ssl=True, \*args, \*\*kw ): super().\_\_init\_\_(\*args, \*\*kw) self.index\_url = index\_url + "/" [:not index\_url.endswith('/')] self.scanned\_urls = {} self.fetched\_urls = {} self.package\_pages = {} self.allows = re.compile('|'.join(map(translate, hosts))).match self.to\_scan = [] self.opener = urllib.request.urlopen
 def add(self, dist): # ignore invalid versions try: parse\_version(dist.version) except Exception: return return super().add(dist)
 # FIXME: 'PackageIndex.process\_url' is too complex (14) def process\_url(self, url, retrieve=False): # noqa: C901 """Evaluate a URL as a possible download, and maybe retrieve it""" if url in self.scanned\_urls and not retrieve: return self.scanned\_urls[url] = True if not URL\_SCHEME(url): self.process\_filename(url) return else: dists = list(distros\_for\_url(url)) if dists: if not self.url\_ok(url): return self.debug("Found link: %s", url)
 if dists or not retrieve or url in self.fetched\_urls: list(map(self.add, dists)) return # don't need the actual page
 if not self.url\_ok(url): self.fetched\_urls[url] = True return
 self.info("Reading %s", url) self.fetched\_urls[url] = True # prevent multiple fetch attempts tmpl = "Download error on %s: %%s -- Some packages may not be found!" f = self.open\_url(url, tmpl % url) if f is None: return if isinstance(f, urllib.error.HTTPError) and f.code == 401: self.info("Authentication error: %s" % f.msg) self.fetched\_urls[f.url] = True if 'html' not in f.headers.get('content-type', '').lower(): f.close() # not html, we can't process it return
 base = f.url # handle redirects page = f.read() if not isinstance(page, str): # In Python 3 and got bytes but want str. if isinstance(f, urllib.error.HTTPError): # Errors have no charset, assume latin1: charset = 'latin-1' else: charset = f.headers.get\_param('charset') or 'latin-1' page = page.decode(charset, "ignore") f.close() for match in HREF.finditer(page): link = urllib.parse.urljoin(base, htmldecode(match.group(1))) self.process\_url(link) if url.startswith(self.index\_url) and getattr(f, 'code', None) != 404: page = self.process\_index(url, page)
 def process\_filename(self, fn, nested=False): # process filenames or directories if not os.path.exists(fn): self.warn("Not found: %s", fn) return
 if os.path.isdir(fn) and not nested: path = os.path.realpath(fn) for item in os.listdir(path): self.process\_filename(os.path.join(path, item), True)
 dists = distros\_for\_filename(fn) if dists: self.debug("Found: %s", fn) list(map(self.add, dists))
 def url\_ok(self, url, fatal=False): s = URL\_SCHEME(url) is\_file = s and s.group(1).lower() == 'file' if is\_file or self.allows(urllib.parse.urlparse(url)[1]): return True msg = ( "\nNote: Bypassing %s (disallowed host; see " "http://bit.ly/2hrImnY for details).\n") if fatal: raise DistutilsError(msg % url) else: self.warn(msg, url)
 def scan\_egg\_links(self, search\_path): dirs = filter(os.path.isdir, search\_path) egg\_links = ( (path, entry) for path in dirs for entry in os.listdir(path) if entry.endswith('.egg-link') ) list(itertools.starmap(self.scan\_egg\_link, egg\_links))
 def scan\_egg\_link(self, path, entry): with open(os.path.join(path, entry)) as raw\_lines: # filter non-empty lines lines = list(filter(None, map(str.strip, raw\_lines)))
 if len(lines) != 2: # format is not recognized; punt return
 egg\_path, setup\_path = lines
 for dist in find\_distributions(os.path.join(path, egg\_path)): dist.location = os.path.join(path, \*lines) dist.precedence = SOURCE\_DIST self.add(dist)
 def \_scan(self, link): # Process a URL to see if it's for a package page NO\_MATCH\_SENTINEL = None, None if not link.startswith(self.index\_url): return NO\_MATCH\_SENTINEL
 parts = list(map( urllib.parse.unquote, link[len(self.index\_url):].split('/') )) if len(parts) != 2 or '#' in parts[1]: return NO\_MATCH\_SENTINEL
 # it's a package page, sanitize and index it pkg = safe\_name(parts[0]) ver = safe\_version(parts[1]) self.package\_pages.setdefault(pkg.lower(), {})[link] = True return to\_filename(pkg), to\_filename(ver)
 def process\_index(self, url, page): """Process the contents of a PyPI page"""
 # process an index page into the package-page index for match in HREF.finditer(page): try: self.\_scan(urllib.parse.urljoin(url, htmldecode(match.group(1)))) except ValueError: pass
 pkg, ver = self.\_scan(url) # ensure this page is in the page index if not pkg: return "" # no sense double-scanning non-package pages
 # process individual package page for new\_url in find\_external\_links(url, page): # Process the found URL base, frag = egg\_info\_for\_url(new\_url) if base.endswith('.py') and not frag: if ver: new\_url += '#egg=%s-%s' % (pkg, ver) else: self.need\_version\_info(url) self.scan\_url(new\_url)
 return PYPI\_MD5.sub( lambda m: '<a href="%s#md5=%s">%s</a>' % m.group(1, 3, 2), page )
 def need\_version\_info(self, url): self.scan\_all( "Page at %s links to .py file(s) without version info; an index " "scan is required.", url )
 def scan\_all(self, msg=None, \*args): if self.index\_url not in self.fetched\_urls: if msg: self.warn(msg, \*args) self.info( "Scanning index of all packages (this may take a while)" ) self.scan\_url(self.index\_url)
 def find\_packages(self, requirement): self.scan\_url(self.index\_url + requirement.unsafe\_name + '/')
 if not self.package\_pages.get(requirement.key): # Fall back to safe version of the name self.scan\_url(self.index\_url + requirement.project\_name + '/')
 if not self.package\_pages.get(requirement.key): # We couldn't find the target package, so search the index page too self.not\_found\_in\_index(requirement)
 for url in list(self.package\_pages.get(requirement.key, ())): # scan each page that might be related to the desired package self.scan\_url(url)
 def obtain(self, requirement, installer=None): self.prescan() self.find\_packages(requirement) for dist in self[requirement.key]: if dist in requirement: return dist self.debug("%s does not match %s", requirement, dist) return super(PackageIndex, self).obtain(requirement, installer)
 def check\_hash(self, checker, filename, tfp): """ checker is a ContentChecker """ checker.report( self.debug, "Validating %%s checksum for %s" % filename) if not checker.is\_valid(): tfp.close() os.unlink(filename) raise DistutilsError( "%s validation failed for %s; " "possible download problem?" % (checker.hash.name, os.path.basename(filename)) )
 def add\_find\_links(self, urls): """Add `urls` to the list that will be prescanned for searches""" for url in urls: if ( self.to\_scan is None # if we have already "gone online" or not URL\_SCHEME(url) # or it's a local file/directory or url.startswith('file:') or list(distros\_for\_url(url)) # or a direct package link ): # then go ahead and process it now self.scan\_url(url) else: # otherwise, defer retrieval till later self.to\_scan.append(url)
 def prescan(self): """Scan urls scheduled for prescanning (e.g. --find-links)""" if self.to\_scan: list(map(self.scan\_url, self.to\_scan)) self.to\_scan = None # from now on, go ahead and process immediately
 def not\_found\_in\_index(self, requirement): if self[requirement.key]: # we've seen at least one distro meth, msg = self.info, "Couldn't retrieve index page for %r" else: # no distros seen for this name, might be misspelled meth, msg = ( self.warn, "Couldn't find index page for %r (maybe misspelled?)") meth(msg, requirement.unsafe\_name) self.scan\_all()
 def download(self, spec, tmpdir): """Locate and/or download `spec` to `tmpdir`, returning a local path
 `spec` may be a ``Requirement`` object, or a string containing a URL, an existing local filename, or a project/version requirement spec (i.e. the string form of a ``Requirement`` object). If it is the URL of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one that escapes ``-`` as ``\_`` throughout), a trivial ``setup.py`` is automatically created alongside the downloaded file.
 If `spec` is a ``Requirement`` object or a string containing a project/version requirement spec, this method returns the location of a matching distribution (possibly after downloading it to `tmpdir`). If `spec` is a locally existing file or directory name, it is simply returned unchanged. If `spec` is a URL, it is downloaded to a subpath of `tmpdir`, and the local filename is returned. Various errors may be raised if a problem occurs during downloading. """ if not isinstance(spec, Requirement): scheme = URL\_SCHEME(spec) if scheme: # It's a url, download it to tmpdir found = self.\_download\_url(scheme.group(1), spec, tmpdir) base, fragment = egg\_info\_for\_url(spec) if base.endswith('.py'): found = self.gen\_setup(found, fragment, tmpdir) return found elif os.path.exists(spec): # Existing file or directory, just return it return spec else: spec = parse\_requirement\_arg(spec) return getattr(self.fetch\_distribution(spec, tmpdir), 'location', None)
 def fetch\_distribution( # noqa: C901 # is too complex (14) # FIXME self, requirement, tmpdir, force\_scan=False, source=False, develop\_ok=False, local\_index=None): """Obtain a distribution suitable for fulfilling `requirement`
 `requirement` must be a ``pkg\_resources.Requirement`` instance. If necessary, or if the `force\_scan` flag is set, the requirement is searched for in the (online) package index as well as the locally installed packages. If a distribution matching `requirement` is found, the returned distribution's ``location`` is the value you would have gotten from calling the ``download()`` method with the matching distribution's URL or filename. If no matching distribution is found, ``None`` is returned.
 If the `source` flag is set, only source distributions and source checkout links will be considered. Unless the `develop\_ok` flag is set, development and system eggs (i.e., those using the ``.egg-info`` format) will be ignored. """ # process a Requirement self.info("Searching for %s", requirement) skipped = {} dist = None
 def find(req, env=None): if env is None: env = self # Find a matching distribution; may be called more than once
 for dist in env[req.key]:
 if dist.precedence == DEVELOP\_DIST and not develop\_ok: if dist not in skipped: self.warn( "Skipping development or system egg: %s", dist, ) skipped[dist] = 1 continue
 test = ( dist in req and (dist.precedence <= SOURCE\_DIST or not source) ) if test: loc = self.download(dist.location, tmpdir) dist.download\_location = loc if os.path.exists(dist.download\_location): return dist
 if force\_scan: self.prescan() self.find\_packages(requirement) dist = find(requirement)
 if not dist and local\_index is not None: dist = find(requirement, local\_index)
 if dist is None: if self.to\_scan is not None: self.prescan() dist = find(requirement)
 if dist is None and not force\_scan: self.find\_packages(requirement) dist = find(requirement)
 if dist is None: self.warn( "No local packages or working download links found for %s%s", (source and "a source distribution of " or ""), requirement, ) else: self.info("Best match: %s", dist) return dist.clone(location=dist.download\_location)
 def fetch(self, requirement, tmpdir, force\_scan=False, source=False): """Obtain a file suitable for fulfilling `requirement`
 DEPRECATED; use the ``fetch\_distribution()`` method now instead. For backward compatibility, this routine is identical but returns the ``location`` of the downloaded distribution instead of a distribution object. """ dist = self.fetch\_distribution(requirement, tmpdir, force\_scan, source) if dist is not None: return dist.location return None
 def gen\_setup(self, filename, fragment, tmpdir): match = EGG\_FRAGMENT.match(fragment) dists = match and [ d for d in interpret\_distro\_name(filename, match.group(1), None) if d.version ] or []
 if len(dists) == 1: # unambiguous ``#egg`` fragment basename = os.path.basename(filename)
 # Make sure the file has been downloaded to the temp dir. if os.path.dirname(filename) != tmpdir: dst = os.path.join(tmpdir, basename) if not (os.path.exists(dst) and os.path.samefile(filename, dst)): shutil.copy2(filename, dst) filename = dst
 with open(os.path.join(tmpdir, 'setup.py'), 'w') as file: file.write( "from setuptools import setup\n" "setup(name=%r, version=%r, py\_modules=[%r])\n" % ( dists[0].project\_name, dists[0].version, os.path.splitext(basename)[0] ) ) return filename
 elif match: raise DistutilsError( "Can't unambiguously interpret project/version identifier %r; " "any dashes in the name or version should be escaped using " "underscores. %r" % (fragment, dists) ) else: raise DistutilsError( "Can't process plain .py files without an '#egg=name-version'" " suffix to enable automatic setup script generation." )
 dl\_blocksize = 8192
 def \_download\_to(self, url, filename): self.info("Downloading %s", url) # Download the file fp = None try: checker = HashChecker.from\_url(url) fp = self.open\_url(url) if isinstance(fp, urllib.error.HTTPError): raise DistutilsError( "Can't download %s: %s %s" % (url, fp.code, fp.msg) ) headers = fp.info() blocknum = 0 bs = self.dl\_blocksize size = -1 if "content-length" in headers: # Some servers return multiple Content-Length headers :( sizes = headers.get\_all('Content-Length') size = max(map(int, sizes)) self.reporthook(url, filename, blocknum, bs, size) with open(filename, 'wb') as tfp: while True: block = fp.read(bs) if block: checker.feed(block) tfp.write(block) blocknum += 1 self.reporthook(url, filename, blocknum, bs, size) else: break self.check\_hash(checker, filename, tfp) return headers finally: if fp: fp.close()
 def reporthook(self, url, filename, blocknum, blksize, size): pass # no-op
 # FIXME: def open\_url(self, url, warning=None): # noqa: C901 # is too complex (12) if url.startswith('file:'): return local\_open(url) try: return open\_with\_auth(url, self.opener) except (ValueError, http.client.InvalidURL) as v: msg = ' '.join([str(arg) for arg in v.args]) if warning: self.warn(warning, msg) else: raise DistutilsError('%s %s' % (url, msg)) from v except urllib.error.HTTPError as v: return v except urllib.error.URLError as v: if warning: self.warn(warning, v.reason) else: raise DistutilsError("Download error for %s: %s" % (url, v.reason)) from v except http.client.BadStatusLine as v: if warning: self.warn(warning, v.line) else: raise DistutilsError( '%s returned a bad status line. The server might be ' 'down, %s' % (url, v.line) ) from v except (http.client.HTTPException, socket.error) as v: if warning: self.warn(warning, v) else: raise DistutilsError("Download error for %s: %s" % (url, v)) from v
 def \_download\_url(self, scheme, url, tmpdir): # Determine download filename # name, fragment = egg\_info\_for\_url(url) if name: while '..' in name: name = name.replace('..', '.').replace('\\', '\_') else: name = "\_\_downloaded\_\_" # default if URL has no path contents
 if name.endswith('.egg.zip'): name = name[:-4] # strip the extra .zip before download
 filename = os.path.join(tmpdir, name)
 # Download the file # if scheme == 'svn' or scheme.startswith('svn+'): return self.\_download\_svn(url, filename) elif scheme == 'git' or scheme.startswith('git+'): return self.\_download\_git(url, filename) elif scheme.startswith('hg+'): return self.\_download\_hg(url, filename) elif scheme == 'file': return urllib.request.url2pathname(urllib.parse.urlparse(url)[2]) else: self.url\_ok(url, True) # raises error if not allowed return self.\_attempt\_download(url, filename)
 def scan\_url(self, url): self.process\_url(url, True)
 def \_attempt\_download(self, url, filename): headers = self.\_download\_to(url, filename) if 'html' in headers.get('content-type', '').lower(): return self.\_download\_html(url, headers, filename) else: return filename
 def \_download\_html(self, url, headers, filename): file = open(filename) for line in file: if line.strip(): # Check for a subversion index page if re.search(r'<title>([^- ]+ - )?Revision \d+:', line): # it's a subversion index page: file.close() os.unlink(filename) return self.\_download\_svn(url, filename) break # not an index page file.close() os.unlink(filename) raise DistutilsError("Unexpected HTML page found at " + url)
 def \_download\_svn(self, url, filename): warnings.warn("SVN download support is deprecated", UserWarning) url = url.split('#', 1)[0] # remove any fragment for svn's sake creds = '' if url.lower().startswith('svn:') and '@' in url: scheme, netloc, path, p, q, f = urllib.parse.urlparse(url) if not netloc and path.startswith('//') and '/' in path[2:]: netloc, path = path[2:].split('/', 1) auth, host = \_splituser(netloc) if auth: if ':' in auth: user, pw = auth.split(':', 1) creds = " --username=%s --password=%s" % (user, pw) else: creds = " --username=" + auth netloc = host parts = scheme, netloc, url, p, q, f url = urllib.parse.urlunparse(parts) self.info("Doing subversion checkout from %s to %s", url, filename) os.system("svn checkout%s -q %s %s" % (creds, url, filename)) return filename
 @staticmethod def \_vcs\_split\_rev\_from\_url(url, pop\_prefix=False): scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)
 scheme = scheme.split('+', 1)[-1]
 # Some fragment identification fails path = path.split('#', 1)[0]
 rev = None if '@' in path: path, rev = path.rsplit('@', 1)
 # Also, discard fragment url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''))
 return url, rev
 def \_download\_git(self, url, filename): filename = filename.split('#', 1)[0] url, rev = self.\_vcs\_split\_rev\_from\_url(url, pop\_prefix=True)
 self.info("Doing git clone from %s to %s", url, filename) os.system("git clone --quiet %s %s" % (url, filename))
 if rev is not None: self.info("Checking out %s", rev) os.system("git -C %s checkout --quiet %s" % ( filename, rev, ))
 return filename
 def \_download\_hg(self, url, filename): filename = filename.split('#', 1)[0] url, rev = self.\_vcs\_split\_rev\_from\_url(url, pop\_prefix=True)
 self.info("Doing hg clone from %s to %s", url, filename) os.system("hg clone --quiet %s %s" % (url, filename))
 if rev is not None: self.info("Updating to %s", rev) os.system("hg --cwd %s up -C -r %s -q" % ( filename, rev, ))
 return filename
 def debug(self, msg, \*args): log.debug(msg, \*args)
 def info(self, msg, \*args): log.info(msg, \*args)
 def warn(self, msg, \*args): log.warn(msg, \*args)
# This pattern matches a character entity reference (a decimal numeric# references, a hexadecimal numeric reference, or a named reference).entity\_sub = re.compile(r'&(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?').sub
def decode\_entity(match): what = match.group(0) return html.unescape(what)
def htmldecode(text): """ Decode HTML entities in the given text.
 >>> htmldecode( ... 'https://../package\_name-0.1.2.tar.gz' ... '?tokena=A&amp;tokenb=B">package\_name-0.1.2.tar.gz') 'https://../package\_name-0.1.2.tar.gz?tokena=A&tokenb=B">package\_name-0.1.2.tar.gz' """ return entity\_sub(decode\_entity, text)
def socket\_timeout(timeout=15): def \_socket\_timeout(func): def \_socket\_timeout(\*args, \*\*kwargs): old\_timeout = socket.getdefaulttimeout() socket.setdefaulttimeout(timeout) try: return func(\*args, \*\*kwargs) finally: socket.setdefaulttimeout(old\_timeout)
 return \_socket\_timeout
 return \_socket\_timeout
def \_encode\_auth(auth): """ Encode auth from a URL suitable for an HTTP header. >>> str(\_encode\_auth('username%3Apassword')) 'dXNlcm5hbWU6cGFzc3dvcmQ='
 Long auth strings should not cause a newline to be inserted. >>> long\_auth = 'username:' + 'password'\*10 >>> chr(10) in str(\_encode\_auth(long\_auth)) False """ auth\_s = urllib.parse.unquote(auth) # convert to bytes auth\_bytes = auth\_s.encode() encoded\_bytes = base64.b64encode(auth\_bytes) # convert back to a string encoded = encoded\_bytes.decode() # strip the trailing carriage return return encoded.replace('\n', '')
class Credential: """ A username/password pair. Use like a namedtuple. """
 def \_\_init\_\_(self, username, password): self.username = username self.password = password
 def \_\_iter\_\_(self): yield self.username yield self.password
 def \_\_str\_\_(self): return '%(username)s:%(password)s' % vars(self)
class PyPIConfig(configparser.RawConfigParser): def \_\_init\_\_(self): """[View remainder of file in raw view](https://github.com/pypa/setuptools/raw/fe8a98e696241487ba6ac9f91faa38ade939ec5d/setuptools/package_index.py)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

