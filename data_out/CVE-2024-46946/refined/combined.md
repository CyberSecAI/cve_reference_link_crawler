=== Content from github.com_37f86cdf_20250111_195814.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flangchain-ai%2Flangchain%2Freleases%2Ftag%2Flangchain-experimental%253D%253D0.3.0)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Flangchain-ai%2Flangchain%2Freleases%2Ftag%2Flangchain-experimental%253D%253D0.3.0)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Freleases%2Fshow&source=header-repo&source_repo=langchain-ai%2Flangchain)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[langchain-ai](/langchain-ai)
/
**[langchain](/langchain-ai/langchain)**
Public

* [Notifications](/login?return_to=%2Flangchain-ai%2Flangchain) You must be signed in to change notification settings
* [Fork
  15.9k](/login?return_to=%2Flangchain-ai%2Flangchain)
* [Star
   98k](/login?return_to=%2Flangchain-ai%2Flangchain)

* [Code](/langchain-ai/langchain/tree/langchain-experimental%3D%3D0.3.0)
* [Issues
  381](/langchain-ai/langchain/issues)
* [Pull requests
  46](/langchain-ai/langchain/pulls)
* [Discussions](/langchain-ai/langchain/discussions)
* [Actions](/langchain-ai/langchain/actions)
* [Projects
  2](/langchain-ai/langchain/projects)
* [Security](/langchain-ai/langchain/security)
* [Insights](/langchain-ai/langchain/pulse)

Additional navigation options

* [Code](/langchain-ai/langchain/tree/langchain-experimental%3D%3D0.3.0)
* [Issues](/langchain-ai/langchain/issues)
* [Pull requests](/langchain-ai/langchain/pulls)
* [Discussions](/langchain-ai/langchain/discussions)
* [Actions](/langchain-ai/langchain/actions)
* [Projects](/langchain-ai/langchain/projects)
* [Security](/langchain-ai/langchain/security)
* [Insights](/langchain-ai/langchain/pulse)

1. [Releases](/langchain-ai/langchain/releases)
2. [langchain-experimental==0.3.0](/langchain-ai/langchain/releases/tag/langchain-experimental%3D%3D0.3.0)

# langchain-experimental==0.3.0

 Compare

Choose a tag to compare

Could not load tags

Nothing to show

[{{ refName }}
default](/langchain-ai/langchain/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...langchain-experimental%3D%3D0.3.0)

 Loading

[View all tags](/langchain-ai/langchain/tags)

![@github-actions](https://avatars.githubusercontent.com/in/15368?s=40&v=4)
[github-actions](/apps/github-actions)
released this
13 Sep 23:12

[langchain-experimental==0.3.0](/langchain-ai/langchain/tree/langchain-experimental%3D%3D0.3.0)

[`8abc7ff`](/langchain-ai/langchain/commit/8abc7ff55ae104d846614cfb62269f2dfbe02000)

This commit was created on GitHub.com and signed with GitHubâ€™s **verified signature**.

GPG key ID: B5690EEEBB952194

[Learn about vigilant mode](https://docs.github.com/github/authenticating-to-github/displaying-verification-statuses-for-all-of-your-commits).

Changes since langchain-experimental==0.0.65

experimental: release 0.3 ([#26477](https://github.com/langchain-ai/langchain/pull/26477))

multiple: pydantic 2 compatibility, v0.3 ([#26443](https://github.com/langchain-ai/langchain/pull/26443))

Add the option to ignore structured output method to LLM graph transfâ€¦ ([#26013](https://github.com/langchain-ai/langchain/pull/26013))

 Assets
2

 Loading

 ðŸŽ‰
1
 QuantumChemist reacted with hooray emoji

All reactions

* ðŸŽ‰
  1 reaction

 1 person reacted

## Footer

Â© 2025 GitHub,Â Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You canâ€™t perform that action at this time.



=== Content from gist.github.com_778d7f3e_20250111_195813.html ===

[Skip to content](#start-of-content)

[All gists](/discover)
[Back to GitHub](https://github.com)
[Sign in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820)
[Sign up](/join?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820&source=header-gist)

[SignÂ in](https://gist.github.com/auth/github?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820) [SignÂ up](/join?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820&source=header-gist)

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

Instantly share code, notes, and snippets.

[![@12end](https://avatars.githubusercontent.com/u/46096442?s=64&v=4)](/12end)

# [12end](/12end)/**[CVE-2024-46946.txt](/12end/68c0c58d2564ef4141bccd4651480820)**

Last active
December 27, 2024 06:35

Show Gist options

* [Download ZIP](/12end/68c0c58d2564ef4141bccd4651480820/archive/4f2e451f8853558e59e8253b0de14acc056b2313.zip)

* [Star
  (0)
  0](/login?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820)You must be signed in to star a gist
* [Fork
  (0)
  0](/login?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820)You must be signed in to fork a gist

* Embed

  + Embed
     Embed this gist in your website.
  + Share
     Copy sharable link for this gist.
  + Clone via HTTPS
     Clone using the web URL.
  + [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

  Clone this repository at &lt;script src=&quot;https://gist.github.com/12end/68c0c58d2564ef4141bccd4651480820.js&quot;&gt;&lt;/script&gt;
* Save 12end/68c0c58d2564ef4141bccd4651480820 to your computer and use it in GitHub Desktop.

[Code](/12end/68c0c58d2564ef4141bccd4651480820)
[Revisions
2](/12end/68c0c58d2564ef4141bccd4651480820/revisions)

Embed

* Embed
   Embed this gist in your website.
* Share
   Copy sharable link for this gist.
* Clone via HTTPS
   Clone using the web URL.
* [Learn more about clone URLs](https://docs.github.com/articles/which-remote-url-should-i-use)

Clone this repository at &lt;script src=&quot;https://gist.github.com/12end/68c0c58d2564ef4141bccd4651480820.js&quot;&gt;&lt;/script&gt;

Save 12end/68c0c58d2564ef4141bccd4651480820 to your computer and use it in GitHub Desktop.

[Download ZIP](/12end/68c0c58d2564ef4141bccd4651480820/archive/4f2e451f8853558e59e8253b0de14acc056b2313.zip)

CVE-2024-46946: Remote Code Execution in LangChain's SymbolicMathChain

 [Raw](/12end/68c0c58d2564ef4141bccd4651480820/raw/4f2e451f8853558e59e8253b0de14acc056b2313/CVE-2024-46946.txt)

[**CVE-2024-46946.txt**](#file-cve-2024-46946-txt)

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

|  | CVE ID: CVE-2024-46946 |
| --- | --- |
|  | Vulnerability Type: Remote Code Execution |
|  | Affected Component: SymbolicMathChain in LangChain |
|  | Affected Versions: Introduced in commit https://github.com/langchain-ai/langchain/commit/fcccde406dd9e9b05fc9babcbeb9ff527b0ec0c6 |
|  | Discoverer: 12end@cyberkl |
|  |  |
|  | Description: |
|  | A remote code execution vulnerability has been identified in LangChain's SymbolicMathChain component. The vulnerability stems from the use of sympy.sympify() to evaluate mathematical expressions without proper input sanitization. |
|  |  |
|  | The SymbolicMathChain class was introduced in the commit fcccde406dd9e9b05fc9babcbeb9ff527b0ec0c6. It uses a regular expression to match content between ````text` delimiters and passes this content to sympy.sympify() for evaluation. |
|  |  |
|  | However, sympy.sympify() internally uses Python's eval() function, which can lead to arbitrary code execution if not properly restricted. |
|  |  |
|  | Proof of Concept: |
|  | The following payload demonstrates the ability to execute arbitrary system commands: |
|  |  |
|  | ```python |
|  | sympy.sympify("this.\_\_class\_\_.\_\_mro\_\_[8].\_\_subclasses\_\_()[154].\_\_init\_\_.\_\_globals\_\_['\_\_builtins\_\_']['exec']('import os;os.system(\"id\")')") |
|  | ``` |
|  |  |
|  | Impact: |
|  | An attacker who can control the input to SymbolicMathChain could potentially execute arbitrary code on the system running the LangChain application, leading to full system compromise. |
|  |  |
|  | Recommendation: |
|  | It is recommended to implement strict input validation and sanitization before passing any user-controlled input to sympy.sympify(). Consider using a whitelist of allowed mathematical operations and symbols, or explore alternative methods for safe mathematical expression evaluation. |

[Sign up for free](/join?source=comment-gist)
**to join this conversation on GitHub**.
Already have an account?
[Sign in to comment](/login?return_to=https%3A%2F%2Fgist.github.com%2F12end%2F68c0c58d2564ef4141bccd4651480820)

## Footer

Â© 2025 GitHub,Â Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You canâ€™t perform that action at this time.



=== Content from docs.sympy.org_6ec3d399_20250111_195813.html ===


Contents

Menu

Expand

Light mode

Dark mode

Auto light/dark, in light mode

Auto light/dark, in dark mode

Hide navigation sidebar

Hide table of contents sidebar

[Skip to content](#furo-main-content)
Toggle site navigation sidebar

[SymPy 1.13.3 documentation](../index.html)

Toggle Light / Dark / Auto color theme

Toggle table of contents sidebar

[![Logo](../_static/sympylogo.png)

SymPy 1.13.3 documentation](../index.html)

* [Installation](../install.html)
* [Tutorials](../tutorials/index.html)Toggle navigation of Tutorials
  + [Introductory Tutorial](../tutorials/intro-tutorial/index.html)Toggle navigation of Introductory Tutorial
    - [Preliminaries](../tutorials/intro-tutorial/preliminaries.html)
    - [Introduction](../tutorials/intro-tutorial/intro.html)
    - [Gotchas](../tutorials/intro-tutorial/gotchas.html)
    - [SymPy Features](../tutorials/intro-tutorial/features.html)Toggle navigation of SymPy Features
      * [Basic Operations](../tutorials/intro-tutorial/basic_operations.html)
      * [Printing](../tutorials/intro-tutorial/printing.html)
      * [Simplification](../tutorials/intro-tutorial/simplification.html)
      * [Calculus](../tutorials/intro-tutorial/calculus.html)
      * [Solvers](../tutorials/intro-tutorial/solvers.html)
      * [Matrices](../tutorials/intro-tutorial/matrices.html)
      * [Advanced Expression Manipulation](../tutorials/intro-tutorial/manipulation.html)
    - [Whatâ€™s Next](../tutorials/intro-tutorial/next.html)
  + [Physics Tutorials](../tutorials/physics/index.html)Toggle navigation of Physics Tutorials
    - [Biomechanics Tutorials](../tutorials/physics/biomechanics/index.html)Toggle navigation of Biomechanics Tutorials
      * [Introduction to Biomechanical Modeling](../tutorials/physics/biomechanics/biomechanics.html)
      * [Biomechanical Model Example](../tutorials/physics/biomechanics/biomechanical-model-example.html)
* [How-to Guides](../guides/index.html)Toggle navigation of How-to Guides
  + [Assumptions](../guides/assumptions.html)
  + [Symbolic and fuzzy booleans](../guides/booleans.html)
  + [Writing Custom Functions](../guides/custom-functions.html)
  + [Physics](../guides/physics/index.html)Toggle navigation of Physics
    - [Control Package Examples](../guides/physics/control_problems.html)
  + [Solve Equations](../guides/solving/index.html)Toggle navigation of Solve Equations
    - [Solving Guidance](../guides/solving/solving-guidance.html)
    - [Solve an Equation Algebraically](../guides/solving/solve-equation-algebraically.html)
    - [Solve a System of Equations Algebraically](../guides/solving/solve-system-of-equations-algebraically.html)
    - [Solve One or a System of Equations Numerically](../guides/solving/solve-numerically.html)
    - [Solve an Ordinary Differential Equation (ODE) Algebraically](../guides/solving/solve-ode.html)
    - [Find the Roots of a Polynomial Algebraically or Numerically](../guides/solving/find-roots-polynomial.html)
    - [Solve a Matrix Equation Algebraically](../guides/solving/solve-matrix-equation.html)
    - [Reduce One or a System of Inequalities for a Single Variable Algebraically](../guides/solving/reduce-inequalities-algebraically.html)
    - [Solve a Diophantine Equation Algebraically](../guides/solving/solve-diophantine-equation.html)
  + [SymPy Logo](../guides/logo.html)
  + [Citing SymPy](../citing.html)
* [Explanations](../explanation/index.html)Toggle navigation of Explanations
  + [Best Practices](../explanation/best-practices.html)
  + [Gotchas and Pitfalls](../explanation/gotchas.html)
  + [Solve Output by Type](../explanation/solve_output.html)
  + [SymPy Special Topics](../explanation/special_topics/index.html)Toggle navigation of SymPy Special Topics
    - [Finite Difference Approximations to Derivatives](../explanation/special_topics/finite_diff_derivatives.html)
    - [Classification of SymPy objects](../explanation/special_topics/classification.html)
  + [List of active deprecations](../explanation/active-deprecations.html)
  + [Glossary](../explanation/glossary.html)
* [API Reference](../reference/index.html)Toggle navigation of API Reference
  + [Basics](../reference/public/basics/index.html)Toggle navigation of Basics
    - [Assumptions](assumptions/index.html)Toggle navigation of Assumptions
      * [Ask](assumptions/ask.html)
      * [Assume](assumptions/assume.html)
      * [Refine](assumptions/refine.html)
      * [Predicates](assumptions/predicates.html)
    - [Calculus](calculus/index.html)
    - [Combinatorics](combinatorics/index.html)Toggle navigation of Combinatorics
      * [Partitions](combinatorics/partitions.html)
      * [Permutations](combinatorics/permutations.html)
      * [Permutation Groups](combinatorics/perm_groups.html)
      * [Polyhedron](combinatorics/polyhedron.html)
      * [Prufer Sequences](combinatorics/prufer.html)
      * [Subsets](combinatorics/subsets.html)
      * [Gray Code](combinatorics/graycode.html)
      * [Named Groups](combinatorics/named_groups.html)
      * [Galois Groups](combinatorics/galois.html)
      * [Number of groups](combinatorics/group_numbers.html)
      * [Utilities](combinatorics/util.html)
      * [Group constructors](combinatorics/group_constructs.html)
      * [Test Utilities](combinatorics/testutil.html)
      * [Tensor Canonicalization](combinatorics/tensor_can.html)
      * [Finitely Presented Groups](combinatorics/fp_groups.html)
      * [Polycyclic Groups](combinatorics/pc_groups.html)
    - [Functions](functions/index.html)Toggle navigation of Functions
      * [Elementary](functions/elementary.html)
      * [Combinatorial](functions/combinatorial.html)
      * [Enumeration](functions/combinatorial.html#enumeration)
      * [Special](functions/special.html)
    - [Integrals](integrals/index.html)Toggle navigation of Integrals
      * [Computing Integrals using Meijer G-Functions](integrals/g-functions.html)
      * [Integrals](integrals/integrals.html)
    - [Series](series/index.html)Toggle navigation of Series
      * [Series Expansions](series/series.html)
      * [Sequences](series/sequences.html)
      * [Fourier Series](series/fourier.html)
      * [Formal Power Series](series/formal.html)
      * [Limits of Sequences](series/limitseq.html)
    - [Simplify](simplify/index.html)Toggle navigation of Simplify
      * [Simplify](simplify/simplify.html)
      * [Hypergeometric Expansion](simplify/hyperexpand.html)
      * [Hongguang Fuâ€™s Trigonometric Simplification](simplify/fu.html)
    - [Solvers](solvers/index.html)Toggle navigation of Solvers
      * [Diophantine](solvers/diophantine.html)
      * [Inequality Solvers](solvers/inequalities.html)
      * [ODE](solvers/ode.html)
      * [PDE](solvers/pde.html)
      * [Solvers](solvers/solvers.html)
      * [Solveset](solvers/solveset.html)
    - [abc](abc.html)
    - [Algebras](algebras.html)
    - [Concrete](concrete.html)
    - [Core](core.html)
    - [Discrete](discrete.html)
    - [Numerical Evaluation](evalf.html)
    - [Numeric Computation](numeric-computation.html)
    - [Term Rewriting](rewriting.html)
  + [Code Generation](../reference/public/codegeneration/index.html)Toggle navigation of Code Generation
    - Code Generation
  + [Logic](../reference/public/logic/index.html)Toggle navigation of Logic
    - [Logic](logic.html)
    - [Sets](sets.html)
  + [Matrices](../reference/public/matrices/index.html)Toggle navigation of Matrices
    - [Matrices](matrices/index.html)Toggle navigation of Matrices
      * [Matrices (linear algebra)](matrices/matrices.html)
      * [Matrix Kind](matrices/kind.html)
      * [Dense Matrices](matrices/dense.html)
      * [Sparse Matrices](matrices/sparse.html)
      * [Sparse Tools](matrices/sparsetools.html)
      * [Immutable Matrices](matrices/immutablematrices.html)
      * [Matrix Expressions](matrices/expressions.html)
      * [Matrix Normal Forms](matrices/normalforms.html)
    - [Tensor](tensor/index.html)Toggle navigation of Tensor
      * [N-dim array](tensor/array.html)
      * [N-dim array expressions](tensor/array_expressions.html)
      * [Indexed Objects](tensor/indexed.html)
      * [Methods](tensor/index_methods.html)
      * [Tensor](tensor/tensor.html)
      * [Tensor Operators](tensor/toperators.html)
    - [Vector](vector/index.html)Toggle navigation of Vector
      * [Introduction](vector/intro.html)
      * [Basic Implementation details](vector/basics.html)
      * [More about Coordinate Systems](vector/coordsys.html)
      * [Scalar and Vector Field Functionality](vector/fields.html)
      * [General examples of usage](vector/examples.html)
      * [Applications of Vector Integrals](vector/vector_integration.html)
      * [Vector API](vector/api/index.html)Toggle navigation of Vector API
        + [Essential Classes in sympy.vector (docstrings)](vector/api/classes.html)
        + [Orienter classes (docstrings)](vector/api/orienterclasses.html)
        + [Essential Functions in sympy.vector (docstrings)](vector/api/vectorfunctions.html)
  + [Number Theory](../reference/public/numbertheory/index.html)Toggle navigation of Number Theory
    - [Number Theory](ntheory.html)
  + [Physics](../reference/public/physics/index.html)Toggle navigation of Physics
    - [Hydrogen Wavefunctions](physics/hydrogen.html)
    - [Matrices](physics/matrices.html)
    - [Pauli Algebra](physics/paulialgebra.html)
    - [Quantum Harmonic Oscillator in 1-D](physics/qho_1d.html)
    - [Quantum Harmonic Oscillator in 3-D](physics/sho.html)
    - [Second Quantization](physics/secondquant.html)
    - [Wigner Symbols](physics/wigner.html)
    - [Unit systems](physics/units/index.html)Toggle navigation of Unit systems
      * [Philosophy behind unit systems](physics/units/philosophy.html)
      * [More examples](physics/units/examples.html)
      * [Dimensions and dimension systems](physics/units/dimensions.html)
      * [Unit prefixes](physics/units/prefixes.html)
      * [Units and unit systems](physics/units/unitsystem.html)
      * [Physical quantities](physics/units/quantities.html)
    - [High energy physics](physics/hep/index.html)
    - [The Physics Vector Module](physics/vector/index.html)Toggle navigation of The Physics Vector Module
      * [Vector & ReferenceFrame](physics/vector/vectors.html)
      * [Vector: Kinematics](physics/vector/kinematics.html)
      * [Potential Issues/Advanced Topics/Future Features in Physics/Vector Module](physics/vector/advanced.html)
      * [Scalar and Vector Field Functionality](physics/vector/fields.html)
      * [Physics Vector API](physics/vector/api/index.html)Toggle navigation of Physics Vector API
        + [Essential Classes](physics/vector/api/classes.html)
        + [Kinematics (Docstrings)](physics/vector/api/kinematics.html)
        + [Printing (Docstrings)](physics/vector/api/printing.html)
        + [Essential Functions (Docstrings)](physics/vector/api/functions.html)
        + [Docstrings for basic field functions](physics/vector/api/fieldfunctions.html)
    - [Classical Mechanics](physics/mechanics/index.html)Toggle navigation of Classical Mechanics
      * [Masses, Inertias, Particles and Rigid Bodies in Physics/Mechanics](physics/mechanics/masses.html)
      * [Kaneâ€™s Method in Physics/Mechanics](physics/mechanics/kane.html)
      * [Lagrangeâ€™s Method in Physics/Mechanics](physics/mechanics/lagrange.html)
      * [Joints Framework in Physics/Mechanics](physics/mechanics/joints.html)
      * [Symbolic Systems in Physics/Mechanics](physics/mechanics/symsystem.html)
      * [Linearization in Physics/Mechanics](physics/mechanics/linearize.html)Toggle navigation of Linearization in Physics/Mechanics
        + [Nonminimal Coordinates Pendulum](physics/mechanics/examples/lin_pend_nonmin_example.html)
      * [Examples for Physics/Mechanics](physics/mechanics/examples.html)Toggle navigation of Examples for Physics/Mechanics
        + [A rolling disc](physics/mechanics/examples/rollingdisc_example.html)Toggle navigation of A rolling disc
          - [A rolling disc, with Kaneâ€™s method](physics/mechanics/examples/rollingdisc_example_kane.html)
          - [A rolling disc, with Kaneâ€™s method and constraint forces](physics/mechanics/examples/rollingdisc_example_kane_constraints.html)
          - [A rolling disc using Lagrangeâ€™s Method](physics/mechanics/examples/rollingdisc_example_lagrange.html)
        + [A bicycle](physics/mechanics/examples/bicycle_example.html)
        + [Nonminimal Coordinates Pendulum](physics/mechanics/examples/lin_pend_nonmin_example.html)
        + [Multi Degree of Freedom Holonomic System](physics/mechanics/examples/multi_degree_freedom_holonomic_system.html)
        + [A four bar linkage](physics/mechanics/examples/four_bar_linkage_example.html)
      * [Potential Issues/Advanced Topics/Future Features in Physics/Mechanics](physics/mechanics/advanced.html)
      * [References for Physics/Mechanics](physics/mechanics/reference.html)
      * [Autolev Parser](physics/mechanics/autolev_parser.html)
      * [SymPy Mechanics for Autolev Users](physics/mechanics/sympy_mechanics_for_autolev_users.html)
      * [Mechanics API Reference](physics/mechanics/api/index.html)Toggle navigation of Mechanics API Reference
        + [Bodies, Inertias, Loads & Other Functions (Docstrings)](physics/mechanics/api/part_bod.html)
        + [Kaneâ€™s Method & Lagrangeâ€™s Method (Docstrings)](physics/mechanics/api/kane_lagrange.html)
        + [Joints Framework (Docstrings)](physics/mechanics/api/joint.html)
        + [System (Docstrings)](physics/mechanics/api/system.html)
        + [Linearization (Docstrings)](physics/mechanics/api/linearize.html)
        + [Expression Manipulation (Docstrings)](physics/mechanics/api/expr_manip.html)
        + [Printing (Docstrings)](physics/mechanics/api/printing.html)
        + [Pathway (Docstrings)](physics/mechanics/api/pathway.html)
        + [Actuator (Docstrings)](physics/mechanics/api/actuator.html)
        + [Wrapping Geometry (Docstrings)](physics/mechanics/api/wrapping_geometry.html)
        + [Deprecated Classes (Docstrings)](physics/mechanics/api/deprecated_classes.html)
    - [Biomechanics](physics/biomechanics/index.html)Toggle navigation of Biomechanics
      * [Biomechanics API Reference](physics/biomechanics/api/index.html)Toggle navigation of Biomechanics API Reference
        + [Musculotendon (Docstrings)](physics/biomechanics/api/musculotendon.html)
        + [Activation (Docstrings)](physics/biomechanics/api/activation.html)
        + [Curve (Docstrings)](physics/biomechanics/api/curve.html)
    - [Quantum Mechanics](physics/quantum/index.html)Toggle navigation of Quantum Mechanics
      * [Anticommutator](physics/quantum/anticommutator.html)
      * [Clebsch-Gordan Coefficients](physics/quantum/cg.html)
      * [Commutator](physics/quantum/commutator.html)
      * [Constants](physics/quantum/constants.html)
      * [Dagger](physics/quantum/dagger.html)
      * [Inner Product](physics/quantum/innerproduct.html)
      * [Tensor Product](physics/quantum/tensorproduct.html)
      * [Cartesian Operators and States](physics/quantum/cartesian.html)
      * [Hilbert Space](physics/quantum/hilbert.html)
      * [Operator](physics/quantum/operator.html)
      * [Operator/State Helper Functions](physics/quantum/operatorset.html)
      * [Qapply](physics/quantum/qapply.html)
      * [Represent](physics/quantum/represent.html)
      * [Spin](physics/quantum/spin.html)
      * [State](physics/quantum/state.html)
      * [Circuit Plot](physics/quantum/circuitplot.html)
      * [Gates](physics/quantum/gate.html)
      * [Groverâ€™s Algorithm](physics/quantum/grover.html)
      * [QFT](physics/quantum/qft.html)
      * [Qubit](physics/quantum/qubit.html)
      * [Shorâ€™s Algorithm](physics/quantum/shor.html)
      * [Particle in a Box](physics/quantum/piab.html)
    - [Optics Module](physics/optics/index.html)Toggle navigation of Optics Module
      * [Gaussian Optics](physics/optics/gaussopt.html)
      * [Medium](physics/optics/medium.html)
      * [Polarization](physics/optics/polarization.html)
      * [Utilities](physics/optics/utils.html)
      * [Waves](physics/optics/waves.html)
    - [Control Module](physics/control/index.html)Toggle navigation of Control Module
      * [Control](physics/control/control.html)
      * [Control API](physics/control/lti.html)
      * [Control System Plots](physics/control/control_plots.html)
    - [Continuum Mechanics](physics/continuum_mechanics/index.html)Toggle navigation of Continuum Mechanics
      * [Beam (Docstrings)](physics/continuum_mechanics/beam.html)
      * [Solving Beam Bending Problems using Singularity Functions](physics/continuum_mechanics/beam_problems.html)
      * [Truss (Docstrings)](physics/continuum_mechanics/truss.html)
      * [Cable (Docstrings)](physics/continuum_mechanics/cable.html)
  + [Utilities](../reference/public/utilities/index.html)Toggle navigation of Utilities
    - [Testing](testing/index.html)Toggle navigation of Testing
      * [pytest](testing/pytest.html)
      * [Randomised Testing](testing/randtest.html)
      * [Run Tests](testing/runtests.html)
    - [Utilities](utilities/index.html)Toggle navigation of Utilities
      * [Autowrap Module](utilities/autowrap.html)
      * [Codegen](utilities/codegen.html)
      * [Decorator](utilities/decorator.html)
      * [Enumerative](utilities/enumerative.html)
      * [Exceptions and Warnings](utilities/exceptions.html)
      * [Iterables](utilities/iterables.html)
      * [Lambdify](utilities/lambdify.html)
      * [Memoization](utilities/memoization.html)
      * [Miscellaneous](utilities/misc.html)
      * [Source Code Inspection](utilities/source.html)
      * [Timing Utilities](utilities/timeutils.html)
    - [Interactive](interactive.html)
    - [Parsing](parsing.html)
    - [Printing](printing.html)
  + [Topics](../reference/public/topics/index.html)Toggle navigation of Topics
    - [Geometry](geometry/index.html)Toggle navigation of Geometry
      * [Entities](geometry/entities.html)
      * [Utils](geometry/utils.html)
      * [Points](geometry/points.html)
      * [Lines](geometry/lines.html)
      * [Curves](geometry/curves.html)
      * [Ellipses](geometry/ellipses.html)
      * [Polygons](geometry/polygons.html)
      * [Plane](geometry/plane.html)
    - [Holonomic](holonomic/index.html)Toggle navigation of Holonomic
      * [About Holonomic Functions](holonomic/about.html)
      * [Representation of holonomic functions in SymPy](holonomic/represent.html)
      * [Operations on holonomic functions](holonomic/operations.html)
      * [Converting other representations to holonomic](holonomic/convert.html)
      * [Uses and Current limitations](holonomic/uses.html)
      * [Internal API](holonomic/internal.html)
    - [Lie Algebra](liealgebras/index.html)
    - [Polynomial Manipulation](polys/index.html)Toggle navigation of Polynomial Manipulation
      * [Basic functionality of the module](polys/basics.html)
      * [Examples from Westerâ€™s Article](polys/wester.html)
      * [Polynomials Manipulation Module Reference](polys/reference.html)
      * [AGCA - Algebraic Geometry and Commutative Algebra Module](polys/agca.html)
      * [Introducing the Domains of the poly module](polys/domainsintro.html)
      * [Reference docs for the Poly Domains](polys/domainsref.html)
      * [Internals of the Polynomial Manipulation Module](polys/internals.html)
      * [Series Manipulation using Polynomials](polys/ringseries.html)
      * [Literature](polys/literature.html)
      * [Poly solvers](polys/solvers.html)
      * [Introducing the domainmatrix of the poly module](polys/domainmatrix.html)
      * [Number Fields](polys/numberfields.html)
    - [Category Theory](categories.html)
    - [Cryptography](crypto.html)
    - [Differential Geometry](diffgeom.html)
    - [Plotting](plotting.html)
    - [Stats](stats.html)
* [Contributing](../contributing/index.html)Toggle navigation of Contributing
  + [Introduction to Contributing](../contributing/introduction-to-contributing.html)
  + [Guide for New Contributors](../contributing/new-contributors-guide/index.html)Toggle navigation of Guide for New Contributors
    - [Setup Development Environment](../contributing/new-contributors-guide/dev-setup.html)
    - [Development Workflow Process](../contributing/new-contributors-guide/workflow-process.html)
    - [Writing Tests](../contributing/new-contributors-guide/writing-tests.html)
    - [Building the Documentation](../contributing/new-contributors-guide/build-docs.html)
  + [Dependencies](../contributing/dependencies.html)
  + [Debugging](../contributing/debug.html)
  + [Docstrings Style Guide](../contributing/docstring.html)
  + [Documentation Style Guide](../contributing/documentation-style-guide.html)
  + [Deprecation Policy](../contributing/deprecations.html)

##### Documentation Version

Back to top
[View this page](../_sources/modules/codegen.rst.txt "View this page")

Toggle Light / Dark / Auto color theme

Toggle table of contents sidebar

# Code Generation[Â¶](#code-generation "Link to this heading")

Several submodules in SymPy allow one to generate directly compilable and
executable code in a variety of different programming languages from SymPy
expressions. In addition, there are functions that generate Python importable
objects that can evaluate SymPy expressions very efficiently.

We will start with a brief introduction to the components that make up the code
generation capabilities of SymPy.

## Introduction[Â¶](#introduction "Link to this heading")

There are four main levels of abstractions:

```
expression
   |
code printers
   |
code generators
   |
autowrap

```

[`sympy.utilities.autowrap`](utilities/autowrap.html#module-sympy.utilities.autowrap "sympy.utilities.autowrap") uses codegen, and codegen uses the code
printers. [`sympy.utilities.autowrap`](utilities/autowrap.html#module-sympy.utilities.autowrap "sympy.utilities.autowrap") does everything: it lets you go
from SymPy expression to numerical function in the same Python process in one
step. Codegen is actual code generation, i.e., to compile and use later, or to
include in some larger project.

The code printers translate the SymPy objects into actual code, like `abs(x)
-> fabs(x)` (for C).

The code printers donâ€™t print optimal code in many cases. An example of this is
powers in C. `x**2` prints as `pow(x, 2)` instead of `x*x`. Other
optimizations (like mathematical simplifications) should happen before the code
printers.

Currently, [`sympy.simplify.cse_main.cse()`](simplify/simplify.html#sympy.simplify.cse_main.cse "sympy.simplify.cse_main.cse") is not applied automatically anywhere in this
chain. It ideally happens at the codegen level, or somewhere above it.

We will iterate through the levels below.

The following three lines will be used to setup each example:

```
>>> from sympy import *
>>> init_printing(use_unicode=True)
>>> from sympy.abc import a, e, k, n, r, t, x, y, z, T, Z
>>> from sympy.abc import beta, omega, tau
>>> f, g = symbols('f, g', cls=Function)

```

## Code printers (sympy.printing)[Â¶](#code-printers-sympy-printing "Link to this heading")

This is where the meat of code generation is; the translation of SymPy
actually more like a lightweight version of codegen for Python, and
Python ([`sympy.printing.pycode.pycode()`](printing.html#sympy.printing.pycode.pycode "sympy.printing.pycode.pycode")), and
[`sympy.printing.lambdarepr.lambdarepr()`](printing.html#sympy.printing.lambdarepr.lambdarepr "sympy.printing.lambdarepr.lambdarepr"), which supports many libraries
(like NumPy), and Aesara
([`sympy.printing.aesaracode.aesara_function()`](printing.html#sympy.printing.aesaracode.aesara_function "sympy.printing.aesaracode.aesara_function")). The code printers are
special cases of the other prints in SymPy (str printer, pretty printer, etc.).

An important distinction is that the code printer has to deal with assignments
(using the [`sympy.codegen.ast.Assignment`](#sympy.codegen.ast.Assignment "sympy.codegen.ast.Assignment") object). This serves as
building blocks for the code printers and hence the `codegen` module. An
example that shows the use of `Assignment` in C code:

```
>>> from sympy.codegen.ast import Assignment
>>> print(ccode(Assignment(x, y + 1)))
x = y + 1;

```

Here is another simple example of printing a C version of a SymPy expression:

```
>>> expr = (Rational(-1, 2) * Z * k * (e**2) / r)
>>> expr
    2
-Zâ‹…e â‹…k
â”€â”€â”€â”€â”€â”€â”€â”€
  2â‹…r
>>> ccode(expr)
-1.0/2.0*Z*pow(e, 2)*k/r
>>> from sympy.codegen.ast import real, float80
>>> ccode(expr, assign_to="E", type_aliases={real: float80})
E = -1.0L/2.0L*Z*powl(e, 2)*k/r;

```

To generate code with some math functions provided by e.g. the C99 standard we need
to import functions from [`sympy.codegen.cfunctions`](#module-sympy.codegen.cfunctions "sympy.codegen.cfunctions"):

```
>>> from sympy.codegen.cfunctions import expm1
>>> ccode(expm1(x), standard='C99')
expm1(x)

```

`Piecewise` expressions are converted into conditionals. If an `assign_to`
variable is provided an if statement is created, otherwise the ternary operator
is used. Note that if the `Piecewise` lacks a default term, represented by
`(expr, True)` then an error will be thrown. This is to prevent generating
an expression that may not evaluate to anything. A use case for `Piecewise`:

```
>>> expr = Piecewise((x + 1, x > 0), (x, True))
>>> print(fcode(expr, tau))
      if (x > 0) then
         tau = x + 1
      else
         tau = x
      end if

```

The various printers also tend to support `Indexed` objects well. With
`contract=True` these expressions will be turned into loops, whereas
`contract=False` will just print the assignment expression that should be
looped over:

```
>>> len_y = 5
>>> mat_1 = IndexedBase('mat_1', shape=(len_y,))
>>> mat_2 = IndexedBase('mat_2', shape=(len_y,))
>>> Dy = IndexedBase('Dy', shape=(len_y-1,))
>>> i = Idx('i', len_y-1)
>>> eq = Eq(Dy[i], (mat_1[i+1] - mat_1[i]) / (mat_2[i+1] - mat_2[i]))
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))
Dy[i] = (mat_1[i + 1] - mat_1[i])/(mat_2[i + 1] - mat_2[i]);
>>> Res = IndexedBase('Res', shape=(len_y,))
>>> j = Idx('j', len_y)
>>> eq = Eq(Res[j], mat_1[j]*mat_2[j])
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=True))
for (var j=0; j<5; j++){
   Res[j] = 0;
}
for (var j=0; j<5; j++){
   for (var j=0; j<5; j++){
      Res[j] = Res[j] + mat_1[j]*mat_2[j];
   }
}
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))
Res[j] = mat_1[j]*mat_2[j];

```

Custom printing can be defined for certain types by passing a dictionary of
â€œtypeâ€ : â€œfunctionâ€ to the `user_functions` kwarg. Alternatively, the
dictionary value can be a list of tuples i.e., `[(argument_test,
cfunction_string)]`. This can be used to call a custom Octave function:

```
>>> custom_functions = {
...   "f": "existing_octave_fcn",
...   "g": [(lambda x: x.is_Matrix, "my_mat_fcn"),
...         (lambda x: not x.is_Matrix, "my_fcn")]
... }
>>> mat = Matrix([[1, x]])
>>> octave_code(f(x) + g(x) + g(mat), user_functions=custom_functions)
existing_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])

```

An example of Mathematica code printer:

```
>>> x_ = Function('x')
>>> expr = x_(n*T) * sin((t - n*T) / T)
>>> expr = expr / ((-T*n + t) / T)
>>> expr
            âŽ›-Tâ‹…n + tâŽž
Tâ‹…x(Tâ‹…n)â‹…sinâŽœâ”€â”€â”€â”€â”€â”€â”€â”€âŽŸ
            âŽ   T    âŽ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       -Tâ‹…n + t

>>> expr = summation(expr, (n, -1, 1))
>>> mathematica_code(expr)
T*(x[-T]*Sin[(T + t)/T]/(T + t) + x[T]*Sin[(-T + t)/T]/(-T + t) + x[0]*Sin[t/T]/t)

```

We can go through a common expression in different languages we support and see
how it works:

```
>>> k, g1, g2, r, I, S = symbols("k, gamma_1, gamma_2, r, I, S")
>>> expr = k * g1 * g2 / (r**3)
>>> expr = expr * 2 * I * S * (3 * (cos(beta))**2 - 1) / 2
>>> expr
            âŽ›     2       âŽž
Iâ‹…Sâ‹…Î³â‚â‹…Î³â‚‚â‹…kâ‹…âŽ3â‹…cos (Î²) - 1âŽ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              3
             r
>>> print(jscode(expr, assign_to="H_is"))
H_is = I*S*gamma_1*gamma_2*k*(3*Math.pow(Math.cos(beta), 2) - 1)/Math.pow(r, 3);
>>> print(ccode(expr, assign_to="H_is", standard='C89'))
H_is = I*S*gamma_1*gamma_2*k*(3*pow(cos(beta), 2) - 1)/pow(r, 3);
>>> print(fcode(expr, assign_to="H_is"))
      H_is = I*S*gamma_1*gamma_2*k*(3*cos(beta)**2 - 1)/r**3
>>> print(julia_code(expr, assign_to="H_is"))
H_is = I .* S .* gamma_1 .* gamma_2 .* k .* (3 * cos(beta) .^ 2 - 1) ./ r .^ 3
>>> print(octave_code(expr, assign_to="H_is"))
H_is = I.*S.*gamma_1.*gamma_2.*k.*(3*cos(beta).^2 - 1)./r.^3;
>>> print(rust_code(expr, assign_to="H_is"))
H_is = I*S*gamma_1*gamma_2*k*(3*beta.cos().powi(2) - 1)/r.powi(3);
>>> print(mathematica_code(expr))
I*S*gamma_1*gamma_2*k*(3*Cos[beta]^2 - 1)/r^3

```

## Codegen (sympy.utilities.codegen)[Â¶](#codegen-sympy-utilities-codegen "Link to this heading")

This module deals with creating compilable code from SymPy expressions. This is
lower level than autowrap, as it doesnâ€™t actually attempt to compile the code,
but higher level than the printers, as it generates compilable files (including
header files), rather than just code snippets.

The user friendly functions, here, are `codegen` and `make_routine`.
`codegen` takes a list of `(variable, expression)` pairs and a language (C,
F95, and Octave/Matlab are supported). It returns, as strings, a code file and
a header file (for relevant languages). The variables are created as functions
that return the value of the expression as output.

Note

The `codegen` callable is not in the sympy namespace automatically,
to use it you must first import `codegen` from `sympy.utilities.codegen`

For instance:

```
>>> from sympy.utilities.codegen import codegen
>>> length, breadth, height = symbols('length, breadth, height')
>>> [(c_name, c_code), (h_name, c_header)] = \
... codegen(('volume', length*breadth*height), "C99", "test",
...         header=False, empty=False)
>>> print(c_name)
test.c
>>> print(c_code)
#include "test.h"
#include <math.h>
double volume(double breadth, double height, double length) {
   double volume_result;
   volume_result = breadth*height*length;
   return volume_result;
}
>>> print(h_name)
test.h
>>> print(c_header)
#ifndef PROJECT__TEST__H
#define PROJECT__TEST__H
double volume(double breadth, double height, double length);
#endif

```

Various flags to `codegen` let you modify things. The project name for
preprocessor instructions can be varied using `project`. Variables listed as
global variables in arg `global_vars` will not show up as function arguments.

`language` is a case-insensitive string that indicates the source code
language. Currently, `C`, `F95` and `Octave` are supported. `Octave`
generates code compatible with both Octave and Matlab.

`header` when True, a header is written on top of each source file. `empty`
when True, empty lines are used to structure the code. With
`argument_sequence` a sequence of arguments for the routine can be defined in
a preferred order.

`prefix` defines a prefix for the names of the files that contain the source
code. If omitted, the name of the first name\_expr tuple is used.

`to_files` when True, the code will be written to one or more files with the
given prefix.

Here is an example:

```
>>> [(f_name, f_code), header] = codegen(("volume", length*breadth*height),
...     "F95", header=False, empty=False, argument_sequence=(breadth, length),
...     global_vars=(height,))
>>> print(f_code)
REAL*8 function volume(breadth, length)
implicit none
REAL*8, intent(in) :: breadth
REAL*8, intent(in) :: length
volume = breadth*height*length
end function

```

The method `make_routine` creates a `Routine` object, which represents an
evaluation routine for a set of expressions. This is only good for internal use
by the CodeGen objects, as an intermediate representation from SymPy expression
to generated code. It is not recommended to make a `Routine` object
yourself. You should instead use `make_routine` method. `make_routine` in
turn calls the `routine` method of the CodeGen object depending upon the
language of choice. This creates the internal objects representing assignments
and so on, and creates the `Routine` class with them.

The various codegen objects such as `Routine` and `Variable` arenâ€™t SymPy
objects (they donâ€™t subclass from Basic).

For example:

```
>>> from sympy.utilities.codegen import make_routine
>>> from sympy.physics.hydrogen import R_nl
>>> expr = R_nl(3, y, x, 6)
>>> routine = make_routine('my_routine', expr)
>>> [arg.result_var for arg in routine.results]
[resultâ‚…â‚â‚„â‚‚â‚ƒâ‚„â‚â‚†â‚ˆâ‚â‚ƒâ‚‰â‚‡â‚‡â‚â‚‰â‚„â‚‚â‚ˆ]
>>> [arg.expr for arg in routine.results]
âŽ¡                __________                                          âŽ¤
âŽ¢          y    â•± (2 - y)!   -2â‹…x                                    âŽ¥
âŽ¢4â‹…âˆš6â‹…(4â‹…x) â‹…  â•±  â”€â”€â”€â”€â”€â”€â”€â”€ â‹…â„¯    â‹…assoc_laguerre(2 - y, 2â‹…y + 1, 4â‹…x)âŽ¥
âŽ¢            â•²â•±   (y + 3)!                                           âŽ¥
âŽ¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âŽ¥
âŽ£                                 3                                  âŽ¦
>>> [arg.name for arg in routine.arguments]
[x, y]

```

Another more complicated example with a mixture of specified and
automatically-assigned names. Also has Matrix output:

```
>>> routine = make_routine('fcn', [x*y, Eq(a, 1), Eq(r, x + r), Matrix([[x, 2]])])
>>> [arg.result_var for arg in routine.results]
[result_5397460570204848505]
>>> [arg.expr for arg in routine.results]
[xâ‹…y]
>>> [arg.name for arg in routine.arguments]
[x, y, a, r, out_8598435338387848786]

```

We can examine the various arguments more closely:

```
>>> from sympy.utilities.codegen import (InputArgument, OutputArgument,
...                                      InOutArgument)
>>> [a.name for a in routine.arguments if isinstance(a, InputArgument)]
[x, y]

>>> [a.name for a in routine.arguments if isinstance(a, OutputArgument)]
[a, out_8598435338387848786]
>>> [a.expr for a in routine.arguments if isinstance(a, OutputArgument)]
[1, [x  2]]

>>> [a.name for a in routine.arguments if isinstance(a, InOutArgument)]
[r]
>>> [a.expr for a in routine.arguments if isinstance(a, InOutArgument)]
[r + x]

```

The full API reference can be viewed [here](utilities/codegen.html#codegen-api).

## Autowrap[Â¶](#autowrap "Link to this heading")

Autowrap automatically generates code, writes it to disk, compiles it, and
imports it into the current session. Main functions of this module are
`autowrap`, `binary_function`, and `ufuncify`.

It also automatically converts expressions containing `Indexed` objects into
summations. The classes IndexedBase, Indexed and Idx represent a matrix element
M[i, j]. See [Tensor](tensor/index.html#tensor-module) for more on this.

`autowrap` creates a wrapper using f2py or Cython and creates a numerical function.

Note

The `autowrap` callable is not in the sympy namespace automatically,
to use it you must first import `autowrap` from `sympy.utilities.autowrap`

The callable returned from autowrap() is a binary Python function, not a SymPy
object. For example:

```
>>> from sympy.utilities.autowrap import autowrap
>>> expr = ((x - y + z)**(13)).expand()
>>> binary_func = autowrap(expr)
>>> binary_func(1, 4, 2)
-1.0

```

The various flags available with autowrap() help to modify the services
provided by the method. The argument `tempdir` tells autowrap to compile the
code in a specific directory, and leave the files intact when finished. For
instance:

```
>>> from sympy.utilities.autowrap import autowrap
>>> from sympy.physics.qho_1d import psi_n
>>> x_ = IndexedBase('x')
>>> y_ = IndexedBase('y')
>>> m = symbols('m', integer=True)
>>> i = Idx('i', m)
>>> qho = autowrap(Eq(y_[i], psi_n(0, x_[i], m, omega)), tempdir='/tmp')

```

Checking the Fortran source code in the directory specified reveals this:

```
subroutine autofunc(m, omega, x, y)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(in), dimension(1:m) :: x
REAL*8, intent(out), dimension(1:m) :: y
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine

```

Using the argument `args` along with it changes argument sequence:

```
>>> eq = Eq(y_[i], psi_n(0, x_[i], m, omega))
>>> qho = autowrap(eq, tempdir='/tmp', args=[y, x, m, omega])

```

yields:

```
subroutine autofunc(y, x, m, omega)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(out), dimension(1:m) :: y
REAL*8, intent(in), dimension(1:m) :: x
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine

```

The argument `verbose` is boolean, optional and if True, autowrap will not
mute the command line backends. This can be helpful for debugging.

The argument `language` and `backend` are used to change defaults:
`Fortran` and `f2py` to `C` and `Cython`. The argument helpers is used
to define auxiliary expressions needed for the main expression. If the main
expression needs to call a specialized function it should be put in the
`helpers` iterable. Autowrap will then make sure that the compiled main
expression can link to the helper routine. Items should be tuples with
`(<function_name>, <sympy_expression>, <arguments>)`. It is mandatory to
supply an argument sequence to helper routines.

Another method available at the `autowrap` level is `binary_function`. It
returns a sympy function. The advantage is that we can have very fast functions
as compared to SymPy speeds. This is because we will be using compiled
functions with SymPy attributes and methods. An illustration:

```
>>> from sympy.utilities.autowrap import binary_function
>>> from sympy.physics.hydrogen import R_nl
>>> psi_nl = R_nl(1, 0, a, r)
>>> f = binary_function('f', psi_nl)
>>> f(a, r).evalf(3, subs={a: 1, r: 2})
0.766

```

While NumPy operations are very efficient for vectorized data but they
sometimes incur unnecessary costs when chained together.
Consider the following operation

```
>>> x = get_numpy_array(...)
>>> y = sin(x) / x

```

The operators `sin` and `/` call routines that execute tight for loops in
`C`. The resulting computation looks something like this

```
for(int i = 0; i < n; i++)
{
    temp[i] = sin(x[i]);
}
for(int i = i; i < n; i++)
{
    y[i] = temp[i] / x[i];
}

```

This is slightly sub-optimal because

1. We allocate an extra `temp` array
2. We walk over `x` memory twice when once would have been sufficient

A better solution would fuse both element-wise operations into a single for loop

```
for(int i = i; i < n; i++)
{
    y[i] = sin(x[i]) / x[i];
}

```

Statically compiled projects like NumPy are unable to take advantage of such
optimizations. Fortunately, SymPy is able to generate efficient low-level C
or Fortran code. It can then depend on projects like `Cython` or `f2py` to
compile and reconnect that code back up to Python. Fortunately this process is
well automated and a SymPy user wishing to make use of this code generation
should call the `ufuncify` function.

`ufuncify` is the third method available with Autowrap module. It basically
implies â€˜Universal functionsâ€™ and follows an ideology set by NumPy. The main
point of ufuncify as compared to autowrap is that it allows arrays as arguments
and can operate in an element-by-element fashion. The core operation done
element-wise is in accordance to Numpyâ€™s array broadcasting rules. See [this](https://numpy.org/doc/stable/reference/ufuncs.html) for more.

```
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x

```

```
>>> from sympy.utilities.autowrap import ufuncify
>>> f = ufuncify([x], expr)

```

This function `f` consumes and returns a NumPy array. Generally `ufuncify`
performs at least as well as `lambdify`. If the expression is complicated
then `ufuncify` often significantly outperforms the NumPy backed solution.
Jensen has a good [blog post](https://ojensen.wordpress.com/2010/08/10/fast-ufunc-ish-hydrogen-solutions/) on this topic.

Let us see an example for some quantitative analysis:

```
>>> from sympy.physics.hydrogen import R_nl
>>> expr = R_nl(3, 1, x, 6)
>>> expr
               -2â‹…x
8â‹…xâ‹…(4 - 4â‹…x)â‹…â„¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         3

```

The lambdify function translates SymPy expressions into Python functions,
leveraging a variety of numerical libraries. By default lambdify relies on
implementations in the `math` standard library. Naturally, Raw Python is
faster than SymPy. However it also supports `mpmath` and most notably,
`numpy`. Using the NumPy library gives the generated function access to
powerful vectorized ufuncs that are backed by compiled C code.

Let us compare the speeds:

```
>>> from sympy.utilities.autowrap import ufuncify
>>> from sympy.utilities.lambdify import lambdify
>>> fn_numpy = lambdify(x, expr, 'numpy')
>>> fn_fortran = ufuncify([x], expr, backend='f2py')
>>> from numpy import linspace
>>> xx = linspace(0, 1, 5)
>>> fn_numpy(xx)
[ 0.          1.21306132  0.98101184  0.44626032  0.        ]
>>> fn_fortran(xx)
[ 0.          1.21306132  0.98101184  0.44626032  0.        ]
>>> import timeit
>>> timeit.timeit('fn_numpy(xx)', 'from __main__ import fn_numpy, xx', number=10000)
0.18891601900395472
>>> timeit.timeit('fn_fortran(xx)', 'from __main__ import fn_fortran, xx', number=10000)
0.004707066000264604

```

The options available with ufuncify are more or less the same as those
available with `autowrap`.

There are other facilities available with SymPy to do efficient numeric
computation. See [this](numeric-computation.html#numeric-computation) page for a comparison among them.

## Classes and functions for rewriting expressions (sympy.codegen.rewriting)[Â¶](#module-sympy.codegen.rewriting "Link to this heading")

Classes and functions useful for rewriting expressions for optimized code
generation. Some languages (or standards thereof), e.g. C99, offer specialized
math functions for better performance and/or precision.

Using the `optimize` function in this module, together with a collection of
rules (represented as instances of `Optimization`), one can rewrite the
expressions for this purpose:

```
>>> from sympy import Symbol, exp, log
>>> from sympy.codegen.rewriting import optimize, optims_c99
>>> x = Symbol('x')
>>> optimize(3*exp(2*x) - 3, optims_c99)
3*expm1(2*x)
>>> optimize(exp(2*x) - 1 - exp(-33), optims_c99)
expm1(2*x) - exp(-33)
>>> optimize(log(3*x + 3), optims_c99)
log1p(x) + log(3)
>>> optimize(log(2*x + 3), optims_c99)
log(2*x + 3)

```

The `optims_c99` imported above is tuple containing the following instances
(which may be imported from `sympy.codegen.rewriting`):

* `expm1_opt`
* `log1p_opt`
* `exp2_opt`
* `log2_opt`
* `log2const_opt`

*class* sympy.codegen.rewriting.FuncMinusOneOptim(*func*, *func\_m\_1*, *opportunistic=True*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L184-L272)[Â¶](#sympy.codegen.rewriting.FuncMinusOneOptim "Link to this definition")

Specialization of ReplaceOptim for functions evaluating â€œf(x) - 1â€.

Parameters:

**func :**

> The function which is subtracted by one.

**func\_m\_1 :**

> The specialized function evaluating `func(x) - 1`.

**opportunistic** : bool

> When `True`, apply the transformation as long as the magnitude of the
> remaining number terms decreases. When `False`, only apply the
> transformation if it completely eliminates the number term.

Explanation

Numerical functions which go toward one as x go toward zero is often best
implemented by a dedicated function in order to avoid catastrophic
cancellation. One such example is `expm1(x)` in the C standard library
which evaluates `exp(x) - 1`. Such functions preserves many more
significant digits when its argument is much smaller than one, compared
to subtracting one afterwards.

Examples

```
>>> from sympy import symbols, exp
>>> from sympy.codegen.rewriting import FuncMinusOneOptim
>>> from sympy.codegen.cfunctions import expm1
>>> x, y = symbols('x y')
>>> expm1_opt = FuncMinusOneOptim(exp, expm1)
>>> expm1_opt(exp(x) + 2*exp(5*y) - 3)
expm1(x) + 2*expm1(5*y)

```

replace\_in\_Add(*e*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L237-L267)[Â¶](#sympy.codegen.rewriting.FuncMinusOneOptim.replace_in_Add "Link to this definition")

passed as second argument to Basic.replace(â€¦)

*class* sympy.codegen.rewriting.Optimization(*cost\_function=None*, *priority=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L52-L69)[Â¶](#sympy.codegen.rewriting.Optimization "Link to this definition")

Abstract base class for rewriting optimization.

Subclasses should implement `__call__` taking an expression
as argument.

Parameters:

**cost\_function** : callable returning number

**priority** : number

*class* sympy.codegen.rewriting.ReplaceOptim(*query*, *value*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L72-L110)[Â¶](#sympy.codegen.rewriting.ReplaceOptim "Link to this definition")

Rewriting optimization calling replace on expressions.

Parameters:

**query :**

> First argument passed to replace.

**value :**

> Second argument passed to replace.

Explanation

The instance can be used as a function on expressions for which
it will apply the `replace` method (see
[`sympy.core.basic.Basic.replace()`](core.html#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")).

Examples

```
>>> from sympy import Symbol
>>> from sympy.codegen.rewriting import ReplaceOptim
>>> from sympy.codegen.cfunctions import exp2
>>> x = Symbol('x')
>>> exp2_opt = ReplaceOptim(lambda p: p.is_Pow and p.base == 2,
...     lambda p: exp2(p.exp))
>>> exp2_opt(2**x)
exp2(x)

```

sympy.codegen.rewriting.create\_expand\_pow\_optimization(*limit*, *\**, *base\_req=<function <lambda>>*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L286-L326)[Â¶](#sympy.codegen.rewriting.create_expand_pow_optimization "Link to this definition")

Creates an instance of [`ReplaceOptim`](#sympy.codegen.rewriting.ReplaceOptim "sympy.codegen.rewriting.ReplaceOptim") for expanding `Pow`.

Parameters:

**limit** : int

> The highest power which is expanded into multiplication.

**base\_req** : function returning bool

> Requirement on base for expansion to happen, default is to return
> the `is_symbol` attribute of the base.

Explanation

The requirements for expansions are that the base needs to be a symbol
and the exponent needs to be an Integer (and be less than or equal to
`limit`).

Examples

```
>>> from sympy import Symbol, sin
>>> from sympy.codegen.rewriting import create_expand_pow_optimization
>>> x = Symbol('x')
>>> expand_opt = create_expand_pow_optimization(3)
>>> expand_opt(x**5 + x**3)
x**5 + x*x*x
>>> expand_opt(x**5 + x**3 + sin(x)**3)
x**5 + sin(x)**3 + x*x*x
>>> opt2 = create_expand_pow_optimization(3, base_req=lambda b: not b.is_Function)
>>> opt2((x+1)**2 + sin(x)**2)
sin(x)**2 + (x + 1)*(x + 1)

```

sympy.codegen.rewriting.optimize(*expr*, *optimizations*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/rewriting.py#L113-L140)[Â¶](#sympy.codegen.rewriting.optimize "Link to this definition")

Apply optimizations to an expression.

Parameters:

**expr** : expression

**optimizations** : iterable of `Optimization` instances

> The optimizations will be sorted with respect to `priority` (highest first).

Examples

```
>>> from sympy import log, Symbol
>>> from sympy.codegen.rewriting import optims_c99, optimize
>>> x = Symbol('x')
>>> optimize(log(x+3)/log(2) + log(x**2 + 1), optims_c99)
log1p(x**2) + log2(x + 3)

```

Additional AST nodes for operations on matrices. The nodes in this module
are meant to represent optimization of matrix expressions within codegenâ€™s
target languages that cannot be represented by SymPy expressions.

As an example, we can use [`sympy.codegen.rewriting.optimize()`](#sympy.codegen.rewriting.optimize "sympy.codegen.rewriting.optimize") and the
`matin_opt` optimization provided in [`sympy.codegen.rewriting`](#module-sympy.codegen.rewriting "sympy.codegen.rewriting") to
transform matrix multiplication under certain assumptions:

```
>>> from sympy import symbols, MatrixSymbol
>>> n = symbols('n', integer=True)
>>> A = MatrixSymbol('A', n, n)
>>> x = MatrixSymbol('x', n, 1)
>>> expr = A**(-1) * x
>>> from sympy import assuming, Q
>>> from sympy.codegen.rewriting import matinv_opt, optimize
>>> with assuming(Q.fullrank(A)):
...     optimize(expr, [matinv_opt])
MatrixSolve(A, vector=x)

```

*class* sympy.codegen.matrix\_nodes.MatrixSolve(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/matrix_nodes.py#L27-L71)[Â¶](#sympy.codegen.matrix_nodes.MatrixSolve "Link to this definition")

Represents an operation to solve a linear matrix equation.

Parameters:

**matrix** : MatrixSymbol

> Matrix representing the coefficients of variables in the linear
> equation. This matrix must be square and full-rank (i.e. all columns must
> be linearly independent) for the solving operation to be valid.

**vector** : MatrixSymbol

> One-column matrix representing the solutions to the equations
> represented in `matrix`.

Examples

```
>>> from sympy import symbols, MatrixSymbol
>>> from sympy.codegen.matrix_nodes import MatrixSolve
>>> n = symbols('n', integer=True)
>>> A = MatrixSymbol('A', n, n)
>>> x = MatrixSymbol('x', n, 1)
>>> from sympy.printing.numpy import NumPyPrinter
>>> NumPyPrinter().doprint(MatrixSolve(A, x))
'numpy.linalg.solve(A, x)'
>>> from sympy import octave_code
>>> octave_code(MatrixSolve(A, x))
'A \\ x'

```

## Tools for simplifying expressions using approximations (sympy.codegen.approximations)[Â¶](#module-sympy.codegen.approximations "Link to this heading")

*class* sympy.codegen.approximations.SeriesApprox(*bounds*, *reltol*, *max\_order=4*, *n\_point\_checks=4*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/approximations.py#L103-L187)[Â¶](#sympy.codegen.approximations.SeriesApprox "Link to this definition")

Approximates functions by expanding them as a series.

Parameters:

**bounds** : dict

> Mapping expressions to length 2 tuple of bounds (low, high).

**reltol** : number

> Threshold for when to ignore a term. Taken relative to the largest
> lower bound among bounds.

**max\_order** : int

> Largest order to include in series expansion

**n\_point\_checks** : int (even)

> The validity of an expansion (with respect to reltol) is checked at
> discrete points (linearly spaced over the bounds of the variable). The
> number of points used in this numerical check is given by this number.

Examples

```
>>> from sympy import sin, pi
>>> from sympy.abc import x, y
>>> from sympy.codegen.rewriting import optimize
>>> from sympy.codegen.approximations import SeriesApprox
>>> bounds = {x: (-.1, .1), y: (pi-1, pi+1)}
>>> series_approx2 = SeriesApprox(bounds, reltol=1e-2)
>>> series_approx3 = SeriesApprox(bounds, reltol=1e-3)
>>> series_approx8 = SeriesApprox(bounds, reltol=1e-8)
>>> expr = sin(x)*sin(y)
>>> optimize(expr, [series_approx2])
x*(-y + (y - pi)**3/6 + pi)
>>> optimize(expr, [series_approx3])
(-x**3/6 + x)*sin(y)
>>> optimize(expr, [series_approx8])
sin(x)*sin(y)

```

*class* sympy.codegen.approximations.SumApprox(*bounds*, *reltol*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/approximations.py#L14-L100)[Â¶](#sympy.codegen.approximations.SumApprox "Link to this definition")

Approximates sum by neglecting small terms.

Parameters:

**bounds** : dict

> Mapping expressions to length 2 tuple of bounds (low, high).

**reltol** : number

> Threshold for when to ignore a term. Taken relative to the largest
> lower bound among bounds.

Explanation

If terms are expressions which can be determined to be monotonic, then
bounds for those expressions are added.

Examples

```
>>> from sympy import exp
>>> from sympy.abc import x, y, z
>>> from sympy.codegen.rewriting import optimize
>>> from sympy.codegen.approximations import SumApprox
>>> bounds = {x: (-1, 1), y: (1000, 2000), z: (-10, 3)}
>>> sum_approx3 = SumApprox(bounds, reltol=1e-3)
>>> sum_approx2 = SumApprox(bounds, reltol=1e-2)
>>> sum_approx1 = SumApprox(bounds, reltol=1e-1)
>>> expr = 3*(x + y + exp(z))
>>> optimize(expr, [sum_approx3])
3*(x + y + exp(z))
>>> optimize(expr, [sum_approx2])
3*y + 3*exp(z)
>>> optimize(expr, [sum_approx1])
3*y

```

## Classes for abstract syntax trees (sympy.codegen.ast)[Â¶](#module-sympy.codegen.ast "Link to this heading")

Types used to represent a full function/module as an Abstract Syntax Tree.

Most types are small, and are merely used as tokens in the AST. A tree diagram
has been included below to illustrate the relationships between the AST types.

### AST Type Tree[Â¶](#ast-type-tree "Link to this heading")

```
*Basic*
     |
     |
 CodegenAST
     |
     |--->AssignmentBase
     |             |--->Assignment
     |             |--->AugmentedAssignment
     |                                    |--->AddAugmentedAssignment
     |                                    |--->SubAugmentedAssignment
     |                                    |--->MulAugmentedAssignment
     |                                    |--->DivAugmentedAssignment
     |                                    |--->ModAugmentedAssignment
     |
     |--->CodeBlock
     |
     |
     |--->Token
              |--->Attribute
              |--->For
              |--->String
              |       |--->QuotedString
              |       |--->Comment
              |--->Type
              |       |--->IntBaseType
              |       |              |--->_SizedIntType
              |       |                               |--->SignedIntType
              |       |                               |--->UnsignedIntType
              |       |--->FloatBaseType
              |                        |--->FloatType
              |                        |--->ComplexBaseType
              |                                           |--->ComplexType
              |--->Node
              |       |--->Variable
              |       |           |---> Pointer
              |       |--->FunctionPrototype
              |                            |--->FunctionDefinition
              |--->Element
              |--->Declaration
              |--->While
              |--->Scope
              |--->Stream
              |--->Print
              |--->FunctionCall
              |--->BreakToken
              |--->ContinueToken
              |--->NoneToken
              |--->Return

```

### Predefined types[Â¶](#predefined-types "Link to this heading")

A number of `Type` instances are provided in the `sympy.codegen.ast` module
for convenience. Perhaps the two most common ones for code-generation (of numeric
codes) are `float32` and `float64` (known as single and double precision respectively).
There are also precision generic versions of Types (for which the codeprinters selects the
underlying data type at time of printing): `real`, `integer`, `complex_`, `bool_`.

The other `Type` instances defined are:

* `intc`: Integer type used by Câ€™s â€œintâ€.
* `intp`: Integer type used by Câ€™s â€œunsignedâ€.
* `int8`, `int16`, `int32`, `int64`: n-bit integers.
* `uint8`, `uint16`, `uint32`, `uint64`: n-bit unsigned integers.
* `float80`: known as â€œextended precisionâ€ on modern x86/amd64 hardware.
* `complex64`: Complex number represented by two `float32` numbers
* `complex128`: Complex number represented by two `float64` numbers

### Using the nodes[Â¶](#using-the-nodes "Link to this heading")

It is possible to construct simple algorithms using the AST nodes. Letâ€™s construct a loop applying
Newtonâ€™s method:

```
>>> from sympy import symbols, cos
>>> from sympy.codegen.ast import While, Assignment, aug_assign, Print, QuotedString
>>> t, dx, x = symbols('tol delta val')
>>> expr = cos(x) - x**3
>>> whl = While(abs(dx) > t, [
...     Assignment(dx, -expr/expr.diff(x)),
...     aug_assign(x, '+', dx),
...     Print([x])
... ])
>>> from sympy import pycode
>>> py_str = pycode(whl)
>>> print(py_str)
while (abs(delta) > tol):
    delta = (val**3 - math.cos(val))/(-3*val**2 - math.sin(val))
    val += delta
    print(val)
>>> import math
>>> tol, val, delta = 1e-5, 0.5, float('inf')
>>> exec(py_str)
1.1121416371
0.909672693737
0.867263818209
0.865477135298
0.865474033111
>>> print('%3.1g' % (math.cos(val) - val**3))
-3e-11

```

If we want to generate Fortran code for the same while loop we simple call `fcode`:

```
>>> from sympy import fcode
>>> print(fcode(whl, standard=2003, source_format='free'))
do while (abs(delta) > tol)
   delta = (val**3 - cos(val))/(-3*val**2 - sin(val))
   val = val + delta
   print *, val
end do

```

There is a function constructing a loop (or a complete function) like this in
[`sympy.codegen.algorithms`](#module-sympy.codegen.algorithms "sympy.codegen.algorithms").

*class* sympy.codegen.ast.Assignment(*lhs*, *rhs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L463-L500)[Â¶](#sympy.codegen.ast.Assignment "Link to this definition")

Represents variable assignment for code generation.

Parameters:

**lhs** : Expr

> SymPy object representing the lhs of the expression. These should be
> singular objects, such as one would use in writing code. Notable types
> include Symbol, MatrixSymbol, MatrixElement, and Indexed. Types that
> subclass these types are also supported.

**rhs** : Expr

> SymPy object representing the rhs of the expression. This can be any
> type, provided its shape corresponds to that of the lhs. For example,
> a Matrix type can be assigned to MatrixSymbol, but not to Symbol, as
> the dimensions will not align.

Examples

```
>>> from sympy import symbols, MatrixSymbol, Matrix
>>> from sympy.codegen.ast import Assignment
>>> x, y, z = symbols('x, y, z')
>>> Assignment(x, y)
Assignment(x, y)
>>> Assignment(x, 0)
Assignment(x, 0)
>>> A = MatrixSymbol('A', 1, 3)
>>> mat = Matrix([x, y, z]).T
>>> Assignment(A, mat)
Assignment(A, Matrix([[x, y, z]]))
>>> Assignment(A[0, 1], x)
Assignment(A[0, 1], x)

```

*class* sympy.codegen.ast.AssignmentBase(*lhs*, *rhs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L404-L460)[Â¶](#sympy.codegen.ast.AssignmentBase "Link to this definition")

Abstract base class for Assignment and AugmentedAssignment.

Attributes:

opstr

Symbol for assignment operator, e.g. â€œ=â€, â€œ+=â€, etc.

*class* sympy.codegen.ast.Attribute(*possibly parametrized*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1366-L1404)[Â¶](#sympy.codegen.ast.Attribute "Link to this definition")

For use with [`sympy.codegen.ast.Node`](#sympy.codegen.ast.Node "sympy.codegen.ast.Node") (which takes instances of
`Attribute` as `attrs`).

Parameters:

**name** : str

**parameters** : Tuple

Examples

```
>>> from sympy.codegen.ast import Attribute
>>> volatile = Attribute('volatile')
>>> volatile
volatile
>>> print(repr(volatile))
Attribute(String('volatile'))
>>> a = Attribute('foo', [1, 2, 3])
>>> a
foo(1, 2, 3)
>>> a.parameters == (1, 2, 3)
True

```

*class* sympy.codegen.ast.AugmentedAssignment(*lhs*, *rhs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L503-L518)[Â¶](#sympy.codegen.ast.AugmentedAssignment "Link to this definition")

Base class for augmented assignments.

Attributes:

binopstr

Symbol for binary operation being applied in the assignment, such as â€œ+â€,
â€œ\*â€, etc.

*class* sympy.codegen.ast.BreakToken(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L340-L354)[Â¶](#sympy.codegen.ast.BreakToken "Link to this definition")

Represents â€˜breakâ€™ in C/Python (â€˜exitâ€™ in Fortran).

Use the premade instance `break_` or instantiate manually.

Examples

```
>>> from sympy import ccode, fcode
>>> from sympy.codegen.ast import break_
>>> ccode(break_)
'break'
>>> fcode(break_, source_format='free')
'exit'

```

*class* sympy.codegen.ast.CodeBlock(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L593-L807)[Â¶](#sympy.codegen.ast.CodeBlock "Link to this definition")

Represents a block of code.

Explanation

For now only assignments are supported. This restriction will be lifted in
the future.

Useful attributes on this object are:

`left_hand_sides`:

Tuple of left-hand sides of assignments, in order.

`left_hand_sides`:

Tuple of right-hand sides of assignments, in order.

`free_symbols`: Free symbols of the expressions in the right-hand sides

which do not appear in the left-hand side of an assignment.

Useful methods on this object are:

`topological_sort`:

Class method. Return a CodeBlock with assignments
sorted so that variables are assigned before they
are used.

`cse`:

Return a new CodeBlock with common subexpressions eliminated and
pulled out as assignments.

Examples

```
>>> from sympy import symbols, ccode
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y = symbols('x y')
>>> c = CodeBlock(Assignment(x, 1), Assignment(y, x + 1))
>>> print(ccode(c))
x = 1;
y = x + 1;

```

cse(*symbols=None*, *optimizations=None*, *postprocess=None*, *order='canonical'*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L746-L807)[Â¶](#sympy.codegen.ast.CodeBlock.cse "Link to this definition")

Return a new code block with common subexpressions eliminated.

Explanation

See the docstring of [`sympy.simplify.cse_main.cse()`](simplify/simplify.html#sympy.simplify.cse_main.cse "sympy.simplify.cse_main.cse") for more
information.

Examples

```
>>> from sympy import symbols, sin
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y, z = symbols('x y z')

```

```
>>> c = CodeBlock(
...     Assignment(x, 1),
...     Assignment(y, sin(x) + 1),
...     Assignment(z, sin(x) - 1),
... )
...
>>> c.cse()
CodeBlock(
    Assignment(x, 1),
    Assignment(x0, sin(x)),
    Assignment(y, x0 + 1),
    Assignment(z, x0 - 1)
)

```

*classmethod* topological\_sort(*assignments*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L665-L744)[Â¶](#sympy.codegen.ast.CodeBlock.topological_sort "Link to this definition")

Return a CodeBlock with topologically sorted assignments so that
variables are assigned before they are used.

Examples

The existing order of assignments is preserved as much as possible.

This function assumes that variables are assigned to only once.

This is a class constructor so that the default constructor for
CodeBlock can error when variables are used before they are assigned.

```
>>> from sympy import symbols
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y, z = symbols('x y z')

```

```
>>> assignments = [
...     Assignment(x, y + z),
...     Assignment(y, z + 1),
...     Assignment(z, 2),
... ]
>>> CodeBlock.topological_sort(assignments)
CodeBlock(
    Assignment(z, 2),
    Assignment(y, z + 1),
    Assignment(x, y + z)
)

```

*class* sympy.codegen.ast.Comment(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L925-L926)[Â¶](#sympy.codegen.ast.Comment "Link to this definition")

Represents a comment.

*class* sympy.codegen.ast.ComplexType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1332-L1334)[Â¶](#sympy.codegen.ast.ComplexType "Link to this definition")

Represents a complex floating point number.

*class* sympy.codegen.ast.ContinueToken(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L359-L373)[Â¶](#sympy.codegen.ast.ContinueToken "Link to this definition")

Represents â€˜continueâ€™ in C/Python (â€˜cycleâ€™ in Fortran)

Use the premade instance `continue_` or instantiate manually.

Examples

```
>>> from sympy import ccode, fcode
>>> from sympy.codegen.ast import continue_
>>> ccode(continue_)
'continue'
>>> fcode(continue_, source_format='free')
'cycle'

```

*class* sympy.codegen.ast.Declaration(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1610-L1634)[Â¶](#sympy.codegen.ast.Declaration "Link to this definition")

Represents a variable declaration

Parameters:

**variable** : Variable

Examples

```
>>> from sympy.codegen.ast import Declaration, NoneToken, untyped
>>> z = Declaration('z')
>>> z.variable.type == untyped
True
>>> # value is special NoneToken() which must be tested with == operator
>>> z.variable.value is None  # won't work
False
>>> z.variable.value == None  # not PEP-8 compliant
True
>>> z.variable.value == NoneToken()  # OK
True

```

*class* sympy.codegen.ast.Element(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1583-L1607)[Â¶](#sympy.codegen.ast.Element "Link to this definition")

Element in (a possibly N-dimensional) array.

Examples

```
>>> from sympy.codegen.ast import Element
>>> elem = Element('x', 'ijk')
>>> elem.symbol.name == 'x'
True
>>> elem.indices
(i, j, k)
>>> from sympy import ccode
>>> ccode(elem)
'x[i][j][k]'
>>> ccode(Element('x', 'ijk', strides='lmn', offset='o'))
'x[i*l + j*m + k*n + o]'

```

*class* sympy.codegen.ast.FloatBaseType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1190-L1193)[Â¶](#sympy.codegen.ast.FloatBaseType "Link to this definition")

Represents a floating point number type.

cast\_nocheck[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/core/numbers.py#L582-L1192)[Â¶](#sympy.codegen.ast.FloatBaseType.cast_nocheck "Link to this definition")

alias of [`Float`](core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")

*class* sympy.codegen.ast.FloatType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1195-L1312)[Â¶](#sympy.codegen.ast.FloatType "Link to this definition")

Represents a floating point type with fixed bit width.

Base 2 & one sign bit is assumed.

Parameters:

**name** : str

> Name of the type.

**nbits** : integer

> Number of bits used (storage).

**nmant** : integer

> Number of bits used to represent the mantissa.

**nexp** : integer

> Number of bits used to represent the mantissa.

Examples

```
>>> from sympy import S
>>> from sympy.codegen.ast import FloatType
>>> half_precision = FloatType('f16', nbits=16, nmant=10, nexp=5)
>>> half_precision.max
65504
>>> half_precision.tiny == S(2)**-14
True
>>> half_precision.eps == S(2)**-10
True
>>> half_precision.dig == 3
True
>>> half_precision.decimal_dig == 5
True
>>> half_precision.cast_check(1.0)
1.0
>>> half_precision.cast_check(1e5)
Traceback (most recent call last):
  ...
ValueError: Maximum value for data type smaller than new value.

```

cast\_nocheck(*value*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1298-L1304)[Â¶](#sympy.codegen.ast.FloatType.cast_nocheck "Link to this definition")

Casts without checking if out of bounds or subnormal.

*property* decimal\_dig[Â¶](#sympy.codegen.ast.FloatType.decimal_dig "Link to this definition")

Number of digits needed to store & load without loss.

Explanation

Number of decimal digits needed to guarantee that two consecutive conversions
(float -> text -> float) to be idempotent. This is useful when one do not want
to loose precision due to rounding errors when storing a floating point value
as text.

*property* dig[Â¶](#sympy.codegen.ast.FloatType.dig "Link to this definition")

Number of decimal digits that are guaranteed to be preserved in text.

When converting text -> float -> text, you are guaranteed that at least `dig`
number of digits are preserved with respect to rounding or overflow.

*property* eps[Â¶](#sympy.codegen.ast.FloatType.eps "Link to this definition")

Difference between 1.0 and the next representable value.

*property* max[Â¶](#sympy.codegen.ast.FloatType.max "Link to this definition")

Maximum value representable.

*property* max\_exponent[Â¶](#sympy.codegen.ast.FloatType.max_exponent "Link to this definition")

The largest positive number n, such that 2\*\*(n - 1) is a representable finite value.

*property* min\_exponent[Â¶](#sympy.codegen.ast.FloatType.min_exponent "Link to this definition")

The lowest negative number n, such that 2\*\*(n - 1) is a valid normalized number.

*property* tiny[Â¶](#sympy.codegen.ast.FloatType.tiny "Link to this definition")

The minimum positive normalized value.

*class* sympy.codegen.ast.For(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L810-L869)[Â¶](#sympy.codegen.ast.For "Link to this definition")

Represents a â€˜for-loopâ€™ in the code.

> Expressions are of the form:
> â€œfor target in iter:
>
> bodyâ€¦â€

Parameters:

**target** : symbol

> iter : iterable
> body : CodeBlock or iterable

**! When passed an iterable it is used to instantiate a CodeBlock.**

Examples

```
>>> from sympy import symbols, Range
>>> from sympy.codegen.ast import aug_assign, For
>>> x, i, j, k = symbols('x i j k')
>>> for_i = For(i, Range(10), [aug_assign(x, '+', i*j*k)])
>>> for_i
For(i, iterable=Range(0, 10, 1), body=CodeBlock(
    AddAugmentedAssignment(x, i*j*k)
))
>>> for_ji = For(j, Range(7), [for_i])
>>> for_ji
For(j, iterable=Range(0, 7, 1), body=CodeBlock(
    For(i, iterable=Range(0, 10, 1), body=CodeBlock(
        AddAugmentedAssignment(x, i*j*k)
    ))
))
>>> for_kji =For(k, Range(5), [for_ji])
>>> for_kji
For(k, iterable=Range(0, 5, 1), body=CodeBlock(
    For(j, iterable=Range(0, 7, 1), body=CodeBlock(
        For(i, iterable=Range(0, 10, 1), body=CodeBlock(
            AddAugmentedAssignment(x, i*j*k)
        ))
    ))
))

```

*class* sympy.codegen.ast.FunctionCall(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1870-L1892)[Â¶](#sympy.codegen.ast.FunctionCall "Link to this definition")

Represents a call to a function in the code.

Parameters:

**name** : str

**function\_args** : Tuple

Examples

```
>>> from sympy.codegen.ast import FunctionCall
>>> from sympy import pycode
>>> fcall = FunctionCall('foo', 'bar baz'.split())
>>> print(pycode(fcall))
foo(bar, baz)

```

*class* sympy.codegen.ast.FunctionDefinition(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1800-L1844)[Â¶](#sympy.codegen.ast.FunctionDefinition "Link to this definition")

Represents a function definition in the code.

Parameters:

**return\_type** : Type

**name** : str

**parameters: iterable of Variable instances**

**body** : CodeBlock or iterable

**attrs** : iterable of Attribute instances

Examples

```
>>> from sympy import ccode, symbols
>>> from sympy.codegen.ast import real, FunctionPrototype
>>> x, y = symbols('x y', real=True)
>>> fp = FunctionPrototype(real, 'foo', [x, y])
>>> ccode(fp)
'double foo(double x, double y)'
>>> from sympy.codegen.ast import FunctionDefinition, Return
>>> body = [Return(x*y)]
>>> fd = FunctionDefinition.from_FunctionPrototype(fp, body)
>>> print(ccode(fd))
double foo(double x, double y){
    return x*y;
}

```

*class* sympy.codegen.ast.FunctionPrototype(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1751-L1797)[Â¶](#sympy.codegen.ast.FunctionPrototype "Link to this definition")

Represents a function prototype

Allows the user to generate forward declaration in e.g. C/C++.

Parameters:

**return\_type** : Type

**name** : str

**parameters: iterable of Variable instances**

**attrs** : iterable of Attribute instances

Examples

```
>>> from sympy import ccode, symbols
>>> from sympy.codegen.ast import real, FunctionPrototype
>>> x, y = symbols('x y', real=True)
>>> fp = FunctionPrototype(real, 'foo', [x, y])
>>> ccode(fp)
'double foo(double x, double y)'

```

*class* sympy.codegen.ast.IntBaseType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1146-L1149)[Â¶](#sympy.codegen.ast.IntBaseType "Link to this definition")

Integer base type, contains no size information.

*class* sympy.codegen.ast.Node(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L928-L960)[Â¶](#sympy.codegen.ast.Node "Link to this definition")

Subclass of Token, carrying the attribute â€˜attrsâ€™ (Tuple)

Examples

```
>>> from sympy.codegen.ast import Node, value_const, pointer_const
>>> n1 = Node([value_const])
>>> n1.attr_params('value_const')  # get the parameters of attribute (by name)
()
>>> from sympy.codegen.fnodes import dimension
>>> n2 = Node([value_const, dimension(5, 3)])
>>> n2.attr_params(value_const)  # get the parameters of attribute (by Attribute instance)
()
>>> n2.attr_params('dimension')  # get the parameters of attribute (by name)
(5, 3)
>>> n2.attr_params(pointer_const) is None
True

```

attr\_params(*looking\_for*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L956-L960)[Â¶](#sympy.codegen.ast.Node.attr_params "Link to this definition")

Returns the parameters of the Attribute with name `looking_for` in self.attrs

*class* sympy.codegen.ast.NoneToken(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L377-L398)[Â¶](#sympy.codegen.ast.NoneToken "Link to this definition")

The AST equivalence of Pythonâ€™s NoneType

The corresponding instance of Pythonâ€™s `None` is `none`.

Examples

```
>>> from sympy.codegen.ast import none, Variable
>>> from sympy import pycode
>>> print(pycode(Variable('x').as_Declaration(value=none)))
x = None

```

*class* sympy.codegen.ast.Pointer(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1558-L1580)[Â¶](#sympy.codegen.ast.Pointer "Link to this definition")

Represents a pointer. See `Variable`.

Examples

Can create instances of `Element`:

```
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Pointer
>>> i = Symbol('i', integer=True)
>>> p = Pointer('x')
>>> p[i+1]
Element(x, indices=(i + 1,))

```

*class* sympy.codegen.ast.Print(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1724-L1748)[Â¶](#sympy.codegen.ast.Print "Link to this definition")

Represents print command in the code.

Parameters:

**formatstring** : str

**\*args** : Basic instances (or convertible to such through sympify)

Examples

```
>>> from sympy.codegen.ast import Print
>>> from sympy import pycode
>>> print(pycode(Print('x y'.split(), "coordinate: %12.5g %12.5g\\n")))
print("coordinate: %12.5g %12.5g\n" % (x, y), end="")

```

*class* sympy.codegen.ast.QuotedString(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L922-L923)[Â¶](#sympy.codegen.ast.QuotedString "Link to this definition")

Represents a string which should be printed with quotes.

*class* sympy.codegen.ast.Raise(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1895-L1897)[Â¶](#sympy.codegen.ast.Raise "Link to this definition")

Prints as â€˜raise â€¦â€™ in Python, â€˜throw â€¦â€™ in C++

*class* sympy.codegen.ast.Return(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1847-L1867)[Â¶](#sympy.codegen.ast.Return "Link to this definition")

Represents a return command in the code.

Parameters:

**return** : Basic

Examples

```
>>> from sympy.codegen.ast import Return
>>> from sympy.printing.pycode import pycode
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> print(pycode(Return(x)))
return x

```

*class* sympy.codegen.ast.RuntimeError\_(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1900-L1906)[Â¶](#sympy.codegen.ast.RuntimeError_ "Link to this definition")

Represents â€˜std::runtime\_errorâ€™ in C++ and â€˜RuntimeErrorâ€™ in Python.

Note that the latter is uncommon, and you might want to use e.g. ValueError.

*class* sympy.codegen.ast.Scope(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1675-L1692)[Â¶](#sympy.codegen.ast.Scope "Link to this definition")

Represents a scope in the code.

Parameters:

**body** : CodeBlock or iterable

> When passed an iterable it is used to instantiate a CodeBlock.

*class* sympy.codegen.ast.SignedIntType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1165-L1174)[Â¶](#sympy.codegen.ast.SignedIntType "Link to this definition")

Represents a signed integer type.

*class* sympy.codegen.ast.Stream(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1695-L1718)[Â¶](#sympy.codegen.ast.Stream "Link to this definition")

Represents a stream.

There are two predefined Stream instances `stdout` & `stderr`.

Parameters:

**name** : str

Examples

```
>>> from sympy import pycode, Symbol
>>> from sympy.codegen.ast import Print, stderr, QuotedString
>>> print(pycode(Print(['x'], file=stderr)))
print(x, file=sys.stderr)
>>> x = Symbol('x')
>>> print(pycode(Print([QuotedString('x')], file=stderr)))  # print literally "x"
print("x", file=sys.stderr)

```

*class* sympy.codegen.ast.String(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L872-L920)[Â¶](#sympy.codegen.ast.String "Link to this definition")

SymPy object representing a string.

Atomic object which is not an expression (as opposed to Symbol).

Parameters:

**text** : str

Examples

```
>>> from sympy.codegen.ast import String
>>> f = String('foo')
>>> f
foo
>>> str(f)
'foo'
>>> f.text
'foo'
>>> print(repr(f))
String('foo')

```

*class* sympy.codegen.ast.Token(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L168-L338)[Â¶](#sympy.codegen.ast.Token "Link to this definition")

Base class for the AST types.

Explanation

Defining fields are set in `_fields`. Attributes (defined in \_fields)
are only allowed to contain instances of Basic (unless atomic, see
`String`). The arguments to `__new__()` correspond to the attributes in
the order defined in `_fields`. The ``defaults` class attribute is a
dictionary mapping attribute names to their default values.

Subclasses should not need to override the `__new__()` method. They may
define a class or static method named `_construct_<attr>` for each
attribute to process the value passed to `__new__()`. Attributes listed
in the class attribute `not_in_args` are not passed to [`Basic`](core.html#sympy.core.basic.Basic "sympy.core.basic.Basic").

kwargs(*exclude=()*, *apply=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L322-L338)[Â¶](#sympy.codegen.ast.Token.kwargs "Link to this definition")

Get instanceâ€™s attributes as dict of keyword arguments.

Parameters:

**exclude** : collection of str

> Collection of keywords to exclude.

**apply** : callable, optional

> Function to apply to all values.

*class* sympy.codegen.ast.Type(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L963-L1143)[Â¶](#sympy.codegen.ast.Type "Link to this definition")

Represents a type.

Parameters:

**name** : str

> Name of the type, e.g. `object`, `int16`, `float16` (where the latter two
> would use the `Type` sub-classes `IntType` and `FloatType` respectively).
> If a `Type` instance is given, the said instance is returned.

Explanation

The naming is a super-set of NumPy naming. Type has a classmethod
`from_expr` which offer type deduction. It also has a method
`cast_check` which casts the argument to its type, possibly raising an
exception if rounding error is not within tolerances, or if the value is not
representable by the underlying data type (e.g. unsigned integers).

Examples

```
>>> from sympy.codegen.ast import Type
>>> t = Type.from_expr(42)
>>> t
integer
>>> print(repr(t))
IntBaseType(String('integer'))
>>> from sympy.codegen.ast import uint8
>>> uint8.cast_check(-1)
Traceback (most recent call last):
  ...
ValueError: Minimum value for data type bigger than new value.
>>> from sympy.codegen.ast import float32
>>> v6 = 0.123456
>>> float32.cast_check(v6)
0.123456
>>> v10 = 12345.67894
>>> float32.cast_check(v10)
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> boost_mp50 = Type('boost::multiprecision::cpp_dec_float_50')
>>> from sympy import cxxcode
>>> from sympy.codegen.ast import Declaration, Variable
>>> cxxcode(Declaration(Variable('x', type=boost_mp50)))
'boost::multiprecision::cpp_dec_float_50 x'

```

References

[[R39](#id2)]

<https://numpy.org/doc/stable/user/basics.types.html>

cast\_check(*value*, *rtol=None*, *atol=0*, *precision\_targets=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1072-L1137)[Â¶](#sympy.codegen.ast.Type.cast_check "Link to this definition")

Casts a value to the data type of the instance.

Parameters:

**value** : number

**rtol** : floating point number

> Relative tolerance. (will be deduced if not given).

**atol** : floating point number

> Absolute tolerance (in addition to `rtol`).

**type\_aliases** : dict

> Maps substitutions for Type, e.g. {integer: int64, real: float32}

Examples

```
>>> from sympy.codegen.ast import integer, float32, int8
>>> integer.cast_check(3.0) == 3
True
>>> float32.cast_check(1e-40)
Traceback (most recent call last):
  ...
ValueError: Minimum value for data type bigger than new value.
>>> int8.cast_check(256)
Traceback (most recent call last):
  ...
ValueError: Maximum value for data type smaller than new value.
>>> v10 = 12345.67894
>>> float32.cast_check(v10)
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> from sympy.codegen.ast import float64
>>> float64.cast_check(v10)
12345.67894
>>> from sympy import Float
>>> v18 = Float('0.123456789012345646')
>>> float64.cast_check(v18)
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> from sympy.codegen.ast import float80
>>> float80.cast_check(v18)
0.123456789012345649

```

*classmethod* from\_expr(*expr*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1026-L1067)[Â¶](#sympy.codegen.ast.Type.from_expr "Link to this definition")

Deduces type from an expression or a `Symbol`.

Parameters:

**expr** : number or SymPy object

> The type will be deduced from type or properties.

Raises:

**ValueError when type deduction fails.**

Examples

```
>>> from sympy.codegen.ast import Type, integer, complex_
>>> Type.from_expr(2) == integer
True
>>> from sympy import Symbol
>>> Type.from_expr(Symbol('z', complex=True)) == complex_
True
>>> Type.from_expr(sum)
Traceback (most recent call last):
  ...
ValueError: Could not deduce type from expr.

```

*class* sympy.codegen.ast.UnsignedIntType(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1177-L1186)[Â¶](#sympy.codegen.ast.UnsignedIntType "Link to this definition")

Represents an unsigned integer type.

*class* sympy.codegen.ast.Variable(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1410-L1556)[Â¶](#sympy.codegen.ast.Variable "Link to this definition")

Represents a variable.

Parameters:

**symbol** : Symbol

**type** : Type (optional)

> Type of the variable.

**attrs** : iterable of Attribute instances

> Will be stored as a Tuple.

Examples

```
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Variable, float32, integer
>>> x = Symbol('x')
>>> v = Variable(x, type=float32)
>>> v.attrs
()
>>> v == Variable('x')
False
>>> v == Variable('x', type=float32)
True
>>> v
Variable(x, type=float32)

```

One may also construct a `Variable` instance with the type deduced from
assumptions about the symbol using the `deduced` classmethod:

```
>>> i = Symbol('i', integer=True)
>>> v = Variable.deduced(i)
>>> v.type == integer
True
>>> v == Variable('i')
False
>>> from sympy.codegen.ast import value_const
>>> value_const in v.attrs
False
>>> w = Variable('w', attrs=[value_const])
>>> w
Variable(w, attrs=(value_const,))
>>> value_const in w.attrs
True
>>> w.as_Declaration(value=42)
Declaration(Variable(w, value=42, attrs=(value_const,)))

```

as\_Declaration(*\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1514-L1544)[Â¶](#sympy.codegen.ast.Variable.as_Declaration "Link to this definition")

Convenience method for creating a Declaration instance.

Explanation

If the variable of the Declaration need to wrap a modified
variable keyword arguments may be passed (overriding e.g.
the `value` of the Variable instance).

Examples

```
>>> from sympy.codegen.ast import Variable, NoneToken
>>> x = Variable('x')
>>> decl1 = x.as_Declaration()
>>> # value is special NoneToken() which must be tested with == operator
>>> decl1.variable.value is None  # won't work
False
>>> decl1.variable.value == None  # not PEP-8 compliant
True
>>> decl1.variable.value == NoneToken()  # OK
True
>>> decl2 = x.as_Declaration(value=42.0)
>>> decl2.variable.value == 42.0
True

```

*classmethod* deduced(*symbol*, *value=None*, *attrs=()*, *cast\_check=True*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1469-L1512)[Â¶](#sympy.codegen.ast.Variable.deduced "Link to this definition")

Alt. constructor with type deduction from `Type.from_expr`.

Deduces type primarily from `symbol`, secondarily from `value`.

Parameters:

**symbol** : Symbol

**value** : expr

> (optional) value of the variable.

**attrs** : iterable of Attribute instances

**cast\_check** : bool

> Whether to apply `Type.cast_check` on `value`.

Examples

```
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Variable, complex_
>>> n = Symbol('n', integer=True)
>>> str(Variable.deduced(n).type)
'integer'
>>> x = Symbol('x', real=True)
>>> v = Variable.deduced(x)
>>> v.type
real
>>> z = Symbol('z', complex=True)
>>> Variable.deduced(z).type == complex_
True

```

*class* sympy.codegen.ast.While(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L1637-L1672)[Â¶](#sympy.codegen.ast.While "Link to this definition")

Represents a â€˜for-loopâ€™ in the code.

Expressions are of the form:
â€œwhile condition:

bodyâ€¦â€

Parameters:

**condition** : expression convertible to Boolean

**body** : CodeBlock or iterable

> When passed an iterable it is used to instantiate a CodeBlock.

Examples

```
>>> from sympy import symbols, Gt, Abs
>>> from sympy.codegen import aug_assign, Assignment, While
>>> x, dx = symbols('x dx')
>>> expr = 1 - x**2
>>> whl = While(Gt(Abs(dx), 1e-9), [
...     Assignment(dx, -expr/expr.diff(x)),
...     aug_assign(x, '+', dx)
... ])

```

sympy.codegen.ast.aug\_assign(*lhs*, *op*, *rhs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/ast.py#L550-L590)[Â¶](#sympy.codegen.ast.aug_assign "Link to this definition")

Create â€˜lhs op= rhsâ€™.

Parameters:

**lhs** : Expr

> SymPy object representing the lhs of the expression. These should be
> singular objects, such as one would use in writing code. Notable types
> include Symbol, MatrixSymbol, MatrixElement, and Indexed. Types that
> subclass these types are also supported.

**op** : str

> Operator (+, -, /, \*, %).

**rhs** : Expr

> SymPy object representing the rhs of the expression. This can be any
> type, provided its shape corresponds to that of the lhs. For example,
> a Matrix type can be assigned to MatrixSymbol, but not to Symbol, as
> the dimensions will not align.

Explanation

Represents augmented variable assignment for code generation. This is a
convenience function. You can also use the AugmentedAssignment classes
directly, like AddAugmentedAssignment(x, y).

Examples

```
>>> from sympy import symbols
>>> from sympy.codegen.ast import aug_assign
>>> x, y = symbols('x, y')
>>> aug_assign(x, '+', y)
AddAugmentedAssignment(x, y)

```

## Special C math functions (sympy.codegen.cfunctions)[Â¶](#module-sympy.codegen.cfunctions "Link to this heading")

This module contains SymPy functions mathcin corresponding to special math functions in the
C standard library (since C99, also available in C++11).

The functions defined in this module allows the user to express functions such as `expm1`
as a SymPy function for symbolic manipulation.

*class* sympy.codegen.cfunctions.Cbrt(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L439-L483)[Â¶](#sympy.codegen.cfunctions.Cbrt "Link to this definition")

Represents the cube root function.

Explanation

The reason why one would use `Cbrt(x)` over `cbrt(x)`
is that the latter is internally represented as `Pow(x, Rational(1, 3))` which
may not be what one wants when doing code-generation.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import Cbrt
>>> Cbrt(x)
Cbrt(x)
>>> Cbrt(x).diff(x)
1/(3*x**(2/3))

```

See also

[`Sqrt`](#sympy.codegen.cfunctions.Sqrt "sympy.codegen.cfunctions.Sqrt")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L467-L474)[Â¶](#sympy.codegen.cfunctions.Cbrt.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.Sqrt(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L389-L432)[Â¶](#sympy.codegen.cfunctions.Sqrt "Link to this definition")

Represents the square root function.

Explanation

The reason why one would use `Sqrt(x)` over `sqrt(x)`
is that the latter is internally represented as `Pow(x, S.Half)` which
may not be what one wants when doing code-generation.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import Sqrt
>>> Sqrt(x)
Sqrt(x)
>>> Sqrt(x).diff(x)
1/(2*sqrt(x))

```

See also

[`Cbrt`](#sympy.codegen.cfunctions.Cbrt "sympy.codegen.cfunctions.Cbrt")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L417-L424)[Â¶](#sympy.codegen.cfunctions.Sqrt.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.exp2(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L168-L217)[Â¶](#sympy.codegen.cfunctions.exp2 "Link to this definition")

Represents the exponential function with base two.

Explanation

The benefit of using `exp2(x)` over `2**x`
is that the latter is not as efficient under finite precision
arithmetic.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import exp2
>>> exp2(2).evalf() == 4.0
True
>>> exp2(x).diff(x)
log(2)*exp2(x)

```

See also

[`log2`](#sympy.codegen.cfunctions.log2 "sympy.codegen.cfunctions.log2")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L197-L204)[Â¶](#sympy.codegen.cfunctions.exp2.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.expm1(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L21-L79)[Â¶](#sympy.codegen.cfunctions.expm1 "Link to this definition")

Represents the exponential function minus one.

Explanation

The benefit of using `expm1(x)` over `exp(x) - 1`
is that the latter is prone to cancellation under finite precision
arithmetic when x is close to zero.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import expm1
>>> '%.0e' % expm1(1e-99).evalf()
'1e-99'
>>> from math import exp
>>> exp(1e-99) - 1
0.0
>>> expm1(x).diff(x)
exp(x)

```

See also

[`log1p`](#sympy.codegen.cfunctions.log1p "sympy.codegen.cfunctions.log1p")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L52-L59)[Â¶](#sympy.codegen.cfunctions.expm1.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.fma(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L288-L326)[Â¶](#sympy.codegen.cfunctions.fma "Link to this definition")

Represents â€œfused multiply addâ€.

Explanation

The benefit of using `fma(x, y, z)` over `x*y + z`
is that, under finite precision arithmetic, the former is
supported by special instructions on some CPUs.

Examples

```
>>> from sympy.abc import x, y, z
>>> from sympy.codegen.cfunctions import fma
>>> fma(x, y, z).diff(x)
y

```

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L310-L319)[Â¶](#sympy.codegen.cfunctions.fma.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.hypot(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L490-L532)[Â¶](#sympy.codegen.cfunctions.hypot "Link to this definition")

Represents the hypotenuse function.

Explanation

The hypotenuse function is provided by e.g. the math library
in the C99 standard, hence one may want to represent the function
symbolically when doing code-generation.

Examples

```
>>> from sympy.abc import x, y
>>> from sympy.codegen.cfunctions import hypot
>>> hypot(3, 4).evalf() == 5.0
True
>>> hypot(x, y)
hypot(x, y)
>>> hypot(x, y).diff(x)
x/hypot(x, y)

```

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L516-L523)[Â¶](#sympy.codegen.cfunctions.hypot.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.log10(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L336-L382)[Â¶](#sympy.codegen.cfunctions.log10 "Link to this definition")

Represents the logarithm function with base ten.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log10
>>> log10(100).evalf() == 2.0
True
>>> log10(x).diff(x)
1/(x*log(10))

```

See also

[`log2`](#sympy.codegen.cfunctions.log2 "sympy.codegen.cfunctions.log2")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L357-L364)[Â¶](#sympy.codegen.cfunctions.log10.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.log1p(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L86-L161)[Â¶](#sympy.codegen.cfunctions.log1p "Link to this definition")

Represents the natural logarithm of a number plus one.

Explanation

The benefit of using `log1p(x)` over `log(x + 1)`
is that the latter is prone to cancellation under finite precision
arithmetic when x is close to zero.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log1p
>>> from sympy import expand_log
>>> '%.0e' % expand_log(log1p(1e-99)).evalf()
'1e-99'
>>> from math import log
>>> log(1 + 1e-99)
0.0
>>> log1p(x).diff(x)
1/(x + 1)

```

See also

[`expm1`](#sympy.codegen.cfunctions.expm1 "sympy.codegen.cfunctions.expm1")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L119-L126)[Â¶](#sympy.codegen.cfunctions.log1p.fdiff "Link to this definition")

Returns the first derivative of this function.

*class* sympy.codegen.cfunctions.log2(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L224-L281)[Â¶](#sympy.codegen.cfunctions.log2 "Link to this definition")

Represents the logarithm function with base two.

Explanation

The benefit of using `log2(x)` over `log(x)/log(2)`
is that the latter is not as efficient under finite precision
arithmetic.

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log2
>>> log2(4).evalf() == 2.0
True
>>> log2(x).diff(x)
1/(x*log(2))

```

See also

[`exp2`](#sympy.codegen.cfunctions.exp2 "sympy.codegen.cfunctions.exp2"), [`log10`](#sympy.codegen.cfunctions.log10 "sympy.codegen.cfunctions.log10")

fdiff(*argindex=1*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cfunctions.py#L253-L260)[Â¶](#sympy.codegen.cfunctions.log2.fdiff "Link to this definition")

Returns the first derivative of this function.

## C specific AST nodes (sympy.codegen.cnodes)[Â¶](#module-sympy.codegen.cnodes "Link to this heading")

AST nodes specific to the C family of languages

*class* sympy.codegen.cnodes.CommaOperator(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L40-L43)[Â¶](#sympy.codegen.cnodes.CommaOperator "Link to this definition")

Represents the comma operator in C

*class* sympy.codegen.cnodes.Label(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L46-L70)[Â¶](#sympy.codegen.cnodes.Label "Link to this definition")

Label for use with e.g. goto statement.

Examples

```
>>> from sympy import ccode, Symbol
>>> from sympy.codegen.cnodes import Label, PreIncrement
>>> print(ccode(Label('foo')))
foo:
>>> print(ccode(Label('bar', [PreIncrement(Symbol('a'))])))
bar:
++(a);

```

*class* sympy.codegen.cnodes.PostDecrement(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L95-L108)[Â¶](#sympy.codegen.cnodes.PostDecrement "Link to this definition")

Represents the post-decrement operator

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PostDecrement
>>> from sympy import ccode
>>> ccode(PostDecrement(x))
'(x)--'

```

*class* sympy.codegen.cnodes.PostIncrement(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L127-L140)[Â¶](#sympy.codegen.cnodes.PostIncrement "Link to this definition")

Represents the post-increment operator

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PostIncrement
>>> from sympy import ccode
>>> ccode(PostIncrement(x))
'(x)++'

```

*class* sympy.codegen.cnodes.PreDecrement(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L79-L92)[Â¶](#sympy.codegen.cnodes.PreDecrement "Link to this definition")

Represents the pre-decrement operator

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PreDecrement
>>> from sympy import ccode
>>> ccode(PreDecrement(x))
'--(x)'

```

*class* sympy.codegen.cnodes.PreIncrement(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L111-L124)[Â¶](#sympy.codegen.cnodes.PreIncrement "Link to this definition")

Represents the pre-increment operator

Examples

```
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PreIncrement
>>> from sympy import ccode
>>> ccode(PreIncrement(x))
'++(x)'

```

sympy.codegen.cnodes.alignof(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L20-L22)[Â¶](#sympy.codegen.cnodes.alignof "Link to this definition")

Generate of FunctionCall instance for calling â€˜alignofâ€™

*class* sympy.codegen.cnodes.goto(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L73-L76)[Â¶](#sympy.codegen.cnodes.goto "Link to this definition")

Represents goto in C

sympy.codegen.cnodes.sizeof(*arg*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L25-L37)[Â¶](#sympy.codegen.cnodes.sizeof "Link to this definition")

Generate of FunctionCall instance for calling â€˜sizeofâ€™

Examples

```
>>> from sympy.codegen.ast import real
>>> from sympy.codegen.cnodes import sizeof
>>> from sympy import ccode
>>> ccode(sizeof(real))
'sizeof(double)'

```

*class* sympy.codegen.cnodes.struct(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L143-L151)[Â¶](#sympy.codegen.cnodes.struct "Link to this definition")

Represents a struct in C

*class* sympy.codegen.cnodes.union(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cnodes.py#L154-L156)[Â¶](#sympy.codegen.cnodes.union "Link to this definition")

Represents a union in C

## C++ specific AST nodes (sympy.codegen.cxxnodes)[Â¶](#module-sympy.codegen.cxxnodes "Link to this heading")

AST nodes specific to C++.

*class* sympy.codegen.cxxnodes.using(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cxxnodes.py#L7-L12)[Â¶](#sympy.codegen.cxxnodes.using "Link to this definition")

Represents a â€˜usingâ€™ statement in C++

## Fortran specific AST nodes (sympy.codegen.fnodes)[Â¶](#module-sympy.codegen.fnodes "Link to this heading")

AST nodes specific to Fortran.

The functions defined in this module allows the user to express functions such as `dsign`
as a SymPy function for symbolic manipulation.

*class* sympy.codegen.fnodes.ArrayConstructor(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L218-L234)[Â¶](#sympy.codegen.fnodes.ArrayConstructor "Link to this definition")

Represents an array constructor.

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import ArrayConstructor
>>> ac = ArrayConstructor([1, 2, 3])
>>> fcode(ac, standard=95, source_format='free')
'(/1, 2, 3/)'
>>> fcode(ac, standard=2003, source_format='free')
'[1, 2, 3]'

```

*class* sympy.codegen.fnodes.Do(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L181-L215)[Â¶](#sympy.codegen.fnodes.Do "Link to this definition")

Represents a Do loop in in Fortran.

Examples

```
>>> from sympy import fcode, symbols
>>> from sympy.codegen.ast import aug_assign, Print
>>> from sympy.codegen.fnodes import Do
>>> i, n = symbols('i n', integer=True)
>>> r = symbols('r', real=True)
>>> body = [aug_assign(r, '+', 1/i), Print([i, r])]
>>> do1 = Do(body, i, 1, n)
>>> print(fcode(do1, source_format='free'))
do i = 1, n
    r = r + 1d0/i
    print *, i, r
end do
>>> do2 = Do(body, i, 1, n, 2)
>>> print(fcode(do2, source_format='free'))
do i = 1, n, 2
    r = r + 1d0/i
    print *, i, r
end do

```

*class* sympy.codegen.fnodes.Extent(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L261-L292)[Â¶](#sympy.codegen.fnodes.Extent "Link to this definition")

Represents a dimension extent.

Examples

```
>>> from sympy.codegen.fnodes import Extent
>>> e = Extent(-3, 3)  # -3, -2, -1, 0, 1, 2, 3
>>> from sympy import fcode
>>> fcode(e, source_format='free')
'-3:3'
>>> from sympy.codegen.ast import Variable, real
>>> from sympy.codegen.fnodes import dimension, intent_out
>>> dim = dimension(e, e)
>>> arr = Variable('x', real, attrs=[dim, intent_out])
>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)
'real*8, dimension(-3:3, -3:3), intent(out) :: x'

```

*class* sympy.codegen.fnodes.FortranReturn(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L556-L579)[Â¶](#sympy.codegen.fnodes.FortranReturn "Link to this definition")

AST node explicitly mapped to a fortran â€œreturnâ€.

Explanation

Because a return statement in fortran is different from C, and
in order to aid reuse of our codegen ASTs the ordinary
`.codegen.ast.Return` is interpreted as assignment to
the result variable of the function. If one for some reason needs
to generate a fortran RETURN statement, this node should be used.

Examples

```
>>> from sympy.codegen.fnodes import FortranReturn
>>> from sympy import fcode
>>> fcode(FortranReturn('x'))
'       return x'

```

*class* sympy.codegen.fnodes.GoTo(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L537-L553)[Â¶](#sympy.codegen.fnodes.GoTo "Link to this definition")

Represents a goto statement in Fortran

Examples

```
>>> from sympy.codegen.fnodes import GoTo
>>> go = GoTo([10, 20, 30], 'i')
>>> from sympy import fcode
>>> fcode(go, source_format='free')
'go to (10, 20, 30), i'

```

*class* sympy.codegen.fnodes.ImpliedDoLoop(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L237-L258)[Â¶](#sympy.codegen.fnodes.ImpliedDoLoop "Link to this definition")

Represents an implied do loop in Fortran.

Examples

```
>>> from sympy import Symbol, fcode
>>> from sympy.codegen.fnodes import ImpliedDoLoop, ArrayConstructor
>>> i = Symbol('i', integer=True)
>>> idl = ImpliedDoLoop(i**3, i, -3, 3, 2)  # -27, -1, 1, 27
>>> ac = ArrayConstructor([-28, idl, 28]) # -28, -27, -1, 1, 27, 28
>>> fcode(ac, standard=2003, source_format='free')
'[-28, (i**3, i = -3, 3, 2), 28]'

```

*class* sympy.codegen.fnodes.Module(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L103-L130)[Â¶](#sympy.codegen.fnodes.Module "Link to this definition")

Represents a module in Fortran.

Examples

```
>>> from sympy.codegen.fnodes import Module
>>> from sympy import fcode
>>> print(fcode(Module('signallib', ['implicit none'], []), source_format='free'))
module signallib
implicit none

contains

end module

```

*class* sympy.codegen.fnodes.Program(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L33-L51)[Â¶](#sympy.codegen.fnodes.Program "Link to this definition")

Represents a â€˜programâ€™ block in Fortran.

Examples

```
>>> from sympy.codegen.ast import Print
>>> from sympy.codegen.fnodes import Program
>>> prog = Program('myprogram', [Print([42])])
>>> from sympy import fcode
>>> print(fcode(prog, source_format='free'))
program myprogram
    print *, 42
end program

```

*class* sympy.codegen.fnodes.Subroutine(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L133-L162)[Â¶](#sympy.codegen.fnodes.Subroutine "Link to this definition")

Represents a subroutine in Fortran.

Examples

```
>>> from sympy import fcode, symbols
>>> from sympy.codegen.ast import Print
>>> from sympy.codegen.fnodes import Subroutine
>>> x, y = symbols('x y', real=True)
>>> sub = Subroutine('mysub', [x, y], [Print([x**2 + y**2, x*y])])
>>> print(fcode(sub, source_format='free', standard=2003))
subroutine mysub(x, y)
real*8 :: x
real*8 :: y
print *, x**2 + y**2, x*y
end subroutine

```

*class* sympy.codegen.fnodes.SubroutineCall(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L164-L178)[Â¶](#sympy.codegen.fnodes.SubroutineCall "Link to this definition")

Represents a call to a subroutine in Fortran.

Examples

```
>>> from sympy.codegen.fnodes import SubroutineCall
>>> from sympy import fcode
>>> fcode(SubroutineCall('mysub', 'x y'.split()))
'       call mysub(x, y)'

```

sympy.codegen.fnodes.allocated(*array*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L383-L396)[Â¶](#sympy.codegen.fnodes.allocated "Link to this definition")

Creates an AST node for a function call to Fortranâ€™s â€œallocated(â€¦)â€

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import allocated
>>> alloc = allocated('x')
>>> fcode(alloc, source_format='free')
'allocated(x)'

```

sympy.codegen.fnodes.array(*symbol*, *dim*, *intent=None*, *\**, *attrs=()*, *value=None*, *type=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L334-L377)[Â¶](#sympy.codegen.fnodes.array "Link to this definition")

Convenience function for creating a Variable instance for a Fortran array.

Parameters:

**symbol** : symbol

**dim** : Attribute or iterable

> If dim is an `Attribute` it need to have the name â€˜dimensionâ€™. If it is
> not an `Attribute`, then it is passed to [`dimension()`](#sympy.codegen.fnodes.dimension "sympy.codegen.fnodes.dimension") as `*dim`

**intent** : str

> One of: â€˜inâ€™, â€˜outâ€™, â€˜inoutâ€™ or None

**\*\*kwargs:**

> Keyword arguments for `Variable` (â€˜typeâ€™ & â€˜valueâ€™)

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.ast import integer, real
>>> from sympy.codegen.fnodes import array
>>> arr = array('a', '*', 'in', type=integer)
>>> print(fcode(arr.as_Declaration(), source_format='free', standard=2003))
integer*4, dimension(*), intent(in) :: a
>>> x = array('x', [3, ':', ':'], intent='out', type=real)
>>> print(fcode(x.as_Declaration(value=1), source_format='free', standard=2003))
real*8, dimension(3, :, :), intent(out) :: x = 1

```

sympy.codegen.fnodes.bind\_C(*name=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L508-L535)[Â¶](#sympy.codegen.fnodes.bind_C "Link to this definition")

Creates an Attribute `bind_C` with a name.

Parameters:

**name** : str

Examples

```
>>> from sympy import fcode, Symbol
>>> from sympy.codegen.ast import FunctionDefinition, real, Return
>>> from sympy.codegen.fnodes import array, sum_, bind_C
>>> a = Symbol('a', real=True)
>>> s = Symbol('s', integer=True)
>>> arr = array(a, dim=[s], intent='in')
>>> body = [Return((sum_(a**2)/s)**.5)]
>>> fd = FunctionDefinition(real, 'rms', [arr, s], body, attrs=[bind_C('rms')])
>>> print(fcode(fd, source_format='free', standard=2003))
real*8 function rms(a, s) bind(C, name="rms")
real*8, dimension(s), intent(in) :: a
integer*4 :: s
rms = sqrt(sum(a**2)/s)
end function

```

*class* sympy.codegen.fnodes.cmplx(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L607-L609)[Â¶](#sympy.codegen.fnodes.cmplx "Link to this definition")

Fortran complex conversion function.

sympy.codegen.fnodes.dimension(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L297-L329)[Â¶](#sympy.codegen.fnodes.dimension "Link to this definition")

Creates a â€˜dimensionâ€™ Attribute with (up to 7) extents.

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import dimension, intent_in
>>> dim = dimension('2', ':')  # 2 rows, runtime determined number of columns
>>> from sympy.codegen.ast import Variable, integer
>>> arr = Variable('a', integer, attrs=[dim, intent_in])
>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)
'integer*4, dimension(2, :), intent(in) :: a'

```

*class* sympy.codegen.fnodes.dsign(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L602-L604)[Â¶](#sympy.codegen.fnodes.dsign "Link to this definition")

Fortran sign intrinsic for double precision arguments.

*class* sympy.codegen.fnodes.isign(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L597-L599)[Â¶](#sympy.codegen.fnodes.isign "Link to this definition")

Fortran sign intrinsic for integer arguments.

*class* sympy.codegen.fnodes.kind(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L612-L614)[Â¶](#sympy.codegen.fnodes.kind "Link to this definition")

Fortran kind function.

sympy.codegen.fnodes.lbound(*array*, *dim=None*, *kind=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L399-L424)[Â¶](#sympy.codegen.fnodes.lbound "Link to this definition")

Creates an AST node for a function call to Fortranâ€™s â€œlbound(â€¦)â€

Parameters:

**array** : Symbol or String

**dim** : expr

**kind** : expr

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import lbound
>>> lb = lbound('arr', dim=2)
>>> fcode(lb, source_format='free')
'lbound(arr, 2)'

```

*class* sympy.codegen.fnodes.literal\_dp(*num*, *dps=None*, *precision=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L640-L643)[Â¶](#sympy.codegen.fnodes.literal_dp "Link to this definition")

Fortran double precision real literal

*class* sympy.codegen.fnodes.literal\_sp(*num*, *dps=None*, *precision=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L634-L637)[Â¶](#sympy.codegen.fnodes.literal_sp "Link to this definition")

Fortran single precision real literal

*class* sympy.codegen.fnodes.merge(*\*args*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L617-L619)[Â¶](#sympy.codegen.fnodes.merge "Link to this definition")

Fortran merge function

sympy.codegen.fnodes.reshape(*source*, *shape*, *pad=None*, *order=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L490-L505)[Â¶](#sympy.codegen.fnodes.reshape "Link to this definition")

Creates an AST node for a function call to Fortranâ€™s â€œreshape(â€¦)â€

Parameters:

**source** : Symbol or String

**shape** : ArrayExpr

sympy.codegen.fnodes.shape(*source*, *kind=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L436-L459)[Â¶](#sympy.codegen.fnodes.shape "Link to this definition")

Creates an AST node for a function call to Fortranâ€™s â€œshape(â€¦)â€

Parameters:

**source** : Symbol or String

**kind** : expr

Examples

```
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import shape
>>> shp = shape('x')
>>> fcode(shp, source_format='free')
'shape(x)'

```

sympy.codegen.fnodes.size(*array*, *dim=None*, *kind=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L462-L487)[Â¶](#sympy.codegen.fnodes.size "Link to this definition")

Creates an AST node for a function call to Fortranâ€™s â€œsize(â€¦)â€

Examples

```
>>> from sympy import fcode, Symbol
>>> from sympy.codegen.ast import FunctionDefinition, real, Return
>>> from sympy.codegen.fnodes import array, sum_, size
>>> a = Symbol('a', real=True)
>>> body = [Return((sum_(a**2)/size(a))**.5)]
>>> arr = array(a, dim=[':'], intent='in')
>>> fd = FunctionDefinition(real, 'rms', [arr], body)
>>> print(fcode(fd, source_format='free', standard=2003))
real*8 function rms(a)
real*8, dimension(:), intent(in) :: a
rms = sqrt(sum(a**2)*1d0/size(a))
end function

```

*class* sympy.codegen.fnodes.use(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L80-L100)[Â¶](#sympy.codegen.fnodes.use "Link to this definition")

Represents a use statement in Fortran.

Examples

```
>>> from sympy.codegen.fnodes import use
>>> from sympy import fcode
>>> fcode(use('signallib'), source_format='free')
'use signallib'
>>> fcode(use('signallib', [('metric', 'snr')]), source_format='free')
'use signallib, metric => snr'
>>> fcode(use('signallib', only=['snr', 'convolution2d']), source_format='free')
'use signallib, only: snr, convolution2d'

```

*class* sympy.codegen.fnodes.use\_rename(*\*args*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/fnodes.py#L54-L72)[Â¶](#sympy.codegen.fnodes.use_rename "Link to this definition")

Represents a renaming in a use statement in Fortran.

Examples

```
>>> from sympy.codegen.fnodes import use_rename, use
>>> from sympy import fcode
>>> ren = use_rename("thingy", "convolution2d")
>>> print(fcode(ren, source_format='free'))
thingy => convolution2d
>>> full = use('signallib', only=['snr', ren])
>>> print(fcode(full, source_format='free'))
use signallib, only: snr, thingy => convolution2d

```

## Algorithms (sympy.codegen.algorithms)[Â¶](#module-sympy.codegen.algorithms "Link to this heading")

sympy.codegen.algorithms.newtons\_method(*expr*, *wrt*, *atol=1e-12*, *delta=None*, *\**, *rtol=4e-16*, *debug=False*, *itermax=None*, *counter=None*, *delta\_fn=<function <lambda>>*, *cse=False*, *handle\_nan=None*, *bounds=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/algorithms.py#L16-L112)[Â¶](#sympy.codegen.algorithms.newtons_method "Link to this definition")

Generates an AST for Newton-Raphson method (a root-finding algorithm).

Parameters:

**expr** : expression

**wrt** : Symbol

> With respect to, i.e. what is the variable.

**atol** : number or expression

> Absolute tolerance (stopping criterion)

**rtol** : number or expression

> Relative tolerance (stopping criterion)

**delta** : Symbol

> Will be a `Dummy` if `None`.

**debug** : bool

> Whether to print convergence information during iterations

**itermax** : number or expr

> Maximum number of iterations.

**counter** : Symbol

> Will be a `Dummy` if `None`.

**delta\_fn: Callable[[Expr, Symbol], Expr]**

> computes the step, default is newtons method. For e.g. Halleyâ€™s method
> use delta\_fn=lambda e, x: -2\*e\*e.diff(x)/(2\*e.diff(x)\*\*2 - e\*e.diff(x, 2))

**cse: bool**

> Perform common sub-expression elimination on delta expression

**handle\_nan: Token**

> How to handle occurrence of not-a-number (NaN).

**bounds: Optional[tuple[Expr, Expr]]**

> Perform optimization within bounds

Explanation

Returns an abstract syntax tree (AST) based on `sympy.codegen.ast` for Netwonâ€™s
method of root-finding.

Examples

```
>>> from sympy import symbols, cos
>>> from sympy.codegen.ast import Assignment
>>> from sympy.codegen.algorithms import newtons_method
>>> x, dx, atol = symbols('x dx atol')
>>> expr = cos(x) - x**3
>>> algo = newtons_method(expr, x, atol=atol, delta=dx)
>>> algo.has(Assignment(dx, -expr/expr.diff(x)))
True

```

References

[[R40](#id3)]

<https://en.wikipedia.org/wiki/Newton%27s_method>

sympy.codegen.algorithms.newtons\_method\_function(*expr*, *wrt*, *params=None*, *func\_name='newton'*, *attrs=()*, *\**, *delta=None*, *\*\*kwargs*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/algorithms.py#L123-L180)[Â¶](#sympy.codegen.algorithms.newtons_method_function "Link to this definition")

Generates an AST for a function implementing the Newton-Raphson method.

Parameters:

**expr** : expression

**wrt** : Symbol

> With respect to, i.e. what is the variable

**params** : iterable of symbols

> Symbols appearing in expr that are taken as constants during the iterations
> (these will be accepted as parameters to the generated function).

**func\_name** : str

> Name of the generated function.

**attrs** : Tuple

> Attribute instances passed as `attrs` to `FunctionDefinition`.

**\*\*kwargs :**

> Keyword arguments passed to [`sympy.codegen.algorithms.newtons_method()`](#sympy.codegen.algorithms.newtons_method "sympy.codegen.algorithms.newtons_method").

Examples

```
>>> from sympy import symbols, cos
>>> from sympy.codegen.algorithms import newtons_method_function
>>> from sympy.codegen.pyutils import render_as_module
>>> x = symbols('x')
>>> expr = cos(x) - x**3
>>> func = newtons_method_function(expr, x)
>>> py_mod = render_as_module(func)  # source code as string
>>> namespace = {}
>>> exec(py_mod, namespace, namespace)
>>> res = eval('newton(0.5)', namespace)
>>> abs(res - 0.865474033102) < 1e-12
True

```

See also

[`sympy.codegen.algorithms.newtons_method`](#sympy.codegen.algorithms.newtons_method "sympy.codegen.algorithms.newtons_method")

## Python utilities (sympy.codegen.pyutils)[Â¶](#module-sympy.codegen.pyutils "Link to this heading")

sympy.codegen.pyutils.render\_as\_module(*content*, *standard='python3'*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/pyutils.py#L6-L24)[Â¶](#sympy.codegen.pyutils.render_as_module "Link to this definition")

Renders Python code as a module (with the required imports).

Parameters:

**standard :**

> See the parameter `standard` in
> [`sympy.printing.pycode.pycode()`](printing.html#sympy.printing.pycode.pycode "sympy.printing.pycode.pycode")

## C utilities (sympy.codegen.cutils)[Â¶](#module-sympy.codegen.cutils "Link to this heading")

sympy.codegen.cutils.render\_as\_source\_file(*content*, *Printer=<class 'sympy.printing.c.C99CodePrinter'>*, *settings=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/cutils.py#L3-L8)[Â¶](#sympy.codegen.cutils.render_as_source_file "Link to this definition")

Renders a C source file (with required #include statements)

## Fortran utilities (sympy.codegen.futils)[Â¶](#module-sympy.codegen.futils "Link to this heading")

sympy.codegen.futils.render\_as\_module(*definitions*, *name*, *declarations=()*, *printer\_settings=None*)[[source]](https://github.com/sympy/sympy/blob/b4ce69ad5d40e4e545614b6c76ca9b0be0b98f0b/sympy/codegen/futils.py#L9-L40)[Â¶](#sympy.codegen.futils.render_as_module "Link to this definition")

Creates a `Module` instance and renders it as a string.

This generates Fortran source code for a module with the correct `use` statements.

Parameters:

**definitions** : iterable

> Passed to [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module").

**name** : str

> Passed to [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module").

**declarations** : iterable

> Passed to [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module"). It will be extended with
> use statements, â€˜implicit noneâ€™ and public list generated from `definitions`.

**printer\_settings** : dict

> Passed to `FCodePrinter` (default: `{'standard': 2003, 'source_format': 'free'}`).

[Next

Logic](../reference/public/logic/index.html)
[Previous

Code Generation](../reference/public/codegeneration/index.html)

Copyright Â© 2024 SymPy Development Team

Made with [Sphinx](https://www.sphinx-doc.org/) and [@pradyunsg](https://pradyunsg.me)'s
[Furo](https://github.com/pradyunsg/furo)
Last updated on Sep 18, 2024

On this page

* Code Generation
  + [Introduction](#introduction)
  + [Code printers (sympy.printing)](#code-printers-sympy-printing)
  + [Codegen (sympy.utilities.codegen)](#codegen-sympy-utilities-codegen)
  + [Autowrap](#autowrap)
  + [Classes and functions for rewriting expressions (sympy.codegen.rewriting)](#module-sympy.codegen.rewriting)
    - [`FuncMinusOneOptim`](#sympy.codegen.rewriting.FuncMinusOneOptim)
      * [`FuncMinusOneOptim.replace_in_Add()`](#sympy.codegen.rewriting.FuncMinusOneOptim.replace_in_Add)
    - [`Optimization`](#sympy.codegen.rewriting.Optimization)
    - [`ReplaceOptim`](#sympy.codegen.rewriting.ReplaceOptim)
    - [`create_expand_pow_optimization()`](#sympy.codegen.rewriting.create_expand_pow_optimization)
    - [`optimize()`](#sympy.codegen.rewriting.optimize)
    - [`MatrixSolve`](#sympy.codegen.matrix_nodes.MatrixSolve)
  + [Tools for simplifying expressions using approximations (sympy.codegen.approximations)](#module-sympy.codegen.approximations)
    - [`SeriesApprox`](#sympy.codegen.approximations.SeriesApprox)
    - [`SumApprox`](#sympy.codegen.approximations.SumApprox)
  + [Classes for abstract syntax trees (sympy.codegen.ast)](#module-sympy.codegen.ast)
    - [AST Type Tree](#ast-type-tree)
    - [Predefined types](#predefined-types)
    - [Using the nodes](#using-the-nodes)
    - [`Assignment`](#sympy.codegen.ast.Assignment)
    - [`AssignmentBase`](#sympy.codegen.ast.AssignmentBase)
    - [`Attribute`](#sympy.codegen.ast.Attribute)
    - [`AugmentedAssignment`](#sympy.codegen.ast.AugmentedAssignment)
    - [`BreakToken`](#sympy.codegen.ast.BreakToken)
    - [`CodeBlock`](#sympy.codegen.ast.CodeBlock)
      * [`CodeBlock.cse()`](#sympy.codegen.ast.CodeBlock.cse)
      * [`CodeBlock.topological_sort()`](#sympy.codegen.ast.CodeBlock.topological_sort)
    - [`Comment`](#sympy.codegen.ast.Comment)
    - [`ComplexType`](#sympy.codegen.ast.ComplexType)
    - [`ContinueToken`](#sympy.codegen.ast.ContinueToken)
    - [`Declaration`](#sympy.codegen.ast.Declaration)
    - [`Element`](#sympy.codegen.ast.Element)
    - [`FloatBaseType`](#sympy.codegen.ast.FloatBaseType)
      * [`FloatBaseType.cast_nocheck`](#sympy.codegen.ast.FloatBaseType.cast_nocheck)
    - [`FloatType`](#sympy.codegen.ast.FloatType)
      * [`FloatType.cast_nocheck()`](#sympy.codegen.ast.FloatType.cast_nocheck)
      * [`FloatType.decimal_dig`](#sympy.codegen.ast.FloatType.decimal_dig)
      * [`FloatType.dig`](#sympy.codegen.ast.FloatType.dig)
      * [`FloatType.eps`](#sympy.codegen.ast.FloatType.eps)
      * [`FloatType.max`](#sympy.codegen.ast.FloatType.max)
      * [`FloatType.max_exponent`](#sympy.codegen.ast.FloatType.max_exponent)
      * [`FloatType.min_exponent`](#sympy.codegen.ast.FloatType.min_exponent)
      * [`FloatType.tiny`](#sympy.codegen.ast.FloatType.tiny)
    - [`For`](#sympy.codegen.ast.For)
    - [`FunctionCall`](#sympy.codegen.ast.FunctionCall)
    - [`FunctionDefinition`](#sympy.codegen.ast.FunctionDefinition)
    - [`FunctionPrototype`](#sympy.codegen.ast.FunctionPrototype)
    - [`IntBaseType`](#sympy.codegen.ast.IntBaseType)
    - [`Node`](#sympy.codegen.ast.Node)
      * [`Node.attr_params()`](#sympy.codegen.ast.Node.attr_params)
    - [`NoneToken`](#sympy.codegen.ast.NoneToken)
    - [`Pointer`](#sympy.codegen.ast.Pointer)
    - [`Print`](#sympy.codegen.ast.Print)
    - [`QuotedString`](#sympy.codegen.ast.QuotedString)
    - [`Raise`](#sympy.codegen.ast.Raise)
    - [`Return`](#sympy.codegen.ast.Return)
    - [`RuntimeError_`](#sympy.codegen.ast.RuntimeError_)
    - [`Scope`](#sympy.codegen.ast.Scope)
    - [`SignedIntType`](#sympy.codegen.ast.SignedIntType)
    - [`Stream`](#sympy.codegen.ast.Stream)
    - [`String`](#sympy.codegen.ast.String)
    - [`Token`](#sympy.codegen.ast.Token)
      * [`Token.kwargs()`](#sympy.codegen.ast.Token.kwargs)
    - [`Type`](#sympy.codegen.ast.Type)
      * [`Type.cast_check()`](#sympy.codegen.ast.Type.cast_check)
      * [`Type.from_expr()`](#sympy.codegen.ast.Type.from_expr)
    - [`UnsignedIntType`](#sympy.codegen.ast.UnsignedIntType)
    - [`Variable`](#sympy.codegen.ast.Variable)
      * [`Variable.as_Declaration()`](#sympy.codegen.ast.Variable.as_Declaration)
      * [`Variable.deduced()`](#sympy.codegen.ast.Variable.deduced)
    - [`While`](#sympy.codegen.ast.While)
    - [`aug_assign()`](#sympy.codegen.ast.aug_assign)
  + [Special C math functions (sympy.codegen.cfunctions)](#module-sympy.codegen.cfunctions)
    - [`Cbrt`](#sympy.codegen.cfunctions.Cbrt)
      * [`Cbrt.fdiff()`](#sympy.codegen.cfunctions.Cbrt.fdiff)
    - [`Sqrt`](#sympy.codegen.cfunctions.Sqrt)
      * [`Sqrt.fdiff()`](#sympy.codegen.cfunctions.Sqrt.fdiff)
    - [`exp2`](#sympy.codegen.cfunctions.exp2)
      * [`exp2.fdiff()`](#sympy.codegen.cfunctions.exp2.fdiff)
    - [`expm1`](#sympy.codegen.cfunctions.expm1)
      * [`expm1.fdiff()`](#sympy.codegen.cfunctions.expm1.fdiff)
    - [`fma`](#sympy.codegen.cfunctions.fma)
      * [`fma.fdiff()`](#sympy.codegen.cfunctions.fma.fdiff)
    - [`hypot`](#sympy.codegen.cfunctions.hypot)
      * [`hypot.fdiff()`](#sympy.codegen.cfunctions.hypot.fdiff)
    - [`log10`](#sympy.codegen.cfunctions.log10)
      * [`log10.fdiff()`](#sympy.codegen.cfunctions.log10.fdiff)
    - [`log1p`](#sympy.codegen.cfunctions.log1p)
      * [`log1p.fdiff()`](#sympy.codegen.cfunctions.log1p.fdiff)
    - [`log2`](#sympy.codegen.cfunctions.log2)
      * [`log2.fdiff()`](#sympy.codegen.cfunctions.log2.fdiff)
  + [C specific AST nodes (sympy.codegen.cnodes)](#module-sympy.codegen.cnodes)
    - [`CommaOperator`](#sympy.codegen.cnodes.CommaOperator)
    - [`Label`](#sympy.codegen.cnodes.Label)
    - [`PostDecrement`](#sympy.codegen.cnodes.PostDecrement)
    - [`PostIncrement`](#sympy.codegen.cnodes.PostIncrement)
    - [`PreDecrement`](#sympy.codegen.cnodes.PreDecrement)
    - [`PreIncrement`](#sympy.codegen.cnodes.PreIncrement)
    - [`alignof()`](#sympy.codegen.cnodes.alignof)
    - [`goto`](#sympy.codegen.cnodes.goto)
    - [`sizeof()`](#sympy.codegen.cnodes.sizeof)
    - [`struct`](#sympy.codegen.cnodes.struct)
    - [`union`](#sympy.codegen.cnodes.union)
  + [C++ specific AST nodes (sympy.codegen.cxxnodes)](#module-sympy.codegen.cxxnodes)
    - [`using`](#sympy.codegen.cxxnodes.using)
  + [Fortran specific AST nodes (sympy.codegen.fnodes)](#module-sympy.codegen.fnodes)
    - [`ArrayConstructor`](#sympy.codegen.fnodes.ArrayConstructor)
    - [`Do`](#sympy.codegen.fnodes.Do)
    - [`Extent`](#sympy.codegen.fnodes.Extent)
    - [`FortranReturn`](#sympy.codegen.fnodes.FortranReturn)
    - [`GoTo`](#sympy.codegen.fnodes.GoTo)
    - [`ImpliedDoLoop`](#sympy.codegen.fnodes.ImpliedDoLoop)
    - [`Module`](#sympy.codegen.fnodes.Module)
    - [`Program`](#sympy.codegen.fnodes.Program)
    - [`Subroutine`](#sympy.codegen.fnodes.Subroutine)
    - [`SubroutineCall`](#sympy.codegen.fnodes.SubroutineCall)
    - [`allocated()`](#sympy.codegen.fnodes.allocated)
    - [`array()`](#sympy.codegen.fnodes.array)
    - [`bind_C()`](#sympy.codegen.fnodes.bind_C)
    - [`cmplx`](#sympy.codegen.fnodes.cmplx)
    - [`dimension()`](#sympy.codegen.fnodes.dimension)
    - [`dsign`](#sympy.codegen.fnodes.dsign)
    - [`isign`](#sympy.codegen.fnodes.isign)
    - [`kind`](#sympy.codegen.fnodes.kind)
    - [`lbound()`](#sympy.codegen.fnodes.lbound)
    - [`literal_dp`](#sympy.codegen.fnodes.literal_dp)
    - [`literal_sp`](#sympy.codegen.fnodes.literal_sp)
    - [`merge`](#sympy.codegen.fnodes.merge)
    - [`reshape()`](#sympy.codegen.fnodes.reshape)
    - [`shape()`](#sympy.codegen.fnodes.shape)
    - [`size()`](#sympy.codegen.fnodes.size)
    - [`use`](#sympy.codegen.fnodes.use)
    - [`use_rename`](#sympy.codegen.fnodes.use_rename)
  + [Algorithms (sympy.codegen.algorithms)](#module-sympy.codegen.algorithms)
    - [`newtons_method()`](#sympy.codegen.algorithms.newtons_method)
    - [`newtons_method_function()`](#sympy.codegen.algorithms.newtons_method_function)
  + [Python utilities (sympy.codegen.pyutils)](#module-sympy.codegen.pyutils)
    - [`render_as_module()`](#sympy.codegen.pyutils.render_as_module)
  + [C utilities (sympy.codegen.cutils)](#module-sympy.codegen.cutils)
    - [`render_as_source_file()`](#sympy.codegen.cutils.render_as_source_file)
  + [Fortran utilities (sympy.codegen.futils)](#module-sympy.codegen.futils)
    - [`render_as_module()`](#sympy.codegen.futils.render_as_module)


