
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2Fefd36709306a9afcca5b4782499d01be0c7a02a5%2Ftee%2Ftee%2Ftee_svc_cryp.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2Fefd36709306a9afcca5b4782499d01be0c7a02a5%2Ftee%2Ftee%2Ftee_svc_cryp.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   53](/login?return_to=%2FSamsung%2FmTower)

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

## Files

 efd3670
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5)
2. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee)
3. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/tee)
/
# tee\_svc\_cryp.c

 Blame  Blame
## Latest commit

## History

[History](/Samsung/mTower/commits/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/tee/tee_svc_cryp.c)3473 lines (3247 loc) · 91.1 KB efd3670
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5)
2. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee)
3. /[tee](/Samsung/mTower/tree/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/tee)
/
# tee\_svc\_cryp.c

Top
## File metadata and controls

* Code
* Blame

3473 lines (3247 loc) · 91.1 KB[Raw](https://github.com/Samsung/mTower/raw/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/tee/tee_svc_cryp.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// SPDX-License-Identifier: BSD-2-Clause/\* \* Copyright (c) 2014, STMicroelectronics International N.V. \* All rights reserved. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions are met: \* \* 1. Redistributions of source code must retain the above copyright notice, \* this list of conditions and the following disclaimer. \* \* 2. Redistributions in binary form must reproduce the above copyright notice, \* this list of conditions and the following disclaimer in the documentation \* and/or other materials provided with the distribution. \* \* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" \* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \* POSSIBILITY OF SUCH DAMAGE. \*/
#include <assert.h>#include <crypto/crypto.h>#include <kernel/tee\_ta\_manager.h>//#include <mm/tee\_mmu.h>//#include <string\_ext.h>#include <string.h>#include <sys/queue.h>#include <tee\_api\_types.h>#include <tee/tee\_cryp\_utl.h>#include <tee/tee\_obj.h>#include <tee/tee\_svc\_cryp.h>#include <tee/tee\_svc.h>#include <trace.h>#include <utee\_defines.h>#include <util.h>#include <kernel/user\_ta.h>
#if defined(CFG\_CRYPTO\_HKDF) || defined(CFG\_CRYPTO\_CONCAT\_KDF) || \ defined(CFG\_CRYPTO\_PBKDF2)#include <tee\_api\_defines\_extensions.h>#endif#if defined(CFG\_CRYPTO\_HKDF)#include <tee/tee\_cryp\_hkdf.h>#endif#if defined(CFG\_CRYPTO\_CONCAT\_KDF)#include <tee/tee\_cryp\_concat\_kdf.h>#endif#if defined(CFG\_CRYPTO\_PBKDF2)#include <tee/tee\_cryp\_pbkdf2.h>#endif
typedef void (\*tee\_cryp\_ctx\_finalize\_func\_t) (void \*ctx, uint32\_t algo);struct tee\_cryp\_state { TAILQ\_ENTRY(tee\_cryp\_state) link; uint32\_t algo; uint32\_t mode; vaddr\_t key1; vaddr\_t key2; void \*ctx; tee\_cryp\_ctx\_finalize\_func\_t ctx\_finalize;};
struct tee\_cryp\_obj\_secret { uint32\_t key\_size; uint32\_t alloc\_size;
 /\* \* Pseudo code visualize layout of structure \* Next follows data, such as: \* uint8\_t data[alloc\_size] \* key\_size must never exceed alloc\_size \*/};
#define TEE\_TYPE\_ATTR\_OPTIONAL 0x0#define TEE\_TYPE\_ATTR\_REQUIRED 0x1#define TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP 0x2#define TEE\_TYPE\_ATTR\_SIZE\_INDICATOR 0x4#define TEE\_TYPE\_ATTR\_GEN\_KEY\_OPT 0x8#define TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ 0x10
 /\* Handle storing of generic secret keys of varying lengths \*/#define ATTR\_OPS\_INDEX\_SECRET 0 /\* Convert to/from big-endian byte array and provider-specific bignum \*/#define ATTR\_OPS\_INDEX\_BIGNUM 1 /\* Convert to/from value attribute depending on direction \*/#define ATTR\_OPS\_INDEX\_VALUE 2
struct tee\_cryp\_obj\_type\_attrs { uint32\_t attr\_id; uint16\_t flags; uint16\_t ops\_index; uint16\_t raw\_offs; uint16\_t raw\_size;};
#define RAW\_DATA(\_x, \_y) \ .raw\_offs = offsetof(\_x, \_y), .raw\_size = MEMBER\_SIZE(\_x, \_y)
static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_secret\_value\_attrs[] = { { .attr\_id = TEE\_ATTR\_SECRET\_VALUE, .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR, .ops\_index = ATTR\_OPS\_INDEX\_SECRET, .raw\_offs = 0, .raw\_size = 0 },};
//static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_rsa\_pub\_key\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_RSA\_MODULUS,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_public\_key, n)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_PUBLIC\_EXPONENT,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_public\_key, e)// },//};////static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_rsa\_keypair\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_RSA\_MODULUS,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, n)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_PUBLIC\_EXPONENT,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, e)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_PRIVATE\_EXPONENT,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, d)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_PRIME1,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, p)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_PRIME2,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, q)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_EXPONENT1,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, dp)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_EXPONENT2,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, dq)// },//// {// .attr\_id = TEE\_ATTR\_RSA\_COEFFICIENT,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct rsa\_keypair, qp)// },//};////static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_dsa\_pub\_key\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_DSA\_PRIME,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_public\_key, p)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_SUBPRIME,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_public\_key, q)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_BASE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_public\_key, g)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_PUBLIC\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_public\_key, y)// },//};////static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_dsa\_keypair\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_DSA\_PRIME,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_keypair, p)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_SUBPRIME,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR |// TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_keypair, q)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_BASE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_keypair, g)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_PRIVATE\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_keypair, x)// },//// {// .attr\_id = TEE\_ATTR\_DSA\_PUBLIC\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dsa\_keypair, y)// },//};////static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_dh\_keypair\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_DH\_PRIME,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR |// TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dh\_keypair, p)// },//// {// .attr\_id = TEE\_ATTR\_DH\_BASE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_GEN\_KEY\_REQ,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dh\_keypair, g)// },//// {// .attr\_id = TEE\_ATTR\_DH\_PUBLIC\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dh\_keypair, y)// },//// {// .attr\_id = TEE\_ATTR\_DH\_PRIVATE\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dh\_keypair, x)// },//// {// .attr\_id = TEE\_ATTR\_DH\_SUBPRIME,// .flags = TEE\_TYPE\_ATTR\_OPTIONAL\_GROUP | TEE\_TYPE\_ATTR\_GEN\_KEY\_OPT,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct dh\_keypair, q)// },//// {// .attr\_id = TEE\_ATTR\_DH\_X\_BITS,// .flags = TEE\_TYPE\_ATTR\_GEN\_KEY\_OPT,// .ops\_index = ATTR\_OPS\_INDEX\_VALUE,// RAW\_DATA(struct dh\_keypair, xbits)// },//};
#if defined(CFG\_CRYPTO\_HKDF)static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_hkdf\_ikm\_attrs[] = { { .attr\_id = TEE\_ATTR\_HKDF\_IKM, .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR, .ops\_index = ATTR\_OPS\_INDEX\_SECRET, .raw\_offs = 0, .raw\_size = 0 },};#endif
#if defined(CFG\_CRYPTO\_CONCAT\_KDF)static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_concat\_kdf\_z\_attrs[] = { { .attr\_id = TEE\_ATTR\_CONCAT\_KDF\_Z, .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR, .ops\_index = ATTR\_OPS\_INDEX\_SECRET, .raw\_offs = 0, .raw\_size = 0 },};#endif
#if defined(CFG\_CRYPTO\_PBKDF2)static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_pbkdf2\_passwd\_attrs[] = { { .attr\_id = TEE\_ATTR\_PBKDF2\_PASSWORD, .flags = TEE\_TYPE\_ATTR\_REQUIRED | TEE\_TYPE\_ATTR\_SIZE\_INDICATOR, .ops\_index = ATTR\_OPS\_INDEX\_SECRET, .raw\_offs = 0, .raw\_size = 0 },};#endif
//static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_ecc\_pub\_key\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_ECC\_PUBLIC\_VALUE\_X,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct ecc\_public\_key, x)// },//// {// .attr\_id = TEE\_ATTR\_ECC\_PUBLIC\_VALUE\_Y,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct ecc\_public\_key, y)// },//// {// .attr\_id = TEE\_ATTR\_ECC\_CURVE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_VALUE,// RAW\_DATA(struct ecc\_public\_key, curve)// },//};////static const struct tee\_cryp\_obj\_type\_attrs tee\_cryp\_obj\_ecc\_keypair\_attrs[] = {// {// .attr\_id = TEE\_ATTR\_ECC\_PRIVATE\_VALUE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct ecc\_keypair, d)// },//// {// .attr\_id = TEE\_ATTR\_ECC\_PUBLIC\_VALUE\_X,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct ecc\_keypair, x)// },//// {// .attr\_id = TEE\_ATTR\_ECC\_PUBLIC\_VALUE\_Y,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_BIGNUM,// RAW\_DATA(struct ecc\_keypair, y)// },//// {// .attr\_id = TEE\_ATTR\_ECC\_CURVE,// .flags = TEE\_TYPE\_ATTR\_REQUIRED,// .ops\_index = ATTR\_OPS\_INDEX\_VALUE,// RAW\_DATA(struct ecc\_keypair, curve)// },//};
struct tee\_cryp\_obj\_type\_props { TEE\_ObjectType obj\_type; uint16\_t min\_size; /\* may not be smaller than this \*/ uint16\_t max\_size; /\* may not be larger than this \*/ uint16\_t alloc\_size; /\* this many bytes are allocated to hold data \*/ uint8\_t quanta; /\* may only be an multiple of this \*/
 uint8\_t num\_type\_attrs; const struct tee\_cryp\_obj\_type\_attrs \*type\_attrs;};
#define PROP(obj\_type, quanta, min\_size, max\_size, alloc\_size, type\_attrs) \ { (obj\_type), (min\_size), (max\_size), (alloc\_size), (quanta), \ ARRAY\_SIZE(type\_attrs), (type\_attrs) }
static const struct tee\_cryp\_obj\_type\_props tee\_cryp\_obj\_props[] = { PROP(TEE\_TYPE\_AES, 64, 128, 256, /\* valid sizes 128, 192, 256 \*/ 256 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_DES, 56, 56, 56, /\* \* Valid size 56 without parity, note that we still allocate \* for 64 bits since the key is supplied with parity. \*/ 64 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_DES3, 56, 112, 168, /\* \* Valid sizes 112, 168 without parity, note that we still \* allocate for with space for the parity since the key is \* supplied with parity. \*/ 192 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_MD5, 8, 64, 512, 512 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_SHA1, 8, 80, 512, 512 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_SHA224, 8, 112, 512, 512 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_SHA256, 8, 192, 1024, 1024 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_SHA384, 8, 256, 1024, 1024 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_HMAC\_SHA512, 8, 256, 1024, 1024 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs), PROP(TEE\_TYPE\_GENERIC\_SECRET, 8, 0, 4096, 4096 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_secret\_value\_attrs),#if defined(CFG\_CRYPTO\_HKDF) PROP(TEE\_TYPE\_HKDF\_IKM, 8, 0, 4096, 4096 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_hkdf\_ikm\_attrs),#endif#if defined(CFG\_CRYPTO\_CONCAT\_KDF) PROP(TEE\_TYPE\_CONCAT\_KDF\_Z, 8, 0, 4096, 4096 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_concat\_kdf\_z\_attrs),#endif#if defined(CFG\_CRYPTO\_PBKDF2) PROP(TEE\_TYPE\_PBKDF2\_PASSWORD, 8, 0, 4096, 4096 / 8 + sizeof(struct tee\_cryp\_obj\_secret), tee\_cryp\_obj\_pbkdf2\_passwd\_attrs),#endif// PROP(TEE\_TYPE\_RSA\_PUBLIC\_KEY, 1, 256, 2048,// sizeof(struct rsa\_public\_key),// tee\_cryp\_obj\_rsa\_pub\_key\_attrs),//// PROP(TEE\_TYPE\_RSA\_KEYPAIR, 1, 256, 2048,// sizeof(struct rsa\_keypair),// tee\_cryp\_obj\_rsa\_keypair\_attrs),//// PROP(TEE\_TYPE\_DSA\_PUBLIC\_KEY, 64, 512, 3072,// sizeof(struct dsa\_public\_key),// tee\_cryp\_obj\_dsa\_pub\_key\_attrs),//// PROP(TEE\_TYPE\_DSA\_KEYPAIR, 64, 512, 3072,// sizeof(struct dsa\_keypair),// tee\_cryp\_obj\_dsa\_keypair\_attrs),//// PROP(TEE\_TYPE\_DH\_KEYPAIR, 1, 256, 2048,// sizeof(struct dh\_keypair),// tee\_cryp\_obj\_dh\_keypair\_attrs),//// PROP(TEE\_TYPE\_ECDSA\_PUBLIC\_KEY, 1, 192, 521,// sizeof(struct ecc\_public\_key),// tee\_cryp\_obj\_ecc\_pub\_key\_attrs),//// PROP(TEE\_TYPE\_ECDSA\_KEYPAIR, 1, 192, 521,// sizeof(struct ecc\_keypair),// tee\_cryp\_obj\_ecc\_keypair\_attrs),//// PROP(TEE\_TYPE\_ECDH\_PUBLIC\_KEY, 1, 192, 521,// sizeof(struct ecc\_public\_key),// tee\_cryp\_obj\_ecc\_pub\_key\_attrs),//// PROP(TEE\_TYPE\_ECDH\_KEYPAIR, 1, 192, 521,// sizeof(struct ecc\_keypair),// tee\_cryp\_obj\_ecc\_keypair\_attrs),};
struct attr\_ops { TEE\_Result (\*from\_user)(void \*attr, const void \*buffer, size\_t size); TEE\_Result (\*to\_user)(void \*attr, struct tee\_ta\_session \*sess, void \*buffer, uint64\_t \*size); TEE\_Result (\*to\_binary)(void \*attr, void \*data, size\_t data\_len, size\_t \*offs); bool (\*from\_binary)(void \*attr, const void \*data, size\_t data\_len, size\_t \*offs); TEE\_Result (\*from\_obj)(void \*attr, void \*src\_attr); void (\*free)(void \*attr); void (\*clear)(void \*attr);};
static TEE\_Result op\_u32\_to\_binary\_helper(uint32\_t v, uint8\_t \*data, size\_t data\_len, size\_t \*offs){ uint32\_t field; size\_t next\_offs;
 if (ADD\_OVERFLOW(\*offs, sizeof(field), &next\_offs)) return TEE\_ERROR\_OVERFLOW;
 if (data && next\_offs <= data\_len) { field = TEE\_U32\_TO\_BIG\_ENDIAN(v); memcpy(data + \*offs, &field, sizeof(field)); } (\*offs) = next\_offs;
 return TEE\_SUCCESS;}
static bool op\_u32\_from\_binary\_helper(uint32\_t \*v, const uint8\_t \*data, size\_t data\_len, size\_t \*offs){ uint32\_t field;
 if (!data || (\*offs + sizeof(field)) > data\_len) return false;
 memcpy(&field, data + \*offs, sizeof(field)); \*v = TEE\_U32\_FROM\_BIG\_ENDIAN(field); (\*offs) += sizeof(field); return true;}
static TEE\_Result op\_attr\_secret\_value\_from\_user(void \*attr, const void \*buffer, size\_t size){ struct tee\_cryp\_obj\_secret \*key = attr;
 /\* Data size has to fit in allocated buffer \*/ if (size > key->alloc\_size) return TEE\_ERROR\_SECURITY; memcpy(key + 1, buffer, size); key->key\_size = size; return TEE\_SUCCESS;}
static TEE\_Result op\_attr\_secret\_value\_to\_user(void \*attr, struct tee\_ta\_session \*sess \_\_unused, void \*buffer, uint64\_t \*size){ TEE\_Result res; struct tee\_cryp\_obj\_secret \*key = attr; uint64\_t s; uint64\_t key\_size;
 res = tee\_svc\_copy\_from\_user(&s, size, sizeof(s)); if (res != TEE\_SUCCESS) return res;
 key\_size = key->key\_size; res = tee\_svc\_copy\_to\_user(size, &key\_size, sizeof(key\_size)); if (res != TEE\_SUCCESS) return res;
 if (s < key->key\_size) return TEE\_ERROR\_SHORT\_BUFFER;
 return tee\_svc\_copy\_to\_user(buffer, key + 1, key->key\_size);}
static TEE\_Result op\_attr\_secret\_value\_to\_binary(void \*attr, void \*data, size\_t data\_len, size\_t \*offs){ TEE\_Result res; struct tee\_cryp\_obj\_secret \*key = attr; size\_t next\_offs;
 res = op\_u32\_to\_binary\_helper(key->key\_size, data, data\_len, offs); if (res != TEE\_SUCCESS) return res;
 if (ADD\_OVERFLOW(\*offs, key->key\_size, &next\_offs)) return TEE\_ERROR\_OVERFLOW;
 if (data && next\_offs <= data\_len) memcpy((uint8\_t \*)data + \*offs, key + 1, key->key\_size); (\*offs) = next\_offs;
 return TEE\_SUCCESS;}
static bool op\_attr\_secret\_value\_from\_binary(void \*attr, const void \*data, size\_t data\_len, size\_t \*offs){ struct tee\_cryp\_obj\_secret \*key = attr; uint32\_t s;
 if (!op\_u32\_from\_binary\_helper(&s, data, data\_len, offs)) return false;
 if ((\*offs + s) > data\_len) return false;
 /\* Data size has to fit in allocated buffer \*/ if (s > key->alloc\_size) return false; key->key\_size = s; memcpy(key + 1, (const uint8\_t \*)data + \*offs, s); (\*offs) += s; return true;}
static TEE\_Result op\_attr\_secret\_value\_from\_obj(void \*attr, void \*src\_attr){ struct tee\_cryp\_obj\_secret \*key = attr; struct tee\_cryp\_obj\_secret \*src\_key = src\_attr;
 if (src\_key->key\_size > key->alloc\_size) return TEE\_ERROR\_BAD\_STATE; memcpy(key + 1, src\_key + 1, src\_key->key\_size); key->key\_size = src\_key->key\_size; return TEE\_SUCCESS;}
static void op\_attr\_secret\_value\_clear(void \*attr){ struct tee\_cryp\_obj\_secret \*key = attr;
 key->key\_size = 0; memset(key + 1, 0, key->alloc\_size);}
//static TEE\_Result op\_attr\_bignum\_from\_user(void \*attr, const void \*buffer,// size\_t size)//{// struct bignum \*\*bn = attr;//// return crypto\_bignum\_bin2bn(buffer, size, \*bn);//}////static TEE\_Result op\_attr\_bignum\_to\_user(void \*attr,// struct tee\_ta\_session \*sess,// void \*buffer, uint64\_t \*size)//{// TEE\_Result res;// struct bignum \*\*bn = attr;// uint64\_t req\_size;// uint64\_t s;//// res = tee\_svc\_copy\_from\_user(&s, size, sizeof(s));// if (res != TEE\_SUCCESS)// return res;//// req\_size = crypto\_bignum\_num\_bytes(\*bn);// res = tee\_svc\_copy\_to\_user(size, &req\_size, sizeof(req\_size));// if (res != TEE\_SUCCESS)// return res;// if (!req\_size)// return TEE\_SUCCESS;// if (s < req\_size)// return TEE\_ERROR\_SHORT\_BUFFER;//// /\* Check we can access data using supplied user mode pointer \*/// res = tee\_mmu\_check\_access\_rights(to\_user\_ta\_ctx(sess->ctx),// TEE\_MEMORY\_ACCESS\_READ |// TEE\_MEMORY\_ACCESS\_WRITE |// TEE\_MEMORY\_ACCESS\_ANY\_OWNER,// (uaddr\_t)buffer, req\_size);// if (res != TEE\_SUCCESS)// return res;// /\*// \* Write the bignum (wich raw data points to) into an array of// \* bytes (stored in buffer)// \*/// crypto\_bignum\_bn2bin(\*bn, buffer);// return TEE\_SUCCESS;//}////static TEE\_Result op\_attr\_bignum\_to\_binary(void \*attr, void \*data,// size\_t data\_len, size\_t \*offs)//{// TEE\_Result res;// struct bignum \*\*bn = attr;// uint32\_t n = crypto\_bignum\_num\_bytes(\*bn);// size\_t next\_offs;//// res = op\_u32\_to\_binary\_helper(n, data, data\_len, offs);// if (res != TEE\_SUCCESS)// return res;//// if (ADD\_OVERFLOW(\*offs, n, &next\_offs))// return TEE\_ERROR\_OVERFLOW;//// if (data && next\_offs <= data\_len)// crypto\_bignum\_bn2bin(\*bn, (uint8\_t \*)data + \*offs);// (\*offs) = next\_offs;//// return TEE\_SUCCESS;//}////static bool op\_attr\_bignum\_from\_binary(void \*attr, const void \*data,// size\_t data\_len, size\_t \*offs)//{// struct bignum \*\*bn = attr;// uint32\_t n;//// if (!op\_u32\_from\_binary\_helper(&n, data, data\_len, offs))// return false;//// if ((\*offs + n) > data\_len)// return false;// if (crypto\_bignum\_bin2bn((const uint8\_t \*)data + \*offs, n, \*bn))// return false;// (\*offs) += n;// return true;//}////static TEE\_Result op\_attr\_bignum\_from\_obj(void \*attr, void \*src\_attr)//{// struct bignum \*\*bn = attr;// struct bignum \*\*src\_bn = src\_attr;//// crypto\_bignum\_copy(\*bn, \*src\_bn);// return TEE\_SUCCESS;//}////static void op\_attr\_bignum\_clear(void \*attr)//{// struct bignum \*\*bn = attr;//// crypto\_bignum\_clear(\*bn);//}////static void op\_attr\_bignum\_free(void \*attr)//{// struct bignum \*\*bn = attr;//// crypto\_bignum\_free(\*bn);// \*bn = NULL;//}////static TEE\_Result op\_attr\_value\_from\_user(void \*attr, const void \*buffer,// size\_t size)//{// uint32\_t \*v = attr;//// if (size != sizeof(uint32\_t) \* 2)// return TEE\_ERROR\_GENERIC; /\* "can't happen \*///// /\* Note that only the first value is copied \*/// memcpy(v, buffer, sizeof(uint32\_t));// return TEE\_SUCCESS;//}////static TEE\_Result op\_attr\_value\_to\_user(void \*attr,// struct tee\_ta\_session \*sess \_\_unused,// void \*buffer, uint64\_t \*size)//{// TEE\_Result res;// uint32\_t \*v = attr;// uint64\_t s;// uint32\_t value[2] = { \*v };// uint64\_t req\_size = sizeof(value);//// res = tee\_svc\_copy\_from\_user(&s, size, sizeof(s));// if (res != TEE\_SUCCESS)// return res;//// if (s < req\_size)// return TEE\_ERROR\_SHORT\_BUFFER;//// return tee\_svc\_copy\_to\_user(buffer, value, req\_size);//}////static TEE\_Result op\_attr\_value\_to\_binary(void \*attr, void \*data,// size\_t data\_len, size\_t \*offs)//{// uint32\_t \*v = attr;//// return op\_u32\_to\_binary\_helper(\*v, data, data\_len, offs);//}////static bool op\_attr\_value\_from\_binary(void \*attr, const void \*data,// size\_t data\_len, size\_t \*offs)//{// uint32\_t \*v = attr;//// return op\_u32\_from\_binary\_helper(v, data, data\_len, offs);//}////static TEE\_Result op\_attr\_value\_from\_obj(void \*attr, void \*src\_attr)//{// uint32\_t \*v = attr;// uint32\_t \*src\_v = src\_attr;//// \*v = \*src\_v;// return TEE\_SUCCESS;//}////static void op\_attr\_value\_clear(void \*attr)//{// uint32\_t \*v = attr;//// \*v = 0;//}//static const struct attr\_ops attr\_ops[] = { [ATTR\_OPS\_INDEX\_SECRET] = { .from\_user = op\_attr\_secret\_value\_from\_user, .to\_user = op\_attr\_secret\_value\_to\_user, .to\_binary = op\_attr\_secret\_value\_to\_binary, .from\_binary = op\_attr\_secret\_value\_from\_binary, .from\_obj = op\_attr\_secret\_value\_from\_obj, .free = op\_attr\_secret\_value\_clear, /\* not a typo \*/ .clear = op\_attr\_secret\_value\_clear, },// [ATTR\_OPS\_INDEX\_BIGNUM] = {// .from\_user = op\_attr\_bignum\_from\_user,// .to\_user = op\_attr\_bignum\_to\_user,// .to\_binary = op\_attr\_bignum\_to\_binary,// .from\_binary = op\_attr\_bignum\_from\_binary,// .from\_obj = op\_attr\_bignum\_from\_obj,// .free = op\_attr\_bignum\_free,// .clear = op\_attr\_bignum\_clear,// },// [ATTR\_OPS\_INDEX\_VALUE] = {// .from\_user = op\_attr\_value\_from\_user,// .to\_user = op\_attr\_value\_to\_user,// .to\_binary = op\_attr\_value\_to\_binary,// .from\_binary = op\_attr\_value\_from\_binary,// .from\_obj = op\_attr\_value\_from\_obj,// .free = op\_attr\_value\_clear, /\* not a typo \*/// .clear = op\_attr\_value\_clear,// },};
TEE\_Result utee\_cryp\_obj\_get\_info(unsigned long obj, TEE\_ObjectInfo \*info){ TEE\_Result res; struct tee\_ta\_session \*sess; struct tee\_obj \*o;
 res = tee\_ta\_get\_current\_session(&sess); if (res != TEE\_SUCCESS) goto exit;
 res = tee\_obj\_get(to\_user\_ta\_ctx(sess->ctx), tee\_svc\_uref\_to\_vaddr(obj), &o); if (res != TEE\_SUCCESS) goto exit;
 res = tee\_svc\_copy\_to\_user(info, &o->info, sizeof(o->info));
exit: return res;}
//TEE\_Result syscall\_cryp\_obj\_restrict\_usage(unsigned long obj,// unsigned long usage)//{// TEE\_Result res;// struct tee\_ta\_session \*sess;// struct tee\_obj \*o;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// goto exit;//// res = tee\_obj\_get(to\_user\_ta\_ctx(sess->ctx),// tee\_svc\_uref\_to\_vaddr(obj), &o);// if (res != TEE\_SUCCESS)// goto exit;//// o->info.objectUsage &= usage;////exit:// return res;//}
static int tee\_svc\_cryp\_obj\_find\_type\_attr\_idx( uint32\_t attr\_id, const struct tee\_cryp\_obj\_type\_props \*type\_props){ size\_t n;
 for (n = 0; n < type\_props->num\_type\_attrs; n++) { if (attr\_id == type\_props->type\_attrs[n].attr\_id) return n; } return -1;}
static const struct tee\_cryp\_obj\_type\_props \*tee\_svc\_find\_type\_props( TEE\_ObjectType obj\_type){ size\_t n;
 for (n = 0; n < ARRAY\_SIZE(tee\_cryp\_obj\_props); n++) { if (tee\_cryp\_obj\_props[n].obj\_type == obj\_type) return tee\_cryp\_obj\_props + n; }
 return NULL;}
///\* Set an attribute on an object \*///static void set\_attribute(struct tee\_obj \*o,// const struct tee\_cryp\_obj\_type\_props \*props,// uint32\_t attr)//{// int idx = tee\_svc\_cryp\_obj\_find\_type\_attr\_idx(attr, props);//// if (idx < 0)// return;// o->have\_attrs |= BIT(idx);//}/////\* Get an attribute on an object \*///static uint32\_t get\_attribute(const struct tee\_obj \*o,// const struct tee\_cryp\_obj\_type\_props \*props,// uint32\_t attr)//{// int idx = tee\_svc\_cryp\_obj\_find\_type\_attr\_idx(attr, props);//// if (idx < 0)// return 0;// return o->have\_attrs & BIT(idx);//}////TEE\_Result syscall\_cryp\_obj\_get\_attr(unsigned long obj, unsigned long attr\_id,// void \*buffer, uint64\_t \*size)//{// TEE\_Result res;// struct tee\_ta\_session \*sess;// struct tee\_obj \*o;// const struct tee\_cryp\_obj\_type\_props \*type\_props;// int idx;// const struct attr\_ops \*ops;// void \*attr;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// return res;//// res = tee\_obj\_get(to\_user\_ta\_ctx(sess->ctx),// tee\_svc\_uref\_to\_vaddr(obj), &o);// if (res != TEE\_SUCCESS)// return TEE\_ERROR\_ITEM\_NOT\_FOUND;//// /\* Check that the object is initialized \*/// if (!(o->info.handleFlags & TEE\_HANDLE\_FLAG\_INITIALIZED))// return TEE\_ERROR\_BAD\_PARAMETERS;//// /\* Check that getting the attribute is allowed \*/// if (!(attr\_id & TEE\_ATTR\_BIT\_PROTECTED) &&// !(o->info.objectUsage & TEE\_USAGE\_EXTRACTABLE))// return TEE\_ERROR\_BAD\_PARAMETERS;//// type\_props = tee\_svc\_find\_type\_props(o->info.objectType);// if (!type\_props) {// /\* Unknown object type, "can't happen" \*/// return TEE\_ERROR\_BAD\_STATE;// }//// idx = tee\_svc\_cryp\_obj\_find\_type\_attr\_idx(attr\_id, type\_props);// if ((idx < 0) || ((o->have\_attrs & (1 << idx)) == 0))// return TEE\_ERROR\_ITEM\_NOT\_FOUND;//// ops = attr\_ops + type\_props->type\_attrs[idx].ops\_index;// attr = (uint8\_t \*)o->attr + type\_props->type\_attrs[idx].raw\_offs;// return ops->to\_user(attr, sess, buffer, size);//}//void tee\_obj\_attr\_free(struct tee\_obj \*o){// DMSG("\*\*\*\*\*\*\*\* FREE \*\*\*\*\*\*\*\*\*"); const struct tee\_cryp\_obj\_type\_props \*tp; size\_t n;
 if (!o->attr) return; tp = tee\_svc\_find\_type\_props(o->info.objectType); if (!tp)[View remainder of file in raw view](https://github.com/Samsung/mTower/raw/efd36709306a9afcca5b4782499d01be0c7a02a5/tee/tee/tee_svc_cryp.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

