

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Kumar Kartikeya Dwivedi <memxor@gmail.com> | 2024-07-09 18:54:39 +0000 |
| --- | --- | --- |
| committer | Alexei Starovoitov <ast@kernel.org> | 2024-07-10 15:59:44 -0700 |
| commit | [a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)) | |
| tree | [6d3e8d438b7174e4ab71c781642bc946d3a84752](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69) | |
| parent | [d4523831f07a267a943f0dde844bf8ead7495f13](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d4523831f07a267a943f0dde844bf8ead7495f13) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69&id2=d4523831f07a267a943f0dde844bf8ead7495f13)) | |
| download | [linux-a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69.tar.gz) | |

bpf: Defer work in bpf\_timer\_cancel\_and\_freeCurrently, the same case as previous patch (two timer callbacks trying
to cancel each other) can be invoked through bpf\_map\_update\_elem as
well, or more precisely, freeing map elements containing timers. Since
this relies on hrtimer\_cancel as well, it is prone to the same deadlock
situation as the previous patch.
It would be sufficient to use hrtimer\_try\_to\_cancel to fix this problem,
as the timer cannot be enqueued after async\_cancel\_and\_free. Once
async\_cancel\_and\_free has been done, the timer must be reinitialized
before it can be armed again. The callback running in parallel trying to
arm the timer will fail, and freeing bpf\_hrtimer without waiting is
sufficient (given kfree\_rcu), and bpf\_timer\_cb will return
HRTIMER\_NORESTART, preventing the timer from being rearmed again.
However, there exists a UAF scenario where the callback arms the timer
before entering this function, such that if cancellation fails (due to
timer callback invoking this routine, or the target timer callback
running concurrently). In such a case, if the timer expiration is
significantly far in the future, the RCU grace period expiration
happening before it will free the bpf\_hrtimer state and along with it
the struct hrtimer, that is enqueued.
Hence, it is clear cancellation needs to occur after
async\_cancel\_and\_free, and yet it cannot be done inline due to deadlock
issues. We thus modify bpf\_timer\_cancel\_and\_free to defer work to the
global workqueue, adding a work\_struct alongside rcu\_head (both used at
\_different\_ points of time, so can share space).
Update existing code comments to reflect the new state of affairs.
Fixes: b00628b1c7d5 ("bpf: Introduce bpf timers.")
Signed-off-by: Kumar Kartikeya Dwivedi <memxor@gmail.com>
Link: [https://lore.kernel.org/r/20240709185440.1104957-3-memxor@gmail.com](https://lore.kernel.org/r/20240709185440.1104957-3-memxor%40gmail.com)
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)

| -rw-r--r-- | [kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/helpers.c?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69) | 61 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 47 insertions, 14 deletions

| diff --git a/kernel/bpf/helpers.c b/kernel/bpf/helpers.cindex 22e779ca50d5ad..3243c83ef3e39f 100644--- a/[kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/helpers.c?id=d4523831f07a267a943f0dde844bf8ead7495f13)+++ b/[kernel/bpf/helpers.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/helpers.c?id=a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69)@@ -1084,7 +1084,10 @@ struct bpf\_async\_cb { struct bpf\_prog \*prog; void \_\_rcu \*callback\_fn; void \*value;- struct rcu\_head rcu;+ union {+ struct rcu\_head rcu;+ struct work\_struct delete\_work;+ }; u64 flags; }; @@ -1220,6 +1223,21 @@ static void bpf\_wq\_delete\_work(struct work\_struct \*work) kfree\_rcu(w, cb.rcu); } +static void bpf\_timer\_delete\_work(struct work\_struct \*work)+{+ struct bpf\_hrtimer \*t = container\_of(work, struct bpf\_hrtimer, cb.delete\_work);++ /\* Cancel the timer and wait for callback to complete if it was running.+ \* If hrtimer\_cancel() can be safely called it's safe to call+ \* kfree\_rcu(t) right after for both preallocated and non-preallocated+ \* maps. The async->cb = NULL was already done and no code path can see+ \* address 't' anymore. Timer if armed for existing bpf\_hrtimer before+ \* bpf\_timer\_cancel\_and\_free will have been cancelled.+ \*/+ hrtimer\_cancel(&t->timer);+ kfree\_rcu(t, cb.rcu);+}+ static int \_\_bpf\_async\_init(struct bpf\_async\_kern \*async, struct bpf\_map \*map, u64 flags, enum bpf\_async\_type type) {@@ -1264,6 +1282,7 @@ static int \_\_bpf\_async\_init(struct bpf\_async\_kern \*async, struct bpf\_map \*map, u t = (struct bpf\_hrtimer \*)cb;  atomic\_set(&t->cancelling, 0);+ INIT\_WORK(&t->cb.delete\_work, bpf\_timer\_delete\_work); hrtimer\_init(&t->timer, clockid, HRTIMER\_MODE\_REL\_SOFT); t->timer.function = bpf\_timer\_cb; cb->value = (void \*)async - map->record->timer\_off;@@ -1544,25 +1563,39 @@ void bpf\_timer\_cancel\_and\_free(void \*val)  if (!t) return;- /\* Cancel the timer and wait for callback to complete if it was running.- \* If hrtimer\_cancel() can be safely called it's safe to call kfree(t)- \* right after for both preallocated and non-preallocated maps.- \* The async->cb = NULL was already done and no code path can- \* see address 't' anymore.- \*- \* Check that bpf\_map\_delete/update\_elem() wasn't called from timer- \* callback\_fn. In such case don't call hrtimer\_cancel() (since it will- \* deadlock) and don't call hrtimer\_try\_to\_cancel() (since it will just- \* return -1). Though callback\_fn is still running on this cpu it's+ /\* We check that bpf\_map\_delete/update\_elem() was called from timer+ \* callback\_fn. In such case we don't call hrtimer\_cancel() (since it+ \* will deadlock) and don't call hrtimer\_try\_to\_cancel() (since it will+ \* just return -1). Though callback\_fn is still running on this cpu it's \* safe to do kfree(t) because bpf\_timer\_cb() read everything it needed \* from 't'. The bpf subprog callback\_fn won't be able to access 't', \* since async->cb = NULL was already done. The timer will be \* effectively cancelled because bpf\_timer\_cb() will return \* HRTIMER\_NORESTART.+ \*+ \* However, it is possible the timer callback\_fn calling us armed the+ \* timer \_before\_ calling us, such that failing to cancel it here will+ \* cause it to possibly use struct hrtimer after freeing bpf\_hrtimer.+ \* Therefore, we \_need\_ to cancel any outstanding timers before we do+ \* kfree\_rcu, even though no more timers can be armed.+ \*+ \* Moreover, we need to schedule work even if timer does not belong to+ \* the calling callback\_fn, as on two different CPUs, we can end up in a+ \* situation where both sides run in parallel, try to cancel one+ \* another, and we end up waiting on both sides in hrtimer\_cancel+ \* without making forward progress, since timer1 depends on time2+ \* callback to finish, and vice versa.+ \*+ \* CPU 1 (timer1\_cb) CPU 2 (timer2\_cb)+ \* bpf\_timer\_cancel\_and\_free(timer2) bpf\_timer\_cancel\_and\_free(timer1)+ \*+ \* To avoid these issues, punt to workqueue context when we are in a+ \* timer callback. \*/- if (this\_cpu\_read(hrtimer\_running) != t)- hrtimer\_cancel(&t->timer);- kfree\_rcu(t, cb.rcu);+ if (this\_cpu\_read(hrtimer\_running))+ queue\_work(system\_unbound\_wq, &t->cb.delete\_work);+ else+ bpf\_timer\_delete\_work(&t->cb.delete\_work); }  /\* This function is called by map\_delete/update\_elem for individual element and |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 14:03:07 +0000

