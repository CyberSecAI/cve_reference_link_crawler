
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNetatalk%2Fnetatalk%2Fblob%2F90d91a9ac9a7d6132ab7620d31c8c23400949206%2Fetc%2Fafpd%2Fdirectory.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FNetatalk%2Fnetatalk%2Fblob%2F90d91a9ac9a7d6132ab7620d31c8c23400949206%2Fetc%2Fafpd%2Fdirectory.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Netatalk%2Fnetatalk)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Netatalk](/Netatalk)
/
**[netatalk](/Netatalk/netatalk)**
Public

* [Notifications](/login?return_to=%2FNetatalk%2Fnetatalk) You must be signed in to change notification settings
* [Fork
  94](/login?return_to=%2FNetatalk%2Fnetatalk)
* [Star
   378](/login?return_to=%2FNetatalk%2Fnetatalk)

* [Code](/Netatalk/netatalk)
* [Issues
  29](/Netatalk/netatalk/issues)
* [Pull requests
  2](/Netatalk/netatalk/pulls)
* [Discussions](/Netatalk/netatalk/discussions)
* [Actions](/Netatalk/netatalk/actions)
* [Projects
  0](/Netatalk/netatalk/projects)
* [Wiki](/Netatalk/netatalk/wiki)
* [Security](/Netatalk/netatalk/security)
* [Insights](/Netatalk/netatalk/pulse)

Additional navigation options

* [Code](/Netatalk/netatalk)
* [Issues](/Netatalk/netatalk/issues)
* [Pull requests](/Netatalk/netatalk/pulls)
* [Discussions](/Netatalk/netatalk/discussions)
* [Actions](/Netatalk/netatalk/actions)
* [Projects](/Netatalk/netatalk/projects)
* [Wiki](/Netatalk/netatalk/wiki)
* [Security](/Netatalk/netatalk/security)
* [Insights](/Netatalk/netatalk/pulse)

## Files

 90d91a9
## Breadcrumbs

1. [netatalk](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206)
2. /[etc](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc)
3. /[afpd](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/afpd)
/
# directory.c

Copy path Blame  Blame
## Latest commit

## History

[History](/Netatalk/netatalk/commits/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/afpd/directory.c)2436 lines (2159 loc) · 73.6 KB 90d91a9
## Breadcrumbs

1. [netatalk](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206)
2. /[etc](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc)
3. /[afpd](/Netatalk/netatalk/tree/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/afpd)
/
# directory.c

Top
## File metadata and controls

* Code
* Blame

2436 lines (2159 loc) · 73.6 KB[Raw](https://github.com/Netatalk/netatalk/raw/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/afpd/directory.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 1990,1993 Regents of The University of Michigan. \* All Rights Reserved. See COPYRIGHT. \*/
#ifdef HAVE\_CONFIG\_H#include "config.h"#endif /\* HAVE\_CONFIG\_H \*/
#include <assert.h>#include <errno.h>#include <grp.h>#include <pwd.h>#include <stdbool.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/param.h>#include <sys/stat.h>#include <utime.h>
#include <atalk/adouble.h>#include <atalk/afp.h>#include <atalk/bstradd.h>#include <atalk/bstrlib.h>#include <atalk/cnid.h>#include <atalk/errchk.h>#include <atalk/fce\_api.h>#include <atalk/globals.h>#include <atalk/logger.h>#include <atalk/netatalk\_conf.h>#include <atalk/unix.h>#include <atalk/util.h>#include <atalk/uuid.h>#include <atalk/vfs.h>
#include "desktop.h"#include "dircache.h"#include "directory.h"#include "file.h"#include "filedir.h"#include "fork.h"#include "hash.h"#include "mangle.h"#include "unix.h"#include "volume.h"
/\* \* FIXMEs, loose ends after the dircache rewrite: \* o merge dircache\_search\_by\_name and dir\_add ?? \* o case-insensitivity is gone from cname \*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* Globals \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
int afp\_errno;/\* As long as directory.c hasn't got its own init call, this get initialized in dircache\_init \*/struct dir rootParent = { NULL, NULL, NULL, NULL, /\* path, d\_m\_name, d\_u\_name, d\_m\_name\_ucs2 \*/ NULL, 0, 0, /\* qidx\_node, ctime, d\_flags \*/ 0, 0, 0, 0 /\* pdid, did, offcnt, d\_vid \*/};struct dir \*curdir = &rootParent;struct path Cur\_Path = { 0, "", /\* mac name \*/ ".", /\* unix name \*/ 0, /\* id \*/ NULL,/\* struct dir \* \*/ 0, /\* stat is not set \*/ 0, /\* errno \*/ {0} /\* struct stat \*/};
/\* \* dir\_remove queues struct dirs to be freed here. We can't just delete them immeidately \* e.g. in dircache\_search\_by\_id, because a caller somewhere up the stack might be \* referencing it. \* So instead: \* - we mark it as invalid by setting d\_did to CNID\_INVALID (ie 0) \* - queue it in "invalid\_dircache\_entries" queue \* - which is finally freed at the end of every AFP func in afp\_dsi.c. \*/q\_t \*invalid\_dircache\_entries;
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* Locals \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\* ------------------------- appledouble mkdir afp error code.\*/static int netatalk\_mkdir(const struct vol \*vol, const char \*name){ int ret; struct stat st;
 if (vol->v\_flags & AFPVOL\_UNIX\_PRIV) { if (lstat(".", &st) < 0) return AFPERR\_MISC; int mode = (DIRBITS & (~S\_ISGID & st.st\_mode)) | (0777 & ~vol->v\_umask); LOG(log\_maxdebug, logtype\_afpd, "netatalk\_mkdir(\"%s\") {parent mode: %04o, vol umask: %04o}", name, st.st\_mode, vol->v\_umask);
 ret = mkdir(name, mode); } else { ret = ad\_mkdir(name, DIRBITS | 0777); }
 if (ret < 0) { switch ( errno ) { case ENOENT : return( AFPERR\_NOOBJ ); case EROFS : return( AFPERR\_VLOCK ); case EPERM: case EACCES : return( AFPERR\_ACCESS ); case EEXIST : return( AFPERR\_EXIST ); case ENOSPC : case EDQUOT : return( AFPERR\_DFULL ); default : return( AFPERR\_PARAM ); } } return AFP\_OK;}
/\* ------------------- \*/static int deletedir(const struct vol \*vol, int dirfd, char \*dir){ char path[MAXPATHLEN + 1]; DIR \*dp; struct dirent \*de; struct stat st; size\_t len; int err = AFP\_OK; size\_t remain;
 if ((len = strlen(dir)) +2 > sizeof(path)) return AFPERR\_PARAM;
 /\* already gone \*/ if ((dp = opendirat(dirfd, dir)) == NULL) return AFP\_OK;
 snprintf(path, MAXPATHLEN, "%s/", dir); len++; remain = strlen(path) -len -1; while ((de = readdir(dp)) && err == AFP\_OK) { /\* skip this and previous directory \*/ if (!strcmp(de->d\_name, ".") || !strcmp(de->d\_name, "..")) continue;
 if (strlen(de->d\_name) > remain) { err = AFPERR\_PARAM; break; } strcpy(path + len, de->d\_name); if (ostatat(dirfd, path, &st, vol\_syml\_opt(vol))) { continue; } if (S\_ISDIR(st.st\_mode)) { err = deletedir(vol, dirfd, path); } else { err = netatalk\_unlinkat(dirfd, path); } } closedir(dp);
 /\* okay. the directory is empty. delete it. note: we already got rid of .AppleDouble. \*/ if (err == AFP\_OK) { err = netatalk\_rmdir(dirfd, dir); } return err;}
/\* do a recursive copy. \*/static int copydir(struct vol \*vol, struct dir \*ddir, int dirfd, char \*src, char \*dst){ char spath[MAXPATHLEN + 1], dpath[MAXPATHLEN + 1]; DIR \*dp; struct dirent \*de; struct stat st; struct utimbuf ut; size\_t slen, dlen; size\_t srem, drem; int err;
 /\* doesn't exist or the path is too long. \*/ if (((slen = strlen(src)) > sizeof(spath) - 2) || ((dlen = strlen(dst)) > sizeof(dpath) - 2) || ((dp = opendirat(dirfd, src)) == NULL)) return AFPERR\_PARAM;
 /\* try to create the destination directory \*/ if (AFP\_OK != (err = netatalk\_mkdir(vol, dst)) ) { closedir(dp); return err; }
 /\* set things up to copy \*/ snprintf(spath, MAXPATHLEN, "%s/", src); slen++; srem = strlen(spath) - slen -1;
 snprintf(dpath, MAXPATHLEN, "%s/", dst); dlen++; drem = strlen(dpath) - dlen -1;
 err = AFP\_OK; while ((de = readdir(dp))) { /\* skip this and previous directory \*/ if (!strcmp(de->d\_name, ".") || !strcmp(de->d\_name, "..")) continue;
 if (strlen(de->d\_name) > srem) { err = AFPERR\_PARAM; break; } strcpy(spath + slen, de->d\_name);
 if (ostatat(dirfd, spath, &st, vol\_syml\_opt(vol)) == 0) { if (strlen(de->d\_name) > drem) { err = AFPERR\_PARAM; break; } strcpy(dpath + dlen, de->d\_name);
 if (S\_ISDIR(st.st\_mode)) { if (AFP\_OK != (err = copydir(vol, ddir, dirfd, spath, dpath))) goto copydir\_done; } else if (AFP\_OK != (err = copyfile(vol, vol, ddir, dirfd, spath, dpath, NULL, NULL))) { goto copydir\_done;
 } else { /\* keep the same time stamp. \*/ ut.actime = ut.modtime = st.st\_mtime; utime(dpath, &ut); } } }
 /\* keep the same time stamp. \*/ if (ostatat(dirfd, src, &st, vol\_syml\_opt(vol)) == 0) { ut.actime = ut.modtime = st.st\_mtime; utime(dst, &ut); }
copydir\_done: closedir(dp); return err;}
/\* --------------------- \* is our cached offspring count valid? \*/static int diroffcnt(struct dir \*dir, struct stat \*st){ return st->st\_ctime == dir->d\_ctime;}
/\* --------------------- \*/static int invisible\_dots(const struct vol \*vol, const char \*name){ return vol\_inv\_dots(vol) && \*name == '.' && strcmp(name, ".") && strcmp(name, "..");}
/\* ------------------ \*/static int set\_dir\_errors(struct path \*path, const char \*where, int err){ switch ( err ) { case EPERM : case EACCES : return AFPERR\_ACCESS; case EROFS : return AFPERR\_VLOCK; } LOG(log\_error, logtype\_afpd, "setdirparam(%s): %s: %s", fullpathname(path->u\_name), where, strerror(err) ); return AFPERR\_PARAM;}
/\*! \* @brief Convert name in client encoding to server encoding \* \* Convert ret->m\_name to ret->u\_name from client encoding to server encoding. \* This only gets called from cname(). \* \* @returns 0 on success, -1 on error \* \* @note If the passed ret->m\_name is mangled, we'll demangle it \*/static int cname\_mtouname(const struct vol \*vol, struct dir \*dir, struct path \*ret, int toUTF8){ static char temp[ MAXPATHLEN + 1]; char \*t; cnid\_t fileid = 0;
 if (vol->v\_obj->afp\_version >= 30) { if (toUTF8) { if (dir->d\_did == DIRDID\_ROOT\_PARENT) { /\* \* With uft8 volume name is utf8-mac, but requested path may be a mangled longname. See #2611981. \* So we compare it with the longname from the current volume and if they match \* we overwrite the requested path with the utf8 volume name so that the following \* strcmp can match. \*/ ucs2\_to\_charset(vol->v\_maccharset, vol->v\_macname, temp, AFPVOL\_MACNAMELEN + 1); if (strcasecmp(ret->m\_name, temp) == 0) ucs2\_to\_charset(CH\_UTF8\_MAC, vol->v\_u8mname, ret->m\_name, AFPVOL\_U8MNAMELEN); } else { /\* toUTF8 \*/ if (mtoUTF8(vol, ret->m\_name, strlen(ret->m\_name), temp, MAXPATHLEN) == (size\_t)-1) { afp\_errno = AFPERR\_PARAM; return -1; } strcpy(ret->m\_name, temp); } }
 /\* check for OS X mangled filename :( \*/ t = demangle\_osx(vol, ret->m\_name, dir->d\_did, &fileid);
 if (curdir == NULL) { /\* demangle\_osx() calls dirlookup() which might have clobbered curdir \*/ movecwd(vol, dir); }
 LOG(log\_maxdebug, logtype\_afpd, "cname\_mtouname('%s',did:%u) {demangled:'%s', fileid:%u}", ret->m\_name, ntohl(dir->d\_did), t, ntohl(fileid));
 if (t != ret->m\_name) { ret->u\_name = t; /\* duplicate work but we can't reuse all convert\_char we did in demangle\_osx \* flags weren't the same \*/ if ( (t = utompath(vol, ret->u\_name, fileid, utf8\_encoding(vol->v\_obj))) ) { /\* at last got our view of mac name \*/ strcpy(ret->m\_name, t); } } } /\* afp\_version >= 30 \*/
 /\* If we haven't got it by now, get it \*/ if (ret->u\_name == NULL) { if ((ret->u\_name = mtoupath(vol, ret->m\_name, dir->d\_did, utf8\_encoding(vol->v\_obj))) == NULL) { afp\_errno = AFPERR\_PARAM; return -1; } }
 return 0;}
/\*! \* @brief Build struct path from struct dir \* \* The final movecwd in cname failed, possibly with EPERM or ENOENT. We: \* 1. move cwd into parent dir (we're often already there, but not always) \* 2. set struct path to the dirname \* 3. in case of \* AFPERR\_ACCESS: the dir is there, we just can't chdir into it \* AFPERR\_NOOBJ: the dir was there when we stated it in cname, so we have a race \* 4. indicate there's no dir for this path \* 5. remove the dir \*/static struct path \*path\_from\_dir(struct vol \*vol, struct dir \*dir, struct path \*ret){ if (dir->d\_did == DIRDID\_ROOT\_PARENT || dir->d\_did == DIRDID\_ROOT) return NULL;
 switch (afp\_errno) {
 case AFPERR\_ACCESS: if (movecwd( vol, dirlookup(vol, dir->d\_pdid)) < 0 ) /\* 1 \*/ return NULL;
 memcpy(ret->m\_name, cfrombstr(dir->d\_m\_name), blength(dir->d\_m\_name) + 1); /\* 3 \*/ if (dir->d\_m\_name == dir->d\_u\_name) { ret->u\_name = ret->m\_name; } else { ret->u\_name = ret->m\_name + blength(dir->d\_m\_name) + 1; memcpy(ret->u\_name, cfrombstr(dir->d\_u\_name), blength(dir->d\_u\_name) + 1); }
 ret->d\_dir = dir;
 LOG(log\_debug, logtype\_afpd, "cname('%s') {path-from-dir: AFPERR\_ACCESS. curdir:'%s', path:'%s'}", cfrombstr(dir->d\_fullpath), cfrombstr(curdir->d\_fullpath), ret->u\_name);
 return ret;
 case AFPERR\_NOOBJ: if (movecwd(vol, dirlookup(vol, dir->d\_pdid)) < 0 ) /\* 1 \*/ return NULL;
 memcpy(ret->m\_name, cfrombstr(dir->d\_m\_name), blength(dir->d\_m\_name) + 1); if (dir->d\_m\_name == dir->d\_u\_name) { ret->u\_name = ret->m\_name; } else { ret->u\_name = ret->m\_name + blength(dir->d\_m\_name) + 1; memcpy(ret->u\_name, cfrombstr(dir->d\_u\_name), blength(dir->d\_u\_name) + 1); }
 ret->d\_dir = NULL; /\* 4 \*/ dir\_remove(vol, dir); /\* 5 \*/ return ret;
 default: return NULL; }
 /\* DEADC0DE: never get here \*/ return NULL;}
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* Interface \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
int get\_afp\_errno(const int param){ if (afp\_errno != AFPERR\_DID1) return afp\_errno; return param;}
/\*! \* @brief Resolve a DID \* \* Resolve a DID, allocate a struct dir for it \* 1. Check for special CNIDs 0 (invalid), 1 and 2. \* 2a. Check if the DID is in the cache. \* 2b. Check if it's really a dir because we cache files too. \* 3. If it's not in the cache resolve it via the database. \* 4. Build complete server-side path to the dir. \* 5. Check if it exists and is a directory. \* 6. Create the struct dir and populate it. \* 7. Add it to the cache. \* \* @param vol (r) pointer to struct vol \* @param did (r) DID to resolve \* \* @returns pointer to struct dir \*/struct dir \*dirlookup(const struct vol \*vol, cnid\_t did){ static char buffer[12 + MAXPATHLEN + 1]; struct stat st; struct dir \*ret = NULL, \*pdir; bstring fullpath = NULL; char \*upath = NULL, \*mpath; cnid\_t cnid, pdid; size\_t maxpath; int buflen = 12 + MAXPATHLEN + 1; int utf8; int err = 0;
 LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): START", ntohl(did));
 /\* check for did 0, 1 and 2 \*/ if (did == 0 || vol == NULL) { /\* 1 \*/ afp\_errno = AFPERR\_PARAM; ret = NULL; goto exit; } else if (did == DIRDID\_ROOT\_PARENT) { rootParent.d\_vid = vol->v\_vid; ret = &rootParent; goto exit; } else if (did == DIRDID\_ROOT) { ret = vol->v\_root; goto exit; }
 /\* Search the cache \*/ if ((ret = dircache\_search\_by\_did(vol, did)) != NULL) { /\* 2a \*/ if (ret->d\_flags & DIRF\_ISFILE) { /\* 2b \*/ afp\_errno = AFPERR\_BADTYPE; ret = NULL; goto exit; } if (lstat(cfrombstr(ret->d\_fullpath), &st) != 0) { LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u, path: \"%s\"): lstat: %s", ntohl(did), cfrombstr(ret->d\_fullpath), strerror(errno)); switch (errno) { case ENOENT: case ENOTDIR: /\* It's not there anymore, so remove it \*/ LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): calling dir\_remove", ntohl(did)); dir\_remove(vol, ret); afp\_errno = AFPERR\_NOOBJ; ret = NULL; goto exit; default: ret = ret; goto exit; } /\* DEADC0DE \*/ ret = NULL; goto exit; } ret = ret; goto exit; }
 utf8 = utf8\_encoding(vol->v\_obj); maxpath = (utf8) ? MAXPATHLEN - 7 : 255;
 /\* Get it from the database \*/ cnid = did; LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): querying CNID database", ntohl(did));
 AFP\_CNID\_START("cnid\_resolve"); upath = cnid\_resolve(vol->v\_cdb, &cnid, buffer, buflen); AFP\_CNID\_DONE(); if (upath == NULL) { afp\_errno = AFPERR\_NOOBJ; err = 1; goto exit; } if ((upath = strdup(upath)) == NULL) { /\* 3 \*/ afp\_errno = AFPERR\_NOOBJ; err = 1; goto exit; } pdid = cnid;
 /\* \* Recurse up the tree, terminates in dirlookup when either \* - DIRDID\_ROOT is hit \* - a cached entry is found \*/ LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): recursion for did: %u", ntohl(did), ntohl(pdid)); if ((pdir = dirlookup(vol, pdid)) == NULL) { err = 1; goto exit; }
 /\* build the fullpath \*/ if ((fullpath = bstrcpy(pdir->d\_fullpath)) == NULL || bconchar(fullpath, '/') != BSTR\_OK || bcatcstr(fullpath, upath) != BSTR\_OK) { err = 1; goto exit; }
 /\* stat it and check if it's a dir \*/ LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): stating \"%s\"", ntohl(did), cfrombstr(fullpath));
 if (ostat(cfrombstr(fullpath), &st, vol\_syml\_opt(vol)) != 0) { /\* 5a \*/ switch (errno) { case ENOENT: afp\_errno = AFPERR\_NOOBJ; err = 1; goto exit; case EPERM: afp\_errno = AFPERR\_ACCESS; err = 1; goto exit; default: afp\_errno = AFPERR\_MISC; err = 1; goto exit; } } else { if ( ! S\_ISDIR(st.st\_mode)) { /\* 5b \*/ afp\_errno = AFPERR\_BADTYPE; err = 1; goto exit; } }
 /\* Get macname from unix name \*/ if ( (mpath = utompath(vol, upath, did, utf8)) == NULL ) { afp\_errno = AFPERR\_NOOBJ; err = 1; goto exit; }
 /\* Create struct dir \*/ if ((ret = dir\_new(mpath, upath, vol, pdid, did, fullpath, &st)) == NULL) { /\* 6 \*/ LOG(log\_error, logtype\_afpd, "dirlookup(did: %u) {%s, %s}: %s", ntohl(did), mpath, upath, strerror(errno)); err = 1; goto exit; }
 /\* Add it to the cache only if it's a dir \*/ if (dircache\_add(vol, ret) != 0) { /\* 7 \*/ err = 1; goto exit; }
exit: if (upath) free(upath); if (err) { LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u) {exit\_error: %s}", ntohl(did), AfpErr2name(afp\_errno)); if (fullpath) bdestroy(fullpath); if (ret) { dir\_free(ret); ret = NULL; } } if (ret) LOG(log\_debug, logtype\_afpd, "dirlookup(did: %u): RESULT: pdid: %u, path: \"%s\"", ntohl(ret->d\_did), ntohl(ret->d\_pdid), cfrombstr(ret->d\_fullpath));
 return ret;}
/\*! \* @brief Construct struct dir \* \* Construct struct dir from parameters. \* \* @param m\_name (r) directory name in UTF8-dec \* @param u\_name (r) directory name in server side encoding \* @param vol (r) pointer to struct vol \* @param pdid (r) Parent CNID \* @param did (r) CNID \* @param path (r) Full unix path to object \* @param st (r) struct stat of object \* \* @returns pointer to new struct dir or NULL on error \* \* @note Most of the time mac name and unix name are the same. \*/struct dir \*dir\_new(const char \*m\_name, const char \*u\_name, const struct vol \*vol, cnid\_t pdid, cnid\_t did, bstring path, struct stat \*st){ struct dir \*dir;
 dir = (struct dir \*) calloc(1, sizeof( struct dir )); if (!dir) return NULL;
 if ((dir->d\_m\_name = bfromcstr(m\_name)) == NULL) { free(dir); return NULL; }
 if (convert\_string\_allocate( (utf8\_encoding(vol->v\_obj)) ? CH\_UTF8\_MAC : vol->v\_maccharset, CH\_UCS2, m\_name, -1, (char \*\*)&dir->d\_m\_name\_ucs2) == (size\_t)-1 ) { LOG(log\_error, logtype\_afpd, "dir\_new(did: %u) {%s, %s}: couldn't set UCS2 name", ntohl(did), m\_name, u\_name); dir->d\_m\_name\_ucs2 = NULL; }
 if (m\_name == u\_name || !strcmp(m\_name, u\_name)) { dir->d\_u\_name = dir->d\_m\_name; } else if ((dir->d\_u\_name = bfromcstr(u\_name)) == NULL) { bdestroy(dir->d\_m\_name); free(dir); return NULL; }
 dir->d\_did = did; dir->d\_pdid = pdid; dir->d\_vid = vol->v\_vid; dir->d\_fullpath = path; dir->dcache\_ctime = st->st\_ctime; dir->dcache\_ino = st->st\_ino; if (!S\_ISDIR(st->st\_mode)) dir->d\_flags = DIRF\_ISFILE; dir->d\_rights\_cache = 0xffffffff; return dir;}
/\*! \* @brief Free a struct dir and all its members \* \* @param (rw) pointer to struct dir \*/void dir\_free(struct dir \*dir){ if (dir->d\_u\_name != dir->d\_m\_name) { bdestroy(dir->d\_u\_name); } if (dir->d\_m\_name\_ucs2) free(dir->d\_m\_name\_ucs2); bdestroy(dir->d\_m\_name); bdestroy(dir->d\_fullpath); free(dir);}
/\*! \* @brief Create struct dir from struct path \* \* Create a new struct dir from struct path. Then add it to the cache. \* \* 1. Open adouble file, get CNID from it. \* 2. Search the database, hinting with the CNID from (1). \* 3. Build fullpath and create struct dir. \* 4. Add it to the cache. \* \* @param vol (r) pointer to struct vol, possibly modified in callee \* @param dir (r) pointer to parrent directory \* @param path (rw) pointer to struct path with valid path->u\_name \* @param len (r) strlen of path->u\_name \* \* @returns Pointer to new struct dir or NULL on error. \* \* @note Function also assigns path->m\_name from path->u\_name. \*/struct dir \*dir\_add(struct vol \*vol, const struct dir \*dir, struct path \*path, int len){ int err = 0; struct dir \*cdir = NULL; cnid\_t id; struct adouble ad; struct adouble \*adp = NULL; bstring fullpath = NULL;
 AFP\_ASSERT(vol); AFP\_ASSERT(dir); AFP\_ASSERT(path); AFP\_ASSERT(len > 0);
 if ((cdir = dircache\_search\_by\_name(vol, dir, path->u\_name, strlen(path->u\_name))) != NULL) { /\* there's a stray entry in the dircache \*/ LOG(log\_debug, logtype\_afpd, "dir\_add(did:%u,'%s/%s'): {stray cache entry: did:%u,'%s', removing}", ntohl(dir->d\_did), cfrombstr(dir->d\_fullpath), path->u\_name, ntohl(cdir->d\_did), cfrombstr(dir->d\_fullpath)); if (dir\_remove(vol, cdir) != 0) { dircache\_dump(); AFP\_PANIC("dir\_add"); } }
 /\* get\_id needs adp for reading CNID from adouble file \*/ ad\_init(&ad, vol); if ((ad\_open(&ad, path->u\_name, ADFLAGS\_HF | ADFLAGS\_DIR | ADFLAGS\_RDONLY)) == 0) /\* 1 \*/ adp = &ad;
 /\* Get CNID \*/ if ((id = get\_id(vol, adp, &path->st, dir->d\_did, path->u\_name, len)) == CNID\_INVALID) { /\* 2 \*/ err = 1; goto exit; }
 if (adp) ad\_close(adp, ADFLAGS\_HF);
 /\* Get macname from unixname \*/ if (path->m\_name == NULL) { if ((path->m\_name = utompath(vol, path->u\_name, id, utf8\_encoding(vol->v\_obj))) == NULL) { LOG(log\_error, logtype\_afpd, "dir\_add(\"%s\"): can't assign macname", path->u\_name); err = 2; goto exit; } }
 /\* Build fullpath \*/ if ( ((fullpath = bstrcpy(dir->d\_fullpath)) == NULL) /\* 3 \*/ || (bconchar(fullpath, '/') != BSTR\_OK) || (bcatcstr(fullpath, path->u\_name)) != BSTR\_OK) { LOG(log\_error, logtype\_afpd, "dir\_add: fullpath: %s", strerror(errno) ); err = 3; goto exit; }
 /\* Allocate and initialize struct dir \*/ if ((cdir = dir\_new(path->m\_name, path->u\_name, vol, dir->d\_did, id, fullpath, &path->st)) == NULL) { /\* 3 \*/ err = 4; goto exit; }
 if ((dircache\_add(vol, cdir)) != 0) { /\* 4 \*/ LOG(log\_error, logtype\_afpd, "dir\_add: fatal dircache error: %s", cfrombstr(fullpath)); exit(EXITERR\_SYS); }
exit: if (err != 0) { LOG(log\_debug, logtype\_afpd, "dir\_add('%s/%s'): error: %u", cfrombstr(dir->d\_u\_name), path->u\_name, err);
 if (adp) ad\_close(adp, ADFLAGS\_HF); if (!cdir && fullpath) bdestroy(fullpath); if (cdir) dir\_free(cdir); cdir = NULL; } else { /\* no error \*/ LOG(log\_debug, logtype\_afpd, "dir\_add(did:%u,'%s/%s'): {cached: %u,'%s'}", ntohl(dir->d\_did), cfrombstr(dir->d\_fullpath), path->u\_name, ntohl(cdir->d\_did), cfrombstr(cdir->d\_fullpath)); }
 return(cdir);}
/\*! \* Free the queue with invalid struct dirs \* \* This gets called at the end of every AFP func. \*/void dir\_free\_invalid\_q(void){ struct dir \*dir; while ((dir = (struct dir \*)dequeue(invalid\_dircache\_entries))) dir\_free(dir);}
/\*! \* @brief Remove a dir from a cache and queue it for freeing \* \* 1. Check if the dir is locked or has opened forks \* 2. Remove it from the cache \* 3. Queue it for removal \* 4. If it's a request to remove curdir, mark curdir as invalid \* 5. Mark it as invalid \* \* @param (r) pointer to struct vol \* @param (rw) pointer to struct dir \*/int dir\_remove(const struct vol \*vol, struct dir \*dir){ AFP\_ASSERT(vol); AFP\_ASSERT(dir);
 if (dir->d\_did == DIRDID\_ROOT\_PARENT || dir->d\_did == DIRDID\_ROOT) return 0;
 LOG(log\_debug, logtype\_afpd, "dir\_remove(did:%u,'%s'): {removing}", ntohl(dir->d\_did), cfrombstr(dir->d\_u\_name));
 dircache\_remove(vol, dir, DIRCACHE | DIDNAME\_INDEX | QUEUE\_INDEX); /\* 2 \*/ enqueue(invalid\_dircache\_entries, dir); /\* 3 \*/
 if (curdir == dir) /\* 4 \*/ curdir = NULL;
 dir->d\_did = CNID\_INVALID; /\* 5 \*/
 return 0;}
/\*! \* @brief Resolve a catalog node name path \* \* 1. Evaluate path type \* 2. Move to start dir, if we can't, it might be e.g. because of EACCES, build \* path from dirname, so e.g. getdirparams has sth it can chew on. curdir \* is dir parent then. All this is done in path\_from\_dir(). \* 3. Parse next cnode name in path, cases: \* 4. single "\0" -> do nothing \* 5. two or more consecutive "\0" -> chdir("..") one or more times \* 6. cnode name -> copy it to path.m\_name \* 7. Get unix name from mac name \* 8. Special handling of request with did 1 \* 9. stat the cnode name \* 10. If it's not there, it's probably an afp\_createfile|dir, \* return with curdir = dir parent, struct path = dirname \* 11. If it's there and it's a file, it must should be the last element of the requested \* path. Return with curdir = cnode name parent dir, struct path = filename \* 12. Treat symlinks like files, don't follow them \* 13. If it's a dir: \* 14. Search the dircache for it \* 15. If it's not in the cache, create a struct dir for it and add it to the cache \* 16. chdir into the dir and \* 17. set m\_name to the mac equivalent of "." \* 18. goto 3 \*/struct path \*cname(struct vol \*vol, struct dir \*dir, char \*\*cpath){ static char path[ MAXPATHLEN + 1]; static struct path ret;
 struct dir \*cdir; char \*data, \*p; int len; uint32\_t hint; uint16\_t len16; int size = 0; int toUTF8 = 0;
 LOG(log\_maxdebug, logtype\_afpd, "cname('%s'): {start}", cfrombstr(dir->d\_fullpath));
 data = \*cpath; afp\_errno = AFPERR\_NOOBJ; memset(&ret, 0, sizeof(ret));
 switch (ret.m\_type = \*data) { /\* 1 \*/ case 2: data++; len = (unsigned char) \*data++; size = 2; if (vol->v\_obj->afp\_version >= 30) { ret.m\_type = 3; toUTF8 = 1; } break; case 3: if (vol->v\_obj->afp\_version >= 30) { data++; memcpy(&hint, data, sizeof(hint)); hint = ntohl(hint); data += sizeof(hint);
 memcpy(&len16, data, sizeof(len16)); len = ntohs(len16); data += 2; size = 7; break; } /\* else it's an error \*/ default: afp\_errno = AFPERR\_PARAM; return( NULL ); } \*cpath += len + size;
 path[0] = 0; ret.m\_name = path;
 if (movecwd(vol, dir) < 0 ) { LOG(log\_debug, logtype\_afpd, "cname(did:%u): failed to chdir to '%s'", ntohl(dir->d\_did), cfrombstr(dir->d\_fullpath)); if (len == 0) return path\_from\_dir(vol, dir, &ret); else return NULL; }
 while (len) { /\* 3 \*/ if (\*data == 0) { /\* 4 or 5 \*/ data++; len--; while (len > 0 && \*data == 0) { /\* 5 \*/ /\* chdir to parrent dir \*/ if ((dir = dirlookup(vol, dir->d\_pdid)) == NULL) return NULL; if (movecwd( vol, dir ) < 0 ) { dir\_remove(vol, dir); return NULL; } data++; len--; } continue; }
 /\* 6\*/ for ( p = path; \*data != 0 && len > 0; len-- ) { \*p++ = \*data++; if (p > &path[UTF8FILELEN\_EARLY]) { /\* FIXME safeguard, limit of early Mac OS X \*/ afp\_errno = AFPERR\_PARAM; return NULL; } } \*p = 0; /\* Terminate string \*/ ret.u\_name = NULL;
 if (cname\_mtouname(vol, dir, &ret, toUTF8) != 0) { /\* 7 \*/ LOG(log\_error, logtype\_afpd, "cname('%s'): error from cname\_mtouname", path); return NULL; }
 LOG(log\_maxdebug, logtype\_afpd, "cname('%s'): {node: '%s}", cfrombstr(dir->d\_fullpath), ret.u\_name);
 /\* Prevent access to our special folders like .AppleDouble \*/ if (check\_name(vol, ret.u\_name)) { /\* the name is illegal \*/ LOG(log\_info, logtype\_afpd, "cname: illegal path: '%s'", ret.u\_name); afp\_errno = AFPERR\_PARAM; if (vol->v\_obj->options.flags & OPTION\_VETOMSG) { bstring message = bformat("Attempt to access vetoed file or directory \"%s\" in directory \"%s\"", ret.u\_name, bdata(dir->d\_u\_name)); if (setmessage(bdata(message)) == 0)[View remainder of file in raw view](https://github.com/Netatalk/netatalk/raw/90d91a9ac9a7d6132ab7620d31c8c23400949206/etc/afpd/directory.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

