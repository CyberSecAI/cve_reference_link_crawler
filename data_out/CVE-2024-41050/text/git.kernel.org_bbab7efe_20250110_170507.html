

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=19f4f399091478c95947f6bd7ad61622300c30d9)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=19f4f399091478c95947f6bd7ad61622300c30d9)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=19f4f399091478c95947f6bd7ad61622300c30d9)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=19f4f399091478c95947f6bd7ad61622300c30d9)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Baokun Li <libaokun1@huawei.com> | 2024-06-28 14:29:29 +0800 |
| --- | --- | --- |
| committer | Christian Brauner <brauner@kernel.org> | 2024-07-03 10:36:16 +0200 |
| commit | [19f4f399091478c95947f6bd7ad61622300c30d9](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=19f4f399091478c95947f6bd7ad61622300c30d9) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=19f4f399091478c95947f6bd7ad61622300c30d9)) | |
| tree | [ebb1f616e535c68406b23fc0cb6bed645b4566ed](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=19f4f399091478c95947f6bd7ad61622300c30d9) | |
| parent | [12e009d60852f7bce0afc373ca0b320f14150418](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=12e009d60852f7bce0afc373ca0b320f14150418) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=19f4f399091478c95947f6bd7ad61622300c30d9&id2=12e009d60852f7bce0afc373ca0b320f14150418)) | |
| download | [linux-19f4f399091478c95947f6bd7ad61622300c30d9.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-19f4f399091478c95947f6bd7ad61622300c30d9.tar.gz) | |

cachefiles: cyclic allocation of msg\_id to avoid reuseReusing the msg\_id after a maliciously completed reopen request may cause
a read request to remain unprocessed and result in a hung, as shown below:
t1 | t2 | t3
-------------------------------------------------
cachefiles\_ondemand\_select\_req
cachefiles\_ondemand\_object\_is\_close(A)
cachefiles\_ondemand\_set\_object\_reopening(A)
queue\_work(fscache\_object\_wq, &info->work)
ondemand\_object\_worker
cachefiles\_ondemand\_init\_object(A)
cachefiles\_ondemand\_send\_req(OPEN)
// get msg\_id 6
wait\_for\_completion(&req\_A->done)
cachefiles\_ondemand\_daemon\_read
// read msg\_id 6 req\_A
cachefiles\_ondemand\_get\_fd
copy\_to\_user
// Malicious completion msg\_id 6
copen 6,-1
cachefiles\_ondemand\_copen
complete(&req\_A->done)
// will not set the object to close
// because ondemand\_id && fd is valid.
// ondemand\_object\_worker() is done
// but the object is still reopening.
// new open req\_B
cachefiles\_ondemand\_init\_object(B)
cachefiles\_ondemand\_send\_req(OPEN)
// reuse msg\_id 6
process\_open\_req
copen 6,A.size
// The expected failed copen was executed successfully
Expect copen to fail, and when it does, it closes fd, which sets the
object to close, and then close triggers reopen again. However, due to
msg\_id reuse resulting in a successful copen, the anonymous fd is not
closed until the daemon exits. Therefore read requests waiting for reopen
to complete may trigger hung task.
To avoid this issue, allocate the msg\_id cyclically to avoid reusing the
msg\_id for a very short duration of time.
Fixes: c8383054506c ("cachefiles: notify the user daemon when looking up cookie")
Signed-off-by: Baokun Li <libaokun1@huawei.com>
Link: [https://lore.kernel.org/r/20240628062930.2467993-9-libaokun@huaweicloud.com](https://lore.kernel.org/r/20240628062930.2467993-9-libaokun%40huaweicloud.com)
Acked-by: Jeff Layton <jlayton@kernel.org>
Reviewed-by: Gao Xiang <hsiangkao@linux.alibaba.com>
Reviewed-by: Jia Zhu <zhujia.zj@bytedance.com>
Signed-off-by: Christian Brauner <brauner@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=19f4f399091478c95947f6bd7ad61622300c30d9)

| -rw-r--r-- | [fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/internal.h?id=19f4f399091478c95947f6bd7ad61622300c30d9) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/ondemand.c?id=19f4f399091478c95947f6bd7ad61622300c30d9) | 20 | |  |  |  | | --- | --- | --- | |

2 files changed, 17 insertions, 4 deletions

| diff --git a/fs/cachefiles/internal.h b/fs/cachefiles/internal.hindex 8ecd296cc1c40a..9200c00f3e98d2 100644--- a/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=12e009d60852f7bce0afc373ca0b320f14150418)+++ b/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=19f4f399091478c95947f6bd7ad61622300c30d9)@@ -128,6 +128,7 @@ struct cachefiles\_cache { unsigned long req\_id\_next; struct xarray ondemand\_ids; /\* xarray for ondemand\_id allocation \*/ u32 ondemand\_id\_next;+ u32 msg\_id\_next; };  static inline bool cachefiles\_in\_ondemand\_mode(struct cachefiles\_cache \*cache)diff --git a/fs/cachefiles/ondemand.c b/fs/cachefiles/ondemand.cindex 6166b66729e49b..d40b17010b5feb 100644--- a/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=12e009d60852f7bce0afc373ca0b320f14150418)+++ b/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=19f4f399091478c95947f6bd7ad61622300c30d9)@@ -433,20 +433,32 @@ static int cachefiles\_ondemand\_send\_req(struct cachefiles\_object \*object, smp\_mb();  if (opcode == CACHEFILES\_OP\_CLOSE &&- !cachefiles\_ondemand\_object\_is\_open(object)) {+ !cachefiles\_ondemand\_object\_is\_open(object)) { WARN\_ON\_ONCE(object->ondemand->ondemand\_id == 0); xas\_unlock(&xas); ret = -EIO; goto out; } - xas.xa\_index = 0;+ /\*+ \* Cyclically find a free xas to avoid msg\_id reuse that would+ \* cause the daemon to successfully copen a stale msg\_id.+ \*/+ xas.xa\_index = cache->msg\_id\_next; xas\_find\_marked(&xas, UINT\_MAX, XA\_FREE\_MARK);+ if (xas.xa\_node == XAS\_RESTART) {+ xas.xa\_index = 0;+ xas\_find\_marked(&xas, cache->msg\_id\_next - 1, XA\_FREE\_MARK);+ } if (xas.xa\_node == XAS\_RESTART) xas\_set\_err(&xas, -EBUSY);+ xas\_store(&xas, req);- xas\_clear\_mark(&xas, XA\_FREE\_MARK);- xas\_set\_mark(&xas, CACHEFILES\_REQ\_NEW);+ if (xas\_valid(&xas)) {+ cache->msg\_id\_next = xas.xa\_index + 1;+ xas\_clear\_mark(&xas, XA\_FREE\_MARK);+ xas\_set\_mark(&xas, CACHEFILES\_REQ\_NEW);+ } xas\_unlock(&xas); } while (xas\_nomem(&xas, GFP\_KERNEL)); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 17:03:44 +0000

