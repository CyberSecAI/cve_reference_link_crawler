

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=de045a82e1a4e04be62718d3c2981a55150765a0)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=de045a82e1a4e04be62718d3c2981a55150765a0)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=de045a82e1a4e04be62718d3c2981a55150765a0)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=de045a82e1a4e04be62718d3c2981a55150765a0)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Baokun Li <libaokun1@huawei.com> | 2024-06-28 14:29:29 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-18 13:21:11 +0200 |
| commit | [de045a82e1a4e04be62718d3c2981a55150765a0](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=de045a82e1a4e04be62718d3c2981a55150765a0) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=de045a82e1a4e04be62718d3c2981a55150765a0)) | |
| tree | [a2fcd2b706d22f38a9e3840954b2c0f598a256d7](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=de045a82e1a4e04be62718d3c2981a55150765a0) | |
| parent | [d3179bae72b1b5e555ba839d6d9f40a350a4d78a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d3179bae72b1b5e555ba839d6d9f40a350a4d78a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=de045a82e1a4e04be62718d3c2981a55150765a0&id2=d3179bae72b1b5e555ba839d6d9f40a350a4d78a)) | |
| download | [linux-de045a82e1a4e04be62718d3c2981a55150765a0.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-de045a82e1a4e04be62718d3c2981a55150765a0.tar.gz) | |

cachefiles: cyclic allocation of msg\_id to avoid reuse[ Upstream commit 19f4f399091478c95947f6bd7ad61622300c30d9 ]
Reusing the msg\_id after a maliciously completed reopen request may cause
a read request to remain unprocessed and result in a hung, as shown below:
t1 | t2 | t3
-------------------------------------------------
cachefiles\_ondemand\_select\_req
cachefiles\_ondemand\_object\_is\_close(A)
cachefiles\_ondemand\_set\_object\_reopening(A)
queue\_work(fscache\_object\_wq, &info->work)
ondemand\_object\_worker
cachefiles\_ondemand\_init\_object(A)
cachefiles\_ondemand\_send\_req(OPEN)
// get msg\_id 6
wait\_for\_completion(&req\_A->done)
cachefiles\_ondemand\_daemon\_read
// read msg\_id 6 req\_A
cachefiles\_ondemand\_get\_fd
copy\_to\_user
// Malicious completion msg\_id 6
copen 6,-1
cachefiles\_ondemand\_copen
complete(&req\_A->done)
// will not set the object to close
// because ondemand\_id && fd is valid.
// ondemand\_object\_worker() is done
// but the object is still reopening.
// new open req\_B
cachefiles\_ondemand\_init\_object(B)
cachefiles\_ondemand\_send\_req(OPEN)
// reuse msg\_id 6
process\_open\_req
copen 6,A.size
// The expected failed copen was executed successfully
Expect copen to fail, and when it does, it closes fd, which sets the
object to close, and then close triggers reopen again. However, due to
msg\_id reuse resulting in a successful copen, the anonymous fd is not
closed until the daemon exits. Therefore read requests waiting for reopen
to complete may trigger hung task.
To avoid this issue, allocate the msg\_id cyclically to avoid reusing the
msg\_id for a very short duration of time.
Fixes: c8383054506c ("cachefiles: notify the user daemon when looking up cookie")
Signed-off-by: Baokun Li <libaokun1@huawei.com>
Link: [https://lore.kernel.org/r/20240628062930.2467993-9-libaokun@huaweicloud.com](https://lore.kernel.org/r/20240628062930.2467993-9-libaokun%40huaweicloud.com)
Acked-by: Jeff Layton <jlayton@kernel.org>
Reviewed-by: Gao Xiang <hsiangkao@linux.alibaba.com>
Reviewed-by: Jia Zhu <zhujia.zj@bytedance.com>
Signed-off-by: Christian Brauner <brauner@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=de045a82e1a4e04be62718d3c2981a55150765a0)

| -rw-r--r-- | [fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/internal.h?id=de045a82e1a4e04be62718d3c2981a55150765a0) | 1 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/ondemand.c?id=de045a82e1a4e04be62718d3c2981a55150765a0) | 20 | |  |  |  | | --- | --- | --- | |

2 files changed, 17 insertions, 4 deletions

| diff --git a/fs/cachefiles/internal.h b/fs/cachefiles/internal.hindex 94f59123726ca3..111ad6ecd4baf3 100644--- a/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=d3179bae72b1b5e555ba839d6d9f40a350a4d78a)+++ b/[fs/cachefiles/internal.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/internal.h?id=de045a82e1a4e04be62718d3c2981a55150765a0)@@ -129,6 +129,7 @@ struct cachefiles\_cache { unsigned long req\_id\_next; struct xarray ondemand\_ids; /\* xarray for ondemand\_id allocation \*/ u32 ondemand\_id\_next;+ u32 msg\_id\_next; };  static inline bool cachefiles\_in\_ondemand\_mode(struct cachefiles\_cache \*cache)diff --git a/fs/cachefiles/ondemand.c b/fs/cachefiles/ondemand.cindex 1f6561814e7024..51173ab6dbd844 100644--- a/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=d3179bae72b1b5e555ba839d6d9f40a350a4d78a)+++ b/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=de045a82e1a4e04be62718d3c2981a55150765a0)@@ -505,20 +505,32 @@ static int cachefiles\_ondemand\_send\_req(struct cachefiles\_object \*object, smp\_mb();  if (opcode == CACHEFILES\_OP\_CLOSE &&- !cachefiles\_ondemand\_object\_is\_open(object)) {+ !cachefiles\_ondemand\_object\_is\_open(object)) { WARN\_ON\_ONCE(object->ondemand->ondemand\_id == 0); xas\_unlock(&xas); ret = -EIO; goto out; } - xas.xa\_index = 0;+ /\*+ \* Cyclically find a free xas to avoid msg\_id reuse that would+ \* cause the daemon to successfully copen a stale msg\_id.+ \*/+ xas.xa\_index = cache->msg\_id\_next; xas\_find\_marked(&xas, UINT\_MAX, XA\_FREE\_MARK);+ if (xas.xa\_node == XAS\_RESTART) {+ xas.xa\_index = 0;+ xas\_find\_marked(&xas, cache->msg\_id\_next - 1, XA\_FREE\_MARK);+ } if (xas.xa\_node == XAS\_RESTART) xas\_set\_err(&xas, -EBUSY);+ xas\_store(&xas, req);- xas\_clear\_mark(&xas, XA\_FREE\_MARK);- xas\_set\_mark(&xas, CACHEFILES\_REQ\_NEW);+ if (xas\_valid(&xas)) {+ cache->msg\_id\_next = xas.xa\_index + 1;+ xas\_clear\_mark(&xas, XA\_FREE\_MARK);+ xas\_set\_mark(&xas, CACHEFILES\_REQ\_NEW);+ } xas\_unlock(&xas); } while (xas\_nomem(&xas, GFP\_KERNEL)); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 17:03:46 +0000

