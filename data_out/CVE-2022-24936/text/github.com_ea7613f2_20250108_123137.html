
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSiliconLabs%2Fgecko_sdk%2Fblame%2F2e82050dc8823c9fe0e8908c1b2666fb83056230%2Fplatform%2Fbootloader%2Fcore%2Fbtl_bootload.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSiliconLabs%2Fgecko_sdk%2Fblame%2F2e82050dc8823c9fe0e8908c1b2666fb83056230%2Fplatform%2Fbootloader%2Fcore%2Fbtl_bootload.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fblame&source=header-repo&source_repo=SiliconLabs%2Fgecko_sdk)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[SiliconLabs](/SiliconLabs)
/
**[gecko\_sdk](/SiliconLabs/gecko_sdk)**
Public

* [Notifications](/login?return_to=%2FSiliconLabs%2Fgecko_sdk) You must be signed in to change notification settings
* [Fork
  164](/login?return_to=%2FSiliconLabs%2Fgecko_sdk)
* [Star
   392](/login?return_to=%2FSiliconLabs%2Fgecko_sdk)

* [Code](/SiliconLabs/gecko_sdk)
* [Pull requests
  11](/SiliconLabs/gecko_sdk/pulls)
* [Actions](/SiliconLabs/gecko_sdk/actions)
* [Security](/SiliconLabs/gecko_sdk/security)
* [Insights](/SiliconLabs/gecko_sdk/pulse)

Additional navigation options

* [Code](/SiliconLabs/gecko_sdk)
* [Pull requests](/SiliconLabs/gecko_sdk/pulls)
* [Actions](/SiliconLabs/gecko_sdk/actions)
* [Security](/SiliconLabs/gecko_sdk/security)
* [Insights](/SiliconLabs/gecko_sdk/pulse)

## Files

 2e82050
## Breadcrumbs

1. [gecko\_sdk](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230)
2. /[platform](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform)
3. /[bootloader](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader)
4. /[core](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader/core)
/
# btl\_bootload.c

 Blame  Blame
## Latest commit

## History

[History](/SiliconLabs/gecko_sdk/commits/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader/core/btl_bootload.c)980 lines (852 loc) · 31.8 KB 2e82050
## Breadcrumbs

1. [gecko\_sdk](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230)
2. /[platform](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform)
3. /[bootloader](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader)
4. /[core](/SiliconLabs/gecko_sdk/tree/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader/core)
/
# btl\_bootload.c

Top
## File metadata and controls

* Code
* Blame

980 lines (852 loc) · 31.8 KB[Raw](https://github.com/SiliconLabs/gecko_sdk/raw/2e82050dc8823c9fe0e8908c1b2666fb83056230/platform/bootloader/core/btl_bootload.c)OlderNewer Dec 15, 2021![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.0](/SiliconLabs/gecko_sdk/commit/991121c706578c9a2135b6f75cc88856e8c64bdc)Dec 15, 20211234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* @file \* @brief Bootloading functionality for the Silicon Labs bootloader \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* # License \* <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b> \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* \* The licensor of this software is Silicon Laboratories Inc. Your use of this \* software is governed by the terms of Silicon Labs Master Software License \* Agreement (MSLA) available at \* www.silabs.com/about-us/legal/master-software-license-agreement. This \* software is distributed to you in Source Code format and is governed by the \* sections of the MSLA applicable to Source Code. \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/#include "config/btl\_config.h"
#include "btl\_bootload.h"#include "btl\_reset.h"#include "btl\_util.h"
#if defined(SEMAILBOX\_PRESENT) || defined(CRYPTOACC\_PRESENT)MISRAC\_DISABLE#include "em\_se.h"MISRAC\_ENABLE#endif
// Interface#include "api/btl\_interface.h"#include "api/application\_properties.h"
// Image parser#include "parser/gbl/btl\_gbl\_parser.h"
// Security algorithms#include "security/btl\_security\_types.h"#include "security/btl\_security\_ecdsa.h"#include "security/btl\_crc32.h"#include "security/btl\_security\_tokens.h"
// Flashing#include "core/flash/btl\_internal\_flash.h"
// Debug#include "debug/btl\_debug.h"
// Get memcpy#include <string.h>
#ifdef \_\_ICCARM\_\_// Silence MISRA warning disallowing statements without side effects#pragma diag\_suppress=Pm049Mar 10, 2022![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.2](/SiliconLabs/gecko_sdk/commit/2e82050dc8823c9fe0e8908c1b2666fb83056230)Mar 10, 2022Blame prior to change 2e82050, made on Mar 10, 20225455// Silence MISRA warning disallowing access to volatile object in right-hand operand of || operator#pragma diag\_suppress=Pm026Dec 15, 2021![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.0](/SiliconLabs/gecko_sdk/commit/991121c706578c9a2135b6f75cc88856e8c64bdc)Dec 15, 20215657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331#endif
//// Option validation//#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1)#if defined(\_SILICON\_LABS\_GECKO\_INTERNAL\_SDID\_80) || defined(MAIN\_BOOTLOADER\_IN\_MAIN\_FLASH)#error "Rollback protection not supported"#endif#endif // defined(BOOTLOADER\_ROLLBACK\_PROTECTION)
#if defined(BOOTLOADER\_SUPPORT\_CERTIFICATES) && (BOOTLOADER\_SUPPORT\_CERTIFICATES == 1)#if !defined(\_SILICON\_LABS\_32B\_SERIES\_2)#error "Certificate not supported"#endif#endif // defined(BOOTLOADER\_SUPPORT\_CERTIFICATES)
// --------------------------------// Local type declarationsstatic bool bootload\_verifySecureBoot(uint32\_t startAddress);
static void flashData(uint32\_t address, uint8\_t data[], size\_t length);
static bool getSignatureX(ApplicationProperties\_t \*appProperties, uint32\_t \*appSignatureX);
#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1)static bool checkResetMagic(void);static bool checkMaxVersionMagic(void);static uint32\_t getHighestApplicationVersionSeen(void);#endif
// --------------------------------// Defines
#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1)#define SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY 6UL#define SL\_GBL\_APPLICATION\_VERSION\_MAX\_MAGIC 0x1234DCBAUL#define SL\_GBL\_APPLICATION\_VERSION\_RESET\_MAGIC 0x5839FBACUL#define SL\_GBL\_UINT32\_MAX\_NUMBER 0xFFFFFFFFUL#endif
// --------------------------------// Local functions
#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1)static bool checkMaxVersionMagic(void){ uint32\_t \*versionMaxMagicPtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY); if (\*versionMaxMagicPtr == SL\_GBL\_APPLICATION\_VERSION\_MAX\_MAGIC) { return true; } return false;}
static bool checkResetMagic(void){ uint32\_t \*versionResetMagicPtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY + 1UL); if (\*versionResetMagicPtr == SL\_GBL\_APPLICATION\_VERSION\_RESET\_MAGIC) { return true; } return false;}
static uint32\_t getHighestApplicationVersionSeen(void){ uint32\_t \*appVersionStoragePtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY); if (checkMaxVersionMagic()) { return SL\_GBL\_UINT32\_MAX\_NUMBER; }
 for (uint32\_t i = 0UL; i < SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY; i++) { ++appVersionStoragePtr; if (\*appVersionStoragePtr != SL\_GBL\_UINT32\_MAX\_NUMBER) { return \*appVersionStoragePtr; } }
 return PARSER\_APPLICATION\_MINIMUM\_VERSION\_VALID;}#endif
static void flashData(uint32\_t address, uint8\_t data[], size\_t length){ const uint32\_t pageSize = (uint32\_t)FLASH\_PAGE\_SIZE;
 // Erase the page if write starts at a page boundary if (address % pageSize == 0UL) { flash\_erasePage(address); }
 // Erase all pages that start inside the write range for (uint32\_t pageAddress = (address + pageSize) & ~(pageSize - 1UL); pageAddress < (address + length); pageAddress += pageSize) { flash\_erasePage(pageAddress); }
 BTL\_DEBUG\_PRINT("F "); BTL\_DEBUG\_PRINT\_WORD\_HEX(length); BTL\_DEBUG\_PRINT(" to "); BTL\_DEBUG\_PRINT\_WORD\_HEX(address); BTL\_DEBUG\_PRINT\_LF();
 flash\_writeBuffer\_dma(address, data, length, SL\_GBL\_MSC\_LDMA\_CHANNEL);}
static bool getSignatureX(ApplicationProperties\_t \*appProperties, uint32\_t \*appSignatureX){ // Check if app properties struct or legacy direct signature pointer if (bootload\_checkApplicationPropertiesMagic(appProperties)) { if (appProperties->signatureType != APPLICATION\_SIGNATURE\_ECDSA\_P256) { // Application signature isn't ECDSA, fail early BTL\_DEBUG\_PRINTLN("Wrong s type"); return false; } // Compatibility check of the application properties struct. if (!bootload\_checkApplicationPropertiesVersion(appProperties)) { return false; } \*appSignatureX = appProperties->signatureLocation; } else { \*appSignatureX = (uint32\_t)appProperties; } return true;}
static bool bootload\_verifySecureBoot(uint32\_t startAddress){ volatile int32\_t retVal = BOOTLOADER\_ERROR\_SECURITY\_REJECTED; Sha256Context\_t shaState;
 BareBootTable\_t \*appStart = (BareBootTable\_t \*)startAddress; uint32\_t appProps = (uint32\_t)appStart->signature; uint32\_t appSignatureX, appSignatureY; ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appProps);
 if (!bootload\_checkApplicationPropertiesMagic(appProperties)) { return false; } if (!bootload\_checkApplicationPropertiesVersion(appProperties)) { return false; }
#if !defined(\_SILICON\_LABS\_GECKO\_INTERNAL\_SDID\_80) if (PARSER\_REQUIRE\_ANTI\_ROLLBACK\_PROTECTION) { if (!bootload\_verifyApplicationVersion(appProperties->app.version, true)) { return false; } }#endif
#if defined(\_SILICON\_LABS\_32B\_SERIES\_2) // Access word 13 to read sl\_app\_properties of the bootloader. ApplicationProperties\_t \*blProperties = (ApplicationProperties\_t \*)(\*(uint32\_t \*)(BTL\_MAIN\_STAGE\_BASE + 52UL)); if (!bootload\_checkApplicationPropertiesMagic(blProperties)) { return false; }#if !defined(MAIN\_BOOTLOADER\_TEST) if ((uint32\_t)blProperties > ((uint32\_t)mainBootloaderTable->startOfAppSpace - sizeof(ApplicationProperties\_t))) { // Make sure that this pointer is within the bootloader space. return false; }#endif
 bool gotCert = false; if (!bootload\_verifyApplicationCertificate(appProperties, &gotCert)) { return false; }#endif
 if (!getSignatureX(appProperties, &appSignatureX)) { return false; }
 // Check that signature is in application flash if ((appSignatureX < (uint32\_t)(mainBootloaderTable->startOfAppSpace)) || (appSignatureX < startAddress) || (appSignatureX > (FLASH\_BASE + FLASH\_SIZE))) { BTL\_DEBUG\_PRINTLN("No sign"); return false; }
 // SHA-256 of the entire application (startAddress until signature) btl\_initSha256(&shaState); btl\_updateSha256(&shaState, (const uint8\_t\*)startAddress, appSignatureX - startAddress); btl\_finalizeSha256(&shaState);
 appSignatureY = appSignatureX + 32UL;#if defined(\_SILICON\_LABS\_32B\_SERIES\_2) if (PARSER\_REQUIRE\_CERTIFICATE\_AUTHENTICITY) { if (gotCert) { // Application certificate is already verified to be valid at this point. // Authenticate the application using the certificate of the application. retVal = btl\_verifyEcdsaP256r1(shaState.sha, (uint8\_t\*)appSignatureX, (uint8\_t\*)appSignatureY, &(appProperties->cert->key[0]), &(appProperties->cert->key[32])); } else { // Application is directly signed + cert on app is not required. // Authenticate the application using the certificate of the bootloader. retVal = btl\_verifyEcdsaP256r1(shaState.sha, (uint8\_t\*)appSignatureX, (uint8\_t\*)appSignatureY, &(blProperties->cert->key[0]), &(blProperties->cert->key[32])); } } else { // Use "lock bits" key or platform key to authenticate the application. retVal = btl\_verifyEcdsaP256r1(shaState.sha, (uint8\_t\*)appSignatureX, (uint8\_t\*)appSignatureY, btl\_getSignedBootloaderKeyXPtr(), btl\_getSignedBootloaderKeyYPtr()); }#else retVal = btl\_verifyEcdsaP256r1(shaState.sha, (uint8\_t\*)appSignatureX, (uint8\_t\*)appSignatureY, btl\_getSignedBootloaderKeyXPtr(), btl\_getSignedBootloaderKeyYPtr());#endif if (retVal == BOOTLOADER\_OK) { return true; } else { BTL\_DEBUG\_PRINTLN("Inv sign"); return false; }}
// --------------------------------// Global functions
// Callbacksvoid bootload\_applicationCallback(uint32\_t address, uint8\_t data[], size\_t length, void \*context){ (void) context; // Check if addresses to write to are within writeable space if ((address < (uint32\_t)(mainBootloaderTable->startOfAppSpace)) || ((address + length) > (uint32\_t)(mainBootloaderTable->endOfAppSpace))) { BTL\_DEBUG\_PRINT("OOB 0x"); BTL\_DEBUG\_PRINT\_WORD\_HEX(address); BTL\_DEBUG\_PRINT\_LF(); return; }
 flashData(address, data, length);}
void bootload\_bootloaderCallback(uint32\_t offset, uint8\_t data[], size\_t length, void \*context){ (void) context;
#if defined(BOOTLOADER\_HAS\_FIRST\_STAGE) if (firstBootloaderTable->header.type != BOOTLOADER\_MAGIC\_FIRST\_STAGE) { // No first stage present return; }#endif
Mar 10, 2022![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.2](/SiliconLabs/gecko_sdk/commit/2e82050dc8823c9fe0e8908c1b2666fb83056230)Mar 10, 2022Blame prior to change 2e82050, made on Mar 10, 2022332333334335336337338339340341342343344345346347348349350351352353354355 // Do not allow overwriting the last page of main flash if it coincides with // the "lock bits" page.#if defined(LOCKBITS\_BASE) \ && (LOCKBITS\_BASE != (FLASH\_BASE + FLASH\_SIZE - FLASH\_PAGE\_SIZE)) const uint32\_t max\_address = FLASH\_BASE + FLASH\_SIZE;#else const uint32\_t max\_address = FLASH\_BASE + FLASH\_SIZE - FLASH\_PAGE\_SIZE;#endif volatile uint32\_t address = BTL\_UPGRADE\_LOCATION + offset;
 // OOB checks // i) if NOT (BTL\_UPGRADE\_LOCATION <= address < max\_address), // with integer overflow check for address if ((offset > (uint32\_t) (UINT32\_MAX - BTL\_UPGRADE\_LOCATION)) || (address >= max\_address)) { BTL\_DEBUG\_PRINT("OOB, address not in allowed range; (address) 0x"); BTL\_DEBUG\_PRINT\_WORD\_HEX(address); BTL\_DEBUG\_PRINT\_LF(); return; } // ii) Semantically equivalent to (address + length > max\_address), // but without the risk of integer overflow (or underflow, because of (i)) if (length > (uint32\_t) (max\_address - address)) { BTL\_DEBUG\_PRINT("OOB, length too large; (address) 0x");Dec 15, 2021![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.0](/SiliconLabs/gecko_sdk/commit/991121c706578c9a2135b6f75cc88856e8c64bdc)Dec 15, 2021356 BTL\_DEBUG\_PRINT\_WORD\_HEX(address);Mar 10, 2022![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.2](/SiliconLabs/gecko_sdk/commit/2e82050dc8823c9fe0e8908c1b2666fb83056230)Mar 10, 2022Blame prior to change 2e82050, made on Mar 10, 2022357358 BTL\_DEBUG\_PRINT(", (length) 0x"); BTL\_DEBUG\_PRINT\_WORD\_HEX(length);Dec 15, 2021![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.0](/SiliconLabs/gecko_sdk/commit/991121c706578c9a2135b6f75cc88856e8c64bdc)Dec 15, 2021359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980 BTL\_DEBUG\_PRINT\_LF(); return; }
 // Erase first page of app if this is the first write and // if the bootloader upgrade location overlaps with the application. // This ensures that application is not misinterpreted as valid when // bootloader upgrade has started if (offset == 0UL) { if (BTL\_UPGRADE\_LOCATION < (uint32\_t)(mainBootloaderTable->endOfAppSpace)) { flash\_erasePage((uint32\_t)(mainBootloaderTable->startOfAppSpace)); } }
 flashData(address, data, length);}
bool bootload\_checkApplicationPropertiesMagic(void \*appProperties){ if (appProperties == NULL) { return false; }
#if (FLASH\_BASE > 0x0UL) if ((uint32\_t)appProperties < FLASH\_BASE) { return false; }#endif
 uint8\_t magicRev[16U] = APPLICATION\_PROPERTIES\_REVERSED; uint8\_t \*magic = (uint8\_t \*)appProperties;
 for (size\_t i = 0U; i < 16U; i++) { if (magicRev[15U - i] != magic[i]) { return false; } }
 return true;}
bool bootload\_checkApplicationPropertiesVersion(void \*appProperties){ ApplicationProperties\_t \*appProp = (ApplicationProperties\_t \*)appProperties; // Compatibility check of the application properties struct. if (((appProp->structVersion & APPLICATION\_PROPERTIES\_VERSION\_MAJOR\_MASK) >> APPLICATION\_PROPERTIES\_VERSION\_MAJOR\_SHIFT) > (uint32\_t)APPLICATION\_PROPERTIES\_VERSION\_MAJOR) { return false; } return true;}
bool bootload\_verifyApplication(uint32\_t startAddress){ BareBootTable\_t \*appStart = (BareBootTable\_t \*)startAddress; uint32\_t appSp = (uint32\_t)appStart->stackTop; uint32\_t appPc = (uint32\_t)appStart->resetVector; uint32\_t appProps = (uint32\_t)appStart->signature;
 // Check that SP points to RAM if ((appSp < SRAM\_BASE) || (appSp > (SRAM\_BASE + SRAM\_SIZE))) { BTL\_DEBUG\_PRINTLN("SP n/i RAM"); return false; }
 // Check that PC points to application flash if ((appPc < (uint32\_t)mainBootloaderTable->startOfAppSpace) || (appPc > (FLASH\_BASE + FLASH\_SIZE))) { BTL\_DEBUG\_PRINTLN("PC n/i flash"); return false; }
 ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appProps);
 // Application properties pointer can take on many possible values: // // 0xFFFFFFFF - Likely unused part of AAT // [FLASH\_BASE, FLASH\_SIZE] - Likely one of three things: // - Pointer to Reset\_Handler (app without app properties) // - Pointer to ApplicationProperties\_t // - Pointer to ECDSA signature (legacy direct solution)
 if ((appProps < ((uint32\_t)mainBootloaderTable->startOfAppSpace + 64UL)) || (appProps > (FLASH\_BASE + FLASH\_SIZE))) { // Application properties pointer does not point inside flash (is not valid) if (BOOTLOADER\_ENFORCE\_SECURE\_BOOT) { // Secure boot is enforced. Either an app properties struct or a direct // pointer to the signature is required. An address outside main flash // is not valid for either case. BTL\_DEBUG\_PRINTLN("AP n/i flash"); return false; } else { // Secure boot is not enforced, we have to assume app is valid BTL\_DEBUG\_PRINTLN("No SB, assume valid"); return true; } } else if (BOOTLOADER\_ENFORCE\_SECURE\_BOOT) { // Secure boot is enforced, attempt to verify secure boot signature BTL\_DEBUG\_PRINTLN("Secure boot 1"); return bootload\_verifySecureBoot(startAddress); } else if (bootload\_checkApplicationPropertiesMagic(appProperties)) { if (!bootload\_checkApplicationPropertiesVersion(appProperties)) { return false; } // Application properties pointer is valid, decide what action to take // based on signature type if (appProperties->signatureType == APPLICATION\_SIGNATURE\_NONE) { // No signature, app has to be assumed valid BTL\_DEBUG\_PRINTLN("No signature, assume valid"); return true; } else if (appProperties->signatureType == APPLICATION\_SIGNATURE\_CRC32) {#ifdef BTL\_LIB\_NO\_SUPPORT\_CRC32\_SIGNATURE // Don't support CRC32, app has to be assumed valid BTL\_DEBUG\_PRINTLN("CRC not supported, assume valid"); return true;#else uint32\_t crc = btl\_crc32Stream( (void \*)startAddress, appProperties->signatureLocation + 4UL - startAddress, BTL\_CRC32\_START); if (crc == BTL\_CRC32\_END) { BTL\_DEBUG\_PRINTLN("CRC success"); return true; } else { return false; }#endif } else { // Default to secure boot check BTL\_DEBUG\_PRINTLN("Secure boot 2"); return bootload\_verifySecureBoot(startAddress); } } else { // Application properties pointer points into flash, but doesn't point to // an application properties struct. // Secure boot is not enforced (checked above), assume that this is a // pointer to the Reset\_Handler and that the app is valid BTL\_DEBUG\_PRINTLN("No AP, assume valid"); return true; }}
uint32\_t bootload\_getApplicationVersionStorageCapacity(void){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) return SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY;#else return 0UL;#endif}
uint32\_t\* bootload\_getApplicationVersionStoragePtr(uint32\_t index){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) uint32\_t endOfBLpage = BTL\_FIRST\_STAGE\_BASE + BTL\_FIRST\_STAGE\_SIZE + BTL\_MAIN\_STAGE\_MAX\_SIZE; uint32\_t \*appVersionStoragePtr = (uint32\_t\*)endOfBLpage - (index + 1UL); return appVersionStoragePtr;#else (void)index; return NULL;#endif}
bool bootload\_storeApplicationVersion(uint32\_t startAddress){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) BareBootTable\_t \*appStart = (BareBootTable\_t \*)startAddress; ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appStart->signature); uint32\_t appVersion = appProperties->app.version; uint32\_t emptySlots = bootload\_remainingApplicationUpgrades(); uint32\_t highestVersionSeen = getHighestApplicationVersionSeen(); uint32\_t \*appVersionStoragePtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY);
 if (!bootload\_checkApplicationPropertiesMagic(appProperties)) { return false; } if (!bootload\_checkApplicationPropertiesVersion(appProperties)) { return false; }
 if (checkMaxVersionMagic()) { // The highest allowed version is seen, which is the maximum version allowed // so we do not need to remember any new application versions. return true; } if (\*appVersionStoragePtr != SL\_GBL\_UINT32\_MAX\_NUMBER) { return false; } if (highestVersionSeen == appVersion) { // Do not need to store a new version. return true; }
 if (appVersion == SL\_GBL\_UINT32\_MAX\_NUMBER) { appVersion = SL\_GBL\_APPLICATION\_VERSION\_MAX\_MAGIC; // Return true eventhough the flash pages are locked to avoid bricking devices. (void)flash\_writeBuffer\_dma((uint32\_t)appVersionStoragePtr, &appVersion, 4UL, SL\_GBL\_MSC\_LDMA\_CHANNEL); return true; }
 // The application that is about to boot has a higher version than the highest seen version. // However, this version can't be stored, so do not allow the application to boot to prevent // downgrade later. This will "never" happen as the number of empty slots is checked before getting to this point. // Unless the slots are already filled for some unexpected reason. if (emptySlots == 0UL) { return false; }
 appVersionStoragePtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY - emptySlots); (void)flash\_writeBuffer\_dma((uint32\_t)appVersionStoragePtr, &appVersion, 4UL, SL\_GBL\_MSC\_LDMA\_CHANNEL); return true;#else (void)startAddress; return false;#endif}
bool bootload\_verifyApplicationVersion(uint32\_t appVersion, bool checkRemainingAppUpgrades){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) uint32\_t highestVersionSeen = getHighestApplicationVersionSeen();
 // Check for the minimum application version that should be allowed. if (PARSER\_APPLICATION\_MINIMUM\_VERSION\_VALID > appVersion) { return false; } if (highestVersionSeen > appVersion) { return false; }
 // Application version is higher/equal than the saved application versions. // Check if we have empty spaces left for storing new application versions. if ((appVersion > highestVersionSeen) && checkRemainingAppUpgrades) { // The new application version needs to be stored, check we have empty spaces left. if (bootload\_remainingApplicationUpgrades() == 0UL) { return false; } }
 return true;#else (void)appVersion; (void)checkRemainingAppUpgrades; return false;#endif}
uint32\_t bootload\_remainingApplicationUpgrades(void){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) uint32\_t \*appVersionStoragePtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY); if (checkMaxVersionMagic()) { return 0UL; }
 for (uint32\_t i = 0UL; i < SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY; i++) { appVersionStoragePtr = bootload\_getApplicationVersionStoragePtr(i); if (\*appVersionStoragePtr == SL\_GBL\_UINT32\_MAX\_NUMBER) { return (SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY - i); } }
 return 0UL;#else return 0UL;#endif}
void bootload\_storeApplicationVersionResetMagic(void){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) uint32\_t \*appVersionResetPtr = bootload\_getApplicationVersionStoragePtr(bootload\_getApplicationVersionStorageCapacity() + 1UL); uint32\_t appVersionResetMagic = SL\_GBL\_APPLICATION\_VERSION\_RESET\_MAGIC; (void)flash\_writeBuffer\_dma((uint32\_t)appVersionResetPtr, &appVersionResetMagic, 4UL, SL\_GBL\_MSC\_LDMA\_CHANNEL);#else return;#endif}
void bootload\_removeStoredApplicationVersions(void){#if defined(BOOTLOADER\_ROLLBACK\_PROTECTION) && (BOOTLOADER\_ROLLBACK\_PROTECTION == 1) uint32\_t \*appVersionResetPtr = bootload\_getApplicationVersionStoragePtr(SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY + 1UL); if ((bootload\_remainingApplicationUpgrades() < SL\_GBL\_APPLICATION\_VERSION\_STORAGE\_CAPACITY) && checkResetMagic()) { // Not empty and reset requested. uint32\_t versionStorageAddr = ((uint32\_t)appVersionResetPtr / FLASH\_PAGE\_SIZE) \* FLASH\_PAGE\_SIZE; (void)flash\_erasePage(versionStorageAddr); }#else return;#endif}
bool bootload\_gotCertificate(void \*appProp){#if defined(BOOTLOADER\_SUPPORT\_CERTIFICATES) && (BOOTLOADER\_SUPPORT\_CERTIFICATES == 1) if (appProp == NULL) { return false; }
 ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appProp); // Compatibility check of the application properties struct. // The application properties struct with the major version 0 // does not contain the certificate struct. if (((appProperties->structVersion & APPLICATION\_PROPERTIES\_VERSION\_MAJOR\_MASK) >> APPLICATION\_PROPERTIES\_VERSION\_MAJOR\_SHIFT) < 1UL) { return false; }
 if (((appProperties->structVersion & APPLICATION\_PROPERTIES\_VERSION\_MINOR\_MASK) >> APPLICATION\_PROPERTIES\_VERSION\_MINOR\_SHIFT) < 1UL) { return false; }
 if (appProperties->cert == NULL) { return false; }
 return true;#else (void)appProp; return false;#endif}
bool bootload\_verifyCertificate(void \*cert){#if defined(BOOTLOADER\_SUPPORT\_CERTIFICATES) && (BOOTLOADER\_SUPPORT\_CERTIFICATES == 1) if (cert == NULL) { return false; } ApplicationCertificate\_t \*appCertificate = (ApplicationCertificate\_t \*)(cert);
 volatile int32\_t retVal = BOOTLOADER\_ERROR\_SECURITY\_REJECTED; Sha256Context\_t shaState;
 // Access word 13 to read sl\_app\_properties of the bootloader. ApplicationProperties\_t \*blProperties = (ApplicationProperties\_t \*)(\*(uint32\_t \*)(BTL\_MAIN\_STAGE\_BASE + 52UL)); if (!bootload\_checkApplicationPropertiesMagic(blProperties)) { return false; }#if !defined(MAIN\_BOOTLOADER\_TEST) if ((uint32\_t)blProperties > (BTL\_APPLICATION\_BASE - sizeof(ApplicationProperties\_t))) { // Make sure that this pointer is within the bootloader space. return false; }#endif
 // Application cert version need to be higher or equal than // the running bootloader version. if (blProperties->cert->version > appCertificate->version) { return false; } else { // Check ECDSA signing. btl\_initSha256(&shaState); btl\_updateSha256(&shaState, (const uint8\_t\*)appCertificate, 72U); btl\_finalizeSha256(&shaState);
 // Use the public key stored in bootloader certificate // to verify the certificate. The bootloader cerfiticate // has been validated by SE. retVal = btl\_verifyEcdsaP256r1(shaState.sha, &(appCertificate->signature[0]), &(appCertificate->signature[32]), &(blProperties->cert->key[0]), &(blProperties->cert->key[32])); if (retVal != BOOTLOADER\_OK) { return false; } return true; }#else (void)cert; return false;#endif}
bool bootload\_verifyApplicationCertificate(void \*appProp, void \*gotCert){#if defined(BOOTLOADER\_SUPPORT\_CERTIFICATES) && (BOOTLOADER\_SUPPORT\_CERTIFICATES == 1) ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appProp); bool \*gotCertificate = (bool \*)gotCert; \*gotCertificate = bootload\_gotCertificate(appProperties); if (\*gotCertificate) { // Validate Cert if (!bootload\_verifyCertificate(appProperties->cert)) { // Cert found, but it contains an invalid signature. return false; } }#if defined(BOOTLOADER\_REJECT\_DIRECT\_SIGNED\_IMG) && (BOOTLOADER\_REJECT\_DIRECT\_SIGNED\_IMG == 1) else { return false; }#endif return true;#else (void)appProp; (void)gotCert; return true;#endif}
// --------------------------------// Secure Element functions
bool bootload\_commitBootloaderUpgrade(uint32\_t upgradeAddress, uint32\_t size){ // Check CRC32 checksum on the bootloader image. uint32\_t crc = btl\_crc32Stream((void \*)upgradeAddress, (size\_t)size, BTL\_CRC32\_START); if (crc != BTL\_CRC32\_END) { // CRC32 check failed. Return early. return false; }
#if defined(SEMAILBOX\_PRESENT)#if defined(\_CMU\_CLKEN1\_SEMAILBOXHOST\_MASK) CMU->CLKEN1\_SET = CMU\_CLKEN1\_SEMAILBOXHOST;#endif
 // Init with != SE\_RESPONSE\_OK response. SE\_Response\_t response = 0x12345678U;
 // Verify upgrade image SE\_Command\_t checkImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_CHECK\_HOST\_IMAGE); SE\_addParameter(&checkImage, upgradeAddress); SE\_addParameter(&checkImage, size);
 SE\_executeCommand(&checkImage); response = SE\_readCommandResponse();
 if (response != SE\_RESPONSE\_OK) { return false; }#endif
#if !defined(\_SILICON\_LABS\_GECKO\_INTERNAL\_SDID\_80) // Set Reset Magic to signal that the application versions should be cleaned. // Doing this to make sure that those application versions gets cleaned with a bootloader upgrade. // (Those versions will not get cleaned if the bootloader image does not require the last bootloader page). bootload\_storeApplicationVersionResetMagic(); #endif
#if defined(SEMAILBOX\_PRESENT) // Set reset code for when we get back reset\_setResetReason(BOOTLOADER\_RESET\_REASON\_BOOTLOAD);
 // Apply upgrade image SE\_Command\_t applyImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_APPLY\_HOST\_IMAGE); SE\_addParameter(&applyImage, upgradeAddress); SE\_addParameter(&applyImage, size);
 SE\_executeCommand(&applyImage);
 // Should never get here response = SE\_readCommandResponse(); return false;#elif defined(CRYPTOACC\_PRESENT) // Set reset code for when we get back reset\_setResetReason(BOOTLOADER\_RESET\_REASON\_BOOTLOAD);
 // Apply upgrade image SE\_Command\_t applyImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_APPLY\_HOST\_IMAGE); SE\_addParameter(&applyImage, upgradeAddress); SE\_addParameter(&applyImage, size);
 SE\_executeCommand(&applyImage);
 // Should never get here return false;#else (void) upgradeAddress; (void) size; // Reboot and apply upgrade reset\_resetWithReason(BOOTLOADER\_RESET\_REASON\_UPGRADE);
 // Should never get here return false;#endif}
#if defined(\_MSC\_PAGELOCK0\_MASK)bool bootload\_lockApplicationArea(uint32\_t startAddress, uint32\_t endAddress){ if (endAddress == 0U) { // It is assumed that a valid start address of application is used. BareBootTable\_t \*appStart = (BareBootTable\_t \*)startAddress; ApplicationProperties\_t \*appProperties = (ApplicationProperties\_t \*)(appStart->signature); bool retVal = getSignatureX(appProperties, &endAddress); if (!retVal) { BTL\_DEBUG\_PRINTLN("Wrong s type"); return false; } }
 if (startAddress > endAddress) { return false; }
 uint32\_t volatile \* pageLockAddr; const uint32\_t pageSize = (uint32\_t)FLASH\_PAGE\_SIZE; uint32\_t pageNo = ((startAddress - (startAddress % pageSize)) - FLASH\_BASE) / pageSize; uint32\_t endPageNo = ((endAddress - (endAddress % pageSize) + pageSize) - FLASH\_BASE) / pageSize;
#if defined(CMU\_CLKEN1\_MSC) CMU->CLKEN1\_SET = CMU\_CLKEN1\_MSC;#endif while (pageNo < endPageNo) { pageLockAddr = (uint32\_t volatile \*)(&(MSC->PAGELOCK0\_SET)); // Find the page lock register that includes current page number. pageLockAddr = &pageLockAddr[pageNo / 32U]; // 32 pages per page lock word. \*pageLockAddr = (1UL << (pageNo % 32U)); pageNo += 1U; }#if defined(CRYPTOACC\_PRESENT) CMU->CLKEN1\_CLR = CMU\_CLKEN1\_MSC;#endif return true;}#endif
#if defined(SEMAILBOX\_PRESENT)bool bootload\_checkSeUpgradeVersion(uint32\_t upgradeVersion){#if defined(\_CMU\_CLKEN1\_SEMAILBOXHOST\_MASK) CMU->CLKEN1\_SET = CMU\_CLKEN1\_SEMAILBOXHOST;#endif
 // Init with != SE\_RESPONSE\_OK response. SE\_Response\_t response = 0x12345678U; uint32\_t runningVersion = 0xFFFFFFFFU;
 SE\_Command\_t getVersion = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_STATUS\_SE\_VERSION); SE\_DataTransfer\_t dataOut = SE\_DATATRANSFER\_DEFAULT(&runningVersion, 4UL); SE\_addDataOutput(&getVersion, &dataOut);
 SE\_executeCommand(&getVersion); response = SE\_readCommandResponse();
 if (response != SE\_RESPONSE\_OK) { // Failed to communicate with SE, can't apply SE upgrade. return false; }
 // Only allow upgrade if it is higher than the running version if (runningVersion < upgradeVersion) { return true; } else { return false; }}
bool bootload\_commitSeUpgrade(uint32\_t upgradeAddress){#if defined(\_CMU\_CLKEN1\_SEMAILBOXHOST\_MASK) CMU->CLKEN1\_SET = CMU\_CLKEN1\_SEMAILBOXHOST;#endif
 // Init with != SE\_RESPONSE\_OK response. SE\_Response\_t response = 0x12345678U;
 // Verify upgrade image SE\_Command\_t checkImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_CHECK\_SE\_IMAGE); SE\_addParameter(&checkImage, upgradeAddress);
 SE\_executeCommand(&checkImage); response = SE\_readCommandResponse();
 if (response != SE\_RESPONSE\_OK) { return false; }
 // Set reset code for when we get back reset\_setResetReason(BOOTLOADER\_RESET\_REASON\_BOOTLOAD);
 // Apply upgrade image SE\_Command\_t applyImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_APPLY\_SE\_IMAGE); SE\_addParameter(&applyImage, upgradeAddress);
 SE\_executeCommand(&applyImage);
 // Should never get here response = SE\_readCommandResponse(); return false;}
#elif defined(CRYPTOACC\_PRESENT)bool bootload\_checkSeUpgradeVersion(uint32\_t upgradeVersion){ uint32\_t runningVersion = 0xFFFFFFFFU; if (SE\_getVersion(&runningVersion) != SE\_RESPONSE\_OK) { // Failed to communicate with SE, can't find the SE version. return false; } // Only allow upgrade if it is higher than the running version if (runningVersion < upgradeVersion) { return true; } return false;}
bool bootload\_commitSeUpgrade(uint32\_t upgradeAddress){ // Set reset code for when we get back reset\_setResetReason(BOOTLOADER\_RESET\_REASON\_BOOTLOAD);
 // Apply upgrade image SE\_Command\_t applyImage = SE\_COMMAND\_DEFAULT(SE\_COMMAND\_APPLY\_SE\_IMAGE); SE\_addParameter(&applyImage, upgradeAddress);
 SE\_executeCommand(&applyImage);
 // Should never get here return false;}#endif // defined(CRYPTOACC\_PRESENT)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

