

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Wen Gu <guwen@linux.alibaba.com> | 2022-01-22 17:43:09 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-02-01 17:29:16 +0100 |
| commit | [4284225cd8001e134f5cf533a7cd244bbb654d0f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)) | |
| tree | [84d7868d922813b074e33d8be4ecb094506de891](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f) | |
| parent | [e3496f8127f1b97ded5fa1ace04210c2de0eace8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e3496f8127f1b97ded5fa1ace04210c2de0eace8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f&id2=e3496f8127f1b97ded5fa1ace04210c2de0eace8)) | |
| download | [linux-4284225cd8001e134f5cf533a7cd244bbb654d0f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-4284225cd8001e134f5cf533a7cd244bbb654d0f.tar.gz) | |

net/smc: Transitional solution for clcsock race issue[ Upstream commit c0bf3d8a943b6f2e912b7c1de03e2ef28e76f760 ]
We encountered a crash in smc\_setsockopt() and it is caused by
accessing smc->clcsock after clcsock was released.
BUG: kernel NULL pointer dereference, address: 0000000000000020
#PF: supervisor read access in kernel mode
#PF: error\_code(0x0000) - not-present page
PGD 0 P4D 0
Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 1 PID: 50309 Comm: nginx Kdump: loaded Tainted: G E 5.16.0-rc4+ #53
RIP: 0010:smc\_setsockopt+0x59/0x280 [smc]
Call Trace:
<TASK>
\_\_sys\_setsockopt+0xfc/0x190
\_\_x64\_sys\_setsockopt+0x20/0x30
do\_syscall\_64+0x34/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
RIP: 0033:0x7f16ba83918e
</TASK>
This patch tries to fix it by holding clcsock\_release\_lock and
checking whether clcsock has already been released before access.
In case that a crash of the same reason happens in smc\_getsockopt()
or smc\_switch\_to\_fallback(), this patch also checkes smc->clcsock
in them too. And the caller of smc\_switch\_to\_fallback() will identify
whether fallback succeeds according to the return value.
Fixes: fd57770dd198 ("net/smc: wait for pending work before clcsock release\_sock")
Link: [https://lore.kernel.org/lkml/5dd7ffd1-28e2-24cc-9442-1defec27375e@linux.ibm.com/T/](https://lore.kernel.org/lkml/5dd7ffd1-28e2-24cc-9442-1defec27375e%40linux.ibm.com/T/)
Signed-off-by: Wen Gu <guwen@linux.alibaba.com>
Acked-by: Karsten Graul <kgraul@linux.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)

| -rw-r--r-- | [net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/af_smc.c?id=4284225cd8001e134f5cf533a7cd244bbb654d0f) | 63 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 51 insertions, 12 deletions

| diff --git a/net/smc/af\_smc.c b/net/smc/af\_smc.cindex 211cd91b6c4085..85e077a69c67da 100644--- a/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=e3496f8127f1b97ded5fa1ace04210c2de0eace8)+++ b/[net/smc/af\_smc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/af_smc.c?id=4284225cd8001e134f5cf533a7cd244bbb654d0f)@@ -566,12 +566,17 @@ static void smc\_stat\_fallback(struct smc\_sock \*smc) mutex\_unlock(&net->smc.mutex\_fback\_rsn); } -static void smc\_switch\_to\_fallback(struct smc\_sock \*smc, int reason\_code)+static int smc\_switch\_to\_fallback(struct smc\_sock \*smc, int reason\_code) { wait\_queue\_head\_t \*smc\_wait = sk\_sleep(&smc->sk);- wait\_queue\_head\_t \*clc\_wait = sk\_sleep(smc->clcsock->sk);+ wait\_queue\_head\_t \*clc\_wait; unsigned long flags; + mutex\_lock(&smc->clcsock\_release\_lock);+ if (!smc->clcsock) {+ mutex\_unlock(&smc->clcsock\_release\_lock);+ return -EBADF;+ } smc->use\_fallback = true; smc->fallback\_rsn = reason\_code; smc\_stat\_fallback(smc);@@ -586,18 +591,30 @@ static void smc\_switch\_to\_fallback(struct smc\_sock \*smc, int reason\_code) \* smc socket->wq, which should be removed \* to clcsocket->wq during the fallback. \*/+ clc\_wait = sk\_sleep(smc->clcsock->sk); spin\_lock\_irqsave(&smc\_wait->lock, flags); spin\_lock\_nested(&clc\_wait->lock, SINGLE\_DEPTH\_NESTING); list\_splice\_init(&smc\_wait->head, &clc\_wait->head); spin\_unlock(&clc\_wait->lock); spin\_unlock\_irqrestore(&smc\_wait->lock, flags); }+ mutex\_unlock(&smc->clcsock\_release\_lock);+ return 0; }  /\* fall back during connect \*/ static int smc\_connect\_fallback(struct smc\_sock \*smc, int reason\_code) {- smc\_switch\_to\_fallback(smc, reason\_code);+ struct net \*net = sock\_net(&smc->sk);+ int rc = 0;++ rc = smc\_switch\_to\_fallback(smc, reason\_code);+ if (rc) { /\* fallback fails \*/+ this\_cpu\_inc(net->smc.smc\_stats->clnt\_hshake\_err\_cnt);+ if (smc->sk.sk\_state == SMC\_INIT)+ sock\_put(&smc->sk); /\* passive closing \*/+ return rc;+ } smc\_copy\_sock\_settings\_to\_clc(smc); smc->connect\_nonblock = 0; if (smc->sk.sk\_state == SMC\_INIT)@@ -1514,11 +1531,12 @@ static void smc\_listen\_decline(struct smc\_sock \*new\_smc, int reason\_code, { /\* RDMA setup failed, switch back to TCP \*/ smc\_conn\_abort(new\_smc, local\_first);- if (reason\_code < 0) { /\* error, no fallback possible \*/+ if (reason\_code < 0 ||+ smc\_switch\_to\_fallback(new\_smc, reason\_code)) {+ /\* error, no fallback possible \*/ smc\_listen\_out\_err(new\_smc); return; }- smc\_switch\_to\_fallback(new\_smc, reason\_code); if (reason\_code && reason\_code != SMC\_CLC\_DECL\_PEERDECL) { if (smc\_clc\_send\_decline(new\_smc, reason\_code, version) < 0) { smc\_listen\_out\_err(new\_smc);@@ -1960,8 +1978,11 @@ static void smc\_listen\_work(struct work\_struct \*work)  /\* check if peer is smc capable \*/ if (!tcp\_sk(newclcsock->sk)->syn\_smc) {- smc\_switch\_to\_fallback(new\_smc, SMC\_CLC\_DECL\_PEERNOSMC);- smc\_listen\_out\_connected(new\_smc);+ rc = smc\_switch\_to\_fallback(new\_smc, SMC\_CLC\_DECL\_PEERNOSMC);+ if (rc)+ smc\_listen\_out\_err(new\_smc);+ else+ smc\_listen\_out\_connected(new\_smc); return; } @@ -2250,7 +2271,9 @@ static int smc\_sendmsg(struct socket \*sock, struct msghdr \*msg, size\_t len)  if (msg->msg\_flags & MSG\_FASTOPEN) { if (sk->sk\_state == SMC\_INIT && !smc->connect\_nonblock) {- smc\_switch\_to\_fallback(smc, SMC\_CLC\_DECL\_OPTUNSUPP);+ rc = smc\_switch\_to\_fallback(smc, SMC\_CLC\_DECL\_OPTUNSUPP);+ if (rc)+ goto out; } else { rc = -EINVAL; goto out;@@ -2443,6 +2466,11 @@ static int smc\_setsockopt(struct socket \*sock, int level, int optname, /\* generic setsockopts reaching us here always apply to the \* CLC socket \*/+ mutex\_lock(&smc->clcsock\_release\_lock);+ if (!smc->clcsock) {+ mutex\_unlock(&smc->clcsock\_release\_lock);+ return -EBADF;+ } if (unlikely(!smc->clcsock->ops->setsockopt)) rc = -EOPNOTSUPP; else@@ -2452,6 +2480,7 @@ static int smc\_setsockopt(struct socket \*sock, int level, int optname, sk->sk\_err = smc->clcsock->sk->sk\_err; sk\_error\_report(sk); }+ mutex\_unlock(&smc->clcsock\_release\_lock);  if (optlen < sizeof(int)) return -EINVAL;@@ -2468,7 +2497,7 @@ static int smc\_setsockopt(struct socket \*sock, int level, int optname, case TCP\_FASTOPEN\_NO\_COOKIE: /\* option not supported by SMC \*/ if (sk->sk\_state == SMC\_INIT && !smc->connect\_nonblock) {- smc\_switch\_to\_fallback(smc, SMC\_CLC\_DECL\_OPTUNSUPP);+ rc = smc\_switch\_to\_fallback(smc, SMC\_CLC\_DECL\_OPTUNSUPP); } else { rc = -EINVAL; }@@ -2511,13 +2540,23 @@ static int smc\_getsockopt(struct socket \*sock, int level, int optname, char \_\_user \*optval, int \_\_user \*optlen) { struct smc\_sock \*smc;+ int rc;  smc = smc\_sk(sock->sk);+ mutex\_lock(&smc->clcsock\_release\_lock);+ if (!smc->clcsock) {+ mutex\_unlock(&smc->clcsock\_release\_lock);+ return -EBADF;+ } /\* socket options apply to the CLC socket \*/- if (unlikely(!smc->clcsock->ops->getsockopt))+ if (unlikely(!smc->clcsock->ops->getsockopt)) {+ mutex\_unlock(&smc->clcsock\_release\_lock); return -EOPNOTSUPP;- return smc->clcsock->ops->getsockopt(smc->clcsock, level, optname,- optval, optlen);+ }+ rc = smc->clcsock->ops->getsockopt(smc->clcsock, level, optname,+ optval, optlen);+ mutex\_unlock(&smc->clcsock\_release\_lock);+ return rc; }  static int smc\_ioctl(struct socket \*sock, unsigned int cmd, |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:50:15 +0000

