=== Content from git.kernel.org_34a88014_20250111_020522.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2024-03-15 19:47:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-11 12:51:07 +0200 |
| commit | [dec987fe2df670827eb53b97c9552ed8dfc63ad4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)) | |
| tree | [33d1a47021c9a3491c57118f9f9f3d0d9ea2f6fd](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) | |
| parent | [86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4&id2=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a)) | |
| download | [linux-dec987fe2df670827eb53b97c9552ed8dfc63ad4.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-dec987fe2df670827eb53b97c9552ed8dfc63ad4.tar.gz) | |

vhost\_task: Handle SIGKILL by flushing work and exiting[ Upstream commit db5247d9bf5c6ade9fd70b4e4897441e0269b233 ]
Instead of lingering until the device is closed, this has us handle
SIGKILL by:
1. marking the worker as killed so we no longer try to use it with
new virtqueues and new flush operations.
2. setting the virtqueue to worker mapping so no new works are queued.
3. running all the exiting works.
Suggested-by: Edward Adam Davis <eadavis@qq.com>
Reported-and-tested-by: syzbot+98edc2df894917b3431f@syzkaller.appspotmail.com
Message-Id: <tencent\_546DA49414E876EEBECF2C78D26D242EE50A@qq.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Message-Id: <20240316004707.45557-9-michael.christie@oracle.com>
Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)

| -rw-r--r-- | [drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.c?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) | 54 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.h?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/sched/vhost_task.h?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/vhost_task.c?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4) | 53 | |  |  |  | | --- | --- | --- | |

4 files changed, 88 insertions, 24 deletions

| diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.cindex 5580b249340153..1740a5f1f35e7c 100644--- a/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a)+++ b/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)@@ -285,7 +285,7 @@ static void \_\_vhost\_worker\_flush(struct vhost\_worker \*worker) { struct vhost\_flush\_struct flush; - if (!worker->attachment\_cnt)+ if (!worker->attachment\_cnt || worker->killed) return;  init\_completion(&flush.wait\_event);@@ -400,7 +400,7 @@ static void vhost\_vq\_reset(struct vhost\_dev \*dev, \_\_vhost\_vq\_meta\_reset(vq); } -static bool vhost\_worker(void \*data)+static bool vhost\_run\_work\_list(void \*data) { struct vhost\_worker \*worker = data; struct vhost\_work \*work, \*work\_next;@@ -425,6 +425,40 @@ static bool vhost\_worker(void \*data) return !!node; } +static void vhost\_worker\_killed(void \*data)+{+ struct vhost\_worker \*worker = data;+ struct vhost\_dev \*dev = worker->dev;+ struct vhost\_virtqueue \*vq;+ int i, attach\_cnt = 0;++ mutex\_lock(&worker->mutex);+ worker->killed = true;++ for (i = 0; i < dev->nvqs; i++) {+ vq = dev->vqs[i];++ mutex\_lock(&vq->mutex);+ if (worker ==+ rcu\_dereference\_check(vq->worker,+ lockdep\_is\_held(&vq->mutex))) {+ rcu\_assign\_pointer(vq->worker, NULL);+ attach\_cnt++;+ }+ mutex\_unlock(&vq->mutex);+ }++ worker->attachment\_cnt -= attach\_cnt;+ if (attach\_cnt)+ synchronize\_rcu();+ /\*+ \* Finish vhost\_worker\_flush calls and any other works that snuck in+ \* before the synchronize\_rcu.+ \*/+ vhost\_run\_work\_list(worker);+ mutex\_unlock(&worker->mutex);+}+ static void vhost\_vq\_free\_iovecs(struct vhost\_virtqueue \*vq) { kfree(vq->indirect);@@ -639,9 +673,11 @@ static struct vhost\_worker \*vhost\_worker\_create(struct vhost\_dev \*dev) if (!worker) return NULL; + worker->dev = dev; snprintf(name, sizeof(name), "vhost-%d", current->pid); - vtsk = vhost\_task\_create(vhost\_worker, worker, name);+ vtsk = vhost\_task\_create(vhost\_run\_work\_list, vhost\_worker\_killed,+ worker, name); if (!vtsk) goto free\_worker; @@ -673,6 +709,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, struct vhost\_worker \*old\_worker;  mutex\_lock(&worker->mutex);+ if (worker->killed) {+ mutex\_unlock(&worker->mutex);+ return;+ }+ mutex\_lock(&vq->mutex);  old\_worker = rcu\_dereference\_check(vq->worker,@@ -693,6 +734,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, \* device wide flushes which doesn't use RCU for execution. \*/ mutex\_lock(&old\_worker->mutex);+ if (old\_worker->killed) {+ mutex\_unlock(&old\_worker->mutex);+ return;+ }+ /\* \* We don't want to call synchronize\_rcu for every vq during setup \* because it will slow down VM startup. If we haven't done@@ -770,7 +816,7 @@ static int vhost\_free\_worker(struct vhost\_dev \*dev, return -ENODEV;  mutex\_lock(&worker->mutex);- if (worker->attachment\_cnt) {+ if (worker->attachment\_cnt || worker->killed) { mutex\_unlock(&worker->mutex); return -EBUSY; }diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.hindex 9e942fcda5c3f7..dc94e6a7d3c22e 100644--- a/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a)+++ b/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)@@ -28,12 +28,14 @@ struct vhost\_work {  struct vhost\_worker { struct vhost\_task \*vtsk;+ struct vhost\_dev \*dev; /\* Used to serialize device wide flushing with worker swapping. \*/ struct mutex mutex; struct llist\_head work\_list; u64 kcov\_handle; u32 id; int attachment\_cnt;+ bool killed; };  /\* Poll a file (eventfd or socket) \*/diff --git a/include/linux/sched/vhost\_task.h b/include/linux/sched/vhost\_task.hindex bc60243d43b361..25446c5d35081a 100644--- a/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a)+++ b/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)@@ -4,7 +4,8 @@  struct vhost\_task; -struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_kill)(void \*), void \*arg, const char \*name); void vhost\_task\_start(struct vhost\_task \*vtsk); void vhost\_task\_stop(struct vhost\_task \*vtsk);diff --git a/kernel/vhost\_task.c b/kernel/vhost\_task.cindex da35e5b7f04738..8800f5acc00717 100644--- a/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=86d615ff5b912fbcf5870c37b3e079ab1ebe5c3a)+++ b/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=dec987fe2df670827eb53b97c9552ed8dfc63ad4)@@ -10,38 +10,32 @@  enum vhost\_task\_flags { VHOST\_TASK\_FLAGS\_STOP,+ VHOST\_TASK\_FLAGS\_KILLED, };  struct vhost\_task { bool (\*fn)(void \*data);+ void (\*handle\_sigkill)(void \*data); void \*data; struct completion exited; unsigned long flags; struct task\_struct \*task;+ /\* serialize SIGKILL and vhost\_task\_stop calls \*/+ struct mutex exit\_mutex; };  static int vhost\_task\_fn(void \*data) { struct vhost\_task \*vtsk = data;- bool dead = false;  for (;;) { bool did\_work; - if (!dead && signal\_pending(current)) {+ if (signal\_pending(current)) { struct ksignal ksig;- /\*- \* Calling get\_signal will block in SIGSTOP,- \* or clear fatal\_signal\_pending, but remember- \* what was set.- \*- \* This thread won't actually exit until all- \* of the file descriptors are closed, and- \* the release function is called.- \*/- dead = get\_signal(&ksig);- if (dead)- clear\_thread\_flag(TIF\_SIGPENDING);++ if (get\_signal(&ksig))+ break; }  /\* mb paired w/ vhost\_task\_stop \*/@@ -57,7 +51,19 @@ static int vhost\_task\_fn(void \*data) schedule(); } + mutex\_lock(&vtsk->exit\_mutex);+ /\*+ \* If a vhost\_task\_stop and SIGKILL race, we can ignore the SIGKILL.+ \* When the vhost layer has called vhost\_task\_stop it's already stopped+ \* new work and flushed.+ \*/+ if (!test\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags);+ vtsk->handle\_sigkill(vtsk->data);+ }+ mutex\_unlock(&vtsk->exit\_mutex); complete(&vtsk->exited);+ do\_exit(0); } @@ -78,12 +84,17 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_wake); \* @vtsk: vhost\_task to stop \* \* vhost\_task\_fn ensures the worker thread exits after- \* VHOST\_TASK\_FLAGS\_SOP becomes true.+ \* VHOST\_TASK\_FLAGS\_STOP becomes true. \*/ void vhost\_task\_stop(struct vhost\_task \*vtsk) {- set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);- vhost\_task\_wake(vtsk);+ mutex\_lock(&vtsk->exit\_mutex);+ if (!test\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);+ vhost\_task\_wake(vtsk);+ }+ mutex\_unlock(&vtsk->exit\_mutex);+ /\* \* Make sure vhost\_task\_fn is no longer accessing the vhost\_task before \* freeing it below.@@ -96,14 +107,16 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_stop); /\*\* \* vhost\_task\_create - create a copy of a task to be used by the kernel \* @fn: vhost worker function- \* @arg: data to be passed to fn+ \* @handle\_sigkill: vhost function to handle when we are killed+ \* @arg: data to be passed to fn and handled\_kill \* @name: the thread's name \* \* This returns a specialized task for use by the vhost layer or NULL on \* failure. The returned task is inactive, and the caller must fire it up \* through vhost\_task\_start(). \*/-struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_sigkill)(void \*), void \*arg, const char \*name) { struct kernel\_clone\_args args = {@@ -122,8 +135,10 @@ struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg, if (!vtsk) return NULL; init\_completion(&vtsk->exited);+ mutex\_init(&vtsk->exit\_mutex); vtsk->data = arg; vtsk->fn = fn;+ vtsk->handle\_sigkill = handle\_sigkill;  args.fn\_arg = vtsk; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:04:00 +0000



=== Content from git.kernel.org_2fed664f_20250111_020521.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2024-03-15 19:47:06 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-07-11 12:49:10 +0200 |
| commit | [abe067dc3a662eef7d5cddbbc41ed50a0b68b0af](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)) | |
| tree | [5b8c3c1a2e9c3f36c028a36485cf4509400457b9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) | |
| parent | [f5bb72196f4905f8c5470f2d9f26302c8616e2b6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f5bb72196f4905f8c5470f2d9f26302c8616e2b6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af&id2=f5bb72196f4905f8c5470f2d9f26302c8616e2b6)) | |
| download | [linux-abe067dc3a662eef7d5cddbbc41ed50a0b68b0af.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-abe067dc3a662eef7d5cddbbc41ed50a0b68b0af.tar.gz) | |

vhost\_task: Handle SIGKILL by flushing work and exiting[ Upstream commit db5247d9bf5c6ade9fd70b4e4897441e0269b233 ]
Instead of lingering until the device is closed, this has us handle
SIGKILL by:
1. marking the worker as killed so we no longer try to use it with
new virtqueues and new flush operations.
2. setting the virtqueue to worker mapping so no new works are queued.
3. running all the exiting works.
Suggested-by: Edward Adam Davis <eadavis@qq.com>
Reported-and-tested-by: syzbot+98edc2df894917b3431f@syzkaller.appspotmail.com
Message-Id: <tencent\_546DA49414E876EEBECF2C78D26D242EE50A@qq.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Message-Id: <20240316004707.45557-9-michael.christie@oracle.com>
Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)

| -rw-r--r-- | [drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.c?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) | 54 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.h?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/sched/vhost_task.h?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/vhost_task.c?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af) | 53 | |  |  |  | | --- | --- | --- | |

4 files changed, 88 insertions, 24 deletions

| diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.cindex 069c8a23bff9e7..d0238bd741b089 100644--- a/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=f5bb72196f4905f8c5470f2d9f26302c8616e2b6)+++ b/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)@@ -285,7 +285,7 @@ static void \_\_vhost\_worker\_flush(struct vhost\_worker \*worker) { struct vhost\_flush\_struct flush; - if (!worker->attachment\_cnt)+ if (!worker->attachment\_cnt || worker->killed) return;  init\_completion(&flush.wait\_event);@@ -400,7 +400,7 @@ static void vhost\_vq\_reset(struct vhost\_dev \*dev, \_\_vhost\_vq\_meta\_reset(vq); } -static bool vhost\_worker(void \*data)+static bool vhost\_run\_work\_list(void \*data) { struct vhost\_worker \*worker = data; struct vhost\_work \*work, \*work\_next;@@ -425,6 +425,40 @@ static bool vhost\_worker(void \*data) return !!node; } +static void vhost\_worker\_killed(void \*data)+{+ struct vhost\_worker \*worker = data;+ struct vhost\_dev \*dev = worker->dev;+ struct vhost\_virtqueue \*vq;+ int i, attach\_cnt = 0;++ mutex\_lock(&worker->mutex);+ worker->killed = true;++ for (i = 0; i < dev->nvqs; i++) {+ vq = dev->vqs[i];++ mutex\_lock(&vq->mutex);+ if (worker ==+ rcu\_dereference\_check(vq->worker,+ lockdep\_is\_held(&vq->mutex))) {+ rcu\_assign\_pointer(vq->worker, NULL);+ attach\_cnt++;+ }+ mutex\_unlock(&vq->mutex);+ }++ worker->attachment\_cnt -= attach\_cnt;+ if (attach\_cnt)+ synchronize\_rcu();+ /\*+ \* Finish vhost\_worker\_flush calls and any other works that snuck in+ \* before the synchronize\_rcu.+ \*/+ vhost\_run\_work\_list(worker);+ mutex\_unlock(&worker->mutex);+}+ static void vhost\_vq\_free\_iovecs(struct vhost\_virtqueue \*vq) { kfree(vq->indirect);@@ -639,9 +673,11 @@ static struct vhost\_worker \*vhost\_worker\_create(struct vhost\_dev \*dev) if (!worker) return NULL; + worker->dev = dev; snprintf(name, sizeof(name), "vhost-%d", current->pid); - vtsk = vhost\_task\_create(vhost\_worker, worker, name);+ vtsk = vhost\_task\_create(vhost\_run\_work\_list, vhost\_worker\_killed,+ worker, name); if (!vtsk) goto free\_worker; @@ -673,6 +709,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, struct vhost\_worker \*old\_worker;  mutex\_lock(&worker->mutex);+ if (worker->killed) {+ mutex\_unlock(&worker->mutex);+ return;+ }+ mutex\_lock(&vq->mutex);  old\_worker = rcu\_dereference\_check(vq->worker,@@ -693,6 +734,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, \* device wide flushes which doesn't use RCU for execution. \*/ mutex\_lock(&old\_worker->mutex);+ if (old\_worker->killed) {+ mutex\_unlock(&old\_worker->mutex);+ return;+ }+ /\* \* We don't want to call synchronize\_rcu for every vq during setup \* because it will slow down VM startup. If we haven't done@@ -770,7 +816,7 @@ static int vhost\_free\_worker(struct vhost\_dev \*dev, return -ENODEV;  mutex\_lock(&worker->mutex);- if (worker->attachment\_cnt) {+ if (worker->attachment\_cnt || worker->killed) { mutex\_unlock(&worker->mutex); return -EBUSY; }diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.hindex f60d5f7bef944e..8014d2b3595039 100644--- a/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=f5bb72196f4905f8c5470f2d9f26302c8616e2b6)+++ b/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)@@ -28,12 +28,14 @@ struct vhost\_work {  struct vhost\_worker { struct vhost\_task \*vtsk;+ struct vhost\_dev \*dev; /\* Used to serialize device wide flushing with worker swapping. \*/ struct mutex mutex; struct llist\_head work\_list; u64 kcov\_handle; u32 id; int attachment\_cnt;+ bool killed; };  /\* Poll a file (eventfd or socket) \*/diff --git a/include/linux/sched/vhost\_task.h b/include/linux/sched/vhost\_task.hindex 837a23624a66a3..3612de6ea1c5d4 100644--- a/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=f5bb72196f4905f8c5470f2d9f26302c8616e2b6)+++ b/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)@@ -5,7 +5,8 @@  struct vhost\_task; -struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_kill)(void \*), void \*arg, const char \*name); void vhost\_task\_start(struct vhost\_task \*vtsk); void vhost\_task\_stop(struct vhost\_task \*vtsk);diff --git a/kernel/vhost\_task.c b/kernel/vhost\_task.cindex da35e5b7f04738..8800f5acc00717 100644--- a/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=f5bb72196f4905f8c5470f2d9f26302c8616e2b6)+++ b/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=abe067dc3a662eef7d5cddbbc41ed50a0b68b0af)@@ -10,38 +10,32 @@  enum vhost\_task\_flags { VHOST\_TASK\_FLAGS\_STOP,+ VHOST\_TASK\_FLAGS\_KILLED, };  struct vhost\_task { bool (\*fn)(void \*data);+ void (\*handle\_sigkill)(void \*data); void \*data; struct completion exited; unsigned long flags; struct task\_struct \*task;+ /\* serialize SIGKILL and vhost\_task\_stop calls \*/+ struct mutex exit\_mutex; };  static int vhost\_task\_fn(void \*data) { struct vhost\_task \*vtsk = data;- bool dead = false;  for (;;) { bool did\_work; - if (!dead && signal\_pending(current)) {+ if (signal\_pending(current)) { struct ksignal ksig;- /\*- \* Calling get\_signal will block in SIGSTOP,- \* or clear fatal\_signal\_pending, but remember- \* what was set.- \*- \* This thread won't actually exit until all- \* of the file descriptors are closed, and- \* the release function is called.- \*/- dead = get\_signal(&ksig);- if (dead)- clear\_thread\_flag(TIF\_SIGPENDING);++ if (get\_signal(&ksig))+ break; }  /\* mb paired w/ vhost\_task\_stop \*/@@ -57,7 +51,19 @@ static int vhost\_task\_fn(void \*data) schedule(); } + mutex\_lock(&vtsk->exit\_mutex);+ /\*+ \* If a vhost\_task\_stop and SIGKILL race, we can ignore the SIGKILL.+ \* When the vhost layer has called vhost\_task\_stop it's already stopped+ \* new work and flushed.+ \*/+ if (!test\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags);+ vtsk->handle\_sigkill(vtsk->data);+ }+ mutex\_unlock(&vtsk->exit\_mutex); complete(&vtsk->exited);+ do\_exit(0); } @@ -78,12 +84,17 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_wake); \* @vtsk: vhost\_task to stop \* \* vhost\_task\_fn ensures the worker thread exits after- \* VHOST\_TASK\_FLAGS\_SOP becomes true.+ \* VHOST\_TASK\_FLAGS\_STOP becomes true. \*/ void vhost\_task\_stop(struct vhost\_task \*vtsk) {- set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);- vhost\_task\_wake(vtsk);+ mutex\_lock(&vtsk->exit\_mutex);+ if (!test\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);+ vhost\_task\_wake(vtsk);+ }+ mutex\_unlock(&vtsk->exit\_mutex);+ /\* \* Make sure vhost\_task\_fn is no longer accessing the vhost\_task before \* freeing it below.@@ -96,14 +107,16 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_stop); /\*\* \* vhost\_task\_create - create a copy of a task to be used by the kernel \* @fn: vhost worker function- \* @arg: data to be passed to fn+ \* @handle\_sigkill: vhost function to handle when we are killed+ \* @arg: data to be passed to fn and handled\_kill \* @name: the thread's name \* \* This returns a specialized task for use by the vhost layer or NULL on \* failure. The returned task is inactive, and the caller must fire it up \* through vhost\_task\_start(). \*/-struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_sigkill)(void \*), void \*arg, const char \*name) { struct kernel\_clone\_args args = {@@ -122,8 +135,10 @@ struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg, if (!vtsk) return NULL; init\_completion(&vtsk->exited);+ mutex\_init(&vtsk->exit\_mutex); vtsk->data = arg; vtsk->fn = fn;+ vtsk->handle\_sigkill = handle\_sigkill;  args.fn\_arg = vtsk; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:03:58 +0000



=== Content from git.kernel.org_b75e6809_20250111_020522.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Mike Christie <michael.christie@oracle.com> | 2024-03-15 19:47:06 -0500 |
| --- | --- | --- |
| committer | Michael S. Tsirkin <mst@redhat.com> | 2024-05-22 08:31:15 -0400 |
| commit | [db5247d9bf5c6ade9fd70b4e4897441e0269b233](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)) | |
| tree | [cfec480a97ddaaf073d69cf6ed272a2edf18ecb4](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) | |
| parent | [ba704ff4e142fd3cfaf3379dd3b3b946754e06e3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233&id2=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3)) | |
| download | [linux-db5247d9bf5c6ade9fd70b4e4897441e0269b233.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-db5247d9bf5c6ade9fd70b4e4897441e0269b233.tar.gz) | |

vhost\_task: Handle SIGKILL by flushing work and exitingInstead of lingering until the device is closed, this has us handle
SIGKILL by:
1. marking the worker as killed so we no longer try to use it with
new virtqueues and new flush operations.
2. setting the virtqueue to worker mapping so no new works are queued.
3. running all the exiting works.
Suggested-by: Edward Adam Davis <eadavis@qq.com>
Reported-and-tested-by: syzbot+98edc2df894917b3431f@syzkaller.appspotmail.com
Message-Id: <tencent\_546DA49414E876EEBECF2C78D26D242EE50A@qq.com>
Signed-off-by: Mike Christie <michael.christie@oracle.com>
Message-Id: <20240316004707.45557-9-michael.christie@oracle.com>
Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)

| -rw-r--r-- | [drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.c?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) | 54 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vhost/vhost.h?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/sched/vhost_task.h?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/vhost_task.c?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233) | 53 | |  |  |  | | --- | --- | --- | |

4 files changed, 88 insertions, 24 deletions

| diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.cindex c6448ff3776830..b609556824748f 100644--- a/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3)+++ b/[drivers/vhost/vhost.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.c?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)@@ -273,7 +273,7 @@ static void \_\_vhost\_worker\_flush(struct vhost\_worker \*worker) { struct vhost\_flush\_struct flush; - if (!worker->attachment\_cnt)+ if (!worker->attachment\_cnt || worker->killed) return;  init\_completion(&flush.wait\_event);@@ -388,7 +388,7 @@ static void vhost\_vq\_reset(struct vhost\_dev \*dev, \_\_vhost\_vq\_meta\_reset(vq); } -static bool vhost\_worker(void \*data)+static bool vhost\_run\_work\_list(void \*data) { struct vhost\_worker \*worker = data; struct vhost\_work \*work, \*work\_next;@@ -413,6 +413,40 @@ static bool vhost\_worker(void \*data) return !!node; } +static void vhost\_worker\_killed(void \*data)+{+ struct vhost\_worker \*worker = data;+ struct vhost\_dev \*dev = worker->dev;+ struct vhost\_virtqueue \*vq;+ int i, attach\_cnt = 0;++ mutex\_lock(&worker->mutex);+ worker->killed = true;++ for (i = 0; i < dev->nvqs; i++) {+ vq = dev->vqs[i];++ mutex\_lock(&vq->mutex);+ if (worker ==+ rcu\_dereference\_check(vq->worker,+ lockdep\_is\_held(&vq->mutex))) {+ rcu\_assign\_pointer(vq->worker, NULL);+ attach\_cnt++;+ }+ mutex\_unlock(&vq->mutex);+ }++ worker->attachment\_cnt -= attach\_cnt;+ if (attach\_cnt)+ synchronize\_rcu();+ /\*+ \* Finish vhost\_worker\_flush calls and any other works that snuck in+ \* before the synchronize\_rcu.+ \*/+ vhost\_run\_work\_list(worker);+ mutex\_unlock(&worker->mutex);+}+ static void vhost\_vq\_free\_iovecs(struct vhost\_virtqueue \*vq) { kfree(vq->indirect);@@ -627,9 +661,11 @@ static struct vhost\_worker \*vhost\_worker\_create(struct vhost\_dev \*dev) if (!worker) return NULL; + worker->dev = dev; snprintf(name, sizeof(name), "vhost-%d", current->pid); - vtsk = vhost\_task\_create(vhost\_worker, worker, name);+ vtsk = vhost\_task\_create(vhost\_run\_work\_list, vhost\_worker\_killed,+ worker, name); if (!vtsk) goto free\_worker; @@ -661,6 +697,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, struct vhost\_worker \*old\_worker;  mutex\_lock(&worker->mutex);+ if (worker->killed) {+ mutex\_unlock(&worker->mutex);+ return;+ }+ mutex\_lock(&vq->mutex);  old\_worker = rcu\_dereference\_check(vq->worker,@@ -681,6 +722,11 @@ static void \_\_vhost\_vq\_attach\_worker(struct vhost\_virtqueue \*vq, \* device wide flushes which doesn't use RCU for execution. \*/ mutex\_lock(&old\_worker->mutex);+ if (old\_worker->killed) {+ mutex\_unlock(&old\_worker->mutex);+ return;+ }+ /\* \* We don't want to call synchronize\_rcu for every vq during setup \* because it will slow down VM startup. If we haven't done@@ -758,7 +804,7 @@ static int vhost\_free\_worker(struct vhost\_dev \*dev, return -ENODEV;  mutex\_lock(&worker->mutex);- if (worker->attachment\_cnt) {+ if (worker->attachment\_cnt || worker->killed) { mutex\_unlock(&worker->mutex); return -EBUSY; }diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.hindex 91ade037f08e6c..bb75a292d50cd3 100644--- a/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3)+++ b/[drivers/vhost/vhost.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vhost/vhost.h?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)@@ -28,12 +28,14 @@ struct vhost\_work {  struct vhost\_worker { struct vhost\_task \*vtsk;+ struct vhost\_dev \*dev; /\* Used to serialize device wide flushing with worker swapping. \*/ struct mutex mutex; struct llist\_head work\_list; u64 kcov\_handle; u32 id; int attachment\_cnt;+ bool killed; };  /\* Poll a file (eventfd or socket) \*/diff --git a/include/linux/sched/vhost\_task.h b/include/linux/sched/vhost\_task.hindex bc60243d43b361..25446c5d35081a 100644--- a/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3)+++ b/[include/linux/sched/vhost\_task.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sched/vhost_task.h?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)@@ -4,7 +4,8 @@  struct vhost\_task; -struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_kill)(void \*), void \*arg, const char \*name); void vhost\_task\_start(struct vhost\_task \*vtsk); void vhost\_task\_stop(struct vhost\_task \*vtsk);diff --git a/kernel/vhost\_task.c b/kernel/vhost\_task.cindex da35e5b7f04738..8800f5acc00717 100644--- a/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=ba704ff4e142fd3cfaf3379dd3b3b946754e06e3)+++ b/[kernel/vhost\_task.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/vhost_task.c?id=db5247d9bf5c6ade9fd70b4e4897441e0269b233)@@ -10,38 +10,32 @@  enum vhost\_task\_flags { VHOST\_TASK\_FLAGS\_STOP,+ VHOST\_TASK\_FLAGS\_KILLED, };  struct vhost\_task { bool (\*fn)(void \*data);+ void (\*handle\_sigkill)(void \*data); void \*data; struct completion exited; unsigned long flags; struct task\_struct \*task;+ /\* serialize SIGKILL and vhost\_task\_stop calls \*/+ struct mutex exit\_mutex; };  static int vhost\_task\_fn(void \*data) { struct vhost\_task \*vtsk = data;- bool dead = false;  for (;;) { bool did\_work; - if (!dead && signal\_pending(current)) {+ if (signal\_pending(current)) { struct ksignal ksig;- /\*- \* Calling get\_signal will block in SIGSTOP,- \* or clear fatal\_signal\_pending, but remember- \* what was set.- \*- \* This thread won't actually exit until all- \* of the file descriptors are closed, and- \* the release function is called.- \*/- dead = get\_signal(&ksig);- if (dead)- clear\_thread\_flag(TIF\_SIGPENDING);++ if (get\_signal(&ksig))+ break; }  /\* mb paired w/ vhost\_task\_stop \*/@@ -57,7 +51,19 @@ static int vhost\_task\_fn(void \*data) schedule(); } + mutex\_lock(&vtsk->exit\_mutex);+ /\*+ \* If a vhost\_task\_stop and SIGKILL race, we can ignore the SIGKILL.+ \* When the vhost layer has called vhost\_task\_stop it's already stopped+ \* new work and flushed.+ \*/+ if (!test\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags);+ vtsk->handle\_sigkill(vtsk->data);+ }+ mutex\_unlock(&vtsk->exit\_mutex); complete(&vtsk->exited);+ do\_exit(0); } @@ -78,12 +84,17 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_wake); \* @vtsk: vhost\_task to stop \* \* vhost\_task\_fn ensures the worker thread exits after- \* VHOST\_TASK\_FLAGS\_SOP becomes true.+ \* VHOST\_TASK\_FLAGS\_STOP becomes true. \*/ void vhost\_task\_stop(struct vhost\_task \*vtsk) {- set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);- vhost\_task\_wake(vtsk);+ mutex\_lock(&vtsk->exit\_mutex);+ if (!test\_bit(VHOST\_TASK\_FLAGS\_KILLED, &vtsk->flags)) {+ set\_bit(VHOST\_TASK\_FLAGS\_STOP, &vtsk->flags);+ vhost\_task\_wake(vtsk);+ }+ mutex\_unlock(&vtsk->exit\_mutex);+ /\* \* Make sure vhost\_task\_fn is no longer accessing the vhost\_task before \* freeing it below.@@ -96,14 +107,16 @@ EXPORT\_SYMBOL\_GPL(vhost\_task\_stop); /\*\* \* vhost\_task\_create - create a copy of a task to be used by the kernel \* @fn: vhost worker function- \* @arg: data to be passed to fn+ \* @handle\_sigkill: vhost function to handle when we are killed+ \* @arg: data to be passed to fn and handled\_kill \* @name: the thread's name \* \* This returns a specialized task for use by the vhost layer or NULL on \* failure. The returned task is inactive, and the caller must fire it up \* through vhost\_task\_start(). \*/-struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg,+struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*),+ void (\*handle\_sigkill)(void \*), void \*arg, const char \*name) { struct kernel\_clone\_args args = {@@ -122,8 +135,10 @@ struct vhost\_task \*vhost\_task\_create(bool (\*fn)(void \*), void \*arg, if (!vtsk) return NULL; init\_completion(&vtsk->exited);+ mutex\_init(&vtsk->exit\_mutex); vtsk->data = arg; vtsk->fn = fn;+ vtsk->handle\_sigkill = handle\_sigkill;  args.fn\_arg = vtsk; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:03:59 +0000


