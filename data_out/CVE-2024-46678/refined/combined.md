=== Content from git.kernel.org_92b04bf1_20250110_204628.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jianbo Liu <jianbol@nvidia.com> | 2024-08-23 06:10:56 +0300 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-04 13:30:10 +0200 |
| commit | [56354b0a2c24a7828eeed7de4b4dc9652d9affa3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)) | |
| tree | [3965ea18fe5d7bd413bc5202fe2737b2dced0f40](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3) | |
| parent | [59405f89f799d59bed4fc5c6abed02d2473fb277](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=59405f89f799d59bed4fc5c6abed02d2473fb277) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3&id2=59405f89f799d59bed4fc5c6abed02d2473fb277)) | |
| download | [linux-56354b0a2c24a7828eeed7de4b4dc9652d9affa3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-56354b0a2c24a7828eeed7de4b4dc9652d9affa3.tar.gz) | |

bonding: change ipsec\_lock from spin lock to mutex[ Upstream commit 2aeeef906d5a526dc60cf4af92eda69836c39b1f ]
In the cited commit, bond->ipsec\_lock is added to protect ipsec\_list,
hence xdo\_dev\_state\_add and xdo\_dev\_state\_delete are called inside
this lock. As ipsec\_lock is a spin lock and such xfrmdev ops may sleep,
"scheduling while atomic" will be triggered when changing bond's
active slave.
[ 101.055189] BUG: scheduling while atomic: bash/902/0x00000200
[ 101.055726] Modules linked in:
[ 101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1
[ 101.058760] Hardware name:
[ 101.059434] Call Trace:
[ 101.059436] <TASK>
[ 101.060873] dump\_stack\_lvl+0x51/0x60
[ 101.061275] \_\_schedule\_bug+0x4e/0x60
[ 101.061682] \_\_schedule+0x612/0x7c0
[ 101.062078] ? \_\_mod\_timer+0x25c/0x370
[ 101.062486] schedule+0x25/0xd0
[ 101.062845] schedule\_timeout+0x77/0xf0
[ 101.063265] ? asm\_common\_interrupt+0x22/0x40
[ 101.063724] ? \_\_bpf\_trace\_itimer\_state+0x10/0x10
[ 101.064215] \_\_wait\_for\_common+0x87/0x190
[ 101.064648] ? usleep\_range\_state+0x90/0x90
[ 101.065091] cmd\_exec+0x437/0xb20 [mlx5\_core]
[ 101.065569] mlx5\_cmd\_do+0x1e/0x40 [mlx5\_core]
[ 101.066051] mlx5\_cmd\_exec+0x18/0x30 [mlx5\_core]
[ 101.066552] mlx5\_crypto\_create\_dek\_key+0xea/0x120 [mlx5\_core]
[ 101.067163] ? bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.067738] ? kmalloc\_trace+0x4d/0x350
[ 101.068156] mlx5\_ipsec\_create\_sa\_ctx+0x33/0x100 [mlx5\_core]
[ 101.068747] mlx5e\_xfrm\_add\_state+0x47b/0xaa0 [mlx5\_core]
[ 101.069312] bond\_change\_active\_slave+0x392/0x900 [bonding]
[ 101.069868] bond\_option\_active\_slave\_set+0x1c2/0x240 [bonding]
[ 101.070454] \_\_bond\_opt\_set+0xa6/0x430 [bonding]
[ 101.070935] \_\_bond\_opt\_set\_notify+0x2f/0x90 [bonding]
[ 101.071453] bond\_opt\_tryset\_rtnl+0x72/0xb0 [bonding]
[ 101.071965] bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.072567] kernfs\_fop\_write\_iter+0x10c/0x1a0
[ 101.073033] vfs\_write+0x2d8/0x400
[ 101.073416] ? alloc\_fd+0x48/0x180
[ 101.073798] ksys\_write+0x5f/0xe0
[ 101.074175] do\_syscall\_64+0x52/0x110
[ 101.074576] entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
As bond\_ipsec\_add\_sa\_all and bond\_ipsec\_del\_sa\_all are only called
from bond\_change\_active\_slave, which requires holding the RTNL lock.
And bond\_ipsec\_add\_sa and bond\_ipsec\_del\_sa are xfrm state
xdo\_dev\_state\_add and xdo\_dev\_state\_delete APIs, which are in user
context. So ipsec\_lock doesn't have to be spin lock, change it to
mutex, and thus the above issue can be resolved.
Fixes: 9a5605505d9c ("bonding: Add struct bond\_ipesc to manage SA")
Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
Reviewed-by: Hangbin Liu <liuhangbin@gmail.com>
Acked-by: Jay Vosburgh <jv@jvosburgh.net>
Link: [https://patch.msgid.link/20240823031056.110999-4-jianbol@nvidia.com](https://patch.msgid.link/20240823031056.110999-4-jianbol%40nvidia.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)

| -rw-r--r-- | [drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/bonding/bond_main.c?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3) | 79 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/bonding.h?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 44 insertions, 37 deletions

| diff --git a/drivers/net/bonding/bond\_main.c b/drivers/net/bonding/bond\_main.cindex e6416bbaf1bf60..60db34095a2557 100644--- a/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=59405f89f799d59bed4fc5c6abed02d2473fb277)+++ b/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)@@ -428,6 +428,7 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -439,24 +440,26 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();- return -ENODEV;+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();+ if (!real\_dev) {+ err = -ENODEV;+ goto out; } - real\_dev = slave->dev; if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) { NL\_SET\_ERR\_MSG\_MOD(extack, "Slave does not support ipsec offload");- rcu\_read\_unlock();- return -EINVAL;+ err = -EINVAL;+ goto out; } - ipsec = kmalloc(sizeof(\*ipsec), GFP\_ATOMIC);+ ipsec = kmalloc(sizeof(\*ipsec), GFP\_KERNEL); if (!ipsec) {- rcu\_read\_unlock();- return -ENOMEM;+ err = -ENOMEM;+ goto out; }  xs->xso.real\_dev = real\_dev;@@ -464,13 +467,14 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, if (!err) { ipsec->xs = xs; INIT\_LIST\_HEAD(&ipsec->list);- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_add(&ipsec->list, &bond->ipsec\_list);- spin\_unlock\_bh(&bond->ipsec\_lock);+ mutex\_unlock(&bond->ipsec\_lock); } else { kfree(ipsec); }- rcu\_read\_unlock();+out:+ netdev\_put(real\_dev, &tracker); return err; } @@ -481,35 +485,35 @@ static void bond\_ipsec\_add\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave)- goto out;+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev)+ return; - real\_dev = slave->dev;+ mutex\_lock(&bond->ipsec\_lock); if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) {- spin\_lock\_bh(&bond->ipsec\_lock); if (!list\_empty(&bond->ipsec\_list)) slave\_warn(bond\_dev, real\_dev, "%s: no slave xdo\_dev\_state\_add\n", \_\_func\_\_);- spin\_unlock\_bh(&bond->ipsec\_lock); goto out; } - spin\_lock\_bh(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) {+ /\* If new state is added before ipsec\_lock acquired \*/+ if (ipsec->xs->xso.real\_dev == real\_dev)+ continue;+ ipsec->xs->xso.real\_dev = real\_dev; if (real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add(ipsec->xs, NULL)) { slave\_warn(bond\_dev, real\_dev, "%s: failed to add SA\n", \_\_func\_\_); ipsec->xs->xso.real\_dev = NULL; } }- spin\_unlock\_bh(&bond->ipsec\_lock); out:- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  /\*\*@@ -520,6 +524,7 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -530,6 +535,9 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();  if (!slave) goto out;@@ -537,7 +545,6 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) if (!xs->xso.real\_dev) goto out; - real\_dev = slave->dev; WARN\_ON(xs->xso.real\_dev != real\_dev);  if (!real\_dev->xfrmdev\_ops ||@@ -549,7 +556,8 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs)  real\_dev->xfrmdev\_ops->xdo\_dev\_state\_delete(xs); out:- spin\_lock\_bh(&bond->ipsec\_lock);+ netdev\_put(real\_dev, &tracker);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (ipsec->xs == xs) { list\_del(&ipsec->list);@@ -557,8 +565,7 @@ out: break; } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond)@@ -568,15 +575,12 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev) return;- } - real\_dev = slave->dev;- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (!ipsec->xs->xso.real\_dev) continue;@@ -593,8 +597,7 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) real\_dev->xfrmdev\_ops->xdo\_dev\_state\_free(ipsec->xs); } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_free\_sa(struct xfrm\_state \*xs)@@ -5921,7 +5924,7 @@ void bond\_setup(struct net\_device \*bond\_dev) /\* set up xfrm device ops (only supported in active-backup right now) \*/ bond\_dev->xfrmdev\_ops = &bond\_xfrmdev\_ops; INIT\_LIST\_HEAD(&bond->ipsec\_list);- spin\_lock\_init(&bond->ipsec\_lock);+ mutex\_init(&bond->ipsec\_lock); #endif /\* CONFIG\_XFRM\_OFFLOAD \*/  /\* don't acquire bond device's netif\_tx\_lock when transmitting \*/@@ -5970,6 +5973,10 @@ static void bond\_uninit(struct net\_device \*bond\_dev) \_\_bond\_release\_one(bond\_dev, slave->dev, true, true); netdev\_info(bond\_dev, "Released all slaves\n"); +#ifdef CONFIG\_XFRM\_OFFLOAD+ mutex\_destroy(&bond->ipsec\_lock);+#endif /\* CONFIG\_XFRM\_OFFLOAD \*/+ bond\_set\_slave\_arr(bond, NULL, NULL);  list\_del\_rcu(&bond->bond\_list);diff --git a/include/net/bonding.h b/include/net/bonding.hindex b61fb1aa3a56b5..8bb5f016969f10 100644--- a/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=59405f89f799d59bed4fc5c6abed02d2473fb277)+++ b/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=56354b0a2c24a7828eeed7de4b4dc9652d9affa3)@@ -260,7 +260,7 @@ struct bonding { #ifdef CONFIG\_XFRM\_OFFLOAD struct list\_head ipsec\_list; /\* protecting ipsec\_list \*/- spinlock\_t ipsec\_lock;+ struct mutex ipsec\_lock; #endif /\* CONFIG\_XFRM\_OFFLOAD \*/ struct bpf\_prog \*xdp\_prog; }; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:45:05 +0000



=== Content from git.kernel.org_ec4ecd21_20250110_204627.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jianbo Liu <jianbol@nvidia.com> | 2024-08-23 06:10:56 +0300 |
| --- | --- | --- |
| committer | Jakub Kicinski <kuba@kernel.org> | 2024-08-27 13:11:37 -0700 |
| commit | [2aeeef906d5a526dc60cf4af92eda69836c39b1f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)) | |
| tree | [1843c88b7e4389cc5f9c255a14746df945419649](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f) | |
| parent | [907ed83a7583e8ffede88c5ac088392701a7d458](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=907ed83a7583e8ffede88c5ac088392701a7d458) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f&id2=907ed83a7583e8ffede88c5ac088392701a7d458)) | |
| download | [linux-2aeeef906d5a526dc60cf4af92eda69836c39b1f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-2aeeef906d5a526dc60cf4af92eda69836c39b1f.tar.gz) | |

bonding: change ipsec\_lock from spin lock to mutexIn the cited commit, bond->ipsec\_lock is added to protect ipsec\_list,
hence xdo\_dev\_state\_add and xdo\_dev\_state\_delete are called inside
this lock. As ipsec\_lock is a spin lock and such xfrmdev ops may sleep,
"scheduling while atomic" will be triggered when changing bond's
active slave.
[ 101.055189] BUG: scheduling while atomic: bash/902/0x00000200
[ 101.055726] Modules linked in:
[ 101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1
[ 101.058760] Hardware name:
[ 101.059434] Call Trace:
[ 101.059436] <TASK>
[ 101.060873] dump\_stack\_lvl+0x51/0x60
[ 101.061275] \_\_schedule\_bug+0x4e/0x60
[ 101.061682] \_\_schedule+0x612/0x7c0
[ 101.062078] ? \_\_mod\_timer+0x25c/0x370
[ 101.062486] schedule+0x25/0xd0
[ 101.062845] schedule\_timeout+0x77/0xf0
[ 101.063265] ? asm\_common\_interrupt+0x22/0x40
[ 101.063724] ? \_\_bpf\_trace\_itimer\_state+0x10/0x10
[ 101.064215] \_\_wait\_for\_common+0x87/0x190
[ 101.064648] ? usleep\_range\_state+0x90/0x90
[ 101.065091] cmd\_exec+0x437/0xb20 [mlx5\_core]
[ 101.065569] mlx5\_cmd\_do+0x1e/0x40 [mlx5\_core]
[ 101.066051] mlx5\_cmd\_exec+0x18/0x30 [mlx5\_core]
[ 101.066552] mlx5\_crypto\_create\_dek\_key+0xea/0x120 [mlx5\_core]
[ 101.067163] ? bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.067738] ? kmalloc\_trace+0x4d/0x350
[ 101.068156] mlx5\_ipsec\_create\_sa\_ctx+0x33/0x100 [mlx5\_core]
[ 101.068747] mlx5e\_xfrm\_add\_state+0x47b/0xaa0 [mlx5\_core]
[ 101.069312] bond\_change\_active\_slave+0x392/0x900 [bonding]
[ 101.069868] bond\_option\_active\_slave\_set+0x1c2/0x240 [bonding]
[ 101.070454] \_\_bond\_opt\_set+0xa6/0x430 [bonding]
[ 101.070935] \_\_bond\_opt\_set\_notify+0x2f/0x90 [bonding]
[ 101.071453] bond\_opt\_tryset\_rtnl+0x72/0xb0 [bonding]
[ 101.071965] bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.072567] kernfs\_fop\_write\_iter+0x10c/0x1a0
[ 101.073033] vfs\_write+0x2d8/0x400
[ 101.073416] ? alloc\_fd+0x48/0x180
[ 101.073798] ksys\_write+0x5f/0xe0
[ 101.074175] do\_syscall\_64+0x52/0x110
[ 101.074576] entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
As bond\_ipsec\_add\_sa\_all and bond\_ipsec\_del\_sa\_all are only called
from bond\_change\_active\_slave, which requires holding the RTNL lock.
And bond\_ipsec\_add\_sa and bond\_ipsec\_del\_sa are xfrm state
xdo\_dev\_state\_add and xdo\_dev\_state\_delete APIs, which are in user
context. So ipsec\_lock doesn't have to be spin lock, change it to
mutex, and thus the above issue can be resolved.
Fixes: 9a5605505d9c ("bonding: Add struct bond\_ipesc to manage SA")
Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
Reviewed-by: Hangbin Liu <liuhangbin@gmail.com>
Acked-by: Jay Vosburgh <jv@jvosburgh.net>
Link: [https://patch.msgid.link/20240823031056.110999-4-jianbol@nvidia.com](https://patch.msgid.link/20240823031056.110999-4-jianbol%40nvidia.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)

| -rw-r--r-- | [drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/bonding/bond_main.c?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f) | 79 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/bonding.h?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 44 insertions, 37 deletions

| diff --git a/drivers/net/bonding/bond\_main.c b/drivers/net/bonding/bond\_main.cindex f9849174842091..bb9c3d6ef43592 100644--- a/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=907ed83a7583e8ffede88c5ac088392701a7d458)+++ b/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)@@ -428,6 +428,7 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -439,24 +440,26 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();- return -ENODEV;+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();+ if (!real\_dev) {+ err = -ENODEV;+ goto out; } - real\_dev = slave->dev; if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) { NL\_SET\_ERR\_MSG\_MOD(extack, "Slave does not support ipsec offload");- rcu\_read\_unlock();- return -EINVAL;+ err = -EINVAL;+ goto out; } - ipsec = kmalloc(sizeof(\*ipsec), GFP\_ATOMIC);+ ipsec = kmalloc(sizeof(\*ipsec), GFP\_KERNEL); if (!ipsec) {- rcu\_read\_unlock();- return -ENOMEM;+ err = -ENOMEM;+ goto out; }  xs->xso.real\_dev = real\_dev;@@ -464,13 +467,14 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, if (!err) { ipsec->xs = xs; INIT\_LIST\_HEAD(&ipsec->list);- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_add(&ipsec->list, &bond->ipsec\_list);- spin\_unlock\_bh(&bond->ipsec\_lock);+ mutex\_unlock(&bond->ipsec\_lock); } else { kfree(ipsec); }- rcu\_read\_unlock();+out:+ netdev\_put(real\_dev, &tracker); return err; } @@ -481,35 +485,35 @@ static void bond\_ipsec\_add\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave)- goto out;+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev)+ return; - real\_dev = slave->dev;+ mutex\_lock(&bond->ipsec\_lock); if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) {- spin\_lock\_bh(&bond->ipsec\_lock); if (!list\_empty(&bond->ipsec\_list)) slave\_warn(bond\_dev, real\_dev, "%s: no slave xdo\_dev\_state\_add\n", \_\_func\_\_);- spin\_unlock\_bh(&bond->ipsec\_lock); goto out; } - spin\_lock\_bh(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) {+ /\* If new state is added before ipsec\_lock acquired \*/+ if (ipsec->xs->xso.real\_dev == real\_dev)+ continue;+ ipsec->xs->xso.real\_dev = real\_dev; if (real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add(ipsec->xs, NULL)) { slave\_warn(bond\_dev, real\_dev, "%s: failed to add SA\n", \_\_func\_\_); ipsec->xs->xso.real\_dev = NULL; } }- spin\_unlock\_bh(&bond->ipsec\_lock); out:- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  /\*\*@@ -520,6 +524,7 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -530,6 +535,9 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();  if (!slave) goto out;@@ -537,7 +545,6 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) if (!xs->xso.real\_dev) goto out; - real\_dev = slave->dev; WARN\_ON(xs->xso.real\_dev != real\_dev);  if (!real\_dev->xfrmdev\_ops ||@@ -549,7 +556,8 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs)  real\_dev->xfrmdev\_ops->xdo\_dev\_state\_delete(xs); out:- spin\_lock\_bh(&bond->ipsec\_lock);+ netdev\_put(real\_dev, &tracker);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (ipsec->xs == xs) { list\_del(&ipsec->list);@@ -557,8 +565,7 @@ out: break; } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond)@@ -568,15 +575,12 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev) return;- } - real\_dev = slave->dev;- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (!ipsec->xs->xso.real\_dev) continue;@@ -593,8 +597,7 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) real\_dev->xfrmdev\_ops->xdo\_dev\_state\_free(ipsec->xs); } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_free\_sa(struct xfrm\_state \*xs)@@ -5921,7 +5924,7 @@ void bond\_setup(struct net\_device \*bond\_dev) /\* set up xfrm device ops (only supported in active-backup right now) \*/ bond\_dev->xfrmdev\_ops = &bond\_xfrmdev\_ops; INIT\_LIST\_HEAD(&bond->ipsec\_list);- spin\_lock\_init(&bond->ipsec\_lock);+ mutex\_init(&bond->ipsec\_lock); #endif /\* CONFIG\_XFRM\_OFFLOAD \*/  /\* don't acquire bond device's netif\_tx\_lock when transmitting \*/@@ -5970,6 +5973,10 @@ static void bond\_uninit(struct net\_device \*bond\_dev) \_\_bond\_release\_one(bond\_dev, slave->dev, true, true); netdev\_info(bond\_dev, "Released all slaves\n"); +#ifdef CONFIG\_XFRM\_OFFLOAD+ mutex\_destroy(&bond->ipsec\_lock);+#endif /\* CONFIG\_XFRM\_OFFLOAD \*/+ bond\_set\_slave\_arr(bond, NULL, NULL);  list\_del\_rcu(&bond->bond\_list);diff --git a/include/net/bonding.h b/include/net/bonding.hindex b61fb1aa3a56b5..8bb5f016969f10 100644--- a/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=907ed83a7583e8ffede88c5ac088392701a7d458)+++ b/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=2aeeef906d5a526dc60cf4af92eda69836c39b1f)@@ -260,7 +260,7 @@ struct bonding { #ifdef CONFIG\_XFRM\_OFFLOAD struct list\_head ipsec\_list; /\* protecting ipsec\_list \*/- spinlock\_t ipsec\_lock;+ struct mutex ipsec\_lock; #endif /\* CONFIG\_XFRM\_OFFLOAD \*/ struct bpf\_prog \*xdp\_prog; }; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:45:04 +0000



=== Content from git.kernel.org_a89b7fdd_20250110_204628.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jianbo Liu <jianbol@nvidia.com> | 2024-08-23 06:10:56 +0300 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-04 13:28:27 +0200 |
| commit | [6b598069164ac1bb60996d6ff94e7f9169dbd2d3](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)) | |
| tree | [b62b09256f35450e6da1057cb72b8a61cd91dc21](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3) | |
| parent | [19792758339b68e54946fb8e6d7781e1ce6048e2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=19792758339b68e54946fb8e6d7781e1ce6048e2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3&id2=19792758339b68e54946fb8e6d7781e1ce6048e2)) | |
| download | [linux-6b598069164ac1bb60996d6ff94e7f9169dbd2d3.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6b598069164ac1bb60996d6ff94e7f9169dbd2d3.tar.gz) | |

bonding: change ipsec\_lock from spin lock to mutex[ Upstream commit 2aeeef906d5a526dc60cf4af92eda69836c39b1f ]
In the cited commit, bond->ipsec\_lock is added to protect ipsec\_list,
hence xdo\_dev\_state\_add and xdo\_dev\_state\_delete are called inside
this lock. As ipsec\_lock is a spin lock and such xfrmdev ops may sleep,
"scheduling while atomic" will be triggered when changing bond's
active slave.
[ 101.055189] BUG: scheduling while atomic: bash/902/0x00000200
[ 101.055726] Modules linked in:
[ 101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1
[ 101.058760] Hardware name:
[ 101.059434] Call Trace:
[ 101.059436] <TASK>
[ 101.060873] dump\_stack\_lvl+0x51/0x60
[ 101.061275] \_\_schedule\_bug+0x4e/0x60
[ 101.061682] \_\_schedule+0x612/0x7c0
[ 101.062078] ? \_\_mod\_timer+0x25c/0x370
[ 101.062486] schedule+0x25/0xd0
[ 101.062845] schedule\_timeout+0x77/0xf0
[ 101.063265] ? asm\_common\_interrupt+0x22/0x40
[ 101.063724] ? \_\_bpf\_trace\_itimer\_state+0x10/0x10
[ 101.064215] \_\_wait\_for\_common+0x87/0x190
[ 101.064648] ? usleep\_range\_state+0x90/0x90
[ 101.065091] cmd\_exec+0x437/0xb20 [mlx5\_core]
[ 101.065569] mlx5\_cmd\_do+0x1e/0x40 [mlx5\_core]
[ 101.066051] mlx5\_cmd\_exec+0x18/0x30 [mlx5\_core]
[ 101.066552] mlx5\_crypto\_create\_dek\_key+0xea/0x120 [mlx5\_core]
[ 101.067163] ? bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.067738] ? kmalloc\_trace+0x4d/0x350
[ 101.068156] mlx5\_ipsec\_create\_sa\_ctx+0x33/0x100 [mlx5\_core]
[ 101.068747] mlx5e\_xfrm\_add\_state+0x47b/0xaa0 [mlx5\_core]
[ 101.069312] bond\_change\_active\_slave+0x392/0x900 [bonding]
[ 101.069868] bond\_option\_active\_slave\_set+0x1c2/0x240 [bonding]
[ 101.070454] \_\_bond\_opt\_set+0xa6/0x430 [bonding]
[ 101.070935] \_\_bond\_opt\_set\_notify+0x2f/0x90 [bonding]
[ 101.071453] bond\_opt\_tryset\_rtnl+0x72/0xb0 [bonding]
[ 101.071965] bonding\_sysfs\_store\_option+0x4d/0x80 [bonding]
[ 101.072567] kernfs\_fop\_write\_iter+0x10c/0x1a0
[ 101.073033] vfs\_write+0x2d8/0x400
[ 101.073416] ? alloc\_fd+0x48/0x180
[ 101.073798] ksys\_write+0x5f/0xe0
[ 101.074175] do\_syscall\_64+0x52/0x110
[ 101.074576] entry\_SYSCALL\_64\_after\_hwframe+0x4b/0x53
As bond\_ipsec\_add\_sa\_all and bond\_ipsec\_del\_sa\_all are only called
from bond\_change\_active\_slave, which requires holding the RTNL lock.
And bond\_ipsec\_add\_sa and bond\_ipsec\_del\_sa are xfrm state
xdo\_dev\_state\_add and xdo\_dev\_state\_delete APIs, which are in user
context. So ipsec\_lock doesn't have to be spin lock, change it to
mutex, and thus the above issue can be resolved.
Fixes: 9a5605505d9c ("bonding: Add struct bond\_ipesc to manage SA")
Signed-off-by: Jianbo Liu <jianbol@nvidia.com>
Signed-off-by: Tariq Toukan <tariqt@nvidia.com>
Reviewed-by: Hangbin Liu <liuhangbin@gmail.com>
Acked-by: Jay Vosburgh <jv@jvosburgh.net>
Link: [https://patch.msgid.link/20240823031056.110999-4-jianbol@nvidia.com](https://patch.msgid.link/20240823031056.110999-4-jianbol%40nvidia.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)

| -rw-r--r-- | [drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/bonding/bond_main.c?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3) | 79 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/bonding.h?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3) | 2 | |  |  |  | | --- | --- | --- | |

2 files changed, 44 insertions, 37 deletions

| diff --git a/drivers/net/bonding/bond\_main.c b/drivers/net/bonding/bond\_main.cindex 6f61bb2f4b9013..53a7b53618d942 100644--- a/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=19792758339b68e54946fb8e6d7781e1ce6048e2)+++ b/[drivers/net/bonding/bond\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/bonding/bond_main.c?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)@@ -428,6 +428,7 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -439,24 +440,26 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();- return -ENODEV;+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();+ if (!real\_dev) {+ err = -ENODEV;+ goto out; } - real\_dev = slave->dev; if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) { NL\_SET\_ERR\_MSG\_MOD(extack, "Slave does not support ipsec offload");- rcu\_read\_unlock();- return -EINVAL;+ err = -EINVAL;+ goto out; } - ipsec = kmalloc(sizeof(\*ipsec), GFP\_ATOMIC);+ ipsec = kmalloc(sizeof(\*ipsec), GFP\_KERNEL); if (!ipsec) {- rcu\_read\_unlock();- return -ENOMEM;+ err = -ENOMEM;+ goto out; }  xs->xso.real\_dev = real\_dev;@@ -464,13 +467,14 @@ static int bond\_ipsec\_add\_sa(struct xfrm\_state \*xs, if (!err) { ipsec->xs = xs; INIT\_LIST\_HEAD(&ipsec->list);- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_add(&ipsec->list, &bond->ipsec\_list);- spin\_unlock\_bh(&bond->ipsec\_lock);+ mutex\_unlock(&bond->ipsec\_lock); } else { kfree(ipsec); }- rcu\_read\_unlock();+out:+ netdev\_put(real\_dev, &tracker); return err; } @@ -481,35 +485,35 @@ static void bond\_ipsec\_add\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave)- goto out;+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev)+ return; - real\_dev = slave->dev;+ mutex\_lock(&bond->ipsec\_lock); if (!real\_dev->xfrmdev\_ops || !real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add || netif\_is\_bond\_master(real\_dev)) {- spin\_lock\_bh(&bond->ipsec\_lock); if (!list\_empty(&bond->ipsec\_list)) slave\_warn(bond\_dev, real\_dev, "%s: no slave xdo\_dev\_state\_add\n", \_\_func\_\_);- spin\_unlock\_bh(&bond->ipsec\_lock); goto out; } - spin\_lock\_bh(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) {+ /\* If new state is added before ipsec\_lock acquired \*/+ if (ipsec->xs->xso.real\_dev == real\_dev)+ continue;+ ipsec->xs->xso.real\_dev = real\_dev; if (real\_dev->xfrmdev\_ops->xdo\_dev\_state\_add(ipsec->xs, NULL)) { slave\_warn(bond\_dev, real\_dev, "%s: failed to add SA\n", \_\_func\_\_); ipsec->xs->xso.real\_dev = NULL; } }- spin\_unlock\_bh(&bond->ipsec\_lock); out:- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  /\*\*@@ -520,6 +524,7 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) { struct net\_device \*bond\_dev = xs->xso.dev; struct net\_device \*real\_dev;+ netdevice\_tracker tracker; struct bond\_ipsec \*ipsec; struct bonding \*bond; struct slave \*slave;@@ -530,6 +535,9 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) rcu\_read\_lock(); bond = netdev\_priv(bond\_dev); slave = rcu\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ netdev\_hold(real\_dev, &tracker, GFP\_ATOMIC);+ rcu\_read\_unlock();  if (!slave) goto out;@@ -537,7 +545,6 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs) if (!xs->xso.real\_dev) goto out; - real\_dev = slave->dev; WARN\_ON(xs->xso.real\_dev != real\_dev);  if (!real\_dev->xfrmdev\_ops ||@@ -549,7 +556,8 @@ static void bond\_ipsec\_del\_sa(struct xfrm\_state \*xs)  real\_dev->xfrmdev\_ops->xdo\_dev\_state\_delete(xs); out:- spin\_lock\_bh(&bond->ipsec\_lock);+ netdev\_put(real\_dev, &tracker);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (ipsec->xs == xs) { list\_del(&ipsec->list);@@ -557,8 +565,7 @@ out: break; } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond)@@ -568,15 +575,12 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) struct bond\_ipsec \*ipsec; struct slave \*slave; - rcu\_read\_lock();- slave = rcu\_dereference(bond->curr\_active\_slave);- if (!slave) {- rcu\_read\_unlock();+ slave = rtnl\_dereference(bond->curr\_active\_slave);+ real\_dev = slave ? slave->dev : NULL;+ if (!real\_dev) return;- } - real\_dev = slave->dev;- spin\_lock\_bh(&bond->ipsec\_lock);+ mutex\_lock(&bond->ipsec\_lock); list\_for\_each\_entry(ipsec, &bond->ipsec\_list, list) { if (!ipsec->xs->xso.real\_dev) continue;@@ -593,8 +597,7 @@ static void bond\_ipsec\_del\_sa\_all(struct bonding \*bond) real\_dev->xfrmdev\_ops->xdo\_dev\_state\_free(ipsec->xs); } }- spin\_unlock\_bh(&bond->ipsec\_lock);- rcu\_read\_unlock();+ mutex\_unlock(&bond->ipsec\_lock); }  static void bond\_ipsec\_free\_sa(struct xfrm\_state \*xs)@@ -5941,7 +5944,7 @@ void bond\_setup(struct net\_device \*bond\_dev) /\* set up xfrm device ops (only supported in active-backup right now) \*/ bond\_dev->xfrmdev\_ops = &bond\_xfrmdev\_ops; INIT\_LIST\_HEAD(&bond->ipsec\_list);- spin\_lock\_init(&bond->ipsec\_lock);+ mutex\_init(&bond->ipsec\_lock); #endif /\* CONFIG\_XFRM\_OFFLOAD \*/  /\* don't acquire bond device's netif\_tx\_lock when transmitting \*/@@ -5990,6 +5993,10 @@ static void bond\_uninit(struct net\_device \*bond\_dev) \_\_bond\_release\_one(bond\_dev, slave->dev, true, true); netdev\_info(bond\_dev, "Released all slaves\n"); +#ifdef CONFIG\_XFRM\_OFFLOAD+ mutex\_destroy(&bond->ipsec\_lock);+#endif /\* CONFIG\_XFRM\_OFFLOAD \*/+ bond\_set\_slave\_arr(bond, NULL, NULL);  list\_del(&bond->bond\_list);diff --git a/include/net/bonding.h b/include/net/bonding.hindex 5b8b1b644a2dbf..94594026a5c554 100644--- a/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=19792758339b68e54946fb8e6d7781e1ce6048e2)+++ b/[include/net/bonding.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/bonding.h?id=6b598069164ac1bb60996d6ff94e7f9169dbd2d3)@@ -258,7 +258,7 @@ struct bonding { #ifdef CONFIG\_XFRM\_OFFLOAD struct list\_head ipsec\_list; /\* protecting ipsec\_list \*/- spinlock\_t ipsec\_lock;+ struct mutex ipsec\_lock; #endif /\* CONFIG\_XFRM\_OFFLOAD \*/ struct bpf\_prog \*xdp\_prog; }; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:45:06 +0000


