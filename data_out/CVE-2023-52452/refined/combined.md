=== Content from git.kernel.org_1fd6e332_20250111_114149.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andrei Matei <andreimatei1@gmail.com> | 2023-12-07 22:25:18 -0500 |
| --- | --- | --- |
| committer | Andrii Nakryiko <andrii@kernel.org> | 2023-12-08 14:19:00 -0800 |
| commit | [6b4a64bafd107e521c01eec3453ce94a3fb38529](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)) | |
| tree | [413fad563de5cfb78b40f9f067d563e4dcfa4221](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | |
| parent | [92e1567ee3e3f6f160e320890ac77eec50bf8e7d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529&id2=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)) | |
| download | [linux-6b4a64bafd107e521c01eec3453ce94a3fb38529.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6b4a64bafd107e521c01eec3453ce94a3fb38529.tar.gz) | |

bpf: Fix accesses to uninit stack slotsPrivileged programs are supposed to be able to read uninitialized stack
memory (ever since 6715df8d5) but, before this patch, these accesses
were permitted inconsistently. In particular, accesses were permitted
above state->allocated\_stack, but not below it. In other words, if the
stack was already "large enough", the access was permitted, but
otherwise the access was rejected instead of being allowed to "grow the
stack". This undesired rejection was happening in two places:
- in check\_stack\_slot\_within\_bounds()
- in check\_stack\_range\_initialized()
This patch arranges for these accesses to be permitted. A bunch of tests
that were relying on the old rejection had to change; all of them were
changed to add also run unprivileged, in which case the old behavior
persists. One tests couldn't be updated - global\_func16 - because it
can't run unprivileged for other reasons.
This patch also fixes the tracking of the stack size for variable-offset
reads. This second fix is bundled in the same commit as the first one
because they're inter-related. Before this patch, writes to the stack
using registers containing a variable offset (as opposed to registers
with fixed, known values) were not properly contributing to the
function's needed stack size. As a result, it was possible for a program
to verify, but then to attempt to read out-of-bounds data at runtime
because a too small stack had been allocated for it.
Each function tracks the size of the stack it needs in
bpf\_subprog\_info.stack\_depth, which is maintained by
update\_stack\_depth(). For regular memory accesses, check\_mem\_access()
was calling update\_state\_depth() but it was passing in only the fixed
part of the offset register, ignoring the variable offset. This was
incorrect; the minimum possible value of that register should be used
instead.
This tracking is now fixed by centralizing the tracking of stack size in
grow\_stack\_state(), and by lifting the calls to grow\_stack\_state() to
check\_stack\_access\_within\_bounds() as suggested by Andrii. The code is
now simpler and more convincingly tracks the correct maximum stack size.
check\_stack\_range\_initialized() can now rely on enough stack having been
allocated for the access; this helps with the fix for the first issue.
A few tests were changed to also check the stack depth computation. The
one that fails without this patch is verifier\_var\_off:stack\_write\_priv\_vs\_unpriv.
Fixes: 01f810ace9ed3 ("bpf: Allow variable-offset stack access")
Reported-by: Hao Sun <sunhao.th@gmail.com>
Signed-off-by: Andrei Matei <andreimatei1@gmail.com>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: [https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com](https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1%40gmail.com)
Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP\_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 65 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/iters.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_global_func16.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 62 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/calls.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529) | 4 | |  |  |  | | --- | --- | --- | |

9 files changed, 92 insertions, 72 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 0e77bb52542d75..de1e29fa467ed1 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -1259,7 +1259,10 @@ static int resize\_reference\_state(struct bpf\_func\_state \*state, size\_t n) return 0; } -static int grow\_stack\_state(struct bpf\_func\_state \*state, int size)+/\* Possibly update state->allocated\_stack to be at least size bytes. Also+ \* possibly update the function's high-water mark in its bpf\_subprog\_info.+ \*/+static int grow\_stack\_state(struct bpf\_verifier\_env \*env, struct bpf\_func\_state \*state, int size) { size\_t old\_n = state->allocated\_stack / BPF\_REG\_SIZE, n = size / BPF\_REG\_SIZE; @@ -1271,6 +1274,11 @@ static int grow\_stack\_state(struct bpf\_func\_state \*state, int size) return -ENOMEM;  state->allocated\_stack = size;++ /\* update known max for given subprogram \*/+ if (env->subprog\_info[state->subprogno].stack\_depth < size)+ env->subprog\_info[state->subprogno].stack\_depth = size;+ return 0; } @@ -4440,9 +4448,6 @@ static int check\_stack\_write\_fixed\_off(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg = NULL; int insn\_flags = insn\_stack\_access\_flags(state->frameno, spi); - err = grow\_stack\_state(state, round\_up(slot + 1, BPF\_REG\_SIZE));- if (err)- return err; /\* caller checked that off % size == 0 and -MAX\_BPF\_STACK <= off < 0, \* so it's aligned access and [off, off + size) are within stack limits \*/@@ -4595,10 +4600,6 @@ static int check\_stack\_write\_var\_off(struct bpf\_verifier\_env \*env, (!value\_reg && is\_bpf\_st\_mem(insn) && insn->imm == 0)) writing\_zero = true; - err = grow\_stack\_state(state, round\_up(-min\_off, BPF\_REG\_SIZE));- if (err)- return err;- for (i = min\_off; i < max\_off; i++) { int spi; @@ -5774,20 +5775,6 @@ static int check\_ptr\_alignment(struct bpf\_verifier\_env \*env, strict); } -static int update\_stack\_depth(struct bpf\_verifier\_env \*env,- const struct bpf\_func\_state \*func,- int off)-{- u16 stack = env->subprog\_info[func->subprogno].stack\_depth;-- if (stack >= -off)- return 0;-- /\* update known max for given subprogram \*/- env->subprog\_info[func->subprogno].stack\_depth = -off;- return 0;-}- /\* starting from main bpf function walk all instructions of the function \* and recursively walk all callees that given function can call. \* Ignore jump and exit insns.@@ -6577,13 +6564,14 @@ static int check\_ptr\_to\_map\_access(struct bpf\_verifier\_env \*env, \* The minimum valid offset is -MAX\_BPF\_STACK for writes, and \* -state->allocated\_stack for reads. \*/-static int check\_stack\_slot\_within\_bounds(s64 off,- struct bpf\_func\_state \*state,- enum bpf\_access\_type t)+static int check\_stack\_slot\_within\_bounds(struct bpf\_verifier\_env \*env,+ s64 off,+ struct bpf\_func\_state \*state,+ enum bpf\_access\_type t) { int min\_valid\_off; - if (t == BPF\_WRITE)+ if (t == BPF\_WRITE || env->allow\_uninit\_stack) min\_valid\_off = -MAX\_BPF\_STACK; else min\_valid\_off = -state->allocated\_stack;@@ -6632,7 +6620,7 @@ static int check\_stack\_access\_within\_bounds( max\_off = reg->smax\_value + off + access\_size; } - err = check\_stack\_slot\_within\_bounds(min\_off, state, type);+ err = check\_stack\_slot\_within\_bounds(env, min\_off, state, type); if (!err && max\_off > 0) err = -EINVAL; /\* out of stack access into non-negative offsets \*/ @@ -6647,8 +6635,10 @@ static int check\_stack\_access\_within\_bounds( verbose(env, "invalid variable-offset%s stack R%d var\_off=%s off=%d size=%d\n", err\_extra, regno, tn\_buf, off, access\_size); }+ return err; }- return err;++ return grow\_stack\_state(env, state, round\_up(-min\_off, BPF\_REG\_SIZE)); }  /\* check whether memory at (regno + off) is accessible for t = (read | write)@@ -6663,7 +6653,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn { struct bpf\_reg\_state \*regs = cur\_regs(env); struct bpf\_reg\_state \*reg = regs + regno;- struct bpf\_func\_state \*state; int size, err = 0;  size = bpf\_size\_to\_bytes(bpf\_size);@@ -6806,11 +6795,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (err) return err; - state = func(env, reg);- err = update\_stack\_depth(env, state, off);- if (err)- return err;- if (t == BPF\_READ) err = check\_stack\_read(env, regno, off, size, value\_regno);@@ -7004,7 +6988,8 @@ static int check\_atomic(struct bpf\_verifier\_env \*env, int insn\_idx, struct bpf\_i  /\* When register 'regno' is used to read the stack (either directly or through \* a helper function) make sure that it's within stack boundary and, depending- \* on the access type, that all elements of the stack are initialized.+ \* on the access type and privileges, that all elements of the stack are+ \* initialized. \* \* 'off' includes 'regno->off', but not its dynamic part (if any). \*@@ -7112,8 +7097,11 @@ static int check\_stack\_range\_initialized(  slot = -i - 1; spi = slot / BPF\_REG\_SIZE;- if (state->allocated\_stack <= slot)- goto err;+ if (state->allocated\_stack <= slot) {+ verbose(env, "verifier bug: allocated\_stack too small");+ return -EFAULT;+ }+ stype = &state->stack[spi].slot\_type[slot % BPF\_REG\_SIZE]; if (\*stype == STACK\_MISC) goto mark;@@ -7137,7 +7125,6 @@ static int check\_stack\_range\_initialized( goto mark; } -err: if (tnum\_is\_const(reg->var\_off)) { verbose(env, "invalid%s read from stack R%d off %d+%d size %d\n", err\_extra, regno, min\_off, i - min\_off, access\_size);@@ -7162,7 +7149,7 @@ mark: \* helper may write to the entire memory range. \*/ }- return update\_stack\_depth(env, state, min\_off);+ return 0; }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,diff --git a/tools/testing/selftests/bpf/progs/iters.c b/tools/testing/selftests/bpf/progs/iters.cindex b2181f850d3e55..3aca3dc145b552 100644--- a/[tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/iters.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/iters.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -846,7 +846,7 @@ \_\_naked int delayed\_precision\_mark(void) "call %[bpf\_iter\_num\_next];" "if r0 == 0 goto 2f;" "if r6 != 42 goto 3f;"- "r7 = -32;"+ "r7 = -33;" "call %[bpf\_get\_prandom\_u32];" "r6 = r0;" "goto 1b;\n"diff --git a/tools/testing/selftests/bpf/progs/test\_global\_func16.c b/tools/testing/selftests/bpf/progs/test\_global\_func16.cindex e7206304632e15..e3e64bc472cdaf 100644--- a/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -13,7 +13,7 @@ \_\_noinline int foo(int (\*arr)[10]) }  SEC("cgroup\_skb/ingress")-\_\_failure \_\_msg("invalid indirect read from stack")+\_\_success int global\_func16(struct \_\_sk\_buff \*skb) { int array[10];diff --git a/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.cindex 359df865a8f3e9..8d77cc5323d337 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -27,8 +27,8 @@ \_\_naked void stack\_out\_of\_bounds(void)  SEC("socket") \_\_description("uninitialized stack1")-\_\_failure \_\_msg("invalid indirect read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack") \_\_naked void uninitialized\_stack1(void) { asm volatile (" \@@ -45,8 +45,8 @@ \_\_naked void uninitialized\_stack1(void)  SEC("socket") \_\_description("uninitialized stack2")-\_\_failure \_\_msg("invalid read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack") \_\_naked void uninitialized\_stack2(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c b/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.cindex 74d9cad469d94e..9fc3fae5cd833b 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("cgroup/sysctl")+SEC("socket") \_\_description("ARG\_PTR\_TO\_LONG uninitialized")-\_\_failure \_\_msg("invalid indirect read from stack R4 off -16+0 size 8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack R4 off -16+0 size 8") \_\_naked void arg\_ptr\_to\_long\_uninitialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.cindex efbfc3a4ad6a99..f67390224a9cf9 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("tc")+SEC("socket") \_\_description("raw\_stack: no skb\_load\_bytes")-\_\_failure \_\_msg("invalid read from stack R6 off=-8 size=8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack R6 off=-8 size=8") \_\_naked void stack\_no\_skb\_load\_bytes(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_var\_off.c b/tools/testing/selftests/bpf/progs/verifier\_var\_off.cindex b7bdd7db3a3579..c810f4f6f479c6 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -59,9 +59,10 @@ \_\_naked void stack\_read\_priv\_vs\_unpriv(void) " ::: \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("variable-offset stack read, uninitialized")-\_\_failure \_\_msg("invalid variable-offset read from stack R2")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void variable\_offset\_stack\_read\_uninitialized(void) { asm volatile (" \@@ -83,13 +84,56 @@ \_\_naked void variable\_offset\_stack\_read\_uninitialized(void)  SEC("socket") \_\_description("variable-offset stack write, priv vs unpriv")-\_\_success \_\_failure\_unpriv+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv /\* Variable stack access is rejected for unprivileged. \*/ \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_retval(0) \_\_naked void stack\_write\_priv\_vs\_unpriv(void) {+ asm volatile (" \+ /\* Get an unknown value \*/ \+ r2 = \*(u32\*)(r1 + 0); \+ /\* Make it small and 8-byte aligned \*/ \+ r2 &= 8; \+ r2 -= 16; \+ /\* Add it to fp. We now have either fp-8 or \+ \* fp-16, but we don't know which \+ \*/ \+ r2 += r10; \+ /\* Dereference it for a stack write \*/ \+ r0 = 0; \+ \*(u64\*)(r2 + 0) = r0; \+ exit; \+" ::: \_\_clobber\_all);+}++/\* Similar to the previous test, but this time also perform a read from the+ \* address written to with a variable offset. The read is allowed, showing that,+ \* after a variable-offset write, a priviledged program can read the slots that+ \* were in the range of that write (even if the verifier doesn't actually know if+ \* the slot being read was really written to or not.+ \*+ \* Despite this test being mostly a superset, the previous test is also kept for+ \* the sake of it checking the stack depth in the case where there is no read.+ \*/+SEC("socket")+\_\_description("variable-offset stack write followed by read")+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv+\_\_msg\_unpriv("R2 variable stack access prohibited for !root")+\_\_retval(0)+\_\_naked void stack\_write\_followed\_by\_read(void)+{ asm volatile (" \ /\* Get an unknown value \*/ \ r2 = \*(u32\*)(r1 + 0); \@@ -103,12 +147,7 @@ \_\_naked void stack\_write\_priv\_vs\_unpriv(void) /\* Dereference it for a stack write \*/ \ r0 = 0; \ \*(u64\*)(r2 + 0) = r0; \- /\* Now read from the address we just wrote. This shows\- \* that, after a variable-offset write, a priviledged\- \* program can read the slots that were in the range of\- \* that write (even if the verifier doesn't actually know\- \* if the slot being read was really written to or not.\- \*/ \+ /\* Now read from the address we just wrote. \*/ \ r3 = \*(u64\*)(r2 + 0); \ r0 = 0; \ exit; \@@ -282,9 +321,10 @@ \_\_naked void access\_min\_out\_of\_bound(void) : \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("indirect variable-offset stack access, min\_off < min\_initialized")-\_\_failure \_\_msg("invalid indirect read from stack R2 var\_off")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void access\_min\_off\_min\_initialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c b/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.cindex 319337bdcfc856..9a7b1106fda812 100644--- a/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -84,17 +84,6 @@ .errstr = "!read\_ok", }, {- "Can't use cmpxchg on uninit memory",- .insns = {- BPF\_MOV64\_IMM(BPF\_REG\_0, 3),- BPF\_MOV64\_IMM(BPF\_REG\_2, 4),- BPF\_ATOMIC\_OP(BPF\_DW, BPF\_CMPXCHG, BPF\_REG\_10, BPF\_REG\_2, -8),- BPF\_EXIT\_INSN(),- },- .result = REJECT,- .errstr = "invalid read from stack",-},-{ "BPF\_W cmpxchg should zero top 32 bits", .insns = { /\* r0 = U64\_MAX; \*/diff --git a/tools/testing/selftests/bpf/verifier/calls.c b/tools/testing/selftests/bpf/verifier/calls.cindex 3d5cd51071f047..ab25a81fd3a108 100644--- a/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=92e1567ee3e3f6f160e320890ac77eec50bf8e7d)+++ b/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=6b4a64bafd107e521c01eec3453ce94a3fb38529)@@ -1505,7 +1505,9 @@ .prog\_type = BPF\_PROG\_TYPE\_XDP, .fixup\_map\_hash\_8b = { 23 }, .result = REJECT,- .errstr = "invalid read from stack R7 off=-16 size=8",+ .errstr = "R0 invalid mem access 'scalar'",+ .result\_unpriv = REJECT,+ .errstr\_unpriv = "invalid read from stack R7 off=-16 size=8", }, { "calls: two calls that receive map\_value via arg=ptr\_stack\_of\_caller. test1", |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 11:40:26 +0000



=== Content from git.kernel.org_24e22e1f_20250111_114149.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andrei Matei <andreimatei1@gmail.com> | 2023-12-07 22:25:18 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-25 15:44:50 -0800 |
| commit | [fbcf372c8eda2290470268e0afb5ab5d5f5d5fde](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)) | |
| tree | [040281a69d7d95951cd33ee23ac591d38c0f59de](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | |
| parent | [e5ad9ecb84405637df82732ee02ad741a5f782a6](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e5ad9ecb84405637df82732ee02ad741a5f782a6) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde&id2=e5ad9ecb84405637df82732ee02ad741a5f782a6)) | |
| download | [linux-fbcf372c8eda2290470268e0afb5ab5d5f5d5fde.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fbcf372c8eda2290470268e0afb5ab5d5f5d5fde.tar.gz) | |

bpf: Fix accesses to uninit stack slots[ Upstream commit 6b4a64bafd107e521c01eec3453ce94a3fb38529 ]
Privileged programs are supposed to be able to read uninitialized stack
memory (ever since 6715df8d5) but, before this patch, these accesses
were permitted inconsistently. In particular, accesses were permitted
above state->allocated\_stack, but not below it. In other words, if the
stack was already "large enough", the access was permitted, but
otherwise the access was rejected instead of being allowed to "grow the
stack". This undesired rejection was happening in two places:
- in check\_stack\_slot\_within\_bounds()
- in check\_stack\_range\_initialized()
This patch arranges for these accesses to be permitted. A bunch of tests
that were relying on the old rejection had to change; all of them were
changed to add also run unprivileged, in which case the old behavior
persists. One tests couldn't be updated - global\_func16 - because it
can't run unprivileged for other reasons.
This patch also fixes the tracking of the stack size for variable-offset
reads. This second fix is bundled in the same commit as the first one
because they're inter-related. Before this patch, writes to the stack
using registers containing a variable offset (as opposed to registers
with fixed, known values) were not properly contributing to the
function's needed stack size. As a result, it was possible for a program
to verify, but then to attempt to read out-of-bounds data at runtime
because a too small stack had been allocated for it.
Each function tracks the size of the stack it needs in
bpf\_subprog\_info.stack\_depth, which is maintained by
update\_stack\_depth(). For regular memory accesses, check\_mem\_access()
was calling update\_state\_depth() but it was passing in only the fixed
part of the offset register, ignoring the variable offset. This was
incorrect; the minimum possible value of that register should be used
instead.
This tracking is now fixed by centralizing the tracking of stack size in
grow\_stack\_state(), and by lifting the calls to grow\_stack\_state() to
check\_stack\_access\_within\_bounds() as suggested by Andrii. The code is
now simpler and more convincingly tracks the correct maximum stack size.
check\_stack\_range\_initialized() can now rely on enough stack having been
allocated for the access; this helps with the fix for the first issue.
A few tests were changed to also check the stack depth computation. The
one that fails without this patch is verifier\_var\_off:stack\_write\_priv\_vs\_unpriv.
Fixes: 01f810ace9ed3 ("bpf: Allow variable-offset stack access")
Reported-by: Hao Sun <sunhao.th@gmail.com>
Signed-off-by: Andrei Matei <andreimatei1@gmail.com>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: [https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com](https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1%40gmail.com)
Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP\_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 65 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/iters.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_global_func16.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 62 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/calls.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde) | 4 | |  |  |  | | --- | --- | --- | |

9 files changed, 92 insertions, 72 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 4d91df312b9903..2b8fbdc1a1134e 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -1685,7 +1685,10 @@ static int resize\_reference\_state(struct bpf\_func\_state \*state, size\_t n) return 0; } -static int grow\_stack\_state(struct bpf\_func\_state \*state, int size)+/\* Possibly update state->allocated\_stack to be at least size bytes. Also+ \* possibly update the function's high-water mark in its bpf\_subprog\_info.+ \*/+static int grow\_stack\_state(struct bpf\_verifier\_env \*env, struct bpf\_func\_state \*state, int size) { size\_t old\_n = state->allocated\_stack / BPF\_REG\_SIZE, n = size / BPF\_REG\_SIZE; @@ -1697,6 +1700,11 @@ static int grow\_stack\_state(struct bpf\_func\_state \*state, int size) return -ENOMEM;  state->allocated\_stack = size;++ /\* update known max for given subprogram \*/+ if (env->subprog\_info[state->subprogno].stack\_depth < size)+ env->subprog\_info[state->subprogno].stack\_depth = size;+ return 0; } @@ -4669,9 +4677,6 @@ static int check\_stack\_write\_fixed\_off(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg = NULL; u32 dst\_reg = insn->dst\_reg; - err = grow\_stack\_state(state, round\_up(slot + 1, BPF\_REG\_SIZE));- if (err)- return err; /\* caller checked that off % size == 0 and -MAX\_BPF\_STACK <= off < 0, \* so it's aligned access and [off, off + size) are within stack limits \*/@@ -4827,10 +4832,6 @@ static int check\_stack\_write\_var\_off(struct bpf\_verifier\_env \*env, (!value\_reg && is\_bpf\_st\_mem(insn) && insn->imm == 0)) writing\_zero = true; - err = grow\_stack\_state(state, round\_up(-min\_off, BPF\_REG\_SIZE));- if (err)- return err;- for (i = min\_off; i < max\_off; i++) { int spi; @@ -5959,20 +5960,6 @@ static int check\_ptr\_alignment(struct bpf\_verifier\_env \*env, strict); } -static int update\_stack\_depth(struct bpf\_verifier\_env \*env,- const struct bpf\_func\_state \*func,- int off)-{- u16 stack = env->subprog\_info[func->subprogno].stack\_depth;-- if (stack >= -off)- return 0;-- /\* update known max for given subprogram \*/- env->subprog\_info[func->subprogno].stack\_depth = -off;- return 0;-}- /\* starting from main bpf function walk all instructions of the function \* and recursively walk all callees that given function can call. \* Ignore jump and exit insns.@@ -6761,13 +6748,14 @@ static int check\_ptr\_to\_map\_access(struct bpf\_verifier\_env \*env, \* The minimum valid offset is -MAX\_BPF\_STACK for writes, and \* -state->allocated\_stack for reads. \*/-static int check\_stack\_slot\_within\_bounds(s64 off,- struct bpf\_func\_state \*state,- enum bpf\_access\_type t)+static int check\_stack\_slot\_within\_bounds(struct bpf\_verifier\_env \*env,+ s64 off,+ struct bpf\_func\_state \*state,+ enum bpf\_access\_type t) { int min\_valid\_off; - if (t == BPF\_WRITE)+ if (t == BPF\_WRITE || env->allow\_uninit\_stack) min\_valid\_off = -MAX\_BPF\_STACK; else min\_valid\_off = -state->allocated\_stack;@@ -6816,7 +6804,7 @@ static int check\_stack\_access\_within\_bounds( max\_off = reg->smax\_value + off + access\_size; } - err = check\_stack\_slot\_within\_bounds(min\_off, state, type);+ err = check\_stack\_slot\_within\_bounds(env, min\_off, state, type); if (!err && max\_off > 0) err = -EINVAL; /\* out of stack access into non-negative offsets \*/ @@ -6831,8 +6819,10 @@ static int check\_stack\_access\_within\_bounds( verbose(env, "invalid variable-offset%s stack R%d var\_off=%s size=%d\n", err\_extra, regno, tn\_buf, access\_size); }+ return err; }- return err;++ return grow\_stack\_state(env, state, round\_up(-min\_off, BPF\_REG\_SIZE)); }  /\* check whether memory at (regno + off) is accessible for t = (read | write)@@ -6847,7 +6837,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn { struct bpf\_reg\_state \*regs = cur\_regs(env); struct bpf\_reg\_state \*reg = regs + regno;- struct bpf\_func\_state \*state; int size, err = 0;  size = bpf\_size\_to\_bytes(bpf\_size);@@ -6990,11 +6979,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (err) return err; - state = func(env, reg);- err = update\_stack\_depth(env, state, off);- if (err)- return err;- if (t == BPF\_READ) err = check\_stack\_read(env, regno, off, size, value\_regno);@@ -7189,7 +7173,8 @@ static int check\_atomic(struct bpf\_verifier\_env \*env, int insn\_idx, struct bpf\_i  /\* When register 'regno' is used to read the stack (either directly or through \* a helper function) make sure that it's within stack boundary and, depending- \* on the access type, that all elements of the stack are initialized.+ \* on the access type and privileges, that all elements of the stack are+ \* initialized. \* \* 'off' includes 'regno->off', but not its dynamic part (if any). \*@@ -7297,8 +7282,11 @@ static int check\_stack\_range\_initialized(  slot = -i - 1; spi = slot / BPF\_REG\_SIZE;- if (state->allocated\_stack <= slot)- goto err;+ if (state->allocated\_stack <= slot) {+ verbose(env, "verifier bug: allocated\_stack too small");+ return -EFAULT;+ }+ stype = &state->stack[spi].slot\_type[slot % BPF\_REG\_SIZE]; if (\*stype == STACK\_MISC) goto mark;@@ -7322,7 +7310,6 @@ static int check\_stack\_range\_initialized( goto mark; } -err: if (tnum\_is\_const(reg->var\_off)) { verbose(env, "invalid%s read from stack R%d off %d+%d size %d\n", err\_extra, regno, min\_off, i - min\_off, access\_size);@@ -7347,7 +7334,7 @@ mark: \* helper may write to the entire memory range. \*/ }- return update\_stack\_depth(env, state, min\_off);+ return 0; }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,diff --git a/tools/testing/selftests/bpf/progs/iters.c b/tools/testing/selftests/bpf/progs/iters.cindex c20c4e38b71c5b..844d968c27d68a 100644--- a/[tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/iters.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/iters.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/iters.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -846,7 +846,7 @@ \_\_naked int delayed\_precision\_mark(void) "call %[bpf\_iter\_num\_next];" "if r0 == 0 goto 2f;" "if r6 != 42 goto 3f;"- "r7 = -32;"+ "r7 = -33;" "call %[bpf\_get\_prandom\_u32];" "r6 = r0;" "goto 1b;\n"diff --git a/tools/testing/selftests/bpf/progs/test\_global\_func16.c b/tools/testing/selftests/bpf/progs/test\_global\_func16.cindex e7206304632e15..e3e64bc472cdaf 100644--- a/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -13,7 +13,7 @@ \_\_noinline int foo(int (\*arr)[10]) }  SEC("cgroup\_skb/ingress")-\_\_failure \_\_msg("invalid indirect read from stack")+\_\_success int global\_func16(struct \_\_sk\_buff \*skb) { int array[10];diff --git a/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.cindex 359df865a8f3e9..8d77cc5323d337 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -27,8 +27,8 @@ \_\_naked void stack\_out\_of\_bounds(void)  SEC("socket") \_\_description("uninitialized stack1")-\_\_failure \_\_msg("invalid indirect read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack") \_\_naked void uninitialized\_stack1(void) { asm volatile (" \@@ -45,8 +45,8 @@ \_\_naked void uninitialized\_stack1(void)  SEC("socket") \_\_description("uninitialized stack2")-\_\_failure \_\_msg("invalid read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack") \_\_naked void uninitialized\_stack2(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c b/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.cindex b054f9c4814337..589e8270de4628 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("cgroup/sysctl")+SEC("socket") \_\_description("ARG\_PTR\_TO\_LONG uninitialized")-\_\_failure \_\_msg("invalid indirect read from stack R4 off -16+0 size 8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack R4 off -16+0 size 8") \_\_naked void arg\_ptr\_to\_long\_uninitialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.cindex efbfc3a4ad6a99..f67390224a9cf9 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("tc")+SEC("socket") \_\_description("raw\_stack: no skb\_load\_bytes")-\_\_failure \_\_msg("invalid read from stack R6 off=-8 size=8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack R6 off=-8 size=8") \_\_naked void stack\_no\_skb\_load\_bytes(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_var\_off.c b/tools/testing/selftests/bpf/progs/verifier\_var\_off.cindex 83a90afba78576..d1f23c1a7c5b4e 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -59,9 +59,10 @@ \_\_naked void stack\_read\_priv\_vs\_unpriv(void) " ::: \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("variable-offset stack read, uninitialized")-\_\_failure \_\_msg("invalid variable-offset read from stack R2")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void variable\_offset\_stack\_read\_uninitialized(void) { asm volatile (" \@@ -83,13 +84,56 @@ \_\_naked void variable\_offset\_stack\_read\_uninitialized(void)  SEC("socket") \_\_description("variable-offset stack write, priv vs unpriv")-\_\_success \_\_failure\_unpriv+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv /\* Variable stack access is rejected for unprivileged. \*/ \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_retval(0) \_\_naked void stack\_write\_priv\_vs\_unpriv(void) {+ asm volatile (" \+ /\* Get an unknown value \*/ \+ r2 = \*(u32\*)(r1 + 0); \+ /\* Make it small and 8-byte aligned \*/ \+ r2 &= 8; \+ r2 -= 16; \+ /\* Add it to fp. We now have either fp-8 or \+ \* fp-16, but we don't know which \+ \*/ \+ r2 += r10; \+ /\* Dereference it for a stack write \*/ \+ r0 = 0; \+ \*(u64\*)(r2 + 0) = r0; \+ exit; \+" ::: \_\_clobber\_all);+}++/\* Similar to the previous test, but this time also perform a read from the+ \* address written to with a variable offset. The read is allowed, showing that,+ \* after a variable-offset write, a priviledged program can read the slots that+ \* were in the range of that write (even if the verifier doesn't actually know if+ \* the slot being read was really written to or not.+ \*+ \* Despite this test being mostly a superset, the previous test is also kept for+ \* the sake of it checking the stack depth in the case where there is no read.+ \*/+SEC("socket")+\_\_description("variable-offset stack write followed by read")+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv+\_\_msg\_unpriv("R2 variable stack access prohibited for !root")+\_\_retval(0)+\_\_naked void stack\_write\_followed\_by\_read(void)+{ asm volatile (" \ /\* Get an unknown value \*/ \ r2 = \*(u32\*)(r1 + 0); \@@ -103,12 +147,7 @@ \_\_naked void stack\_write\_priv\_vs\_unpriv(void) /\* Dereference it for a stack write \*/ \ r0 = 0; \ \*(u64\*)(r2 + 0) = r0; \- /\* Now read from the address we just wrote. This shows\- \* that, after a variable-offset write, a priviledged\- \* program can read the slots that were in the range of\- \* that write (even if the verifier doesn't actually know\- \* if the slot being read was really written to or not.\- \*/ \+ /\* Now read from the address we just wrote. \*/ \ r3 = \*(u64\*)(r2 + 0); \ r0 = 0; \ exit; \@@ -253,9 +292,10 @@ \_\_naked void access\_min\_out\_of\_bound(void) : \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("indirect variable-offset stack access, min\_off < min\_initialized")-\_\_failure \_\_msg("invalid indirect read from stack R2 var\_off")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void access\_min\_off\_min\_initialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c b/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.cindex 319337bdcfc856..9a7b1106fda812 100644--- a/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -84,17 +84,6 @@ .errstr = "!read\_ok", }, {- "Can't use cmpxchg on uninit memory",- .insns = {- BPF\_MOV64\_IMM(BPF\_REG\_0, 3),- BPF\_MOV64\_IMM(BPF\_REG\_2, 4),- BPF\_ATOMIC\_OP(BPF\_DW, BPF\_CMPXCHG, BPF\_REG\_10, BPF\_REG\_2, -8),- BPF\_EXIT\_INSN(),- },- .result = REJECT,- .errstr = "invalid read from stack",-},-{ "BPF\_W cmpxchg should zero top 32 bits", .insns = { /\* r0 = U64\_MAX; \*/diff --git a/tools/testing/selftests/bpf/verifier/calls.c b/tools/testing/selftests/bpf/verifier/calls.cindex 3d5cd51071f047..ab25a81fd3a108 100644--- a/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=e5ad9ecb84405637df82732ee02ad741a5f782a6)+++ b/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=fbcf372c8eda2290470268e0afb5ab5d5f5d5fde)@@ -1505,7 +1505,9 @@ .prog\_type = BPF\_PROG\_TYPE\_XDP, .fixup\_map\_hash\_8b = { 23 }, .result = REJECT,- .errstr = "invalid read from stack R7 off=-16 size=8",+ .errstr = "R0 invalid mem access 'scalar'",+ .result\_unpriv = REJECT,+ .errstr\_unpriv = "invalid read from stack R7 off=-16 size=8", }, { "calls: two calls that receive map\_value via arg=ptr\_stack\_of\_caller. test1", |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 11:40:27 +0000



=== Content from git.kernel.org_680ca18f_20250111_114148.html ===


| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0954982db8283016bf38e9db2da5adf47a102e19)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0954982db8283016bf38e9db2da5adf47a102e19)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0954982db8283016bf38e9db2da5adf47a102e19)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0954982db8283016bf38e9db2da5adf47a102e19)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Andrei Matei <andreimatei1@gmail.com> | 2023-12-07 22:25:18 -0500 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-01-25 15:35:24 -0800 |
| commit | [0954982db8283016bf38e9db2da5adf47a102e19](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0954982db8283016bf38e9db2da5adf47a102e19) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0954982db8283016bf38e9db2da5adf47a102e19)) | |
| tree | [e4ce2a8adba64b2495b8b480075670411a950ee9](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0954982db8283016bf38e9db2da5adf47a102e19) | |
| parent | [ad140fc856f0b1d5e2215bcb6d0cc247a86805a2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0954982db8283016bf38e9db2da5adf47a102e19&id2=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)) | |
| download | [linux-0954982db8283016bf38e9db2da5adf47a102e19.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0954982db8283016bf38e9db2da5adf47a102e19.tar.gz) | |

bpf: Fix accesses to uninit stack slots[ Upstream commit 6b4a64bafd107e521c01eec3453ce94a3fb38529 ]
Privileged programs are supposed to be able to read uninitialized stack
memory (ever since 6715df8d5) but, before this patch, these accesses
were permitted inconsistently. In particular, accesses were permitted
above state->allocated\_stack, but not below it. In other words, if the
stack was already "large enough", the access was permitted, but
otherwise the access was rejected instead of being allowed to "grow the
stack". This undesired rejection was happening in two places:
- in check\_stack\_slot\_within\_bounds()
- in check\_stack\_range\_initialized()
This patch arranges for these accesses to be permitted. A bunch of tests
that were relying on the old rejection had to change; all of them were
changed to add also run unprivileged, in which case the old behavior
persists. One tests couldn't be updated - global\_func16 - because it
can't run unprivileged for other reasons.
This patch also fixes the tracking of the stack size for variable-offset
reads. This second fix is bundled in the same commit as the first one
because they're inter-related. Before this patch, writes to the stack
using registers containing a variable offset (as opposed to registers
with fixed, known values) were not properly contributing to the
function's needed stack size. As a result, it was possible for a program
to verify, but then to attempt to read out-of-bounds data at runtime
because a too small stack had been allocated for it.
Each function tracks the size of the stack it needs in
bpf\_subprog\_info.stack\_depth, which is maintained by
update\_stack\_depth(). For regular memory accesses, check\_mem\_access()
was calling update\_state\_depth() but it was passing in only the fixed
part of the offset register, ignoring the variable offset. This was
incorrect; the minimum possible value of that register should be used
instead.
This tracking is now fixed by centralizing the tracking of stack size in
grow\_stack\_state(), and by lifting the calls to grow\_stack\_state() to
check\_stack\_access\_within\_bounds() as suggested by Andrii. The code is
now simpler and more convincingly tracks the correct maximum stack size.
check\_stack\_range\_initialized() can now rely on enough stack having been
allocated for the access; this helps with the fix for the first issue.
A few tests were changed to also check the stack depth computation. The
one that fails without this patch is verifier\_var\_off:stack\_write\_priv\_vs\_unpriv.
Fixes: 01f810ace9ed3 ("bpf: Allow variable-offset stack access")
Reported-by: Hao Sun <sunhao.th@gmail.com>
Signed-off-by: Andrei Matei <andreimatei1@gmail.com>
Signed-off-by: Andrii Nakryiko <andrii@kernel.org>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: [https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com](https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1%40gmail.com)
Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP\_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0954982db8283016bf38e9db2da5adf47a102e19)

| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 65 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/test_global_func16.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 62 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/tools/testing/selftests/bpf/verifier/calls.c?id=0954982db8283016bf38e9db2da5adf47a102e19) | 4 | |  |  |  | | --- | --- | --- | |

8 files changed, 91 insertions, 71 deletions

| diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex 47599505cdf8e5..ed24ad2e5bd22e 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -1632,7 +1632,10 @@ static int resize\_reference\_state(struct bpf\_func\_state \*state, size\_t n) return 0; } -static int grow\_stack\_state(struct bpf\_func\_state \*state, int size)+/\* Possibly update state->allocated\_stack to be at least size bytes. Also+ \* possibly update the function's high-water mark in its bpf\_subprog\_info.+ \*/+static int grow\_stack\_state(struct bpf\_verifier\_env \*env, struct bpf\_func\_state \*state, int size) { size\_t old\_n = state->allocated\_stack / BPF\_REG\_SIZE, n = size / BPF\_REG\_SIZE; @@ -1644,6 +1647,11 @@ static int grow\_stack\_state(struct bpf\_func\_state \*state, int size) return -ENOMEM;  state->allocated\_stack = size;++ /\* update known max for given subprogram \*/+ if (env->subprog\_info[state->subprogno].stack\_depth < size)+ env->subprog\_info[state->subprogno].stack\_depth = size;+ return 0; } @@ -4323,9 +4331,6 @@ static int check\_stack\_write\_fixed\_off(struct bpf\_verifier\_env \*env, struct bpf\_reg\_state \*reg = NULL; u32 dst\_reg = insn->dst\_reg; - err = grow\_stack\_state(state, round\_up(slot + 1, BPF\_REG\_SIZE));- if (err)- return err; /\* caller checked that off % size == 0 and -MAX\_BPF\_STACK <= off < 0, \* so it's aligned access and [off, off + size) are within stack limits \*/@@ -4481,10 +4486,6 @@ static int check\_stack\_write\_var\_off(struct bpf\_verifier\_env \*env, (!value\_reg && is\_bpf\_st\_mem(insn) && insn->imm == 0)) writing\_zero = true; - err = grow\_stack\_state(state, round\_up(-min\_off, BPF\_REG\_SIZE));- if (err)- return err;- for (i = min\_off; i < max\_off; i++) { int spi; @@ -5599,20 +5600,6 @@ static int check\_ptr\_alignment(struct bpf\_verifier\_env \*env, strict); } -static int update\_stack\_depth(struct bpf\_verifier\_env \*env,- const struct bpf\_func\_state \*func,- int off)-{- u16 stack = env->subprog\_info[func->subprogno].stack\_depth;-- if (stack >= -off)- return 0;-- /\* update known max for given subprogram \*/- env->subprog\_info[func->subprogno].stack\_depth = -off;- return 0;-}- /\* starting from main bpf function walk all instructions of the function \* and recursively walk all callees that given function can call. \* Ignore jump and exit insns.@@ -6371,13 +6358,14 @@ static int check\_ptr\_to\_map\_access(struct bpf\_verifier\_env \*env, \* The minimum valid offset is -MAX\_BPF\_STACK for writes, and \* -state->allocated\_stack for reads. \*/-static int check\_stack\_slot\_within\_bounds(s64 off,- struct bpf\_func\_state \*state,- enum bpf\_access\_type t)+static int check\_stack\_slot\_within\_bounds(struct bpf\_verifier\_env \*env,+ s64 off,+ struct bpf\_func\_state \*state,+ enum bpf\_access\_type t) { int min\_valid\_off; - if (t == BPF\_WRITE)+ if (t == BPF\_WRITE || env->allow\_uninit\_stack) min\_valid\_off = -MAX\_BPF\_STACK; else min\_valid\_off = -state->allocated\_stack;@@ -6426,7 +6414,7 @@ static int check\_stack\_access\_within\_bounds( max\_off = reg->smax\_value + off + access\_size; } - err = check\_stack\_slot\_within\_bounds(min\_off, state, type);+ err = check\_stack\_slot\_within\_bounds(env, min\_off, state, type); if (!err && max\_off > 0) err = -EINVAL; /\* out of stack access into non-negative offsets \*/ @@ -6441,8 +6429,10 @@ static int check\_stack\_access\_within\_bounds( verbose(env, "invalid variable-offset%s stack R%d var\_off=%s size=%d\n", err\_extra, regno, tn\_buf, access\_size); }+ return err; }- return err;++ return grow\_stack\_state(env, state, round\_up(-min\_off, BPF\_REG\_SIZE)); }  /\* check whether memory at (regno + off) is accessible for t = (read | write)@@ -6457,7 +6447,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn { struct bpf\_reg\_state \*regs = cur\_regs(env); struct bpf\_reg\_state \*reg = regs + regno;- struct bpf\_func\_state \*state; int size, err = 0;  size = bpf\_size\_to\_bytes(bpf\_size);@@ -6600,11 +6589,6 @@ static int check\_mem\_access(struct bpf\_verifier\_env \*env, int insn\_idx, u32 regn if (err) return err; - state = func(env, reg);- err = update\_stack\_depth(env, state, off);- if (err)- return err;- if (t == BPF\_READ) err = check\_stack\_read(env, regno, off, size, value\_regno);@@ -6799,7 +6783,8 @@ static int check\_atomic(struct bpf\_verifier\_env \*env, int insn\_idx, struct bpf\_i  /\* When register 'regno' is used to read the stack (either directly or through \* a helper function) make sure that it's within stack boundary and, depending- \* on the access type, that all elements of the stack are initialized.+ \* on the access type and privileges, that all elements of the stack are+ \* initialized. \* \* 'off' includes 'regno->off', but not its dynamic part (if any). \*@@ -6907,8 +6892,11 @@ static int check\_stack\_range\_initialized(  slot = -i - 1; spi = slot / BPF\_REG\_SIZE;- if (state->allocated\_stack <= slot)- goto err;+ if (state->allocated\_stack <= slot) {+ verbose(env, "verifier bug: allocated\_stack too small");+ return -EFAULT;+ }+ stype = &state->stack[spi].slot\_type[slot % BPF\_REG\_SIZE]; if (\*stype == STACK\_MISC) goto mark;@@ -6932,7 +6920,6 @@ static int check\_stack\_range\_initialized( goto mark; } -err: if (tnum\_is\_const(reg->var\_off)) { verbose(env, "invalid%s read from stack R%d off %d+%d size %d\n", err\_extra, regno, min\_off, i - min\_off, access\_size);@@ -6957,7 +6944,7 @@ mark: \* helper may write to the entire memory range. \*/ }- return update\_stack\_depth(env, state, min\_off);+ return 0; }  static int check\_helper\_mem\_access(struct bpf\_verifier\_env \*env, int regno,diff --git a/tools/testing/selftests/bpf/progs/test\_global\_func16.c b/tools/testing/selftests/bpf/progs/test\_global\_func16.cindex e7206304632e15..e3e64bc472cdaf 100644--- a/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/progs/test\_global\_func16.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/test_global_func16.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -13,7 +13,7 @@ \_\_noinline int foo(int (\*arr)[10]) }  SEC("cgroup\_skb/ingress")-\_\_failure \_\_msg("invalid indirect read from stack")+\_\_success int global\_func16(struct \_\_sk\_buff \*skb) { int array[10];diff --git a/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_basic\_stack.cindex 359df865a8f3e9..8d77cc5323d337 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/progs/verifier\_basic\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_basic_stack.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -27,8 +27,8 @@ \_\_naked void stack\_out\_of\_bounds(void)  SEC("socket") \_\_description("uninitialized stack1")-\_\_failure \_\_msg("invalid indirect read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack") \_\_naked void uninitialized\_stack1(void) { asm volatile (" \@@ -45,8 +45,8 @@ \_\_naked void uninitialized\_stack1(void)  SEC("socket") \_\_description("uninitialized stack2")-\_\_failure \_\_msg("invalid read from stack")-\_\_failure\_unpriv+\_\_success \_\_log\_level(4) \_\_msg("stack depth 8")+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack") \_\_naked void uninitialized\_stack2(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c b/tools/testing/selftests/bpf/progs/verifier\_int\_ptr.cindex b054f9c4814337..589e8270de4628 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/progs/verifier\_int\_ptr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_int_ptr.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("cgroup/sysctl")+SEC("socket") \_\_description("ARG\_PTR\_TO\_LONG uninitialized")-\_\_failure \_\_msg("invalid indirect read from stack R4 off -16+0 size 8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid indirect read from stack R4 off -16+0 size 8") \_\_naked void arg\_ptr\_to\_long\_uninitialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c b/tools/testing/selftests/bpf/progs/verifier\_raw\_stack.cindex efbfc3a4ad6a99..f67390224a9cf9 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/progs/verifier\_raw\_stack.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_raw_stack.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -5,9 +5,10 @@ #include <bpf/bpf\_helpers.h> #include "bpf\_misc.h" -SEC("tc")+SEC("socket") \_\_description("raw\_stack: no skb\_load\_bytes")-\_\_failure \_\_msg("invalid read from stack R6 off=-8 size=8")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("invalid read from stack R6 off=-8 size=8") \_\_naked void stack\_no\_skb\_load\_bytes(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/progs/verifier\_var\_off.c b/tools/testing/selftests/bpf/progs/verifier\_var\_off.cindex 83a90afba78576..d1f23c1a7c5b4e 100644--- a/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/progs/verifier\_var\_off.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/progs/verifier_var_off.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -59,9 +59,10 @@ \_\_naked void stack\_read\_priv\_vs\_unpriv(void) " ::: \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("variable-offset stack read, uninitialized")-\_\_failure \_\_msg("invalid variable-offset read from stack R2")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void variable\_offset\_stack\_read\_uninitialized(void) { asm volatile (" \@@ -83,13 +84,56 @@ \_\_naked void variable\_offset\_stack\_read\_uninitialized(void)  SEC("socket") \_\_description("variable-offset stack write, priv vs unpriv")-\_\_success \_\_failure\_unpriv+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv /\* Variable stack access is rejected for unprivileged. \*/ \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_retval(0) \_\_naked void stack\_write\_priv\_vs\_unpriv(void) {+ asm volatile (" \+ /\* Get an unknown value \*/ \+ r2 = \*(u32\*)(r1 + 0); \+ /\* Make it small and 8-byte aligned \*/ \+ r2 &= 8; \+ r2 -= 16; \+ /\* Add it to fp. We now have either fp-8 or \+ \* fp-16, but we don't know which \+ \*/ \+ r2 += r10; \+ /\* Dereference it for a stack write \*/ \+ r0 = 0; \+ \*(u64\*)(r2 + 0) = r0; \+ exit; \+" ::: \_\_clobber\_all);+}++/\* Similar to the previous test, but this time also perform a read from the+ \* address written to with a variable offset. The read is allowed, showing that,+ \* after a variable-offset write, a priviledged program can read the slots that+ \* were in the range of that write (even if the verifier doesn't actually know if+ \* the slot being read was really written to or not.+ \*+ \* Despite this test being mostly a superset, the previous test is also kept for+ \* the sake of it checking the stack depth in the case where there is no read.+ \*/+SEC("socket")+\_\_description("variable-offset stack write followed by read")+\_\_success+/\* Check that the maximum stack depth is correctly maintained according to the+ \* maximum possible variable offset.+ \*/+\_\_log\_level(4) \_\_msg("stack depth 16")+\_\_failure\_unpriv+\_\_msg\_unpriv("R2 variable stack access prohibited for !root")+\_\_retval(0)+\_\_naked void stack\_write\_followed\_by\_read(void)+{ asm volatile (" \ /\* Get an unknown value \*/ \ r2 = \*(u32\*)(r1 + 0); \@@ -103,12 +147,7 @@ \_\_naked void stack\_write\_priv\_vs\_unpriv(void) /\* Dereference it for a stack write \*/ \ r0 = 0; \ \*(u64\*)(r2 + 0) = r0; \- /\* Now read from the address we just wrote. This shows\- \* that, after a variable-offset write, a priviledged\- \* program can read the slots that were in the range of\- \* that write (even if the verifier doesn't actually know\- \* if the slot being read was really written to or not.\- \*/ \+ /\* Now read from the address we just wrote. \*/ \ r3 = \*(u64\*)(r2 + 0); \ r0 = 0; \ exit; \@@ -253,9 +292,10 @@ \_\_naked void access\_min\_out\_of\_bound(void) : \_\_clobber\_all); } -SEC("lwt\_in")+SEC("cgroup/skb") \_\_description("indirect variable-offset stack access, min\_off < min\_initialized")-\_\_failure \_\_msg("invalid indirect read from stack R2 var\_off")+\_\_success+\_\_failure\_unpriv \_\_msg\_unpriv("R2 variable stack access prohibited for !root") \_\_naked void access\_min\_off\_min\_initialized(void) { asm volatile (" \diff --git a/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c b/tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.cindex 319337bdcfc856..9a7b1106fda812 100644--- a/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/verifier/atomic\_cmpxchg.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/atomic_cmpxchg.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -84,17 +84,6 @@ .errstr = "!read\_ok", }, {- "Can't use cmpxchg on uninit memory",- .insns = {- BPF\_MOV64\_IMM(BPF\_REG\_0, 3),- BPF\_MOV64\_IMM(BPF\_REG\_2, 4),- BPF\_ATOMIC\_OP(BPF\_DW, BPF\_CMPXCHG, BPF\_REG\_10, BPF\_REG\_2, -8),- BPF\_EXIT\_INSN(),- },- .result = REJECT,- .errstr = "invalid read from stack",-},-{ "BPF\_W cmpxchg should zero top 32 bits", .insns = { /\* r0 = U64\_MAX; \*/diff --git a/tools/testing/selftests/bpf/verifier/calls.c b/tools/testing/selftests/bpf/verifier/calls.cindex 3d5cd51071f047..ab25a81fd3a108 100644--- a/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=ad140fc856f0b1d5e2215bcb6d0cc247a86805a2)+++ b/[tools/testing/selftests/bpf/verifier/calls.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/testing/selftests/bpf/verifier/calls.c?id=0954982db8283016bf38e9db2da5adf47a102e19)@@ -1505,7 +1505,9 @@ .prog\_type = BPF\_PROG\_TYPE\_XDP, .fixup\_map\_hash\_8b = { 23 }, .result = REJECT,- .errstr = "invalid read from stack R7 off=-16 size=8",+ .errstr = "R0 invalid mem access 'scalar'",+ .result\_unpriv = REJECT,+ .errstr\_unpriv = "invalid read from stack R7 off=-16 size=8", }, { "calls: two calls that receive map\_value via arg=ptr\_stack\_of\_caller. test1", |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 11:40:25 +0000


