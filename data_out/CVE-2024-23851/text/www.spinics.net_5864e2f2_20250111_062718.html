

# [LInux Kernel Crash] "WARNING: kmalloc bug in ctl\_ioctl"

[[Date Prev](msg56573.html)][[Date Next](msg56575.html)][[Thread Prev](msg56573.html)][[Thread Next](msg56588.html)][[Date Index](maillist.html#56574)][[Thread Index](threads.html#56574)]

---

* *Subject*: [LInux Kernel Crash] "WARNING: kmalloc bug in ctl\_ioctl"
* *From*: "Yang, Chenyuan" <cy54@xxxxxxxxxxxx>
* *Date*: Fri, 15 Dec 2023 21:47:17 +0000
* *Accept-language*: en-US
* *Cc*: "agk@xxxxxxxxxx" <agk@xxxxxxxxxx>, "snitzer@xxxxxxxxxx" <snitzer@xxxxxxxxxx>, "mpatocka@xxxxxxxxxx" <mpatocka@xxxxxxxxxx>, "syzkaller@xxxxxxxxxxxxxxxx" <syzkaller@xxxxxxxxxxxxxxxx>, "Zhang, Lingming" <lingming@xxxxxxxxxxxx>, "Marinov, Darko" <marinov@xxxxxxxxxxxx>, "Zhao, Zijie" <zijie4@xxxxxxxxxxxx>

---

| Hello Linux Kernel community,    We encountered a crash bug when testing the driver implemented in `drivers/md/dm-ioctl.c` by using Syzkaller. Notably, we generate the spec for this driver by ourselves and Syzkaller doesn’t have specification for it.    Based on our understanding, this bug is caused by `dmi = kvmalloc(param\_kernel->data\_size, GFP\_NOIO | \_\_GFP\_HIGH);` in ` drivers/md/dm-ioctl.c` (<https://github.com/torvalds/linux/blob/3bd7d748816927202268cb335921f7f68b3ca723/drivers/md/dm-ioctl.c#L1966>), which `kvmalloc` a size more than INT\_MAX.    A possible patch is to have a more strict check for the `param\_kernel->data\_size` in `copy\_params` before calling `kvmalloc` while currently it only checks minimal size (<https://github.com/torvalds/linux/blob/3bd7d748816927202268cb335921f7f68b3ca723/drivers/md/dm-ioctl.c#L1944>).    We reproduced this bug in the latest Linux Kernel (reproducible on 3bd7d748816927202268cb335921f7f68b3ca723 and found on d2f51b3516dade79269ff45eae2a7668ae711b25), and the config for the kernel is attached.    Here is the log and Syzkaller reproducer. C reproducer is also attached, which can compiled by `gcc -pthread`.    Syzkaller hit 'WARNING: kmalloc bug in ctl\_ioctl' bug.    ------------[ cut here ]------------  WARNING: CPU: 1 PID: 8924 at mm/util.c:622 kvmalloc\_node+0x194/0x1a0 mm/util.c:622  Modules linked in:  CPU: 1 PID: 8924 Comm: syz-executor401 Not tainted 6.6.0-gd2f51b3516da #1  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014  RIP: 0010:kvmalloc\_node+0x194/0x1a0 mm/util.c:622  Code: a2 3f 1c 00 eb aa e8 ab 40 c9 ff 41 81 e5 00 20 00 00 31 ff 44 89 ee e8 ba 3c c9 ff 45 85 ed 0f 85 1b ff ff ff e8 8c 40 c9 ff <0f> 0b e9 e3 fe ff ff 0f 1f 44 00 00 f3 0f 1e fa 41 55 49 89 f5 41  RSP: 0018:ffffc900025d7c90 EFLAGS: 00010293  RAX: 0000000000000000 RBX: 0000000000000400 RCX: ffffffff81b9bd56  RDX: ffff888043d13c00 RSI: ffffffff81b9bd64 RDI: 0000000000000005  RBP: 00000000fffffff7 R08: 0000000000000005 R09: 0000000000000000  R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000  R13: 0000000000000000 R14: 00000000ffffffff R15: 0000000000000000  FS:  00007fd044e9f640(0000) GS:ffff88807ec00000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00007fd044e9f658 CR3: 000000001ed0d000 CR4: 0000000000750ef0  PKRU: 55555554  Call Trace:  <TASK>  kvmalloc include/linux/slab.h:738 [inline]  copy\_params drivers/md/dm-ioctl.c:1966 [inline]  ctl\_ioctl+0x5a7/0xad0 drivers/md/dm-ioctl.c:2070  dm\_ctl\_ioctl+0x25/0x30 drivers/md/dm-ioctl.c:2103  vfs\_ioctl fs/ioctl.c:51 [inline]  \_\_do\_sys\_ioctl fs/ioctl.c:871 [inline]  \_\_se\_sys\_ioctl fs/ioctl.c:857 [inline]  \_\_x64\_sys\_ioctl+0x19d/0x210 fs/ioctl.c:857  do\_syscall\_x64 arch/x86/entry/common.c:51 [inline]  do\_syscall\_64+0x3f/0xe0 arch/x86/entry/common.c:82  entry\_SYSCALL\_64\_after\_hwframe+0x63/0x6b  RIP: 0033:0x7fd044f1657d  Code: c3 e8 37 20 00 00 0f 1f 80 00 00 00 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48  RSP: 002b:00007fd044e9f1b8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000010  RAX: ffffffffffffffda RBX: 00007fd044fb1218 RCX: 00007fd044f1657d  RDX: 0000000020001a40 RSI: 00000000c138fd02 RDI: 0000000000000003  RBP: 00007fd044fb1210 R08: 00007ffd74b7727f R09: 00007fd044e9f640  R10: 0000000000000000 R11: 0000000000000246 R12: 00007fd044fb121c  R13: 0000000000000000 R14: 00007fd044ede720 R15: 00007fd044e7f000  </TASK>      **Syzkaller reproducer:**  # {Threaded:true Repeat:true RepeatTimes:0 Procs:1 Slowdown:1 Sandbox: SandboxArg:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false NicVF:false USB:false VhciInjection:false Wifi:false IEEE802154:false Sysctl:false Swap:false UseTmpDir:false HandleSegv:false Repro:false Trace:false LegacyOptions:{Collide:false Fault:false FaultCall:0 FaultNth:0}}  r0 = openat$dm\_ctl(0xffffffffffffff9c, &(0x7f0000001740), 0x2, 0x0)  ioctl$DM\_LIST\_DEVICES(r0, 0xc138fd02, &(0x7f0000001a40)={[0x80, 0x2, 0x8], 0xfffffff7, 0x4, 0xffffffff, 0x1, 0x0, 0x401, 0xb343, 0x5, "68e13bcbb7a06fdc850a413ee671d60fd199aaae3192593434175f393a0b4871b1face608d1c03b8b8e15d908f68279d4f1f54dcf69536a0319bc51d054ebaa2c7f46138fa96f653c6c4eb53df16d75adc3c325c80a5d7c1716c3d64f1d2b45981bdb014925e83a657036110d1fa84f48b1f3061c08ebee460bcfedd9b64150a", "e1b2729c21d9ccf8272995c702bc273fc3498e8ae2dbaf0dcbbaeffa78586e234bacc0ac62fd6f628d162e65c1b9dcb78ab0a713f999bd28558eeece0bb9fbe721be74f153bd73d2ba2d405dddde4efc53ebfad5e02432f94ae6dc4153aca6fd3363ee9bb0c13dbf45349dd21bb09751bbd36317bc36e10c84a9d2a9fb491eb1f9", "2d583a0bcd8671"}) (async)  ioctl$DM\_LIST\_DEVICES(r0, 0xc138fd02, &(0x7f0000001a40)={[0x80, 0x2, 0x8], 0xfffffff7, 0x4, 0xffffffff, 0x1, 0x0, 0x401, 0xb343, 0x5, "68e13bcbb7a06fdc850a413ee671d60fd199aaae3192593434175f393a0b4871b1face608d1c03b8b8e15d908f68279d4f1f54dcf69536a0319bc51d054ebaa2c7f46138fa96f653c6c4eb53df16d75adc3c325c80a5d7c1716c3d64f1d2b45981bdb014925e83a657036110d1fa84f48b1f3061c08ebee460bcfedd9b64150a", "e1b2729c21d9ccf8272995c702bc273fc3498e8ae2dbaf0dcbbaeffa78586e234bacc0ac62fd6f628d162e65c1b9dcb78ab0a713f999bd28558eeece0bb9fbe721be74f153bd73d2ba2d405dddde4efc53ebfad5e02432f94ae6dc4153aca6fd3363ee9bb0c13dbf45349dd21bb09751bbd36317bc36e10c84a9d2a9fb491eb1f9", "2d583a0bcd8671"})    Best,  Chenyuan |
| --- |

**Attachment:
[dm-ctl-bug.log](attachments/binFV7jMy1QQc.bin)**

*Description:* dm-ctl-bug.log

```
// autogenerated by syzkaller (<https://github.com/google/syzkaller>)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i = 0;
  for (; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  for (call = 0; call < 3; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (call == 1)
        break;
      event_timedwait(&th->done, 50);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res = 0;
  switch (call) {
  case 0:
    memcpy((void*)0x20001740, "/dev/mapper/control\000", 20);
    res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul,
                  /*file=*/0x20001740ul, /*flags=*/2ul, /*mode=*/0ul);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    *(uint32_t*)0x20001a40 = 0x80;
    *(uint32_t*)0x20001a44 = 2;
    *(uint32_t*)0x20001a48 = 8;
    *(uint32_t*)0x20001a4c = 0xfffffff7;
    *(uint32_t*)0x20001a50 = 4;
    *(uint32_t*)0x20001a54 = -1;
    *(uint32_t*)0x20001a58 = 1;
    *(uint32_t*)0x20001a5c = 0;
    *(uint32_t*)0x20001a60 = 0x401;
    *(uint32_t*)0x20001a64 = 0xb343;
    *(uint64_t*)0x20001a68 = 5;
    memcpy((void*)0x20001a70,
           "\x68\xe1\x3b\xcb\xb7\xa0\x6f\xdc\x85\x0a\x41\x3e\xe6\x71\xd6\x0f"
           "\xd1\x99\xaa\xae\x31\x92\x59\x34\x34\x17\x5f\x39\x3a\x0b\x48\x71"
           "\xb1\xfa\xce\x60\x8d\x1c\x03\xb8\xb8\xe1\x5d\x90\x8f\x68\x27\x9d"
           "\x4f\x1f\x54\xdc\xf6\x95\x36\xa0\x31\x9b\xc5\x1d\x05\x4e\xba\xa2"
           "\xc7\xf4\x61\x38\xfa\x96\xf6\x53\xc6\xc4\xeb\x53\xdf\x16\xd7\x5a"
           "\xdc\x3c\x32\x5c\x80\xa5\xd7\xc1\x71\x6c\x3d\x64\xf1\xd2\xb4\x59"
           "\x81\xbd\xb0\x14\x92\x5e\x83\xa6\x57\x03\x61\x10\xd1\xfa\x84\xf4"
           "\x8b\x1f\x30\x61\xc0\x8e\xbe\xe4\x60\xbc\xfe\xdd\x9b\x64\x15\x0a",
           128);
    memcpy(
        (void*)0x20001af0,
        "\xe1\xb2\x72\x9c\x21\xd9\xcc\xf8\x27\x29\x95\xc7\x02\xbc\x27\x3f\xc3"
        "\x49\x8e\x8a\xe2\xdb\xaf\x0d\xcb\xba\xef\xfa\x78\x58\x6e\x23\x4b\xac"
        "\xc0\xac\x62\xfd\x6f\x62\x8d\x16\x2e\x65\xc1\xb9\xdc\xb7\x8a\xb0\xa7"
        "\x13\xf9\x99\xbd\x28\x55\x8e\xee\xce\x0b\xb9\xfb\xe7\x21\xbe\x74\xf1"
        "\x53\xbd\x73\xd2\xba\x2d\x40\x5d\xdd\xde\x4e\xfc\x53\xeb\xfa\xd5\xe0"
        "\x24\x32\xf9\x4a\xe6\xdc\x41\x53\xac\xa6\xfd\x33\x63\xee\x9b\xb0\xc1"
        "\x3d\xbf\x45\x34\x9d\xd2\x1b\xb0\x97\x51\xbb\xd3\x63\x17\xbc\x36\xe1"
        "\x0c\x84\xa9\xd2\xa9\xfb\x49\x1e\xb1\xf9",
        129);
    memcpy((void*)0x20001b71, "\x2d\x58\x3a\x0b\xcd\x86\x71", 7);
    syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0xc138fd02, /*arg=*/0x20001a40ul);
    break;
  case 2:
    *(uint32_t*)0x20001a40 = 0x80;
    *(uint32_t*)0x20001a44 = 2;
    *(uint32_t*)0x20001a48 = 8;
    *(uint32_t*)0x20001a4c = 0xfffffff7;
    *(uint32_t*)0x20001a50 = 4;
    *(uint32_t*)0x20001a54 = -1;
    *(uint32_t*)0x20001a58 = 1;
    *(uint32_t*)0x20001a5c = 0;
    *(uint32_t*)0x20001a60 = 0x401;
    *(uint32_t*)0x20001a64 = 0xb343;
    *(uint64_t*)0x20001a68 = 5;
    memcpy((void*)0x20001a70,
           "\x68\xe1\x3b\xcb\xb7\xa0\x6f\xdc\x85\x0a\x41\x3e\xe6\x71\xd6\x0f"
           "\xd1\x99\xaa\xae\x31\x92\x59\x34\x34\x17\x5f\x39\x3a\x0b\x48\x71"
           "\xb1\xfa\xce\x60\x8d\x1c\x03\xb8\xb8\xe1\x5d\x90\x8f\x68\x27\x9d"
           "\x4f\x1f\x54\xdc\xf6\x95\x36\xa0\x31\x9b\xc5\x1d\x05\x4e\xba\xa2"
           "\xc7\xf4\x61\x38\xfa\x96\xf6\x53\xc6\xc4\xeb\x53\xdf\x16\xd7\x5a"
           "\xdc\x3c\x32\x5c\x80\xa5\xd7\xc1\x71\x6c\x3d\x64\xf1\xd2\xb4\x59"
           "\x81\xbd\xb0\x14\x92\x5e\x83\xa6\x57\x03\x61\x10\xd1\xfa\x84\xf4"
           "\x8b\x1f\x30\x61\xc0\x8e\xbe\xe4\x60\xbc\xfe\xdd\x9b\x64\x15\x0a",
           128);
    memcpy(
        (void*)0x20001af0,
        "\xe1\xb2\x72\x9c\x21\xd9\xcc\xf8\x27\x29\x95\xc7\x02\xbc\x27\x3f\xc3"
        "\x49\x8e\x8a\xe2\xdb\xaf\x0d\xcb\xba\xef\xfa\x78\x58\x6e\x23\x4b\xac"
        "\xc0\xac\x62\xfd\x6f\x62\x8d\x16\x2e\x65\xc1\xb9\xdc\xb7\x8a\xb0\xa7"
        "\x13\xf9\x99\xbd\x28\x55\x8e\xee\xce\x0b\xb9\xfb\xe7\x21\xbe\x74\xf1"
        "\x53\xbd\x73\xd2\xba\x2d\x40\x5d\xdd\xde\x4e\xfc\x53\xeb\xfa\xd5\xe0"
        "\x24\x32\xf9\x4a\xe6\xdc\x41\x53\xac\xa6\xfd\x33\x63\xee\x9b\xb0\xc1"
        "\x3d\xbf\x45\x34\x9d\xd2\x1b\xb0\x97\x51\xbb\xd3\x63\x17\xbc\x36\xe1"
        "\x0c\x84\xa9\xd2\xa9\xfb\x49\x1e\xb1\xf9",
        129);
    memcpy((void*)0x20001b71, "\x2d\x58\x3a\x0b\xcd\x86\x71", 7);
    syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0xc138fd02, /*arg=*/0x20001a40ul);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=*/7ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  loop();
  return 0;
}

```

**Attachment:
[kernel.config](attachments/binEDdqoBb7to.bin)**

*Description:* kernel.config

---

* **Follow-Ups**:
  + **[Re: [LInux Kernel Crash] "WARNING: kmalloc bug in ctl\_ioctl"](msg56588.html)**
    - *From:* Greg KH

* Prev by Date:
  **[Re: [PATCH 16/16] multipath: Don't always retry deletgated remove failures](msg56573.html)**
* Next by Date:
  **[Re: Stuck IOs with dm-integrity + md raid1 + dm-thin](msg56575.html)**
* Previous by thread:
  **[Re: [PATCH 16/16] multipath: Don't always retry deletgated remove failures](msg56573.html)**
* Next by thread:
  **[Re: [LInux Kernel Crash] "WARNING: kmalloc bug in ctl\_ioctl"](msg56588.html)**
* Index(es):
  + [**Date**](maillist.html#56574)
  + [**Thread**](threads.html#56574)

[[Index of Archives]](/lists/)

[[DM Crypt]](/lists/dm-crypt/)

[[Fedora Desktop]](/lists/fedora-desktop/)

[[ATA RAID]](/lists/ataraid/)

[[Fedora Marketing]](/lists/fedora-marketing/)

[[Fedora Packaging]](/lists/fedora-packaging/)

[[Fedora SELinux]](/lists/fedora-selinux/)

[[Yosemite Discussion]](https://yosemitenews.info)

[[KDE Users]](/lists/kde/)

[[Fedora Docs]](/lists/fedora-docs/)

---

|  | [Powered by Linux](/lists/) |
| --- | --- |

