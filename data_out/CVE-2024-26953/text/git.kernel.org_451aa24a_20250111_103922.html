

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Dragos Tatulea <dtatulea@nvidia.com> | 2024-03-08 17:26:00 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-03 15:11:29 +0200 |
| commit | [1abb20a5f4b02fb3020f88456fc1e6069b3cdc45](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)) | |
| tree | [77bfe88cb3fab5dffe7900f0fd552cd003cb8911](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45) | |
| parent | [3b8da67191e938a63d2736dabb4ac5d337e5de57](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=3b8da67191e938a63d2736dabb4ac5d337e5de57) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45&id2=3b8da67191e938a63d2736dabb4ac5d337e5de57)) | |
| download | [linux-1abb20a5f4b02fb3020f88456fc1e6069b3cdc45.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-1abb20a5f4b02fb3020f88456fc1e6069b3cdc45.tar.gz) | |

net: esp: fix bad handling of pages from page\_pool[ Upstream commit c3198822c6cb9fb588e446540485669cc81c5d34 ]
When the skb is reorganized during esp\_output (!esp->inline), the pages
coming from the original skb fragments are supposed to be released back
to the system through put\_page. But if the skb fragment pages are
originating from a page\_pool, calling put\_page on them will trigger a
page\_pool leak which will eventually result in a crash.
This leak can be easily observed when using CONFIG\_DEBUG\_VM and doing
ipsec + gre (non offloaded) forwarding:
BUG: Bad page state in process ksoftirqd/16 pfn:1451b6
page:00000000de2b8d32 refcount:0 mapcount:0 mapping:0000000000000000 index:0x1451b6000 pfn:0x1451b6
flags: 0x200000000000000(node=0|zone=2)
page\_type: 0xffffffff()
raw: 0200000000000000 dead000000000040 ffff88810d23c000 0000000000000000
raw: 00000001451b6000 0000000000000001 00000000ffffffff 0000000000000000
page dumped because: page\_pool leak
Modules linked in: ip\_gre gre mlx5\_ib mlx5\_core xt\_conntrack xt\_MASQUERADE nf\_conntrack\_netlink nfnetlink iptable\_nat nf\_nat xt\_addrtype br\_netfilter rpcrdma rdma\_ucm ib\_iser libiscsi scsi\_transport\_iscsi ib\_umad rdma\_cm ib\_ipoib iw\_cm ib\_cm ib\_uverbs ib\_core overlay zram zsmalloc fuse [last unloaded: mlx5\_core]
CPU: 16 PID: 96 Comm: ksoftirqd/16 Not tainted 6.8.0-rc4+ #22
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
Call Trace:
<TASK>
dump\_stack\_lvl+0x36/0x50
bad\_page+0x70/0xf0
free\_unref\_page\_prepare+0x27a/0x460
free\_unref\_page+0x38/0x120
esp\_ssg\_unref.isra.0+0x15f/0x200
esp\_output\_tail+0x66d/0x780
esp\_xmit+0x2c5/0x360
validate\_xmit\_xfrm+0x313/0x370
? validate\_xmit\_skb+0x1d/0x330
validate\_xmit\_skb\_list+0x4c/0x70
sch\_direct\_xmit+0x23e/0x350
\_\_dev\_queue\_xmit+0x337/0xba0
? nf\_hook\_slow+0x3f/0xd0
ip\_finish\_output2+0x25e/0x580
iptunnel\_xmit+0x19b/0x240
ip\_tunnel\_xmit+0x5fb/0xb60
ipgre\_xmit+0x14d/0x280 [ip\_gre]
dev\_hard\_start\_xmit+0xc3/0x1c0
\_\_dev\_queue\_xmit+0x208/0xba0
? nf\_hook\_slow+0x3f/0xd0
ip\_finish\_output2+0x1ca/0x580
ip\_sublist\_rcv\_finish+0x32/0x40
ip\_sublist\_rcv+0x1b2/0x1f0
? ip\_rcv\_finish\_core.constprop.0+0x460/0x460
ip\_list\_rcv+0x103/0x130
\_\_netif\_receive\_skb\_list\_core+0x181/0x1e0
netif\_receive\_skb\_list\_internal+0x1b3/0x2c0
napi\_gro\_receive+0xc8/0x200
gro\_cell\_poll+0x52/0x90
\_\_napi\_poll+0x25/0x1a0
net\_rx\_action+0x28e/0x300
\_\_do\_softirq+0xc3/0x276
? sort\_range+0x20/0x20
run\_ksoftirqd+0x1e/0x30
smpboot\_thread\_fn+0xa6/0x130
kthread+0xcd/0x100
? kthread\_complete\_and\_exit+0x20/0x20
ret\_from\_fork+0x31/0x50
? kthread\_complete\_and\_exit+0x20/0x20
ret\_from\_fork\_asm+0x11/0x20
</TASK>
The suggested fix is to introduce a new wrapper (skb\_page\_unref) that
covers page refcounting for page\_pool pages as well.
Cc: stable@vger.kernel.org
Fixes: 6a5bcd84e886 ("page\_pool: Allow drivers to hint on SKB recycling")
Reported-and-tested-by: Anatoli N.Chechelnickiy <Anatoli.Chechelnickiy@m.interpipe.biz>
Reported-by: Ian Kumlien <ian.kumlien@gmail.com>
Link: [https://lore.kernel.org/netdev/CAA85sZvvHtrpTQRqdaOx6gd55zPAVsqMYk\_Lwh4Md5knTq7AyA@mail.gmail.com](https://lore.kernel.org/netdev/CAA85sZvvHtrpTQRqdaOx6gd55zPAVsqMYk_Lwh4Md5knTq7AyA%40mail.gmail.com)
Signed-off-by: Dragos Tatulea <dtatulea@nvidia.com>
Reviewed-by: Mina Almasry <almasrymina@google.com>
Reviewed-by: Jakub Kicinski <kuba@kernel.org>
Acked-by: Ilias Apalodimas <ilias.apalodimas@linaro.org>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)

| -rw-r--r-- | [include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/skbuff.h?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/esp4.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/esp4.c?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/esp6.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/esp6.c?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45) | 8 | |  |  |  | | --- | --- | --- | |

3 files changed, 18 insertions, 8 deletions

| diff --git a/include/linux/skbuff.h b/include/linux/skbuff.hindex 763e9264402f06..bd06942757f5fd 100644--- a/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=3b8da67191e938a63d2736dabb4ac5d337e5de57)+++ b/[include/linux/skbuff.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/skbuff.h?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)@@ -3439,6 +3439,16 @@ static inline void skb\_frag\_ref(struct sk\_buff \*skb, int f) bool napi\_pp\_put\_page(struct page \*page, bool napi\_safe);  static inline void+skb\_page\_unref(const struct sk\_buff \*skb, struct page \*page, bool napi\_safe)+{+#ifdef CONFIG\_PAGE\_POOL+ if (skb->pp\_recycle && napi\_pp\_put\_page(page, napi\_safe))+ return;+#endif+ put\_page(page);+}++static inline void napi\_frag\_unref(skb\_frag\_t \*frag, bool recycle, bool napi\_safe) { struct page \*page = skb\_frag\_page(frag);diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.cindex 4ccfc104f13a51..fe501d2186bcf0 100644--- a/[net/ipv4/esp4.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/esp4.c?id=3b8da67191e938a63d2736dabb4ac5d337e5de57)+++ b/[net/ipv4/esp4.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/esp4.c?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)@@ -95,7 +95,7 @@ static inline struct scatterlist \*esp\_req\_sg(struct crypto\_aead \*aead, \_\_alignof\_\_(struct scatterlist)); } -static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp)+static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp, struct sk\_buff \*skb) { struct crypto\_aead \*aead = x->data; int extralen = 0;@@ -114,7 +114,7 @@ static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp) \*/ if (req->src != req->dst) for (sg = sg\_next(req->src); sg; sg = sg\_next(sg))- put\_page(sg\_page(sg));+ skb\_page\_unref(skb, sg\_page(sg), false); }  #ifdef CONFIG\_INET\_ESPINTCP@@ -260,7 +260,7 @@ static void esp\_output\_done(void \*data, int err) }  tmp = ESP\_SKB\_CB(skb)->tmp;- esp\_ssg\_unref(x, tmp);+ esp\_ssg\_unref(x, tmp, skb); kfree(tmp);  if (xo && (xo->flags & XFRM\_DEV\_RESUME)) {@@ -639,7 +639,7 @@ int esp\_output\_tail(struct xfrm\_state \*x, struct sk\_buff \*skb, struct esp\_info \* }  if (sg != dsg)- esp\_ssg\_unref(x, tmp);+ esp\_ssg\_unref(x, tmp, skb);  if (!err && x->encap && x->encap->encap\_type == TCP\_ENCAP\_ESPINTCP) err = esp\_output\_tail\_tcp(x, skb);diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.cindex 2cc1a45742d823..a3fa3eda388a44 100644--- a/[net/ipv6/esp6.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/esp6.c?id=3b8da67191e938a63d2736dabb4ac5d337e5de57)+++ b/[net/ipv6/esp6.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/esp6.c?id=1abb20a5f4b02fb3020f88456fc1e6069b3cdc45)@@ -112,7 +112,7 @@ static inline struct scatterlist \*esp\_req\_sg(struct crypto\_aead \*aead, \_\_alignof\_\_(struct scatterlist)); } -static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp)+static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp, struct sk\_buff \*skb) { struct crypto\_aead \*aead = x->data; int extralen = 0;@@ -131,7 +131,7 @@ static void esp\_ssg\_unref(struct xfrm\_state \*x, void \*tmp) \*/ if (req->src != req->dst) for (sg = sg\_next(req->src); sg; sg = sg\_next(sg))- put\_page(sg\_page(sg));+ skb\_page\_unref(skb, sg\_page(sg), false); }  #ifdef CONFIG\_INET6\_ESPINTCP@@ -294,7 +294,7 @@ static void esp\_output\_done(void \*data, int err) }  tmp = ESP\_SKB\_CB(skb)->tmp;- esp\_ssg\_unref(x, tmp);+ esp\_ssg\_unref(x, tmp, skb); kfree(tmp);  esp\_output\_encap\_csum(skb);@@ -677,7 +677,7 @@ int esp6\_output\_tail(struct xfrm\_state \*x, struct sk\_buff \*skb, struct esp\_info }  if (sg != dsg)- esp\_ssg\_unref(x, tmp);+ esp\_ssg\_unref(x, tmp, skb);  if (!err && x->encap && x->encap->encap\_type == TCP\_ENCAP\_ESPINTCP) err = esp\_output\_tail\_tcp(x, skb); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 10:38:00 +0000

