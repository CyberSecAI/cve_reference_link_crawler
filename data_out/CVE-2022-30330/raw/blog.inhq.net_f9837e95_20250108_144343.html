<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag -->
<title>KeepKey Supervisor Vulnerabilities (CVE-2022-30330) | invd blog</title>
<meta name="generator" content="Jekyll" />
<meta property="og:title" content="KeepKey Supervisor Vulnerabilities (CVE-2022-30330)" />
<meta name="author" content="Christian Reitter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The article describes several vulnerabilities in the KeepKey hardware wallet. Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes." />
<meta property="og:description" content="The article describes several vulnerabilities in the KeepKey hardware wallet. Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes." />
<link rel="canonical" href="https://blog.inhq.net/posts/keepkey-CVE-2022-30330/" />
<meta property="og:url" content="https://blog.inhq.net/posts/keepkey-CVE-2022-30330/" />
<meta property="og:site_name" content="invd blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-18T16:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="KeepKey Supervisor Vulnerabilities (CVE-2022-30330)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Christian Reitter"},"dateModified":"2022-05-18T16:00:00+02:00","datePublished":"2022-05-18T16:00:00+02:00","description":"The article describes several vulnerabilities in the KeepKey hardware wallet. Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations. Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes.","headline":"KeepKey Supervisor Vulnerabilities (CVE-2022-30330)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.inhq.net/posts/keepkey-CVE-2022-30330/"},"url":"https://blog.inhq.net/posts/keepkey-CVE-2022-30330/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.inhq.net/feed.xml" title="invd blog" /><script type="text/javascript">
  var _paq = window._paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  _paq.push(['setSecureCookie', true]);
  _paq.push(['setVisitorCookieTimeout', 60 * 60 * 24 * 90]);
  _paq.push(['setReferralCookieTimeout', 60 * 60 * 24 * 90]);
  _paq.push(['appendToTrackingUrl', 'bots=1']);
  (function() {
    var u="https://mato.inhq.net/";
    _paq.push(['setTrackerUrl', u+'m']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'mat.js'; s.parentNode.insertBefore(g,s);
  })();
  </script></head>
<body><header class="site-header"><noscript><img src="https://mato.inhq.net/m?rec=1&bots=1&idsite=1" alt="" style="position:absolute; visibility:hidden" /></noscript><div class="wrapper"><a class="site-title" rel="author" href="/">invd blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
        <a class="page-link" href="/archive/">Archive</a><a class="page-link" href="/cve/">CVEs</a><a class="page-link" href="/consulting/">Consulting</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">KeepKey Supervisor Vulnerabilities (CVE-2022-30330)</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-05-18T16:00:00+02:00" itemprop="datePublished">
        May 18, 2022
      </time>â¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Christian Reitter</span></span><br/>ID:
        
          
          <span>CVE-2022-30330</span>
        <br/>
      <div class="related_article">
      Related articles:
      <a href="/posts/keepkey-CVE-2023-27892/">KeepKey Memory Exfiltration Vulnerability (CVE-2023-27892)</a>
          â¢ <a href="/posts/keepkey-VULN-22003/">KeepKey Message State Handling Vulnerability (VULN-22003)</a>
          â¢ <a href="/posts/keepkey-glitching-vuln-21020/">Glitching over KeepKey Firmware Protections (VULN-21020)</a>
          </p></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The article describes several vulnerabilities in the KeepKey hardware wallet. Flaws in the supervisor interface can be exploited to bypass important security restrictions on firmware operations.
Using these flaws, malicious firmware code can elevate privileges, permanently make the device inoperable or overwrite the trusted bootloader code to compromise the hardware wallet across reboots or storage wipes.</p>

<p>The new discovery has implications for code execution attacks such as <a href="/posts/keepkey-CVE-2021-31616/">CVE-2021-31616</a>, attacks with some level of physical access as well as the general trust expectations for the wallet system integrity after the installation of unofficial firmware.
<br /></p>

<div id="toc-container">
  <h2 class="no_toc">Contents</h2>
<ul id="markdown-toc">
  <li><a href="#high-level-summary" id="markdown-toc-high-level-summary">High-Level Summary</a></li>
  <li><a href="#technical-introduction" id="markdown-toc-technical-introduction">Technical Introduction</a></li>
  <li><a href="#the-vulnerabilities" id="markdown-toc-the-vulnerabilities">The Vulnerabilities</a>    <ul>
      <li><a href="#insufficient-protection-of-flash-sector-erase-functionality-vuln-22004" id="markdown-toc-insufficient-protection-of-flash-sector-erase-functionality-vuln-22004">Insufficient Protection of Flash Sector Erase Functionality (VULN-22004)</a></li>
      <li><a href="#insufficient-protection-of-flash-block-write-functionality-vuln-22005" id="markdown-toc-insufficient-protection-of-flash-block-write-functionality-vuln-22005">Insufficient Protection of Flash Block Write Functionality (VULN-22005)</a></li>
      <li><a href="#unrestricted-memory-and-flash-overwrite-via-supervisor-functions-vuln-22006" id="markdown-toc-unrestricted-memory-and-flash-overwrite-via-supervisor-functions-vuln-22006">Unrestricted Memory and Flash Overwrite via Supervisor Functions (VULN-22006)</a></li>
    </ul>
  </li>
  <li><a href="#poc" id="markdown-toc-poc">POC</a>    <ul>
      <li><a href="#poc-for-vuln-22004-and-vuln-22005" id="markdown-toc-poc-for-vuln-22004-and-vuln-22005">POC for VULN-22004 and VULN-22005</a></li>
      <li><a href="#poc-vuln-22006---attacking-privileged-sram-region" id="markdown-toc-poc-vuln-22006---attacking-privileged-sram-region">POC VULN-22006 - Attacking Privileged SRAM Region</a></li>
      <li><a href="#poc-vuln-22006---attacking-privileged-flash-region" id="markdown-toc-poc-vuln-22006---attacking-privileged-flash-region">POC VULN-22006 - Attacking Privileged Flash Region</a></li>
    </ul>
  </li>
  <li><a href="#attack-scenario-and-security-implications" id="markdown-toc-attack-scenario-and-security-implications">Attack Scenario and Security Implications</a></li>
  <li><a href="#coordinated-disclosure" id="markdown-toc-coordinated-disclosure">Coordinated disclosure</a>    <ul>
      <li><a href="#relevant-product" id="markdown-toc-relevant-product">Relevant product</a></li>
      <li><a href="#a-note-about-research-affiliation-and-work-time" id="markdown-toc-a-note-about-research-affiliation-and-work-time">A Note About Research Affiliation and Work Time</a></li>
      <li><a href="#detailed-timeline" id="markdown-toc-detailed-timeline">Detailed timeline</a></li>
      <li><a href="#bug-bounty" id="markdown-toc-bug-bounty">Bug bounty</a></li>
    </ul>
  </li>
</ul>

</div>

<h2 class="no_toc">Consulting</h2>

<p><i>Iâm a freelance Security Consultant and currently available for new projects.
  If you are looking for assistance to secure your projects or organization, <a href="/consulting">contact me</a>.</i></p>

<p><a id="high_level_summary"></a></p>
<h2 id="high-level-summary">High-Level Summary</h2>
<p>The following article is highly technical, so here is a slightly less-technical summary.</p>

<p>The KeepKey hardware wallet has some basic protections in place to limit what some parts of its software can do.
This gives trust in the device by making it harder to backdoor permanently via malware, similar to modern smartphone systems.</p>

<p>The new flaws in KeepKey protections that I discovered basically allow a âJailbreakâ of the KeepKey. The main program on the device can break out of the protective cage it is in.
This may be useful for some power users who want more control over their device, but itâs also useful for attackers who temporarily made it onto the device somehow or have physical access and can install custom firmware. They can use these flaws to permanently corrupt the core device software.</p>

<p>A device with malicious core software no longer has to follow the normal rules.
It could generate new mnemonic secrets that an attacker has access to, lie to you about installing updates or attack your computer via USB. It can also erase itself and stop working at any time.
This is clearly a bad situation for trusting the device with funds, and the extra annoying part is that it is difficult to find out <em>if</em> a device is malicious, for example if you buy a new one tomorrow from a less-trustworthy seller. Unfortunately, the hologram stickers <a href="/posts/tamper-evident-seals2/#breaking-holographic-designs">wonât help you</a> and wiping the device storage or reinstalling the firmware is not enough.</p>

<p>My main recommendation is to swiftly install the new security patches.
However, if you have previously used firmware <code class="language-plaintext highlighter-rouge">v7.0.3</code> on computers or websites you donât fully trust, it may be a good time to read up on <a href="/posts/keepkey-CVE-2021-31616/">CVE-2021-31616</a>, check your funds and change your mnemonic seed or device.</p>

<p>Be extra careful about new devices that you buy, as this vulnerability makes it cheaper for attacker to corrupt them.</p>

<h2 id="technical-introduction">Technical Introduction</h2>
<p>This article focuses on breaking the security supervisor code implementation of the KeepKey hardware wallet.
To understand the context, first a little primer on what this software component is supposed to be doing.</p>

<p>The ARM Cortex M3 microcontroller series does not have any multi-tasking capability or sophisticated process security concepts that one may expect from larger processors.
Instead, the available hardware-assisted protections consist of a two-level privilege concept for code separation at runtime which is enforced through hardware-assisted privilege level handling and memory protection settings.
The Trezor and KeepKey system designs use this privilege system to limit potential actions of malicious firmware, especially for the flash write operations, with the goal to harden the overall system or at least make security issues observable to the user. This is done through a software root-of-trust concept based on a trusted bootloader, combined with cryptographically signed firmware releases. The bootloader controls firmware updates, checks firmware signatures on device startup, and provides the code for the supervisor component that is active after boot.</p>

<p>Essential configuration steps during startup:</p>
<ol>
  <li>The Memory Protection Unit (MPU) for the lower-privileged operation mode is configured to disallow access to flash controller related memory areas, the flash, the bootloader RAM section and other memory. This limits the internal access of the firmware.</li>
  <li>The code drops permissions by switching into a lower-privileged mode before starting the main firmware (for custom firmware) or briefly after the start of main firmware execution (for signed firmware). From this state, hardware protections ensure that the firmware is not able to directly re-enter the privileged mode or change the MPU configuration. This helps to limit the impact of code issues or compromises of the main firmware during normal operations.</li>
</ol>

<p>On the KeepKey, the supervisor logic mainly focuses on guarding flash operations. All flash writes of the firmware are proxied through the supervisor code via custom interrupts. The <code class="language-plaintext highlighter-rouge">svc_handler_main()</code> is tasked with the role of a gatekeeper for potentially dangerous accesses.</p>

<p>However, Iâve discovered that this code is broken in several ways, which completely undermines the sandbox design and allows the firmware to break out of it.</p>

<h2 id="the-vulnerabilities">The Vulnerabilities</h2>

<p>During security research in February 2022, I took a closer look at the <code class="language-plaintext highlighter-rouge">supervise.c</code> code and found several flaws. They are clustered into several sections with similar issue patterns.</p>

<h3 id="insufficient-protection-of-flash-sector-erase-functionality-vuln-22004">Insufficient Protection of Flash Sector Erase Functionality (VULN-22004)</h3>

<p>The ARM Cortex M onboard flash is divided into a number of differently sized flash sectors. On the <code class="language-plaintext highlighter-rouge">STM32F205</code> chip that the KeepKey uses, they have the id <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">11</code>. Sector numbers go up to <code class="language-plaintext highlighter-rouge">23</code> on other STM32 chip series.</p>

<p>For technical reasons, the supervisor function call parameters of <code class="language-plaintext highlighter-rouge">svc_*</code> functions are typically passed as unsigned 32-bit integer variables during the interrupt handling. As a result, despite the limited numerical range that is actually required to describe the target sector, <code class="language-plaintext highlighter-rouge">svhandler_flash_erase_sector()</code> accepts and internally uses the full 32-bit  <code class="language-plaintext highlighter-rouge">uint32_t sector</code> for describing the flash sector ID that should be erased.</p>

<p>This choice of parameter type is problematic.</p>

<p>The defensive code checks on the flash erase are designed to reject the three specific sector numbers of 0, 5 and 6 that correspond to important flash areas for the bootloader and for the microcontroller configuration that are exclusively controlled by the bootloader.
Aside from the three numbers on the blocklist, they allow the main firmware to request erasures of all other sectors.</p>

<p>Here is the corresponding code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint32_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">_param_1</span><span class="p">;</span>

<span class="c1">// Do not allow firmware to erase bootstrap or bootloader sectors.</span>
<span class="k">if</span> <span class="p">((</span><span class="n">sector</span> <span class="o">==</span> <span class="n">FLASH_BOOTSTRAP_SECTOR</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">sector</span> <span class="o">&gt;=</span> <span class="n">FLASH_BOOT_SECTOR_FIRST</span> <span class="o">&amp;&amp;</span> <span class="n">sector</span> <span class="o">&lt;=</span> <span class="n">FLASH_BOOT_SECTOR_LAST</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/keepkey/keepkey-firmware/blob/65eddf28e6aff94dd67818cdfb148bf441a502fa/lib/board/supervise.c#L79-L85" class="highlightref">supervise.c</a></p>

<p>The sector erase is done via a <code class="language-plaintext highlighter-rouge">libopencm3</code> library call:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Erase the sector.</span>
<span class="n">flash_erase_sector</span><span class="p">(</span><span class="n">sector</span><span class="p">,</span> <span class="n">FLASH_CR_PROGRAM_X32</span><span class="p">);</span></code></pre></figure>

<p><a href="https://github.com/keepkey/keepkey-firmware/blob/65eddf28e6aff94dd67818cdfb148bf441a502fa/lib/board/supervise.c#L91-92" class="highlightref">supervise.c</a></p>

<p>Crucially, the libopencm3 library function is defined as follows:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">flash_erase_sector</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">sector</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">program_size</span><span class="p">)</span></code></pre></figure>

<p><a href="https://libopencm3.org/docs/latest/stm32f2/html/group__flash__file.html#gad49638626fa6ff605563012ef599bb11" class="highlightref">libopencm3 documentation</a></p>

<p>Why is this a problem?</p>

<p><code class="language-plaintext highlighter-rouge">svhandler_flash_erase_sector()</code> treats the sector number as an unsigned 32 bit number, and incorrectly expects the flash library function <em>to count the same way</em>. Instead, the difference in <code class="language-plaintext highlighter-rouge">sector</code> integer type leads to a well-defined but lossy unsigned integer conversion of the sector number down to the <code class="language-plaintext highlighter-rouge">uint8_t</code> type before it is handed over to the library function.</p>

<p>This conversion maps multiple larger numbers into the forbidden sector numbers <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">6</code>.
An attacker can use this to completely bypass the defensive checks shown previously. For example, a deletion request for the sector <code class="language-plaintext highlighter-rouge">256</code> passes the checks but then actually asks the library to erase the forbidden sector <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>Using this flaw, malicious firmware can request the erasure of any flash sector.</p>

<p><a id="vuln-22004_trezor_aspect"></a></p>
<h4 id="similar-code-problem-on-trezor-one">Similar Code Problem on Trezor One</h4>
<p>During analysis of the erase problem, I found a similar problem in the Trezor One code.
It uses a <code class="language-plaintext highlighter-rouge">uint16_t sector</code> variable that theoretically has the same integer conversion problem during the <code class="language-plaintext highlighter-rouge">flash_erase_sector(sector, FLASH_CR_PROGRAM_X32)</code> call.</p>

<p>However, the Trezor code uses an allowlist approach for the sector checks, which doesnât let any problematic values through:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* we only allow erasing storage sectors 2 and 3. */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">&lt;</span> <span class="n">FLASH_STORAGE_SECTOR_FIRST</span> <span class="o">||</span>
    <span class="n">sector</span> <span class="o">&gt;</span> <span class="n">FLASH_STORAGE_SECTOR_LAST</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/trezor/trezor-firmware/blob/187ca8ad509db65e2f15e587927c2fcf20b83836/legacy/supervise.c#L49-L53=" class="highlightref">supervise.c</a></p>

<p>Sectors <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> donât have a conversion problem, therefore the Trezor One is not practically affected via this issue.</p>

<h3 id="insufficient-protection-of-flash-block-write-functionality-vuln-22005">Insufficient Protection of Flash Block Write Functionality (VULN-22005)</h3>

<p>The KeepKey supervisor interface has two functions for flash writes:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_word()</code> for writing individual 32-bit words to flash</li>
  <li><code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_blk()</code> for writing larger blocks of memory to flash</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">VULN-22005</code> concerns the block write functionality.
The code has existing defenses that detect overflows of the address calculation.
It also checks that the <code class="language-plaintext highlighter-rouge">beginAddr</code> and <code class="language-plaintext highlighter-rouge">beginAddr + length</code> pointers are not <em>in</em> the forbidden memory regions of sectors <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">5 &amp; 6</code>.</p>

<p>Here is the first part of the code checks:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Do not allow firmware to erase bootstrap or bootloader sectors.</span>
<span class="k">if</span> <span class="p">(((</span><span class="n">beginAddr</span> <span class="o">&gt;=</span> <span class="n">BSTRP_FLASH_SECT_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">beginAddr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">BSTRP_FLASH_SECT_START</span> <span class="o">+</span> <span class="n">BSTRP_FLASH_SECT_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">||</span>
    <span class="p">(((</span><span class="n">beginAddr</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">BSTRP_FLASH_SECT_START</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">((</span><span class="n">beginAddr</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&lt;=</span>
      <span class="p">(</span><span class="n">BSTRP_FLASH_SECT_START</span> <span class="o">+</span> <span class="n">BSTRP_FLASH_SECT_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/keepkey/keepkey-firmware/blob/65eddf28e6aff94dd67818cdfb148bf441a502fa/lib/board/supervise.c#L117-L124=" class="highlightref">supervise.c</a></p>

<p>However, these defenses have are incomplete.
They do not prevent a situation where <code class="language-plaintext highlighter-rouge">beginAddr</code> points in <em>front</em> of the forbidden region and <code class="language-plaintext highlighter-rouge">beginAddr + length</code> points <em>behind</em> it.
In other words, whole bootloader sections can be overwritten as long as at least one extra byte behind and in front of them is also overwritten.</p>

<p>Using this flaw, malicious firmware can modify protected flash memory in bulk.</p>

<h4 id="limitations-of-this-attack">Limitations of this Attack</h4>
<p>Similarly to <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_word()</code>, the block write has the typical limitations when writing data to physical flash memory, which means it can only change flash memory bits from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">0</code>. If this were the only vulnerability a malicious firmware had access to, modifications would be limited to flipping bits in one direction in the existing flash data contents. However, this attack can be combined with vulnerability <code class="language-plaintext highlighter-rouge">VULN-22004</code> from the previous section, which makes the data limitation go away. By first erasing the targeted flash region and then overwriting it, memory content can be modified arbitrarily.</p>

<p>During practical testing, writing into sector <code class="language-plaintext highlighter-rouge">0</code> using the <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_blk()</code> does not work. The attack requires at least one write operation <em>in front</em> of the targeted sector. However, the required flash write in front of sector <code class="language-plaintext highlighter-rouge">0</code> is not seen as valid by the microcontroller and the operation gets stuck. The memory in front of sector <code class="language-plaintext highlighter-rouge">0</code> is <em>âreservedâ</em> according to datasheet. It may be possible to circumvent this problem by using some other undocumented edge case behavior. However, I havenât explored this edge case further after the discovery of another attack that doesnât share this limitation.</p>

<p>Writing over the combined sector block 5+6 works as described, see the <a href="#poc_vuln-22005">proof-of-concept</a>.</p>

<h3 id="unrestricted-memory-and-flash-overwrite-via-supervisor-functions-vuln-22006">Unrestricted Memory and Flash Overwrite via Supervisor Functions (VULN-22006)</h3>

<p>While looking into additional problems of <code class="language-plaintext highlighter-rouge">VULN-22005</code>, I noticed that the arbitrary pointer âwrite data from the source to the destinationâ construction of <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_blk()</code> and âwrite this value to the destinationâ of <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_word()</code> are very powerful primitives. 
The blocklist-based defense has shown to be incomplete, are there other ways to misuse them?</p>

<p>After digging a bit deeper, I realized that one needs to view these functions as privileged memory write gadgets (both functions) or a privileged memory read gadget (via <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_blk()</code>).
This is because the STM32 uses memory-mapped IO to write to the flash and has one continuous memory region.
In other words, the microprocessor generally treats flash content as normal memory and writes to it word-wise with direct assignments, or smaller writes if necessary. Therefore, the libopencm3 flash functions can essentially be used to write or read any other data in the STM32 address space if theyâre called with target pointers outside of flash space.</p>

<p>For example, the <a href="https://libopencm3.org/docs/latest/stm32f2/html/group__flash__file.html#ga73937aa6df8710e95425b165730626a2"><code class="language-plaintext highlighter-rouge">flash_program_word()</code></a> essentially prepares the flash write, unlocks the flash and then does a simple write:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">flash_program_word</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">address</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Ensure that all flash operations are complete. */</span>
	<span class="n">flash_wait_for_last_operation</span><span class="p">();</span>
	<span class="n">flash_set_program_size</span><span class="p">(</span><span class="n">FLASH_CR_PROGRAM_X32</span><span class="p">);</span>

	<span class="cm">/* Enable writes to flash. */</span>
	<span class="n">FLASH_CR</span> <span class="o">|=</span> <span class="n">FLASH_CR_PG</span><span class="p">;</span>

	<span class="cm">/* Program the word. */</span>
	<span class="n">MMIO32</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Wait for the write to complete. */</span>
	<span class="n">flash_wait_for_last_operation</span><span class="p">();</span>

	<span class="cm">/* Disable writes to flash. */</span>
	<span class="n">FLASH_CR</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLASH_CR_PG</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/libopencm3/libopencm3/blob/72d40647442b264f2a84f23715c0513297b7dd07/lib/stm32/common/flash_common_f24.c#L124-L141=" class="highlightref">supervise.c</a></p>

<p>Crucially, the <code class="language-plaintext highlighter-rouge">MMIO32(address) = data;</code> succeeds even if itâs not in flash related memory space. The <code class="language-plaintext highlighter-rouge">svhandler_flash_pgm_blk()</code> works similarly and can also be used to copy secret information out of protected memory.</p>

<p>Since this write operation happens in the context of the privileged bootloader code, it does not falls under the restrictive MPU protections for the unprivileged thread.
This is a huge problem for the supervisor integrity. The supervisor operates on its own little memory stack thatâs protected by the MPU from interference by the main firmware:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="c1">// SRAM (0x2001F800 - 0x2001FFFF, bootloader protected ram, priv read-write</span>
  <span class="c1">// only, execute never, disable high subregion)</span>
  <span class="n">MPU_RBAR</span> <span class="o">=</span> <span class="n">BLPROTECT_BASE</span> <span class="o">|</span> <span class="n">MPU_RBAR_VALID</span> <span class="o">|</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="n">MPU_RBAR_REGION_LSB</span><span class="p">);</span>
  <span class="n">MPU_RASR</span> <span class="o">=</span> <span class="n">MPU_RASR_ENABLE</span> <span class="o">|</span> <span class="n">MPU_RASR_ATTR_SRAM</span> <span class="o">|</span> <span class="n">MPU_RASR_DIS_SUB_8</span> <span class="o">|</span>
             <span class="n">MPU_RASR_SIZE_2KB</span> <span class="o">|</span> <span class="n">MPU_RASR_ATTR_AP_PRW_UNO</span> <span class="o">|</span> <span class="n">MPU_RASR_ATTR_XN</span><span class="p">;</span></code></pre></figure>

<p><a href="https://github.com/keepkey/keepkey-firmware/blob/65eddf28e6aff94dd67818cdfb148bf441a502fa/lib/board/memory.c#L72-L76=" class="highlightref">memory.c</a></p>

<p>The memory region protection falls apart if the main firmware can make the privileged thread corrupt its own stack with targeted writes.
This has a significant impact on the bootloader code integrity at runtime. Practical impact may be limited a bit by stack protection and other defenses, but those can likely be circumvented through additional writes.</p>

<p>Additionally, in the global address space of the STM32, important device control registers are memory-mapped to special positions. The unprivileged firmware can access them with through the same flaw, for example the flash controller:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="c1">// by default, the flash controller regs are accessible in unpriv mode, apply</span>
  <span class="c1">// protection (0x40023C00 - 0x40023FFF, privileged read-write, unpriv no,</span>
  <span class="c1">// execute never)</span>
  <span class="n">MPU_RBAR</span> <span class="o">=</span> <span class="mh">0x40023c00</span> <span class="o">|</span> <span class="n">MPU_RBAR_VALID</span> <span class="o">|</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">MPU_RBAR_REGION_LSB</span><span class="p">);</span>
  <span class="n">MPU_RASR</span> <span class="o">=</span> <span class="n">MPU_RASR_ENABLE</span> <span class="o">|</span> <span class="n">MPU_RASR_ATTR_PERIPH</span> <span class="o">|</span> <span class="n">MPU_RASR_SIZE_1KB</span> <span class="o">|</span>
             <span class="n">MPU_RASR_ATTR_AP_PRW_UNO</span> <span class="o">|</span> <span class="n">MPU_RASR_ATTR_XN</span><span class="p">;</span></code></pre></figure>

<p><a href="https://github.com/keepkey/keepkey-firmware/blob/65eddf28e6aff94dd67818cdfb148bf441a502fa/lib/board/memory.c#L84-L89=" class="highlightref">memory.c</a></p>

<p>This can have additional impact, although the MPU still protects some parts of the flash, so there is a remaining barrier against direct modifications of sector <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>How can we break the remaining defenses?</p>

<p>The explicit memory region defense logic of the mentioned flash write functions assumes that there is only one canonical way to address and overwrite the protected flash sections.
However, this assumption is wrong: as the <code class="language-plaintext highlighter-rouge">STM32F205</code> datasheet hints at on page 66, other memory regions such as <code class="language-plaintext highlighter-rouge">0x0000 0000</code> to <code class="language-plaintext highlighter-rouge">0x000F FFFF</code> can <em>alias</em> into the flash memory range. <a href="https://www.codeinsideout.com/blog/stm32/intro/#12-memory-map">Here</a> is a helpful visual overview of relevant memory regions.</p>

<p>What does this mean? Depending on the microcontroller system configuration, the lower memory ranges <em>map directly into flash memory</em>, just as the âmainâ flash memory section starting at <code class="language-plaintext highlighter-rouge">0x08000000</code> does.
The main difference is that the supervisor flash functions forbid access to the protected sectors in the <code class="language-plaintext highlighter-rouge">0x080....</code> regions due to the address comparisons, but they completely allow all writes to the <code class="language-plaintext highlighter-rouge">0x000....</code> region.</p>

<p>Bingo! Weâve just broken the remaining bootloader and trusted boot code integrity defenses.</p>

<p>At this point, I would like to give some credits to Thomas Roth and the rest of the wallet.fail team. They published this memory alias based attack concept as part of the <code class="language-plaintext highlighter-rouge">F00DBABE</code> attack in 2018, see <a href="https://media.ccc.de/v/35c3-9563-wallet_fail#t=1225">the talk section</a> of their classic 35C3 presentation. I half-remembered, half re-discovered this on my own for the KeepKey, but their work is clearly a direct inspiration for the attack idea.</p>

<p>By making the privileged thread write into the aliased flash region, the write protections for sectors <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">6</code> are circumvented without the strict need for special offsets or complete sector overwrites. 
This allows more targeted overwrites of individual areas than the previously described <code class="language-plaintext highlighter-rouge">VULN-22005</code> vulnerability.</p>

<p>As a result of this attack, the complete flash memory can be replaced with arbitrary contents, which breaks the core security model of the KeepKey root of trust.</p>

<h2 id="poc">POC</h2>

<p>Please read the following section carefully.</p>

<p>By the nature of the KeepKey hardware wallet design, access to <code class="language-plaintext highlighter-rouge">SWD</code> and other debug interfaces is permanently disabled on production devices and production firmware.
This is done with the explicit goal to prevent read or write access to the flash.
As a result, there is no intended or straightforward way to recover from problems with the boot-related flash memory.
Testing the issues discussed in this article directly requires erasing or modifying flash content in those essential sectors, so there is a good chance that youâll permanently turn your test device into a dead device. No, itâs not resting - itâs stone dead! ð¦.</p>

<p>To prevent any devices from passing on due to catastrophic flash writes, it is required to both</p>
<ol>
  <li>Have a custom KeepKey with an unlocked <code class="language-plaintext highlighter-rouge">STM32F205</code> microcontroller that is not in <code class="language-plaintext highlighter-rouge">RDP2</code> state.</li>
  <li>Use custom compiled variants of bootloader and firmware which do not lock it.</li>
</ol>

<p>A custom KeepKey devkit can be built by SMD rework, specifically by replacing the TQFP64 chip with a new chip in factory configuration and programming the custom bootloader and firmware variants.</p>

<p>In this configuration, a hardware debugger like the STLINK-V3 can be connected and used to restore flash contents externally as well as controlling the execution. Note that the MPU and thread privilege mechanisms are still active, the unit is just at <code class="language-plaintext highlighter-rouge">RDP0</code> debug protection level.
The POC section describes testing steps with such a setup.</p>

<p><strong>The following proof-of-concept steps will be deadly to your device unless you have working hardware debugger access. You have been warned.</strong></p>

<h3 id="poc-for-vuln-22004-and-vuln-22005">POC for VULN-22004 and VULN-22005</h3>
<p><a id="poc_vuln-22004"></a>
<a id="poc_vuln-22005"></a></p>

<p>This is a combined proof-of-concept for two issues.</p>

<p>For <code class="language-plaintext highlighter-rouge">VULN-22004</code>, the sector number <code class="language-plaintext highlighter-rouge">261</code> is used to target sector <code class="language-plaintext highlighter-rouge">261 % 256 = 5</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// connecting to SWD debug, firmware in idle</span>
<span class="n">display_refresh</span> <span class="p">()</span> <span class="n">at</span> <span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">keepkey</span><span class="o">-</span><span class="n">firmware</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">board</span><span class="o">/</span><span class="n">keepkey_display</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">296</span>

<span class="c1">// original sector 5 bootloader start</span>
<span class="c1">// normal code content</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x08020000</span>
<span class="mh">0x8020000</span><span class="o">:</span>    <span class="mh">0xe8</span>    <span class="mh">0xfe</span>    <span class="mh">0x01</span>    <span class="mh">0x20</span>    <span class="mh">0xef</span>    <span class="mh">0x0c</span>    <span class="mh">0x02</span>    <span class="mh">0x08</span>
<span class="mh">0x8020008</span><span class="o">:</span>    <span class="mh">0xe9</span>    <span class="mh">0x13</span>    <span class="mh">0x02</span>    <span class="mh">0x08</span>    <span class="mh">0xf9</span>    <span class="mh">0xa2</span>    <span class="mh">0x02</span>    <span class="mh">0x08</span>

<span class="c1">// using vulnerability VULN-22004 to erase sector no. 5</span>
<span class="c1">// this triggers the supervisor call from the main firmware</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">svc_flash_erase_sector</span><span class="p">(</span><span class="mi">261</span><span class="p">)</span>

<span class="c1">// sector 5 is now in erased 0xff state</span>
<span class="c1">// attack successful</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x08020000</span>
<span class="mh">0x8020000</span><span class="o">:</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>
<span class="mh">0x8020008</span><span class="o">:</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span>    <span class="mh">0xff</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// arbitrarily chosen memory region with source data</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x20000000</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">10</span>
<span class="mh">0x20002800</span> <span class="o">&lt;</span><span class="n">shadow_config</span><span class="o">+</span><span class="mi">32</span><span class="o">&gt;:</span>    <span class="mh">0x33</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x31</span>    <span class="mh">0x43</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>
<span class="mh">0x20002808</span> <span class="o">&lt;</span><span class="n">shadow_config</span><span class="o">+</span><span class="mi">40</span><span class="o">&gt;:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x10</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>

<span class="c1">// using vulnerability VULN-22005 to overwrite the bootloader sector 5 and 6 with memory from the SRAM source</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">svc_flash_pgm_blk</span><span class="p">(</span><span class="mh">0x0801FFFF</span><span class="p">,</span> <span class="mh">0x20000000</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">10</span> <span class="p">,</span> <span class="mh">0x20000</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// [...]</span>

<span class="c1">// result shows that the flash is overwritten with the provided values</span>
<span class="c1">// note the expected 1-byte address offset due to the target offset</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x08020000</span>
<span class="mh">0x8020000</span><span class="o">:</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x31</span>    <span class="mh">0x43</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x00</span>
<span class="mh">0x8020008</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x10</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x7c</span></code></pre></figure>

<h3 id="poc-vuln-22006---attacking-privileged-sram-region">POC VULN-22006 - Attacking Privileged SRAM Region</h3>
<p><a id="poc_vuln-22006_a"></a></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// connecting to a SWD debug, firmware in idle</span>

<span class="c1">// show target area in supposedly secure bootloader ram</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x2001F800</span>
<span class="mh">0x2001f800</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>
<span class="mh">0x2001f808</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>

<span class="c1">// attack via vulnerability VULN-22006</span>
<span class="c1">// 32-bit word write variant</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">svc_flash_pgm_word</span><span class="p">(</span><span class="mh">0x2001F800</span><span class="p">,</span> <span class="mh">0x42424242</span><span class="p">)</span>
<span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="nb">true</span>

<span class="c1">// show successful write</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x2001F800</span>
<span class="mh">0x2001f800</span><span class="o">:</span>    <span class="mh">0x42</span>    <span class="mh">0x42</span>    <span class="mh">0x42</span>    <span class="mh">0x42</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>
<span class="mh">0x2001f808</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// connecting to a SWD debug, firmware in idle</span>

<span class="c1">// show target area in supposedly secure bootloader ram</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x2001F800</span>
<span class="mh">0x2001f800</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>
<span class="mh">0x2001f808</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>

<span class="c1">// attack via vulnerability VULN-22006</span>
<span class="c1">// block write variant</span>
<span class="c1">// copy data from firmware SRAM to bootloader SRAM</span>
<span class="c1">// chosen source and size are arbitrary examples</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">svc_flash_pgm_blk</span><span class="p">(</span><span class="mh">0x2001F800</span><span class="p">,</span> <span class="mh">0x20000000</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="nb">true</span>

<span class="c1">// show successful write</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x2001F800</span>
<span class="mh">0x2001f800</span><span class="o">:</span>    <span class="mh">0x33</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>    <span class="mh">0x31</span>    <span class="mh">0x43</span>    <span class="mh">0x30</span>    <span class="mh">0x30</span>
<span class="mh">0x2001f808</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x10</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span></code></pre></figure>

<p>For comparison, the following call with firmware-level access would lead to a memory exception due to the MPU:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">memset</span><span class="p">(</span><span class="mh">0x2001F800</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span></code></pre></figure>

<h3 id="poc-vuln-22006---attacking-privileged-flash-region">POC VULN-22006 - Attacking Privileged Flash Region</h3>
<p><a id="poc_vuln-22006_b"></a></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// inspect sector 0 beginning at the main address</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x8000000</span>
<span class="mh">0x8000000</span><span class="o">:</span>    <span class="mh">0xf8</span>    <span class="mh">0xff</span>    <span class="mh">0x01</span>    <span class="mh">0x20</span>    <span class="mh">0xc7</span>    <span class="mh">0x01</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span>
<span class="mh">0x8000008</span><span class="o">:</span>    <span class="mh">0x2b</span>    <span class="mh">0x02</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span>    <span class="mh">0x29</span>    <span class="mh">0x02</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span>

<span class="c1">// write 0x00000000 into address 0x0, which aliases to 0x8000000</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">call</span> <span class="n">svc_flash_pgm_word</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">)</span>
<span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="nb">true</span>

<span class="c1">// show successful write</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">x</span><span class="o">/</span><span class="mi">16</span><span class="n">xb</span> <span class="mh">0x8000000</span>
<span class="mh">0x8000000</span><span class="o">:</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0x00</span>    <span class="mh">0xc7</span>    <span class="mh">0x01</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span>
<span class="mh">0x8000008</span><span class="o">:</span>    <span class="mh">0x2b</span>    <span class="mh">0x02</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span>    <span class="mh">0x29</span>    <span class="mh">0x02</span>    <span class="mh">0x00</span>    <span class="mh">0x08</span></code></pre></figure>

<h2 id="attack-scenario-and-security-implications">Attack Scenario and Security Implications</h2>

<p>See the <a href="#high_level_summary">high-level summary</a>.</p>

<p>The discovered KeepKey issues apply to all recent bootloader versions since the problems in <code class="language-plaintext highlighter-rouge">supervisor.c</code> have been present for multiple years.</p>

<h2 id="coordinated-disclosure">Coordinated disclosure</h2>

<p>The coordinated disclosure went similarly to the <a href="/posts/keepkey-VULN-22003/#coordinated-disclosure">VULN-22003</a> disclosure that started slightly earlier in February with the same vendor.
I received a lot of good feedback and confirmation in a technical call about two weeks into the disclosure.</p>

<p>Unfortunately, there was a significant gap in the communication in April where I was unable to reach them via multiple communication channels. As a result, I did not have a chance to comment on their patch set before the release or coordinate with them on a publication date.
Itâs good to see that they still released a firmware fix and public acknowledgment within the 90-day timeframe.
I have been able to re-establish communications in May.</p>

<p>Iâm looking forward to the full vendor advisory, which has not been released at the time of writing.</p>

<h3 id="relevant-product">Relevant product</h3>

<table>
  <thead>
    <tr>
      <th>Product</th>
      <th>Source</th>
      <th>Known Affected Version</th>
      <th>Fixed Version</th>
      <th>Patch</th>
      <th>Vendor Publications</th>
      <th>IDs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ShapeShift KeepKey</td>
      <td><a href="https://github.com/keepkey/keepkey-firmware/">GitHub</a></td>
      <td>bootloader â¤ bl_v2.0.0</td>
      <td>bootloader <strong>bl_v2.1.4</strong></td>
      <td><a href="https://github.com/keepkey/keepkey-firmware/commit/447c1f038a31378ab9589965c098467d9ea6cccc">patch1</a></td>
      <td><a href="https://github.com/keepkey/keepkey-firmware/releases/tag/v7.3.2">bl_v2.1.4 + v7.3.2 GitHub Changelog</a></td>
      <td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30330">CVE-2022-30330</a><br />VULN-22004, VULN-22005, VULN-22006</td>
    </tr>
  </tbody>
</table>

<p>Iâm not aware of other hardware wallets with practical security impacts.</p>

<p>Please note that Iâve included SatoshiLabs in the disclosure communication due to the Trezor One product to ensure that there are no practical vulnerabilities on the Trezor side where some the code originated from after finding  <a href="#vuln-22004_trezor_aspect">a minor code issue</a>. Ultimately, the Trezor One did not have any practical issues and we did not switch to a full multi-vendor format for the coordinated disclosure. This approach was discussed with both vendors.</p>

<h3 id="a-note-about-research-affiliation-and-work-time">A Note About Research Affiliation and Work Time</h3>

<p>I want to emphasize that the main work for this security research was done on my own time and initiative.
In particular, the original research that led to the discovery of the issue was not sponsored by SatoshiLabs.</p>

<p>With agreement by ShapeShift, I spend some paid hours on extended background research to evaluate the potential security impacts of related issues on the Trezor project for SatoshiLabs.</p>

<h3 id="detailed-timeline">Detailed timeline</h3>

<table>
  <thead>
    <tr>
      <th>Date</th>
      <th>Information</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2022-02-23</td>
      <td>Confidential disclosure to ShapeShift, with CC to SatoshiLabs</td>
    </tr>
    <tr>
      <td>2022-03-10</td>
      <td>Technical call with ShapeShift, ShapeShift acknowledges the issues</td>
    </tr>
    <tr>
      <td>2022-04-26</td>
      <td>ShapeShift releases patched bootloader version <code class="language-plaintext highlighter-rouge">bl_v2.1.4</code> together with firmware <code class="language-plaintext highlighter-rouge">v7.3.2</code></td>
    </tr>
    <tr>
      <td>2022-04-26</td>
      <td>ShapeShift publishes a short advisory summary via the GitHub tag description</td>
    </tr>
    <tr>
      <td>2022-05-07</td>
      <td><code class="language-plaintext highlighter-rouge">CVE-2022-30330</code> assigned by MITRE</td>
    </tr>
    <tr>
      <td>2022-05-18</td>
      <td>Publication of this blog article</td>
    </tr>
  </tbody>
</table>

<h3 id="bug-bounty">Bug bounty</h3>

<p>ShapeShift paid a bug bounty for this issue.</p>

  </div>


  <a class="u-url" href="/posts/keepkey-CVE-2022-30330/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col-left">
        <ul class="contact-list">
          <li class="p-name">
            <b>Christian Reitter</b>
          </li>
        </ul>
        <p>Information security and other interests.</p>

      </div>

      <div class="footer-col-right">
        <div class="social-ref"><ul class="social-ref-list"><li><a rel="me" href="https://github.com/invd" title="invd"><svg class="svg-icon grey"><use xlink:href="/assets/minima-icons.svg#github"></use></svg></a></li><li><a href="/feed.xml" title="Atom"><svg class="svg-icon grey"><use xlink:href="/assets/minima-icons.svg#rss"></use></svg></a></li></ul>
</div>
      </div>
    </div>
  </div>
</footer>
</body>

</html>
