

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e2d192301a0df8160d1555b66ae8611e8050e424)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e2d192301a0df8160d1555b66ae8611e8050e424)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e2d192301a0df8160d1555b66ae8611e8050e424)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e2d192301a0df8160d1555b66ae8611e8050e424)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Eric Dumazet <edumazet@google.com> | 2021-09-17 15:15:56 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2021-10-06 15:56:04 +0200 |
| commit | [e2d192301a0df8160d1555b66ae8611e8050e424](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e2d192301a0df8160d1555b66ae8611e8050e424) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e2d192301a0df8160d1555b66ae8611e8050e424)) | |
| tree | [7001798519863406890b69472bfcac723e2374d2](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e2d192301a0df8160d1555b66ae8611e8050e424) | |
| parent | [deb2949417677649e2413266d7ce8c2ff73952b4](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=deb2949417677649e2413266d7ce8c2ff73952b4) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e2d192301a0df8160d1555b66ae8611e8050e424&id2=deb2949417677649e2413266d7ce8c2ff73952b4)) | |
| download | [linux-e2d192301a0df8160d1555b66ae8611e8050e424.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e2d192301a0df8160d1555b66ae8611e8050e424.tar.gz) | |

netfilter: conntrack: serialize hash resizes and cleanupscommit e9edc188fc76499b0b9bd60364084037f6d03773 upstream.
Syzbot was able to trigger the following warning [1]
No repro found by syzbot yet but I was able to trigger similar issue
by having 2 scripts running in parallel, changing conntrack hash sizes,
and:
for j in `seq 1 1000` ; do unshare -n /bin/true >/dev/null ; done
It would take more than 5 minutes for net\_namespace structures
to be cleaned up.
This is because nf\_ct\_iterate\_cleanup() has to restart everytime
a resize happened.
By adding a mutex, we can serialize hash resizes and cleanups
and also make get\_next\_corpse() faster by skipping over empty
buckets.
Even without resizes in the picture, this patch considerably
speeds up network namespace dismantles.
[1]
INFO: task syz-executor.0:8312 can't die for more than 144 seconds.
task:syz-executor.0 state:R running task stack:25672 pid: 8312 ppid: 6573 flags:0x00004006
Call Trace:
context\_switch kernel/sched/core.c:4955 [inline]
\_\_schedule+0x940/0x26f0 kernel/sched/core.c:6236
preempt\_schedule\_common+0x45/0xc0 kernel/sched/core.c:6408
preempt\_schedule\_thunk+0x16/0x18 arch/x86/entry/thunk\_64.S:35
\_\_local\_bh\_enable\_ip+0x109/0x120 kernel/softirq.c:390
local\_bh\_enable include/linux/bottom\_half.h:32 [inline]
get\_next\_corpse net/netfilter/nf\_conntrack\_core.c:2252 [inline]
nf\_ct\_iterate\_cleanup+0x15a/0x450 net/netfilter/nf\_conntrack\_core.c:2275
nf\_conntrack\_cleanup\_net\_list+0x14c/0x4f0 net/netfilter/nf\_conntrack\_core.c:2469
ops\_exit\_list+0x10d/0x160 net/core/net\_namespace.c:171
setup\_net+0x639/0xa30 net/core/net\_namespace.c:349
copy\_net\_ns+0x319/0x760 net/core/net\_namespace.c:470
create\_new\_namespaces+0x3f6/0xb20 kernel/nsproxy.c:110
unshare\_nsproxy\_namespaces+0xc1/0x1f0 kernel/nsproxy.c:226
ksys\_unshare+0x445/0x920 kernel/fork.c:3128
\_\_do\_sys\_unshare kernel/fork.c:3202 [inline]
\_\_se\_sys\_unshare kernel/fork.c:3200 [inline]
\_\_x64\_sys\_unshare+0x2d/0x40 kernel/fork.c:3200
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x35/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
RIP: 0033:0x7f63da68e739
RSP: 002b:00007f63d7c05188 EFLAGS: 00000246 ORIG\_RAX: 0000000000000110
RAX: ffffffffffffffda RBX: 00007f63da792f80 RCX: 00007f63da68e739
RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000040000000
RBP: 00007f63da6e8cc4 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f63da792f80
R13: 00007fff50b75d3f R14: 00007f63d7c05300 R15: 0000000000022000
Showing all locks held in the system:
1 lock held by khungtaskd/27:
#0: ffffffff8b980020 (rcu\_read\_lock){....}-{1:2}, at: debug\_show\_all\_locks+0x53/0x260 kernel/locking/lockdep.c:6446
2 locks held by kworker/u4:2/153:
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: arch\_atomic64\_set arch/x86/include/asm/atomic64\_64.h:34 [inline]
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: arch\_atomic\_long\_set include/linux/atomic/atomic-long.h:41 [inline]
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: atomic\_long\_set include/linux/atomic/atomic-instrumented.h:1198 [inline]
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: set\_work\_data kernel/workqueue.c:634 [inline]
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: set\_work\_pool\_and\_clear\_pending kernel/workqueue.c:661 [inline]
#0: ffff888010c69138 ((wq\_completion)events\_unbound){+.+.}-{0:0}, at: process\_one\_work+0x896/0x1690 kernel/workqueue.c:2268
#1: ffffc9000140fdb0 ((kfence\_timer).work){+.+.}-{0:0}, at: process\_one\_work+0x8ca/0x1690 kernel/workqueue.c:2272
1 lock held by systemd-udevd/2970:
1 lock held by in:imklog/6258:
#0: ffff88807f970ff0 (&f->f\_pos\_lock){+.+.}-{3:3}, at: \_\_fdget\_pos+0xe9/0x100 fs/file.c:990
3 locks held by kworker/1:6/8158:
1 lock held by syz-executor.0/8312:
2 locks held by kworker/u4:13/9320:
1 lock held by syz-executor.5/10178:
1 lock held by syz-executor.4/10217:
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: syzbot <syzkaller@googlegroups.com>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e2d192301a0df8160d1555b66ae8611e8050e424)

| -rw-r--r-- | [net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/netfilter/nf_conntrack_core.c?id=e2d192301a0df8160d1555b66ae8611e8050e424) | 70 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 37 insertions, 33 deletions

| diff --git a/net/netfilter/nf\_conntrack\_core.c b/net/netfilter/nf\_conntrack\_core.cindex 54430a34d2f646..6a66e994593516 100644--- a/[net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_conntrack_core.c?id=deb2949417677649e2413266d7ce8c2ff73952b4)+++ b/[net/netfilter/nf\_conntrack\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/netfilter/nf_conntrack_core.c?id=e2d192301a0df8160d1555b66ae8611e8050e424)@@ -75,6 +75,9 @@ static \_\_read\_mostly struct kmem\_cache \*nf\_conntrack\_cachep; static DEFINE\_SPINLOCK(nf\_conntrack\_locks\_all\_lock); static \_\_read\_mostly bool nf\_conntrack\_locks\_all; +/\* serialize hash resizes and nf\_ct\_iterate\_cleanup \*/+static DEFINE\_MUTEX(nf\_conntrack\_mutex);+ #define GC\_SCAN\_INTERVAL (120u \* HZ) #define GC\_SCAN\_MAX\_DURATION msecs\_to\_jiffies(10) @@ -2173,28 +2176,31 @@ get\_next\_corpse(int (\*iter)(struct nf\_conn \*i, void \*data), spinlock\_t \*lockp;  for (; \*bucket < nf\_conntrack\_htable\_size; (\*bucket)++) {+ struct hlist\_nulls\_head \*hslot = &nf\_conntrack\_hash[\*bucket];++ if (hlist\_nulls\_empty(hslot))+ continue;+ lockp = &nf\_conntrack\_locks[\*bucket % CONNTRACK\_LOCKS]; local\_bh\_disable(); nf\_conntrack\_lock(lockp);- if (\*bucket < nf\_conntrack\_htable\_size) {- hlist\_nulls\_for\_each\_entry(h, n, &nf\_conntrack\_hash[\*bucket], hnnode) {- if (NF\_CT\_DIRECTION(h) != IP\_CT\_DIR\_REPLY)- continue;- /\* All nf\_conn objects are added to hash table twice, one- \* for original direction tuple, once for the reply tuple.- \*- \* Exception: In the IPS\_NAT\_CLASH case, only the reply- \* tuple is added (the original tuple already existed for- \* a different object).- \*- \* We only need to call the iterator once for each- \* conntrack, so we just use the 'reply' direction- \* tuple while iterating.- \*/- ct = nf\_ct\_tuplehash\_to\_ctrack(h);- if (iter(ct, data))- goto found;- }+ hlist\_nulls\_for\_each\_entry(h, n, hslot, hnnode) {+ if (NF\_CT\_DIRECTION(h) != IP\_CT\_DIR\_REPLY)+ continue;+ /\* All nf\_conn objects are added to hash table twice, one+ \* for original direction tuple, once for the reply tuple.+ \*+ \* Exception: In the IPS\_NAT\_CLASH case, only the reply+ \* tuple is added (the original tuple already existed for+ \* a different object).+ \*+ \* We only need to call the iterator once for each+ \* conntrack, so we just use the 'reply' direction+ \* tuple while iterating.+ \*/+ ct = nf\_ct\_tuplehash\_to\_ctrack(h);+ if (iter(ct, data))+ goto found; } spin\_unlock(lockp); local\_bh\_enable();@@ -2212,26 +2218,20 @@ found: static void nf\_ct\_iterate\_cleanup(int (\*iter)(struct nf\_conn \*i, void \*data), void \*data, u32 portid, int report) {- unsigned int bucket = 0, sequence;+ unsigned int bucket = 0; struct nf\_conn \*ct;  might\_sleep(); - for (;;) {- sequence = read\_seqcount\_begin(&nf\_conntrack\_generation);-- while ((ct = get\_next\_corpse(iter, data, &bucket)) != NULL) {- /\* Time to push up daises... \*/+ mutex\_lock(&nf\_conntrack\_mutex);+ while ((ct = get\_next\_corpse(iter, data, &bucket)) != NULL) {+ /\* Time to push up daises... \*/ - nf\_ct\_delete(ct, portid, report);- nf\_ct\_put(ct);- cond\_resched();- }-- if (!read\_seqcount\_retry(&nf\_conntrack\_generation, sequence))- break;- bucket = 0;+ nf\_ct\_delete(ct, portid, report);+ nf\_ct\_put(ct);+ cond\_resched(); }+ mutex\_unlock(&nf\_conntrack\_mutex); }  struct iter\_data {@@ -2461,8 +2461,10 @@ int nf\_conntrack\_hash\_resize(unsigned int hashsize) if (!hash) return -ENOMEM; + mutex\_lock(&nf\_conntrack\_mutex); old\_size = nf\_conntrack\_htable\_size; if (old\_size == hashsize) {+ mutex\_unlock(&nf\_conntrack\_mutex); kvfree(hash); return 0; }@@ -2498,6 +2500,8 @@ int nf\_conntrack\_hash\_resize(unsigned int hashsize) nf\_conntrack\_all\_unlock(); local\_bh\_enable(); + mutex\_unlock(&nf\_conntrack\_mutex);+ synchronize\_net(); kvfree(old\_hash); return 0; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 15:06:44 +0000

