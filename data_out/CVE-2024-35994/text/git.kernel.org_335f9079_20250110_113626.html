

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Maximilian Luz <luzmaximilian@gmail.com> | 2024-04-06 15:01:09 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-05-02 16:35:31 +0200 |
| commit | [dd22b34fb53cb04b13b2f5eee5c9200bb091fc88](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)) | |
| tree | [ec95848b817b55de1815aa54470fa4c7c65d52fa](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) | |
| parent | [68f43870e9f9ba77082e76b78115cd3733972a30](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=68f43870e9f9ba77082e76b78115cd3733972a30) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88&id2=68f43870e9f9ba77082e76b78115cd3733972a30)) | |
| download | [linux-dd22b34fb53cb04b13b2f5eee5c9200bb091fc88.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-dd22b34fb53cb04b13b2f5eee5c9200bb091fc88.tar.gz) | |

firmware: qcom: uefisecapp: Fix memory related IO errors and crashescommit ed09f81eeaa8f9265e1787282cb283f10285c259 upstream.
It turns out that while the QSEECOM APP\_SEND command has specific fields
for request and response buffers, uefisecapp expects them both to be in
a single memory region. Failure to adhere to this has (so far) resulted
in either no response being written to the response buffer (causing an
EIO to be emitted down the line), the SCM call to fail with EINVAL
(i.e., directly from TZ/firmware), or the device to be hard-reset.
While this issue can be triggered deterministically, in the current form
it seems to happen rather sporadically (which is why it has gone
unnoticed during earlier testing). This is likely due to the two
kzalloc() calls (for request and response) being directly after each
other. Which means that those likely return consecutive regions most of
the time, especially when not much else is going on in the system.
Fix this by allocating a single memory region for both request and
response buffers, properly aligning both structs inside it. This
unfortunately also means that the qcom\_scm\_qseecom\_app\_send() interface
needs to be restructured, as it should no longer map the DMA regions
separately. Therefore, move the responsibility of DMA allocation (or
mapping) to the caller.
Fixes: 759e7a2b62eb ("firmware: Add support for Qualcomm UEFI Secure Application")
Cc: stable@vger.kernel.org # 6.7
Tested-by: Johan Hovold <johan+linaro@kernel.org>
Reviewed-by: Johan Hovold <johan+linaro@kernel.org>
Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Tested-by: Konrad Dybcio <konrad.dybcio@linaro.org> # X13s
Link: [https://lore.kernel.org/r/20240406130125.1047436-1-luzmaximilian@gmail.com](https://lore.kernel.org/r/20240406130125.1047436-1-luzmaximilian%40gmail.com)
Signed-off-by: Bjorn Andersson <andersson@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)

| -rw-r--r-- | [drivers/firmware/qcom/qcom\_qseecom\_uefisecapp.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/firmware/qcom/qcom_qseecom_uefisecapp.c?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) | 137 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/firmware/qcom/qcom\_scm.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/firmware/qcom/qcom_scm.c?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) | 37 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/firmware/qcom/qcom\_qseecom.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/firmware/qcom/qcom_qseecom.h?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) | 55 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/firmware/qcom/qcom\_scm.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/firmware/qcom/qcom_scm.h?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88) | 10 | |  |  |  | | --- | --- | --- | |

4 files changed, 153 insertions, 86 deletions

| diff --git a/drivers/firmware/qcom/qcom\_qseecom\_uefisecapp.c b/drivers/firmware/qcom/qcom\_qseecom\_uefisecapp.cindex 32188f098ef349..bc550ad0dbe0c7 100644--- a/[drivers/firmware/qcom/qcom\_qseecom\_uefisecapp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/firmware/qcom/qcom_qseecom_uefisecapp.c?id=68f43870e9f9ba77082e76b78115cd3733972a30)+++ b/[drivers/firmware/qcom/qcom\_qseecom\_uefisecapp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/firmware/qcom/qcom_qseecom_uefisecapp.c?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)@@ -221,6 +221,19 @@ struct qsee\_rsp\_uefi\_query\_variable\_info { \* alignment of 8 bytes (64 bits) for GUIDs. Our definition of efi\_guid\_t, \* however, has an alignment of 4 byte (32 bits). So far, this seems to work \* fine here. See also the comment on the typedef of efi\_guid\_t.+ \*+ \* Note: It looks like uefisecapp is quite picky about how the memory passed to+ \* it is structured and aligned. In particular the request/response setup used+ \* for QSEE\_CMD\_UEFI\_GET\_VARIABLE. While qcom\_qseecom\_app\_send(), in theory,+ \* accepts separate buffers/addresses for the request and response parts, in+ \* practice, however, it seems to expect them to be both part of a larger+ \* contiguous block. We initially allocated separate buffers for the request+ \* and response but this caused the QSEE\_CMD\_UEFI\_GET\_VARIABLE command to+ \* either not write any response to the response buffer or outright crash the+ \* device. Therefore, we now allocate a single contiguous block of DMA memory+ \* for both and properly align the data using the macros below. In particular,+ \* request and response structs are aligned at 8 byte (via \_\_reqdata\_offs()),+ \* following the driver that this has been reverse-engineered from. \*/ #define qcuefi\_buf\_align\_fields(fields...) \ ({ \@@ -244,6 +257,12 @@ struct qsee\_rsp\_uefi\_query\_variable\_info { #define \_\_array\_offs(type, count, offset) \ \_\_field\_impl(sizeof(type) \* (count), \_\_alignof\_\_(type), offset) +#define \_\_array\_offs\_aligned(type, count, align, offset) \+ \_\_field\_impl(sizeof(type) \* (count), align, offset)++#define \_\_reqdata\_offs(size, offset) \+ \_\_array\_offs\_aligned(u8, size, 8, offset)+ #define \_\_array(type, count) \_\_array\_offs(type, count, NULL) #define \_\_field\_offs(type, offset) \_\_array\_offs(type, 1, offset) #define \_\_field(type) \_\_array\_offs(type, 1, NULL)@@ -277,10 +296,15 @@ static efi\_status\_t qsee\_uefi\_get\_variable(struct qcuefi\_client \*qcuefi, const e unsigned long buffer\_size = \*data\_size; efi\_status\_t efi\_status = EFI\_SUCCESS; unsigned long name\_length;+ dma\_addr\_t cmd\_buf\_dma;+ size\_t cmd\_buf\_size;+ void \*cmd\_buf; size\_t guid\_offs; size\_t name\_offs; size\_t req\_size; size\_t rsp\_size;+ size\_t req\_offs;+ size\_t rsp\_offs; ssize\_t status;  if (!name || !guid)@@ -304,17 +328,19 @@ static efi\_status\_t qsee\_uefi\_get\_variable(struct qcuefi\_client \*qcuefi, const e \_\_array(u8, buffer\_size) ); - req\_data = kzalloc(req\_size, GFP\_KERNEL);- if (!req\_data) {+ cmd\_buf\_size = qcuefi\_buf\_align\_fields(+ \_\_reqdata\_offs(req\_size, &req\_offs)+ \_\_reqdata\_offs(rsp\_size, &rsp\_offs)+ );++ cmd\_buf = qseecom\_dma\_alloc(qcuefi->client, cmd\_buf\_size, &cmd\_buf\_dma, GFP\_KERNEL);+ if (!cmd\_buf) { efi\_status = EFI\_OUT\_OF\_RESOURCES; goto out; } - rsp\_data = kzalloc(rsp\_size, GFP\_KERNEL);- if (!rsp\_data) {- efi\_status = EFI\_OUT\_OF\_RESOURCES;- goto out\_free\_req;- }+ req\_data = cmd\_buf + req\_offs;+ rsp\_data = cmd\_buf + rsp\_offs;  req\_data->command\_id = QSEE\_CMD\_UEFI\_GET\_VARIABLE; req\_data->data\_size = buffer\_size;@@ -332,7 +358,9 @@ static efi\_status\_t qsee\_uefi\_get\_variable(struct qcuefi\_client \*qcuefi, const e  memcpy(((void \*)req\_data) + req\_data->guid\_offset, guid, req\_data->guid\_size); - status = qcom\_qseecom\_app\_send(qcuefi->client, req\_data, req\_size, rsp\_data, rsp\_size);+ status = qcom\_qseecom\_app\_send(qcuefi->client,+ cmd\_buf\_dma + req\_offs, req\_size,+ cmd\_buf\_dma + rsp\_offs, rsp\_size); if (status) { efi\_status = EFI\_DEVICE\_ERROR; goto out\_free;@@ -407,9 +435,7 @@ static efi\_status\_t qsee\_uefi\_get\_variable(struct qcuefi\_client \*qcuefi, const e memcpy(data, ((void \*)rsp\_data) + rsp\_data->data\_offset, rsp\_data->data\_size);  out\_free:- kfree(rsp\_data);-out\_free\_req:- kfree(req\_data);+ qseecom\_dma\_free(qcuefi->client, cmd\_buf\_size, cmd\_buf, cmd\_buf\_dma); out: return efi\_status; }@@ -422,10 +448,15 @@ static efi\_status\_t qsee\_uefi\_set\_variable(struct qcuefi\_client \*qcuefi, const e struct qsee\_rsp\_uefi\_set\_variable \*rsp\_data; efi\_status\_t efi\_status = EFI\_SUCCESS; unsigned long name\_length;+ dma\_addr\_t cmd\_buf\_dma;+ size\_t cmd\_buf\_size;+ void \*cmd\_buf; size\_t name\_offs; size\_t guid\_offs; size\_t data\_offs; size\_t req\_size;+ size\_t req\_offs;+ size\_t rsp\_offs; ssize\_t status;  if (!name || !guid)@@ -450,17 +481,19 @@ static efi\_status\_t qsee\_uefi\_set\_variable(struct qcuefi\_client \*qcuefi, const e \_\_array\_offs(u8, data\_size, &data\_offs) ); - req\_data = kzalloc(req\_size, GFP\_KERNEL);- if (!req\_data) {+ cmd\_buf\_size = qcuefi\_buf\_align\_fields(+ \_\_reqdata\_offs(req\_size, &req\_offs)+ \_\_reqdata\_offs(sizeof(\*rsp\_data), &rsp\_offs)+ );++ cmd\_buf = qseecom\_dma\_alloc(qcuefi->client, cmd\_buf\_size, &cmd\_buf\_dma, GFP\_KERNEL);+ if (!cmd\_buf) { efi\_status = EFI\_OUT\_OF\_RESOURCES; goto out; } - rsp\_data = kzalloc(sizeof(\*rsp\_data), GFP\_KERNEL);- if (!rsp\_data) {- efi\_status = EFI\_OUT\_OF\_RESOURCES;- goto out\_free\_req;- }+ req\_data = cmd\_buf + req\_offs;+ rsp\_data = cmd\_buf + rsp\_offs;  req\_data->command\_id = QSEE\_CMD\_UEFI\_SET\_VARIABLE; req\_data->attributes = attributes;@@ -483,8 +516,9 @@ static efi\_status\_t qsee\_uefi\_set\_variable(struct qcuefi\_client \*qcuefi, const e if (data\_size) memcpy(((void \*)req\_data) + req\_data->data\_offset, data, req\_data->data\_size); - status = qcom\_qseecom\_app\_send(qcuefi->client, req\_data, req\_size, rsp\_data,- sizeof(\*rsp\_data));+ status = qcom\_qseecom\_app\_send(qcuefi->client,+ cmd\_buf\_dma + req\_offs, req\_size,+ cmd\_buf\_dma + rsp\_offs, sizeof(\*rsp\_data)); if (status) { efi\_status = EFI\_DEVICE\_ERROR; goto out\_free;@@ -507,9 +541,7 @@ static efi\_status\_t qsee\_uefi\_set\_variable(struct qcuefi\_client \*qcuefi, const e }  out\_free:- kfree(rsp\_data);-out\_free\_req:- kfree(req\_data);+ qseecom\_dma\_free(qcuefi->client, cmd\_buf\_size, cmd\_buf, cmd\_buf\_dma); out: return efi\_status; }@@ -521,10 +553,15 @@ static efi\_status\_t qsee\_uefi\_get\_next\_variable(struct qcuefi\_client \*qcuefi, struct qsee\_req\_uefi\_get\_next\_variable \*req\_data; struct qsee\_rsp\_uefi\_get\_next\_variable \*rsp\_data; efi\_status\_t efi\_status = EFI\_SUCCESS;+ dma\_addr\_t cmd\_buf\_dma;+ size\_t cmd\_buf\_size;+ void \*cmd\_buf; size\_t guid\_offs; size\_t name\_offs; size\_t req\_size; size\_t rsp\_size;+ size\_t req\_offs;+ size\_t rsp\_offs; ssize\_t status;  if (!name\_size || !name || !guid)@@ -545,17 +582,19 @@ static efi\_status\_t qsee\_uefi\_get\_next\_variable(struct qcuefi\_client \*qcuefi, \_\_array(\*name, \*name\_size / sizeof(\*name)) ); - req\_data = kzalloc(req\_size, GFP\_KERNEL);- if (!req\_data) {+ cmd\_buf\_size = qcuefi\_buf\_align\_fields(+ \_\_reqdata\_offs(req\_size, &req\_offs)+ \_\_reqdata\_offs(rsp\_size, &rsp\_offs)+ );++ cmd\_buf = qseecom\_dma\_alloc(qcuefi->client, cmd\_buf\_size, &cmd\_buf\_dma, GFP\_KERNEL);+ if (!cmd\_buf) { efi\_status = EFI\_OUT\_OF\_RESOURCES; goto out; } - rsp\_data = kzalloc(rsp\_size, GFP\_KERNEL);- if (!rsp\_data) {- efi\_status = EFI\_OUT\_OF\_RESOURCES;- goto out\_free\_req;- }+ req\_data = cmd\_buf + req\_offs;+ rsp\_data = cmd\_buf + rsp\_offs;  req\_data->command\_id = QSEE\_CMD\_UEFI\_GET\_NEXT\_VARIABLE; req\_data->guid\_offset = guid\_offs;@@ -572,7 +611,9 @@ static efi\_status\_t qsee\_uefi\_get\_next\_variable(struct qcuefi\_client \*qcuefi, goto out\_free; } - status = qcom\_qseecom\_app\_send(qcuefi->client, req\_data, req\_size, rsp\_data, rsp\_size);+ status = qcom\_qseecom\_app\_send(qcuefi->client,+ cmd\_buf\_dma + req\_offs, req\_size,+ cmd\_buf\_dma + rsp\_offs, rsp\_size); if (status) { efi\_status = EFI\_DEVICE\_ERROR; goto out\_free;@@ -645,9 +686,7 @@ static efi\_status\_t qsee\_uefi\_get\_next\_variable(struct qcuefi\_client \*qcuefi, }  out\_free:- kfree(rsp\_data);-out\_free\_req:- kfree(req\_data);+ qseecom\_dma\_free(qcuefi->client, cmd\_buf\_size, cmd\_buf, cmd\_buf\_dma); out: return efi\_status; }@@ -659,26 +698,34 @@ static efi\_status\_t qsee\_uefi\_query\_variable\_info(struct qcuefi\_client \*qcuefi, struct qsee\_req\_uefi\_query\_variable\_info \*req\_data; struct qsee\_rsp\_uefi\_query\_variable\_info \*rsp\_data; efi\_status\_t efi\_status = EFI\_SUCCESS;+ dma\_addr\_t cmd\_buf\_dma;+ size\_t cmd\_buf\_size;+ void \*cmd\_buf;+ size\_t req\_offs;+ size\_t rsp\_offs; int status; - req\_data = kzalloc(sizeof(\*req\_data), GFP\_KERNEL);- if (!req\_data) {+ cmd\_buf\_size = qcuefi\_buf\_align\_fields(+ \_\_reqdata\_offs(sizeof(\*req\_data), &req\_offs)+ \_\_reqdata\_offs(sizeof(\*rsp\_data), &rsp\_offs)+ );++ cmd\_buf = qseecom\_dma\_alloc(qcuefi->client, cmd\_buf\_size, &cmd\_buf\_dma, GFP\_KERNEL);+ if (!cmd\_buf) { efi\_status = EFI\_OUT\_OF\_RESOURCES; goto out; } - rsp\_data = kzalloc(sizeof(\*rsp\_data), GFP\_KERNEL);- if (!rsp\_data) {- efi\_status = EFI\_OUT\_OF\_RESOURCES;- goto out\_free\_req;- }+ req\_data = cmd\_buf + req\_offs;+ rsp\_data = cmd\_buf + rsp\_offs;  req\_data->command\_id = QSEE\_CMD\_UEFI\_QUERY\_VARIABLE\_INFO; req\_data->attributes = attr; req\_data->length = sizeof(\*req\_data); - status = qcom\_qseecom\_app\_send(qcuefi->client, req\_data, sizeof(\*req\_data), rsp\_data,- sizeof(\*rsp\_data));+ status = qcom\_qseecom\_app\_send(qcuefi->client,+ cmd\_buf\_dma + req\_offs, sizeof(\*req\_data),+ cmd\_buf\_dma + rsp\_offs, sizeof(\*rsp\_data)); if (status) { efi\_status = EFI\_DEVICE\_ERROR; goto out\_free;@@ -711,9 +758,7 @@ static efi\_status\_t qsee\_uefi\_query\_variable\_info(struct qcuefi\_client \*qcuefi, \*max\_variable\_size = rsp\_data->max\_variable\_size;  out\_free:- kfree(rsp\_data);-out\_free\_req:- kfree(req\_data);+ qseecom\_dma\_free(qcuefi->client, cmd\_buf\_size, cmd\_buf, cmd\_buf\_dma); out: return efi\_status; }diff --git a/drivers/firmware/qcom/qcom\_scm.c b/drivers/firmware/qcom/qcom\_scm.cindex 520de9b5633abc..90283f160a2286 100644--- a/[drivers/firmware/qcom/qcom\_scm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/firmware/qcom/qcom_scm.c?id=68f43870e9f9ba77082e76b78115cd3733972a30)+++ b/[drivers/firmware/qcom/qcom\_scm.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/firmware/qcom/qcom_scm.c?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)@@ -1576,9 +1576,9 @@ EXPORT\_SYMBOL\_GPL(qcom\_scm\_qseecom\_app\_get\_id); /\*\* \* qcom\_scm\_qseecom\_app\_send() - Send to and receive data from a given QSEE app. \* @app\_id: The ID of the target app.- \* @req: Request buffer sent to the app (must be DMA-mappable).+ \* @req: DMA address of the request buffer sent to the app. \* @req\_size: Size of the request buffer.- \* @rsp: Response buffer, written to by the app (must be DMA-mappable).+ \* @rsp: DMA address of the response buffer, written to by the app. \* @rsp\_size: Size of the response buffer. \* \* Sends a request to the QSEE app associated with the given ID and read back@@ -1589,33 +1589,13 @@ EXPORT\_SYMBOL\_GPL(qcom\_scm\_qseecom\_app\_get\_id); \* \* Return: Zero on success, nonzero on failure. \*/-int qcom\_scm\_qseecom\_app\_send(u32 app\_id, void \*req, size\_t req\_size, void \*rsp,- size\_t rsp\_size)+int qcom\_scm\_qseecom\_app\_send(u32 app\_id, dma\_addr\_t req, size\_t req\_size,+ dma\_addr\_t rsp, size\_t rsp\_size) { struct qcom\_scm\_qseecom\_resp res = {}; struct qcom\_scm\_desc desc = {};- dma\_addr\_t req\_phys;- dma\_addr\_t rsp\_phys; int status; - /\* Map request buffer \*/- req\_phys = dma\_map\_single(\_\_scm->dev, req, req\_size, DMA\_TO\_DEVICE);- status = dma\_mapping\_error(\_\_scm->dev, req\_phys);- if (status) {- dev\_err(\_\_scm->dev, "qseecom: failed to map request buffer\n");- return status;- }-- /\* Map response buffer \*/- rsp\_phys = dma\_map\_single(\_\_scm->dev, rsp, rsp\_size, DMA\_FROM\_DEVICE);- status = dma\_mapping\_error(\_\_scm->dev, rsp\_phys);- if (status) {- dma\_unmap\_single(\_\_scm->dev, req\_phys, req\_size, DMA\_TO\_DEVICE);- dev\_err(\_\_scm->dev, "qseecom: failed to map response buffer\n");- return status;- }-- /\* Set up SCM call data \*/ desc.owner = QSEECOM\_TZ\_OWNER\_TZ\_APPS; desc.svc = QSEECOM\_TZ\_SVC\_APP\_ID\_PLACEHOLDER; desc.cmd = QSEECOM\_TZ\_CMD\_APP\_SEND;@@ -1623,18 +1603,13 @@ int qcom\_scm\_qseecom\_app\_send(u32 app\_id, void \*req, size\_t req\_size, void \*rsp, QCOM\_SCM\_RW, QCOM\_SCM\_VAL, QCOM\_SCM\_RW, QCOM\_SCM\_VAL); desc.args[0] = app\_id;- desc.args[1] = req\_phys;+ desc.args[1] = req; desc.args[2] = req\_size;- desc.args[3] = rsp\_phys;+ desc.args[3] = rsp; desc.args[4] = rsp\_size; - /\* Perform call \*/ status = qcom\_scm\_qseecom\_call(&desc, &res); - /\* Unmap buffers \*/- dma\_unmap\_single(\_\_scm->dev, rsp\_phys, rsp\_size, DMA\_FROM\_DEVICE);- dma\_unmap\_single(\_\_scm->dev, req\_phys, req\_size, DMA\_TO\_DEVICE);- if (status) return status; diff --git a/include/linux/firmware/qcom/qcom\_qseecom.h b/include/linux/firmware/qcom/qcom\_qseecom.hindex 5c28298a98bec8..366243ee96096d 100644--- a/[include/linux/firmware/qcom/qcom\_qseecom.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/firmware/qcom/qcom_qseecom.h?id=68f43870e9f9ba77082e76b78115cd3733972a30)+++ b/[include/linux/firmware/qcom/qcom\_qseecom.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/firmware/qcom/qcom_qseecom.h?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)@@ -10,6 +10,7 @@ #define \_\_QCOM\_QSEECOM\_H  #include <linux/auxiliary\_bus.h>+#include <linux/dma-mapping.h> #include <linux/types.h>  #include <linux/firmware/qcom/qcom\_scm.h>@@ -25,11 +26,56 @@ struct qseecom\_client { };  /\*\*+ \* qseecom\_scm\_dev() - Get the SCM device associated with the QSEECOM client.+ \* @client: The QSEECOM client device.+ \*+ \* Returns the SCM device under which the provided QSEECOM client device+ \* operates. This function is intended to be used for DMA allocations.+ \*/+static inline struct device \*qseecom\_scm\_dev(struct qseecom\_client \*client)+{+ return client->aux\_dev.dev.parent->parent;+}++/\*\*+ \* qseecom\_dma\_alloc() - Allocate DMA memory for a QSEECOM client.+ \* @client: The QSEECOM client to allocate the memory for.+ \* @size: The number of bytes to allocate.+ \* @dma\_handle: Pointer to where the DMA address should be stored.+ \* @gfp: Allocation flags.+ \*+ \* Wrapper function for dma\_alloc\_coherent(), allocating DMA memory usable for+ \* TZ/QSEECOM communication. Refer to dma\_alloc\_coherent() for details.+ \*/+static inline void \*qseecom\_dma\_alloc(struct qseecom\_client \*client, size\_t size,+ dma\_addr\_t \*dma\_handle, gfp\_t gfp)+{+ return dma\_alloc\_coherent(qseecom\_scm\_dev(client), size, dma\_handle, gfp);+}++/\*\*+ \* dma\_free\_coherent() - Free QSEECOM DMA memory.+ \* @client: The QSEECOM client for which the memory has been allocated.+ \* @size: The number of bytes allocated.+ \* @cpu\_addr: Virtual memory address to free.+ \* @dma\_handle: DMA memory address to free.+ \*+ \* Wrapper function for dma\_free\_coherent(), freeing memory previously+ \* allocated with qseecom\_dma\_alloc(). Refer to dma\_free\_coherent() for+ \* details.+ \*/+static inline void qseecom\_dma\_free(struct qseecom\_client \*client, size\_t size,+ void \*cpu\_addr, dma\_addr\_t dma\_handle)+{+ return dma\_free\_coherent(qseecom\_scm\_dev(client), size, cpu\_addr, dma\_handle);+}++/\*\* \* qcom\_qseecom\_app\_send() - Send to and receive data from a given QSEE app. \* @client: The QSEECOM client associated with the target app.- \* @req: Request buffer sent to the app (must be DMA-mappable).+ \* @req: DMA address of the request buffer sent to the app. \* @req\_size: Size of the request buffer.- \* @rsp: Response buffer, written to by the app (must be DMA-mappable).+ \* @rsp: DMA address of the response buffer, written to by the app. \* @rsp\_size: Size of the response buffer. \* \* Sends a request to the QSEE app associated with the given client and read@@ -43,8 +89,9 @@ struct qseecom\_client { \* \* Return: Zero on success, nonzero on failure. \*/-static inline int qcom\_qseecom\_app\_send(struct qseecom\_client \*client, void \*req, size\_t req\_size,- void \*rsp, size\_t rsp\_size)+static inline int qcom\_qseecom\_app\_send(struct qseecom\_client \*client,+ dma\_addr\_t req, size\_t req\_size,+ dma\_addr\_t rsp, size\_t rsp\_size) { return qcom\_scm\_qseecom\_app\_send(client->app\_id, req, req\_size, rsp, rsp\_size); }diff --git a/include/linux/firmware/qcom/qcom\_scm.h b/include/linux/firmware/qcom/qcom\_scm.hindex ccaf288460546a..aaa19f93ac4306 100644--- a/[include/linux/firmware/qcom/qcom\_scm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/firmware/qcom/qcom_scm.h?id=68f43870e9f9ba77082e76b78115cd3733972a30)+++ b/[include/linux/firmware/qcom/qcom\_scm.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/firmware/qcom/qcom_scm.h?id=dd22b34fb53cb04b13b2f5eee5c9200bb091fc88)@@ -118,8 +118,8 @@ bool qcom\_scm\_lmh\_dcvsh\_available(void); #ifdef CONFIG\_QCOM\_QSEECOM  int qcom\_scm\_qseecom\_app\_get\_id(const char \*app\_name, u32 \*app\_id);-int qcom\_scm\_qseecom\_app\_send(u32 app\_id, void \*req, size\_t req\_size, void \*rsp,- size\_t rsp\_size);+int qcom\_scm\_qseecom\_app\_send(u32 app\_id, dma\_addr\_t req, size\_t req\_size,+ dma\_addr\_t rsp, size\_t rsp\_size);  #else /\* CONFIG\_QCOM\_QSEECOM \*/ @@ -128,9 +128,9 @@ static inline int qcom\_scm\_qseecom\_app\_get\_id(const char \*app\_name, u32 \*app\_id) return -EINVAL; } -static inline int qcom\_scm\_qseecom\_app\_send(u32 app\_id, void \*req,- size\_t req\_size, void \*rsp,- size\_t rsp\_size)+static inline int qcom\_scm\_qseecom\_app\_send(u32 app\_id,+ dma\_addr\_t req, size\_t req\_size,+ dma\_addr\_t rsp, size\_t rsp\_size) { return -EINVAL; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 11:35:03 +0000

