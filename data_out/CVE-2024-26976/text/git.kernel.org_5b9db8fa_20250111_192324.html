

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Sean Christopherson <seanjc@google.com> | 2024-01-09 17:15:30 -0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-10 16:18:34 +0200 |
| commit | [83d3c5e309611ef593e2fcb78444fc8ceedf9bac](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)) | |
| tree | [9a0babbe31c2570db6aff246c8fd94a2ec35419c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac) | |
| parent | [fec51819607ff0a80ad8ce678120fda80ca0b2fa](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fec51819607ff0a80ad8ce678120fda80ca0b2fa) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac&id2=fec51819607ff0a80ad8ce678120fda80ca0b2fa)) | |
| download | [linux-83d3c5e309611ef593e2fcb78444fc8ceedf9bac.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-83d3c5e309611ef593e2fcb78444fc8ceedf9bac.tar.gz) | |

KVM: Always flush async #PF workqueue when vCPU is being destroyed[ Upstream commit 3d75b8aa5c29058a512db29da7cbee8052724157 ]
Always flush the per-vCPU async #PF workqueue when a vCPU is clearing its
completion queue, e.g. when a VM and all its vCPUs is being destroyed.
KVM must ensure that none of its workqueue callbacks is running when the
last reference to the KVM \_module\_ is put. Gifting a reference to the
associated VM prevents the workqueue callback from dereferencing freed
vCPU/VM memory, but does not prevent the KVM module from being unloaded
before the callback completes.
Drop the misguided VM refcount gifting, as calling kvm\_put\_kvm() from
async\_pf\_execute() if kvm\_put\_kvm() flushes the async #PF workqueue will
result in deadlock. async\_pf\_execute() can't return until kvm\_put\_kvm()
finishes, and kvm\_put\_kvm() can't return until async\_pf\_execute() finishes:
WARNING: CPU: 8 PID: 251 at virt/kvm/kvm\_main.c:1435 kvm\_put\_kvm+0x2d/0x320 [kvm]
Modules linked in: vhost\_net vhost vhost\_iotlb tap kvm\_intel kvm irqbypass
CPU: 8 PID: 251 Comm: kworker/8:1 Tainted: G W 6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015
Workqueue: events async\_pf\_execute [kvm]
RIP: 0010:kvm\_put\_kvm+0x2d/0x320 [kvm]
Call Trace:
<TASK>
async\_pf\_execute+0x198/0x260 [kvm]
process\_one\_work+0x145/0x2d0
worker\_thread+0x27e/0x3a0
kthread+0xba/0xe0
ret\_from\_fork+0x2d/0x50
ret\_from\_fork\_asm+0x11/0x20
</TASK>
---[ end trace 0000000000000000 ]---
INFO: task kworker/8:1:251 blocked for more than 120 seconds.
Tainted: G W 6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119
"echo 0 > /proc/sys/kernel/hung\_task\_timeout\_secs" disables this message.
task:kworker/8:1 state:D stack:0 pid:251 ppid:2 flags:0x00004000
Workqueue: events async\_pf\_execute [kvm]
Call Trace:
<TASK>
\_\_schedule+0x33f/0xa40
schedule+0x53/0xc0
schedule\_timeout+0x12a/0x140
\_\_wait\_for\_common+0x8d/0x1d0
\_\_flush\_work.isra.0+0x19f/0x2c0
kvm\_clear\_async\_pf\_completion\_queue+0x129/0x190 [kvm]
kvm\_arch\_destroy\_vm+0x78/0x1b0 [kvm]
kvm\_put\_kvm+0x1c1/0x320 [kvm]
async\_pf\_execute+0x198/0x260 [kvm]
process\_one\_work+0x145/0x2d0
worker\_thread+0x27e/0x3a0
kthread+0xba/0xe0
ret\_from\_fork+0x2d/0x50
ret\_from\_fork\_asm+0x11/0x20
</TASK>
If kvm\_clear\_async\_pf\_completion\_queue() actually flushes the workqueue,
then there's no need to gift async\_pf\_execute() a reference because all
invocations of async\_pf\_execute() will be forced to complete before the
vCPU and its VM are destroyed/freed. And that in turn fixes the module
unloading bug as \_\_fput() won't do module\_put() on the last vCPU reference
until the vCPU has been freed, e.g. if closing the vCPU file also puts the
last reference to the KVM module.
Note that kvm\_check\_async\_pf\_completion() may also take the work item off
the completion queue and so also needs to flush the work queue, as the
work will not be seen by kvm\_clear\_async\_pf\_completion\_queue(). Waiting
on the workqueue could theoretically delay a vCPU due to waiting for the
work to complete, but that's a very, very small chance, and likely a very
small delay. kvm\_arch\_async\_page\_present\_queued() unconditionally makes a
new request, i.e. will effectively delay entering the guest, so the
remaining work is really just:
trace\_kvm\_async\_pf\_completed(addr, cr2\_or\_gpa);
\_\_kvm\_vcpu\_wake\_up(vcpu);
mmput(mm);
and mmput() can't drop the last reference to the page tables if the vCPU is
still alive, i.e. the vCPU won't get stuck tearing down page tables.
Add a helper to do the flushing, specifically to deal with "wakeup all"
work items, as they aren't actually work items, i.e. are never placed in a
workqueue. Trying to flush a bogus workqueue entry rightly makes
\_\_flush\_work() complain (kudos to whoever added that sanity check).
Note, commit 5f6de5cbebee ("KVM: Prevent module exit until all VMs are
freed") \*tried\* to fix the module refcounting issue by having VMs grab a
reference to the module, but that only made the bug slightly harder to hit
as it gave async\_pf\_execute() a bit more time to complete before the KVM
module could be unloaded.
Fixes: af585b921e5d ("KVM: Halt vcpu if page it tries to access is swapped out")
Cc: stable@vger.kernel.org
Cc: David Matlack <dmatlack@google.com>
Reviewed-by: Xu Yilun <yilun.xu@intel.com>
Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Link: [https://lore.kernel.org/r/20240110011533.503302-2-seanjc@google.com](https://lore.kernel.org/r/20240110011533.503302-2-seanjc%40google.com)
Signed-off-by: Sean Christopherson <seanjc@google.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)

| -rw-r--r-- | [virt/kvm/async\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/virt/kvm/async_pf.c?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac) | 31 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 26 insertions, 5 deletions

| diff --git a/virt/kvm/async\_pf.c b/virt/kvm/async\_pf.cindex dd777688d14a92..952afb1bc83b4d 100644--- a/[virt/kvm/async\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/virt/kvm/async_pf.c?id=fec51819607ff0a80ad8ce678120fda80ca0b2fa)+++ b/[virt/kvm/async\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/virt/kvm/async_pf.c?id=83d3c5e309611ef593e2fcb78444fc8ceedf9bac)@@ -88,7 +88,27 @@ static void async\_pf\_execute(struct work\_struct \*work) rcuwait\_wake\_up(&vcpu->wait);  mmput(mm);- kvm\_put\_kvm(vcpu->kvm);+}++static void kvm\_flush\_and\_free\_async\_pf\_work(struct kvm\_async\_pf \*work)+{+ /\*+ \* The async #PF is "done", but KVM must wait for the work item itself,+ \* i.e. async\_pf\_execute(), to run to completion. If KVM is a module,+ \* KVM must ensure \*no\* code owned by the KVM (the module) can be run+ \* after the last call to module\_put(). Note, flushing the work item+ \* is always required when the item is taken off the completion queue.+ \* E.g. even if the vCPU handles the item in the "normal" path, the VM+ \* could be terminated before async\_pf\_execute() completes.+ \*+ \* Wake all events skip the queue and go straight done, i.e. don't+ \* need to be flushed (but sanity check that the work wasn't queued).+ \*/+ if (work->wakeup\_all)+ WARN\_ON\_ONCE(work->work.func);+ else+ flush\_work(&work->work);+ kmem\_cache\_free(async\_pf\_cache, work); }  void kvm\_clear\_async\_pf\_completion\_queue(struct kvm\_vcpu \*vcpu)@@ -115,7 +135,6 @@ void kvm\_clear\_async\_pf\_completion\_queue(struct kvm\_vcpu \*vcpu) #else if (cancel\_work\_sync(&work->work)) { mmput(work->mm);- kvm\_put\_kvm(vcpu->kvm); /\* == work->vcpu->kvm \*/ kmem\_cache\_free(async\_pf\_cache, work); } #endif@@ -127,7 +146,10 @@ void kvm\_clear\_async\_pf\_completion\_queue(struct kvm\_vcpu \*vcpu) list\_first\_entry(&vcpu->async\_pf.done, typeof(\*work), link); list\_del(&work->link);- kmem\_cache\_free(async\_pf\_cache, work);++ spin\_unlock(&vcpu->async\_pf.lock);+ kvm\_flush\_and\_free\_async\_pf\_work(work);+ spin\_lock(&vcpu->async\_pf.lock); } spin\_unlock(&vcpu->async\_pf.lock); @@ -152,7 +174,7 @@ void kvm\_check\_async\_pf\_completion(struct kvm\_vcpu \*vcpu)  list\_del(&work->queue); vcpu->async\_pf.queued--;- kmem\_cache\_free(async\_pf\_cache, work);+ kvm\_flush\_and\_free\_async\_pf\_work(work); } } @@ -187,7 +209,6 @@ bool kvm\_setup\_async\_pf(struct kvm\_vcpu \*vcpu, gpa\_t cr2\_or\_gpa, work->arch = \*arch; work->mm = current->mm; mmget(work->mm);- kvm\_get\_kvm(work->vcpu->kvm);  INIT\_WORK(&work->work, async\_pf\_execute); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:22:01 +0000

