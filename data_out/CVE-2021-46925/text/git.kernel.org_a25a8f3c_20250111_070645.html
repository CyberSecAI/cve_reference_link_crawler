

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Dust Li <dust.li@linux.alibaba.com> | 2021-12-28 17:03:25 +0800 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2021-12-28 12:42:45 +0000 |
| commit | [349d43127dac00c15231e8ffbcaabd70f7b0e544](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)) | |
| tree | [7dc9d1354ef88f560485ae6e2ecf701b55ec9645](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | |
| parent | [90cee52f2e780345d3629e278291aea5ac74f40f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=90cee52f2e780345d3629e278291aea5ac74f40f) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544&id2=90cee52f2e780345d3629e278291aea5ac74f40f)) | |
| download | [linux-349d43127dac00c15231e8ffbcaabd70f7b0e544.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-349d43127dac00c15231e8ffbcaabd70f7b0e544.tar.gz) | |

net/smc: fix kernel panic caused by race of smc\_sockA crash occurs when smc\_cdc\_tx\_handler() tries to access smc\_sock
but smc\_release() has already freed it.
[ 4570.695099] BUG: unable to handle page fault for address: 000000002eae9e88
[ 4570.696048] #PF: supervisor write access in kernel mode
[ 4570.696728] #PF: error\_code(0x0002) - not-present page
[ 4570.697401] PGD 0 P4D 0
[ 4570.697716] Oops: 0002 [#1] PREEMPT SMP NOPTI
[ 4570.698228] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.16.0-rc4+ #111
[ 4570.699013] Hardware name: Alibaba Cloud Alibaba Cloud ECS, BIOS 8c24b4c 04/0
[ 4570.699933] RIP: 0010:\_raw\_spin\_lock+0x1a/0x30
<...>
[ 4570.711446] Call Trace:
[ 4570.711746] <IRQ>
[ 4570.711992] smc\_cdc\_tx\_handler+0x41/0xc0
[ 4570.712470] smc\_wr\_tx\_tasklet\_fn+0x213/0x560
[ 4570.712981] ? smc\_cdc\_tx\_dismisser+0x10/0x10
[ 4570.713489] tasklet\_action\_common.isra.17+0x66/0x140
[ 4570.714083] \_\_do\_softirq+0x123/0x2f4
[ 4570.714521] irq\_exit\_rcu+0xc4/0xf0
[ 4570.714934] common\_interrupt+0xba/0xe0
Though smc\_cdc\_tx\_handler() checked the existence of smc connection,
smc\_release() may have already dismissed and released the smc socket
before smc\_cdc\_tx\_handler() further visits it.
smc\_cdc\_tx\_handler() |smc\_release()
if (!conn) |
|
|smc\_cdc\_tx\_dismiss\_slots()
| smc\_cdc\_tx\_dismisser()
|
|sock\_put(&smc->sk) <- last sock\_put,
| smc\_sock freed
bh\_lock\_sock(&smc->sk) (panic) |
To make sure we won't receive any CDC messages after we free the
smc\_sock, add a refcount on the smc\_connection for inflight CDC
message(posted to the QP but haven't received related CQE), and
don't release the smc\_connection until all the inflight CDC messages
haven been done, for both success or failed ones.
Using refcount on CDC messages brings another problem: when the link
is going to be destroyed, smcr\_link\_clear() will reset the QP, which
then remove all the pending CQEs related to the QP in the CQ. To make
sure all the CQEs will always come back so the refcount on the
smc\_connection can always reach 0, smc\_ib\_modify\_qp\_reset() was replaced
by smc\_ib\_modify\_qp\_error().
And remove the timeout in smc\_wr\_tx\_wait\_no\_pending\_sends() since we
need to wait for all pending WQEs done, or we may encounter use-after-
free when handling CQEs.
For IB device removal routine, we need to wait for all the QPs on that
device been destroyed before we can destroy CQs on the device, or
the refcount on smc\_connection won't reach 0 and smc\_sock cannot be
released.
Fixes: 5f08318f617b ("smc: connection data control (CDC)")
Reported-by: Wen Gu <guwen@linux.alibaba.com>
Signed-off-by: Dust Li <dust.li@linux.alibaba.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)

| -rw-r--r-- | [net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 5 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/smc/smc\_cdc.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_cdc.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 52 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_cdc.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_cdc.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_core.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 25 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_ib.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_ib.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_ib.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_ib.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_wr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_wr.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 41 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/smc/smc\_wr.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/smc/smc_wr.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544) | 3 | |  |  |  | | --- | --- | --- | |

8 files changed, 57 insertions, 76 deletions

| diff --git a/net/smc/smc.h b/net/smc/smc.hindex f4286ca1f22836..1a4fc1c6c4ab60 100644--- a/[net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc.h?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -180,6 +180,11 @@ struct smc\_connection { u16 tx\_cdc\_seq; /\* sequence # for CDC send \*/ u16 tx\_cdc\_seq\_fin; /\* sequence # - tx completed \*/ spinlock\_t send\_lock; /\* protect wr\_sends \*/+ atomic\_t cdc\_pend\_tx\_wr; /\* number of pending tx CDC wqe+ \* - inc when post wqe,+ \* - dec on polled tx cqe+ \*/+ wait\_queue\_head\_t cdc\_pend\_tx\_wq; /\* wakeup on no cdc\_pend\_tx\_wr\*/ struct delayed\_work tx\_work; /\* retry of smc\_cdc\_msg\_send \*/ u32 tx\_off; /\* base offset in peer rmb \*/ diff --git a/net/smc/smc\_cdc.c b/net/smc/smc\_cdc.cindex 99acd337ba90d8..84c8a4374fddda 100644--- a/[net/smc/smc\_cdc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_cdc.c?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_cdc.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_cdc.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -31,10 +31,6 @@ static void smc\_cdc\_tx\_handler(struct smc\_wr\_tx\_pend\_priv \*pnd\_snd, struct smc\_sock \*smc; int diff; - if (!conn)- /\* already dismissed \*/- return;- smc = container\_of(conn, struct smc\_sock, conn); bh\_lock\_sock(&smc->sk); if (!wc\_status) {@@ -51,6 +47,12 @@ static void smc\_cdc\_tx\_handler(struct smc\_wr\_tx\_pend\_priv \*pnd\_snd, conn); conn->tx\_cdc\_seq\_fin = cdcpend->ctrl\_seq; }++ if (atomic\_dec\_and\_test(&conn->cdc\_pend\_tx\_wr) &&+ unlikely(wq\_has\_sleeper(&conn->cdc\_pend\_tx\_wq)))+ wake\_up(&conn->cdc\_pend\_tx\_wq);+ WARN\_ON(atomic\_read(&conn->cdc\_pend\_tx\_wr) < 0);+ smc\_tx\_sndbuf\_nonfull(smc); bh\_unlock\_sock(&smc->sk); }@@ -107,6 +109,10 @@ int smc\_cdc\_msg\_send(struct smc\_connection \*conn, conn->tx\_cdc\_seq++; conn->local\_tx\_ctrl.seqno = conn->tx\_cdc\_seq; smc\_host\_msg\_to\_cdc((struct smc\_cdc\_msg \*)wr\_buf, conn, &cfed);++ atomic\_inc(&conn->cdc\_pend\_tx\_wr);+ smp\_mb\_\_after\_atomic(); /\* Make sure cdc\_pend\_tx\_wr added before post \*/+ rc = smc\_wr\_tx\_send(link, (struct smc\_wr\_tx\_pend\_priv \*)pend); if (!rc) { smc\_curs\_copy(&conn->rx\_curs\_confirmed, &cfed, conn);@@ -114,6 +120,7 @@ int smc\_cdc\_msg\_send(struct smc\_connection \*conn, } else { conn->tx\_cdc\_seq--; conn->local\_tx\_ctrl.seqno = conn->tx\_cdc\_seq;+ atomic\_dec(&conn->cdc\_pend\_tx\_wr); }  return rc;@@ -136,7 +143,18 @@ int smcr\_cdc\_msg\_send\_validation(struct smc\_connection \*conn, peer->token = htonl(local->token); peer->prod\_flags.failover\_validation = 1; + /\* We need to set pend->conn here to make sure smc\_cdc\_tx\_handler()+ \* can handle properly+ \*/+ smc\_cdc\_add\_pending\_send(conn, pend);++ atomic\_inc(&conn->cdc\_pend\_tx\_wr);+ smp\_mb\_\_after\_atomic(); /\* Make sure cdc\_pend\_tx\_wr added before post \*/+ rc = smc\_wr\_tx\_send(link, (struct smc\_wr\_tx\_pend\_priv \*)pend);+ if (unlikely(rc))+ atomic\_dec(&conn->cdc\_pend\_tx\_wr);+ return rc; } @@ -193,31 +211,9 @@ int smc\_cdc\_get\_slot\_and\_msg\_send(struct smc\_connection \*conn) return rc; } -static bool smc\_cdc\_tx\_filter(struct smc\_wr\_tx\_pend\_priv \*tx\_pend,- unsigned long data)+void smc\_cdc\_wait\_pend\_tx\_wr(struct smc\_connection \*conn) {- struct smc\_connection \*conn = (struct smc\_connection \*)data;- struct smc\_cdc\_tx\_pend \*cdc\_pend =- (struct smc\_cdc\_tx\_pend \*)tx\_pend;-- return cdc\_pend->conn == conn;-}--static void smc\_cdc\_tx\_dismisser(struct smc\_wr\_tx\_pend\_priv \*tx\_pend)-{- struct smc\_cdc\_tx\_pend \*cdc\_pend =- (struct smc\_cdc\_tx\_pend \*)tx\_pend;-- cdc\_pend->conn = NULL;-}--void smc\_cdc\_tx\_dismiss\_slots(struct smc\_connection \*conn)-{- struct smc\_link \*link = conn->lnk;-- smc\_wr\_tx\_dismiss\_slots(link, SMC\_CDC\_MSG\_TYPE,- smc\_cdc\_tx\_filter, smc\_cdc\_tx\_dismisser,- (unsigned long)conn);+ wait\_event(conn->cdc\_pend\_tx\_wq, !atomic\_read(&conn->cdc\_pend\_tx\_wr)); }  /\* Send a SMC-D CDC header.diff --git a/net/smc/smc\_cdc.h b/net/smc/smc\_cdc.hindex 0a0a89abd38b29..696cc11f2303b9 100644--- a/[net/smc/smc\_cdc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_cdc.h?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_cdc.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_cdc.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -291,7 +291,7 @@ int smc\_cdc\_get\_free\_slot(struct smc\_connection \*conn, struct smc\_wr\_buf \*\*wr\_buf, struct smc\_rdma\_wr \*\*wr\_rdma\_buf, struct smc\_cdc\_tx\_pend \*\*pend);-void smc\_cdc\_tx\_dismiss\_slots(struct smc\_connection \*conn);+void smc\_cdc\_wait\_pend\_tx\_wr(struct smc\_connection \*conn); int smc\_cdc\_msg\_send(struct smc\_connection \*conn, struct smc\_wr\_buf \*wr\_buf, struct smc\_cdc\_tx\_pend \*pend); int smc\_cdc\_get\_slot\_and\_msg\_send(struct smc\_connection \*conn);diff --git a/net/smc/smc\_core.c b/net/smc/smc\_core.cindex 55ca175e8d5786..a6849362f4ddd3 100644--- a/[net/smc/smc\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_core.c?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_core.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -1127,7 +1127,7 @@ void smc\_conn\_free(struct smc\_connection \*conn) smc\_ism\_unset\_conn(conn); tasklet\_kill(&conn->rx\_tsklet); } else {- smc\_cdc\_tx\_dismiss\_slots(conn);+ smc\_cdc\_wait\_pend\_tx\_wr(conn); if (current\_work() != &conn->abort\_work) cancel\_work\_sync(&conn->abort\_work); }@@ -1204,7 +1204,7 @@ void smcr\_link\_clear(struct smc\_link \*lnk, bool log) smc\_llc\_link\_clear(lnk, log); smcr\_buf\_unmap\_lgr(lnk); smcr\_rtoken\_clear\_link(lnk);- smc\_ib\_modify\_qp\_reset(lnk);+ smc\_ib\_modify\_qp\_error(lnk); smc\_wr\_free\_link(lnk); smc\_ib\_destroy\_queue\_pair(lnk); smc\_ib\_dealloc\_protection\_domain(lnk);@@ -1336,7 +1336,7 @@ static void smc\_conn\_kill(struct smc\_connection \*conn, bool soft) else tasklet\_unlock\_wait(&conn->rx\_tsklet); } else {- smc\_cdc\_tx\_dismiss\_slots(conn);+ smc\_cdc\_wait\_pend\_tx\_wr(conn); } smc\_lgr\_unregister\_conn(conn); smc\_close\_active\_abort(smc);@@ -1459,11 +1459,16 @@ void smc\_smcd\_terminate\_all(struct smcd\_dev \*smcd) /\* Called when an SMCR device is removed or the smc module is unloaded. \* If smcibdev is given, all SMCR link groups using this device are terminated. \* If smcibdev is NULL, all SMCR link groups are terminated.+ \*+ \* We must wait here for QPs been destroyed before we destroy the CQs,+ \* or we won't received any CQEs and cdc\_pend\_tx\_wr cannot reach 0 thus+ \* smc\_sock cannot be released. \*/ void smc\_smcr\_terminate\_all(struct smc\_ib\_device \*smcibdev) { struct smc\_link\_group \*lgr, \*lg; LIST\_HEAD(lgr\_free\_list);+ LIST\_HEAD(lgr\_linkdown\_list); int i;  spin\_lock\_bh(&smc\_lgr\_list.lock);@@ -1475,7 +1480,7 @@ void smc\_smcr\_terminate\_all(struct smc\_ib\_device \*smcibdev) list\_for\_each\_entry\_safe(lgr, lg, &smc\_lgr\_list.list, list) { for (i = 0; i < SMC\_LINKS\_PER\_LGR\_MAX; i++) { if (lgr->lnk[i].smcibdev == smcibdev)- smcr\_link\_down\_cond\_sched(&lgr->lnk[i]);+ list\_move\_tail(&lgr->list, &lgr\_linkdown\_list); } } }@@ -1487,6 +1492,16 @@ void smc\_smcr\_terminate\_all(struct smc\_ib\_device \*smcibdev) \_\_smc\_lgr\_terminate(lgr, false); } + list\_for\_each\_entry\_safe(lgr, lg, &lgr\_linkdown\_list, list) {+ for (i = 0; i < SMC\_LINKS\_PER\_LGR\_MAX; i++) {+ if (lgr->lnk[i].smcibdev == smcibdev) {+ mutex\_lock(&lgr->llc\_conf\_mutex);+ smcr\_link\_down\_cond(&lgr->lnk[i]);+ mutex\_unlock(&lgr->llc\_conf\_mutex);+ }+ }+ }+ if (smcibdev) { if (atomic\_read(&smcibdev->lnk\_cnt)) wait\_event(smcibdev->lnks\_deleted,@@ -1586,7 +1601,6 @@ static void smcr\_link\_down(struct smc\_link \*lnk) if (!lgr || lnk->state == SMC\_LNK\_UNUSED || list\_empty(&lgr->list)) return; - smc\_ib\_modify\_qp\_reset(lnk); to\_lnk = smc\_switch\_conns(lgr, lnk, true); if (!to\_lnk) { /\* no backup link available \*/ smcr\_link\_clear(lnk, true);@@ -1824,6 +1838,7 @@ create: conn->local\_tx\_ctrl.common.type = SMC\_CDC\_MSG\_TYPE; conn->local\_tx\_ctrl.len = SMC\_WR\_TX\_SIZE; conn->urg\_state = SMC\_URG\_READ;+ init\_waitqueue\_head(&conn->cdc\_pend\_tx\_wq); INIT\_WORK(&smc->conn.abort\_work, smc\_conn\_abort\_work); if (ini->is\_smcd) { conn->rx\_off = sizeof(struct smcd\_cdc\_msg);diff --git a/net/smc/smc\_ib.c b/net/smc/smc\_ib.cindex d93055ec17ae86..fe5d5399c4e844 100644--- a/[net/smc/smc\_ib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_ib.c?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_ib.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_ib.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -109,12 +109,12 @@ int smc\_ib\_modify\_qp\_rts(struct smc\_link \*lnk) IB\_QP\_MAX\_QP\_RD\_ATOMIC); } -int smc\_ib\_modify\_qp\_reset(struct smc\_link \*lnk)+int smc\_ib\_modify\_qp\_error(struct smc\_link \*lnk) { struct ib\_qp\_attr qp\_attr;  memset(&qp\_attr, 0, sizeof(qp\_attr));- qp\_attr.qp\_state = IB\_QPS\_RESET;+ qp\_attr.qp\_state = IB\_QPS\_ERR; return ib\_modify\_qp(lnk->roce\_qp, &qp\_attr, IB\_QP\_STATE); } diff --git a/net/smc/smc\_ib.h b/net/smc/smc\_ib.hindex 07585937370ebc..bfa1c6bf6313bf 100644--- a/[net/smc/smc\_ib.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_ib.h?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_ib.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_ib.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -90,6 +90,7 @@ int smc\_ib\_create\_queue\_pair(struct smc\_link \*lnk); int smc\_ib\_ready\_link(struct smc\_link \*lnk); int smc\_ib\_modify\_qp\_rts(struct smc\_link \*lnk); int smc\_ib\_modify\_qp\_reset(struct smc\_link \*lnk);+int smc\_ib\_modify\_qp\_error(struct smc\_link \*lnk); long smc\_ib\_setup\_per\_ibdev(struct smc\_ib\_device \*smcibdev); int smc\_ib\_get\_memory\_region(struct ib\_pd \*pd, int access\_flags, struct smc\_buf\_desc \*buf\_slot, u8 link\_idx);diff --git a/net/smc/smc\_wr.c b/net/smc/smc\_wr.cindex df1dc225cbab60..c6cfdea8b71b97 100644--- a/[net/smc/smc\_wr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_wr.c?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_wr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_wr.c?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -62,13 +62,9 @@ static inline bool smc\_wr\_is\_tx\_pend(struct smc\_link \*link) }  /\* wait till all pending tx work requests on the given link are completed \*/-int smc\_wr\_tx\_wait\_no\_pending\_sends(struct smc\_link \*link)+void smc\_wr\_tx\_wait\_no\_pending\_sends(struct smc\_link \*link) {- if (wait\_event\_timeout(link->wr\_tx\_wait, !smc\_wr\_is\_tx\_pend(link),- SMC\_WR\_TX\_WAIT\_PENDING\_TIME))- return 0;- else /\* timeout \*/- return -EPIPE;+ wait\_event(link->wr\_tx\_wait, !smc\_wr\_is\_tx\_pend(link)); }  static inline int smc\_wr\_tx\_find\_pending\_index(struct smc\_link \*link, u64 wr\_id)@@ -87,7 +83,6 @@ static inline void smc\_wr\_tx\_process\_cqe(struct ib\_wc \*wc) struct smc\_wr\_tx\_pend pnd\_snd; struct smc\_link \*link; u32 pnd\_snd\_idx;- int i;  link = wc->qp->qp\_context; @@ -128,14 +123,6 @@ static inline void smc\_wr\_tx\_process\_cqe(struct ib\_wc \*wc) }  if (wc->status) {- for\_each\_set\_bit(i, link->wr\_tx\_mask, link->wr\_tx\_cnt) {- /\* clear full struct smc\_wr\_tx\_pend including .priv \*/- memset(&link->wr\_tx\_pends[i], 0,- sizeof(link->wr\_tx\_pends[i]));- memset(&link->wr\_tx\_bufs[i], 0,- sizeof(link->wr\_tx\_bufs[i]));- clear\_bit(i, link->wr\_tx\_mask);- } if (link->lgr->smc\_version == SMC\_V2) { memset(link->wr\_tx\_v2\_pend, 0, sizeof(\*link->wr\_tx\_v2\_pend));@@ -421,25 +408,6 @@ int smc\_wr\_reg\_send(struct smc\_link \*link, struct ib\_mr \*mr) return rc; } -void smc\_wr\_tx\_dismiss\_slots(struct smc\_link \*link, u8 wr\_tx\_hdr\_type,- smc\_wr\_tx\_filter filter,- smc\_wr\_tx\_dismisser dismisser,- unsigned long data)-{- struct smc\_wr\_tx\_pend\_priv \*tx\_pend;- struct smc\_wr\_rx\_hdr \*wr\_tx;- int i;-- for\_each\_set\_bit(i, link->wr\_tx\_mask, link->wr\_tx\_cnt) {- wr\_tx = (struct smc\_wr\_rx\_hdr \*)&link->wr\_tx\_bufs[i];- if (wr\_tx->type != wr\_tx\_hdr\_type)- continue;- tx\_pend = &link->wr\_tx\_pends[i].priv;- if (filter(tx\_pend, data))- dismisser(tx\_pend);- }-}- /\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* receive queue \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/  int smc\_wr\_rx\_register\_handler(struct smc\_wr\_rx\_handler \*handler)@@ -675,10 +643,7 @@ void smc\_wr\_free\_link(struct smc\_link \*lnk) smc\_wr\_wakeup\_reg\_wait(lnk); smc\_wr\_wakeup\_tx\_wait(lnk); - if (smc\_wr\_tx\_wait\_no\_pending\_sends(lnk))- memset(lnk->wr\_tx\_mask, 0,- BITS\_TO\_LONGS(SMC\_WR\_BUF\_CNT) \*- sizeof(\*lnk->wr\_tx\_mask));+ smc\_wr\_tx\_wait\_no\_pending\_sends(lnk); wait\_event(lnk->wr\_reg\_wait, (!atomic\_read(&lnk->wr\_reg\_refcnt))); wait\_event(lnk->wr\_tx\_wait, (!atomic\_read(&lnk->wr\_tx\_refcnt))); diff --git a/net/smc/smc\_wr.h b/net/smc/smc\_wr.hindex 48ed9b08ac7add..47512ccce5ef87 100644--- a/[net/smc/smc\_wr.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_wr.h?id=90cee52f2e780345d3629e278291aea5ac74f40f)+++ b/[net/smc/smc\_wr.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/smc/smc_wr.h?id=349d43127dac00c15231e8ffbcaabd70f7b0e544)@@ -22,7 +22,6 @@ #define SMC\_WR\_BUF\_CNT 16 /\* # of ctrl buffers per link \*/  #define SMC\_WR\_TX\_WAIT\_FREE\_SLOT\_TIME (10 \* HZ)-#define SMC\_WR\_TX\_WAIT\_PENDING\_TIME (5 \* HZ)  #define SMC\_WR\_TX\_SIZE 44 /\* actual size of wr\_send data (<=SMC\_WR\_BUF\_SIZE) \*/ @@ -130,7 +129,7 @@ void smc\_wr\_tx\_dismiss\_slots(struct smc\_link \*lnk, u8 wr\_rx\_hdr\_type, smc\_wr\_tx\_filter filter, smc\_wr\_tx\_dismisser dismisser, unsigned long data);-int smc\_wr\_tx\_wait\_no\_pending\_sends(struct smc\_link \*link);+void smc\_wr\_tx\_wait\_no\_pending\_sends(struct smc\_link \*link);  int smc\_wr\_rx\_register\_handler(struct smc\_wr\_rx\_handler \*handler); int smc\_wr\_rx\_post\_init(struct smc\_link \*link); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 07:05:22 +0000

