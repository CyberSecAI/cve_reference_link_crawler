

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jan Kara <jack@suse.cz> | 2024-03-21 17:26:50 +0100 |
| --- | --- | --- |
| committer | Theodore Ts'o <tytso@mit.edu> | 2024-05-03 00:02:24 -0400 |
| commit | [0a46ef234756dca04623b7591e8ebb3440622f0b](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0a46ef234756dca04623b7591e8ebb3440622f0b) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)) | |
| tree | [ac265fb5d61ded08f5e31b49db3339176371f0c5](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0a46ef234756dca04623b7591e8ebb3440622f0b) | |
| parent | [4f3e6db3c3719952cfef89340290e0b7b03f7cbc](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=4f3e6db3c3719952cfef89340290e0b7b03f7cbc) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0a46ef234756dca04623b7591e8ebb3440622f0b&id2=4f3e6db3c3719952cfef89340290e0b7b03f7cbc)) | |
| download | [linux-0a46ef234756dca04623b7591e8ebb3440622f0b.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0a46ef234756dca04623b7591e8ebb3440622f0b.tar.gz) | |

ext4: do not create EA inode under buffer lockext4\_xattr\_set\_entry() creates new EA inodes while holding buffer lock
on the external xattr block. This is problematic as it nests all the
allocation locking (which acquires locks on other buffers) under the
buffer lock. This can even deadlock when the filesystem is corrupted and
e.g. quota file is setup to contain xattr block as data block. Move the
allocation of EA inode out of ext4\_xattr\_set\_entry() into the callers.
Reported-by: syzbot+a43d4f48b8397d0e41a9@syzkaller.appspotmail.com
Signed-off-by: Jan Kara <jack@suse.cz>
Link: [https://lore.kernel.org/r/20240321162657.27420-2-jack@suse.cz](https://lore.kernel.org/r/20240321162657.27420-2-jack%40suse.cz)
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0a46ef234756dca04623b7591e8ebb3440622f0b)

| -rw-r--r-- | [fs/ext4/xattr.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/ext4/xattr.c?id=0a46ef234756dca04623b7591e8ebb3440622f0b) | 113 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 53 insertions, 60 deletions

| diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.cindex 146690c10c73f2..04f90df8dbae98 100644--- a/[fs/ext4/xattr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ext4/xattr.c?id=4f3e6db3c3719952cfef89340290e0b7b03f7cbc)+++ b/[fs/ext4/xattr.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/ext4/xattr.c?id=0a46ef234756dca04623b7591e8ebb3440622f0b)@@ -1619,6 +1619,7 @@ out\_err: static int ext4\_xattr\_set\_entry(struct ext4\_xattr\_info \*i, struct ext4\_xattr\_search \*s, handle\_t \*handle, struct inode \*inode,+ struct inode \*new\_ea\_inode, bool is\_block) { struct ext4\_xattr\_entry \*last, \*next;@@ -1626,7 +1627,6 @@ static int ext4\_xattr\_set\_entry(struct ext4\_xattr\_info \*i, size\_t min\_offs = s->end - s->base, name\_len = strlen(i->name); int in\_inode = i->in\_inode; struct inode \*old\_ea\_inode = NULL;- struct inode \*new\_ea\_inode = NULL; size\_t old\_size, new\_size; int ret; @@ -1711,38 +1711,11 @@ static int ext4\_xattr\_set\_entry(struct ext4\_xattr\_info \*i, old\_ea\_inode = NULL; goto out; }- }- if (i->value && in\_inode) {- WARN\_ON\_ONCE(!i->value\_len);-- new\_ea\_inode = ext4\_xattr\_inode\_lookup\_create(handle, inode,- i->value, i->value\_len);- if (IS\_ERR(new\_ea\_inode)) {- ret = PTR\_ERR(new\_ea\_inode);- new\_ea\_inode = NULL;- goto out;- }- } - if (old\_ea\_inode) { /\* We are ready to release ref count on the old\_ea\_inode. \*/ ret = ext4\_xattr\_inode\_dec\_ref(handle, old\_ea\_inode);- if (ret) {- /\* Release newly required ref count on new\_ea\_inode. \*/- if (new\_ea\_inode) {- int err;-- err = ext4\_xattr\_inode\_dec\_ref(handle,- new\_ea\_inode);- if (err)- ext4\_warning\_inode(new\_ea\_inode,- "dec ref new\_ea\_inode err=%d",- err);- ext4\_xattr\_inode\_free\_quota(inode, new\_ea\_inode,- i->value\_len);- }+ if (ret) goto out;- }  ext4\_xattr\_inode\_free\_quota(inode, old\_ea\_inode, le32\_to\_cpu(here->e\_value\_size));@@ -1866,7 +1839,6 @@ update\_hash: ret = 0; out: iput(old\_ea\_inode);- iput(new\_ea\_inode); return ret; } @@ -1929,9 +1901,21 @@ ext4\_xattr\_block\_set(handle\_t \*handle, struct inode \*inode, size\_t old\_ea\_inode\_quota = 0; unsigned int ea\_ino; - #define header(x) ((struct ext4\_xattr\_header \*)(x)) + /\* If we need EA inode, prepare it before locking the buffer \*/+ if (i->value && i->in\_inode) {+ WARN\_ON\_ONCE(!i->value\_len);++ ea\_inode = ext4\_xattr\_inode\_lookup\_create(handle, inode,+ i->value, i->value\_len);+ if (IS\_ERR(ea\_inode)) {+ error = PTR\_ERR(ea\_inode);+ ea\_inode = NULL;+ goto cleanup;+ }+ }+ if (s->base) { int offset = (char \*)s->here - bs->bh->b\_data; @@ -1940,6 +1924,7 @@ ext4\_xattr\_block\_set(handle\_t \*handle, struct inode \*inode, EXT4\_JTR\_NONE); if (error) goto cleanup;+ lock\_buffer(bs->bh);  if (header(s->base)->h\_refcount == cpu\_to\_le32(1)) {@@ -1966,7 +1951,7 @@ ext4\_xattr\_block\_set(handle\_t \*handle, struct inode \*inode, } ea\_bdebug(bs->bh, "modifying in-place"); error = ext4\_xattr\_set\_entry(i, s, handle, inode,- true /\* is\_block \*/);+ ea\_inode, true /\* is\_block \*/); ext4\_xattr\_block\_csum\_set(inode, bs->bh); unlock\_buffer(bs->bh); if (error == -EFSCORRUPTED)@@ -2034,29 +2019,13 @@ clone\_block: s->end = s->base + sb->s\_blocksize; } - error = ext4\_xattr\_set\_entry(i, s, handle, inode, true /\* is\_block \*/);+ error = ext4\_xattr\_set\_entry(i, s, handle, inode, ea\_inode,+ true /\* is\_block \*/); if (error == -EFSCORRUPTED) goto bad\_block; if (error) goto cleanup; - if (i->value && s->here->e\_value\_inum) {- /\*- \* A ref count on ea\_inode has been taken as part of the call to- \* ext4\_xattr\_set\_entry() above. We would like to drop this- \* extra ref but we have to wait until the xattr block is- \* initialized and has its own ref count on the ea\_inode.- \*/- ea\_ino = le32\_to\_cpu(s->here->e\_value\_inum);- error = ext4\_xattr\_inode\_iget(inode, ea\_ino,- le32\_to\_cpu(s->here->e\_hash),- &ea\_inode);- if (error) {- ea\_inode = NULL;- goto cleanup;- }- }- inserted: if (!IS\_LAST\_ENTRY(s->first)) { new\_bh = ext4\_xattr\_block\_cache\_find(inode, header(s->base),@@ -2209,17 +2178,16 @@ getblk\_failed:  cleanup: if (ea\_inode) {- int error2;-- error2 = ext4\_xattr\_inode\_dec\_ref(handle, ea\_inode);- if (error2)- ext4\_warning\_inode(ea\_inode, "dec ref error=%d",- error2);+ if (error) {+ int error2; - /\* If there was an error, revert the quota charge. \*/- if (error)+ error2 = ext4\_xattr\_inode\_dec\_ref(handle, ea\_inode);+ if (error2)+ ext4\_warning\_inode(ea\_inode, "dec ref error=%d",+ error2); ext4\_xattr\_inode\_free\_quota(inode, ea\_inode, i\_size\_read(ea\_inode));+ } iput(ea\_inode); } if (ce)@@ -2277,14 +2245,38 @@ int ext4\_xattr\_ibody\_set(handle\_t \*handle, struct inode \*inode, { struct ext4\_xattr\_ibody\_header \*header; struct ext4\_xattr\_search \*s = &is->s;+ struct inode \*ea\_inode = NULL; int error;  if (!EXT4\_INODE\_HAS\_XATTR\_SPACE(inode)) return -ENOSPC; - error = ext4\_xattr\_set\_entry(i, s, handle, inode, false /\* is\_block \*/);- if (error)+ /\* If we need EA inode, prepare it before locking the buffer \*/+ if (i->value && i->in\_inode) {+ WARN\_ON\_ONCE(!i->value\_len);++ ea\_inode = ext4\_xattr\_inode\_lookup\_create(handle, inode,+ i->value, i->value\_len);+ if (IS\_ERR(ea\_inode))+ return PTR\_ERR(ea\_inode);+ }+ error = ext4\_xattr\_set\_entry(i, s, handle, inode, ea\_inode,+ false /\* is\_block \*/);+ if (error) {+ if (ea\_inode) {+ int error2;++ error2 = ext4\_xattr\_inode\_dec\_ref(handle, ea\_inode);+ if (error2)+ ext4\_warning\_inode(ea\_inode, "dec ref error=%d",+ error2);++ ext4\_xattr\_inode\_free\_quota(inode, ea\_inode,+ i\_size\_read(ea\_inode));+ iput(ea\_inode);+ } return error;+ } header = IHDR(inode, ext4\_raw\_inode(&is->iloc)); if (!IS\_LAST\_ENTRY(s->first)) { header->h\_magic = cpu\_to\_le32(EXT4\_XATTR\_MAGIC);@@ -2293,6 +2285,7 @@ int ext4\_xattr\_ibody\_set(handle\_t \*handle, struct inode \*inode, header->h\_magic = cpu\_to\_le32(0); ext4\_clear\_inode\_state(inode, EXT4\_STATE\_XATTR); }+ iput(ea\_inode); return 0; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:06:37 +0000

