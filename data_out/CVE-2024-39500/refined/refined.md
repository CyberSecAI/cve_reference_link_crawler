```
{
  "vulnerability": {
    "root_cause": "Race condition between `sock_map_close` and `sk_psock_put` leading to a use-after-free.",
    "weaknesses": [
      "Use-after-free",
      "Race condition"
    ],
    "impact": "Kernel crash due to use-after-free, triggered by a WARN_ON_ONCE in the sock_map_close function.",
    "attack_vectors": [
      "A thread deletes an element from the sock map",
      "Another thread creates a socket, adds it to the map, and closes it concurrently"
    ],
    "required_capabilities": "Concurrent execution of two threads with specific operations on the sock map and sockets.",
    "details": "The `sk_psock_get` function could return NULL if the refcount of psock reaches 0 after the last call to `sk_psock_put`. However, `sk_psock_drop` might not be finished yet, and the close callback could still point to `sock_map_close` even if psock is NULL. This leads to a use-after-free when `sock_map_close` is called. The fix uses `sk_psock` to check if the pointer is not NULL and reorders the condition to simplify control flow."
  }
}
```