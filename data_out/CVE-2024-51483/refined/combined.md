=== Content from github.com_ef94729c_20250111_072147.html ===
ChangeDetection.io Path Travsersal

GitHub - dgtlmoon/changedetection.io: The best and simplest free open source web page change detection, website watcher,  restock m

onitor and notification service. Restock Monitor, change detection. Designed for simplicity - Simply monitor which websites had a text chang

e for free. Free Open source web page change detection, Website defacement monitoring, Price change notification

There’s a path traversal issue in changedetection when an external webdriver is used. In this example the path traversal is retrieving the file

from the webdriver container, however in production this is likely to be deployed on the same server as changedetection or other resources

with potentially sensitive information.

The root cause is the payload  source:file:///etc/passwd passes the regex here and also passes the check here where a traditional

file:///etc/passwd  would get blocked

Setup

 Run two containers following the wiki instructions to enable a webdriver for more dynamic web pages:

1. Start WebDriver Container

1 docker run --name selenium --restart unless-stopped -p 4444:4444 --shm-size="2g"  selenium/standalone-chrome-

debug:3.141.59

2. Start changedetection.io Container

1 docker run --link selenium  -p "127.0.0.1:5000:5000"  -e WEBDRIVER_URL="http://selenium:4444/wd/hub"  -v

datastore-volume:/datastore dgtlmoon/changedetection.io

Steps to Reproduce

1. Run the setup commands

2. Visit http://127.0.0.1:5000/ in a web browser

3. Navigate to Fetch Settings and enable the WebDriver http://127.0.0.1:5000/settings#fetching

  4. Back at the main screen enter source:file:///etc/passwd in the form

5. Click Watch and wait a few seconds

6. Refresh the page and click the Preview Button, the contents of the webdriver’s /etc/passwd file is displayed

Trying with just file:///etc/passwd gets blocked



=== Content from github.com_d8ac41fb_20250111_072144.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fprocessors%2F__init__.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fprocessors%2F__init__.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=dgtlmoon%2Fchangedetection.io)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dgtlmoon](/dgtlmoon)
/
**[changedetection.io](/dgtlmoon/changedetection.io)**
Public

* [Notifications](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)
* [Star
   21k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)

* [Code](/dgtlmoon/changedetection.io)
* [Issues
  223](/dgtlmoon/changedetection.io/issues)
* [Pull requests
  36](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects
  0](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

Additional navigation options

* [Code](/dgtlmoon/changedetection.io)
* [Issues](/dgtlmoon/changedetection.io/issues)
* [Pull requests](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

## Files

 master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[processors](/dgtlmoon/changedetection.io/tree/master/changedetectionio/processors)
/
# \_\_init\_\_.py

Copy path Blame  Blame
## Latest commit

## History

[History](/dgtlmoon/changedetection.io/commits/master/changedetectionio/processors/__init__.py)254 lines (199 loc) · 11.1 KB master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[processors](/dgtlmoon/changedetection.io/tree/master/changedetectionio/processors)
/
# \_\_init\_\_.py

Top
## File metadata and controls

* Code
* Blame

254 lines (199 loc) · 11.1 KB[Raw](https://github.com/dgtlmoon/changedetection.io/raw/refs/heads/master/changedetectionio/processors/__init__.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253from abc import abstractmethodfrom changedetectionio.content\_fetchers.base import Fetcherfrom changedetectionio.strtobool import strtoboolfrom copy import deepcopyfrom loguru import loggerimport hashlibimport importlibimport inspectimport osimport pkgutilimport re
class difference\_detection\_processor():
 browser\_steps = None datastore = None fetcher = None screenshot = None watch = None xpath\_data = None preferred\_proxy = None
 def \_\_init\_\_(self, \*args, datastore, watch\_uuid, \*\*kwargs): super().\_\_init\_\_(\*args, \*\*kwargs) self.datastore = datastore self.watch = deepcopy(self.datastore.data['watching'].get(watch\_uuid)) # Generic fetcher that should be extended (requests, playwright etc) self.fetcher = Fetcher()
 def call\_browser(self, preferred\_proxy\_id=None):
 from requests.structures import CaseInsensitiveDict
 url = self.watch.link
 # Protect against file:, file:/, file:// access, check the real "link" without any meta "source:" etc prepended. if re.search(r'^file:', url.strip(), re.IGNORECASE): if not strtobool(os.getenv('ALLOW\_FILE\_URI', 'false')): raise Exception( "file:// type access is denied for security reasons." )
 # Requests, playwright, other browser via wss:// etc, fetch\_extra\_something prefer\_fetch\_backend = self.watch.get('fetch\_backend', 'system')
 # Proxy ID "key" preferred\_proxy\_id = preferred\_proxy\_id if preferred\_proxy\_id else self.datastore.get\_preferred\_proxy\_for\_watch(uuid=self.watch.get('uuid'))
 # Pluggable content self.fetcher if not prefer\_fetch\_backend or prefer\_fetch\_backend == 'system': prefer\_fetch\_backend = self.datastore.data['settings']['application'].get('fetch\_backend')
 # In the case that the preferred fetcher was a browser config with custom connection URL.. # @todo - on save watch, if its extra\_browser\_ then it should be obvious it will use playwright (like if its requests now..) custom\_browser\_connection\_url = None if prefer\_fetch\_backend.startswith('extra\_browser\_'): (t, key) = prefer\_fetch\_backend.split('extra\_browser\_') connection = list( filter(lambda s: (s['browser\_name'] == key), self.datastore.data['settings']['requests'].get('extra\_browsers', []))) if connection: prefer\_fetch\_backend = 'html\_webdriver' custom\_browser\_connection\_url = connection[0].get('browser\_connection\_url')
 # PDF should be html\_requests because playwright will serve it up (so far) in a embedded page # @todo https://github.com/dgtlmoon/changedetection.io/issues/2019 # @todo needs test to or a fix if self.watch.is\_pdf: prefer\_fetch\_backend = "html\_requests"
 # Grab the right kind of 'fetcher', (playwright, requests, etc) from changedetectionio import content\_fetchers if hasattr(content\_fetchers, prefer\_fetch\_backend): # @todo TEMPORARY HACK - SWITCH BACK TO PLAYWRIGHT FOR BROWSERSTEPS if prefer\_fetch\_backend == 'html\_webdriver' and self.watch.has\_browser\_steps: # This is never supported in selenium anyway logger.warning("Using playwright fetcher override for possible puppeteer request in browsersteps, because puppetteer:browser steps is incomplete.") from changedetectionio.content\_fetchers.playwright import fetcher as playwright\_fetcher fetcher\_obj = playwright\_fetcher else: fetcher\_obj = getattr(content\_fetchers, prefer\_fetch\_backend) else: # What it referenced doesnt exist, Just use a default fetcher\_obj = getattr(content\_fetchers, "html\_requests")
 proxy\_url = None if preferred\_proxy\_id: # Custom browser endpoints should NOT have a proxy added if not prefer\_fetch\_backend.startswith('extra\_browser\_'): proxy\_url = self.datastore.proxy\_list.get(preferred\_proxy\_id).get('url') logger.debug(f"Selected proxy key '{preferred\_proxy\_id}' as proxy URL '{proxy\_url}' for {url}") else: logger.debug(f"Skipping adding proxy data when custom Browser endpoint is specified. ")
 # Now call the fetcher (playwright/requests/etc) with arguments that only a fetcher would need. # When browser\_connection\_url is None, it method should default to working out whats the best defaults (os env vars etc) self.fetcher = fetcher\_obj(proxy\_override=proxy\_url, custom\_browser\_connection\_url=custom\_browser\_connection\_url )
 if self.watch.has\_browser\_steps: self.fetcher.browser\_steps = self.watch.get('browser\_steps', []) self.fetcher.browser\_steps\_screenshot\_path = os.path.join(self.datastore.datastore\_path, self.watch.get('uuid'))
 # Tweak the base config with the per-watch ones from changedetectionio.safe\_jinja import render as jinja\_render request\_headers = CaseInsensitiveDict()
 ua = self.datastore.data['settings']['requests'].get('default\_ua') if ua and ua.get(prefer\_fetch\_backend): request\_headers.update({'User-Agent': ua.get(prefer\_fetch\_backend)})
 request\_headers.update(self.watch.get('headers', {})) request\_headers.update(self.datastore.get\_all\_base\_headers()) request\_headers.update(self.datastore.get\_all\_headers\_in\_textfile\_for\_watch(uuid=self.watch.get('uuid')))
 # https://github.com/psf/requests/issues/4525 # Requests doesnt yet support brotli encoding, so don't put 'br' here, be totally sure that the user cannot # do this by accident. if 'Accept-Encoding' in request\_headers and "br" in request\_headers['Accept-Encoding']: request\_headers['Accept-Encoding'] = request\_headers['Accept-Encoding'].replace(', br', '')
 for header\_name in request\_headers: request\_headers.update({header\_name: jinja\_render(template\_str=request\_headers.get(header\_name))})
 timeout = self.datastore.data['settings']['requests'].get('timeout')
 request\_body = self.watch.get('body') if request\_body: request\_body = jinja\_render(template\_str=self.watch.get('body'))  request\_method = self.watch.get('method') ignore\_status\_codes = self.watch.get('ignore\_status\_codes', False)
 # Configurable per-watch or global extra delay before extracting text (for webDriver types) system\_webdriver\_delay = self.datastore.data['settings']['application'].get('webdriver\_delay', None) if self.watch.get('webdriver\_delay'): self.fetcher.render\_extract\_delay = self.watch.get('webdriver\_delay') elif system\_webdriver\_delay is not None: self.fetcher.render\_extract\_delay = system\_webdriver\_delay
 if self.watch.get('webdriver\_js\_execute\_code') is not None and self.watch.get('webdriver\_js\_execute\_code').strip(): self.fetcher.webdriver\_js\_execute\_code = self.watch.get('webdriver\_js\_execute\_code')
 # Requests for PDF's, images etc should be passwd the is\_binary flag is\_binary = self.watch.is\_pdf
 # And here we go! call the right browser with browser-specific settings empty\_pages\_are\_a\_change = self.datastore.data['settings']['application'].get('empty\_pages\_are\_a\_change', False)
 self.fetcher.run(url=url, timeout=timeout, request\_headers=request\_headers, request\_body=request\_body, request\_method=request\_method, ignore\_status\_codes=ignore\_status\_codes, current\_include\_filters=self.watch.get('include\_filters'), is\_binary=is\_binary, empty\_pages\_are\_a\_change=empty\_pages\_are\_a\_change )
 #@todo .quit here could go on close object, so we can run JS if change-detected self.fetcher.quit()
 # After init, call run\_changedetection() which will do the actual change-detection
 @abstractmethod def run\_changedetection(self, watch): update\_obj = {'last\_notification\_error': False, 'last\_error': False} some\_data = 'xxxxx' update\_obj["previous\_md5"] = hashlib.md5(some\_data.encode('utf-8')).hexdigest() changed\_detected = False return changed\_detected, update\_obj, ''.encode('utf-8')
def find\_sub\_packages(package\_name): """ Find all sub-packages within the given package.
 :param package\_name: The name of the base package to scan for sub-packages. :return: A list of sub-package names. """ package = importlib.import\_module(package\_name) return [name for \_, name, is\_pkg in pkgutil.iter\_modules(package.\_\_path\_\_) if is\_pkg]
def find\_processors(): """ Find all subclasses of DifferenceDetectionProcessor in the specified package.
 :param package\_name: The name of the package to scan for processor modules. :return: A list of (module, class) tuples. """ package\_name = "changedetectionio.processors" # Name of the current package/module
 processors = [] sub\_packages = find\_sub\_packages(package\_name)
 for sub\_package in sub\_packages: module\_name = f"{package\_name}.{sub\_package}.processor" try: module = importlib.import\_module(module\_name)
 # Iterate through all classes in the module for name, obj in inspect.getmembers(module, inspect.isclass): if issubclass(obj, difference\_detection\_processor) and obj is not difference\_detection\_processor: processors.append((module, sub\_package)) except (ModuleNotFoundError, ImportError) as e: logger.warning(f"Failed to import module {module\_name}: {e} (find\_processors())")
 return processors
def get\_parent\_module(module): module\_name = module.\_\_name\_\_ if '.' not in module\_name: return None # Top-level module has no parent parent\_module\_name = module\_name.rsplit('.', 1)[0] try: return importlib.import\_module(parent\_module\_name) except Exception as e: pass
 return False
def get\_custom\_watch\_obj\_for\_processor(processor\_name): from changedetectionio.model import Watch watch\_class = Watch.model processor\_classes = find\_processors() custom\_watch\_obj = next((tpl for tpl in processor\_classes if tpl[1] == processor\_name), None) if custom\_watch\_obj: # Parent of .processor.py COULD have its own Watch implementation parent\_module = get\_parent\_module(custom\_watch\_obj[0]) if hasattr(parent\_module, 'Watch'): watch\_class = parent\_module.Watch
 return watch\_class
def available\_processors(): """ Get a list of processors by name and description for the UI elements :return: A list :) """
 processor\_classes = find\_processors()
 available = [] for package, processor\_class in processor\_classes: available.append((processor\_class, package.name))
 return available

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_5d65cebd_20250111_072145.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fsecurity%2Fadvisories%2FGHSA-cwgg-57xj-g77r)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fsecurity%2Fadvisories%2FGHSA-cwgg-57xj-g77r)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=dgtlmoon%2Fchangedetection.io)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dgtlmoon](/dgtlmoon)
/
**[changedetection.io](/dgtlmoon/changedetection.io)**
Public

* [Notifications](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)
* [Star
   21k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)

* [Code](/dgtlmoon/changedetection.io)
* [Issues
  223](/dgtlmoon/changedetection.io/issues)
* [Pull requests
  36](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects
  0](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

Additional navigation options

* [Code](/dgtlmoon/changedetection.io)
* [Issues](/dgtlmoon/changedetection.io/issues)
* [Pull requests](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

# Path Traversal

Moderate

[dgtlmoon](/dgtlmoon)
published
GHSA-cwgg-57xj-g77r
Oct 31, 2024

## Package

No package listed

## Affected versions

<= 0.47.04

## Patched versions

0.47.05

## Description

### Summary

When a WebDriver is used to fetch files source:file:///etc/passwd can be used to retrieve local system files, where the more traditional file:///etc/passwd gets blocked

### Details

The root cause is the payload source:file:///etc/passwdpasses the regex [here](https://github.com/dgtlmoon/changedetection.io/blob/master/changedetectionio/model/Watch.py#L19) and also passes the check [here](https://github.com/dgtlmoon/changedetection.io/blob/master/changedetectionio/processors/__init__.py#L35) where a traditional file:///etc/passwd would get blocked

### PoC

[CL-ChangeDetection.io Path Travsersal-311024-181039.pdf](https://github.com/user-attachments/files/17591630/CL-ChangeDetection.io.Path.Travsersal-311024-181039.pdf)

### Impact

It depends on where the webdriver is deployed but generally this is a high impact vulnerability

### Severity

Moderate

6.5

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Network

Attack complexity
Low

Privileges required
None

User interaction
None

Scope
Unchanged

Confidentiality
Low

Integrity
Low

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N

### CVE ID

CVE-2024-51483

### Weaknesses

No CWEs

### Credits

* [![@chasebowman-contrast](https://avatars.githubusercontent.com/u/175045663?s=40&v=4)](/chasebowman-contrast)
  [chasebowman-contrast](/chasebowman-contrast)
  Reporter

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_4c0f4ddf_20250111_072143.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fmodel%2FWatch.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fmodel%2FWatch.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=dgtlmoon%2Fchangedetection.io)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dgtlmoon](/dgtlmoon)
/
**[changedetection.io](/dgtlmoon/changedetection.io)**
Public

* [Notifications](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)
* [Star
   21k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)

* [Code](/dgtlmoon/changedetection.io)
* [Issues
  223](/dgtlmoon/changedetection.io/issues)
* [Pull requests
  36](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects
  0](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

Additional navigation options

* [Code](/dgtlmoon/changedetection.io)
* [Issues](/dgtlmoon/changedetection.io/issues)
* [Pull requests](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

## Files

 master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[model](/dgtlmoon/changedetection.io/tree/master/changedetectionio/model)
/
# Watch.py

Copy path Blame  Blame
## Latest commit

## History

[History](/dgtlmoon/changedetection.io/commits/master/changedetectionio/model/Watch.py)636 lines (496 loc) · 22.8 KB master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[model](/dgtlmoon/changedetection.io/tree/master/changedetectionio/model)
/
# Watch.py

Top
## File metadata and controls

* Code
* Blame

636 lines (496 loc) · 22.8 KB[Raw](https://github.com/dgtlmoon/changedetection.io/raw/refs/heads/master/changedetectionio/model/Watch.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636from changedetectionio.strtobool import strtoboolfrom changedetectionio.safe\_jinja import render as jinja\_renderfrom . import watch\_baseimport osimport refrom pathlib import Pathfrom loguru import logger
from ..html\_tools import TRANSLATE\_WHITESPACE\_TABLE
# Allowable protocols, protects against javascript: etc# file:// is further checked by ALLOW\_FILE\_URISAFE\_PROTOCOL\_REGEX='^(http|https|ftp|file):'
minimum\_seconds\_recheck\_time = int(os.getenv('MINIMUM\_SECONDS\_RECHECK\_TIME', 3))mtable = {'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'weeks': 86400 \* 7}
def is\_safe\_url(test\_url): # See https://github.com/dgtlmoon/changedetection.io/issues/1358
 # Remove 'source:' prefix so we dont get 'source:javascript:' etc # 'source:' is a valid way to tell us to return the source
 r = re.compile(re.escape('source:'), re.IGNORECASE) test\_url = r.sub('', test\_url)
 pattern = re.compile(os.getenv('SAFE\_PROTOCOL\_REGEX', SAFE\_PROTOCOL\_REGEX), re.IGNORECASE) if not pattern.match(test\_url.strip()): return False
 return True
class model(watch\_base): \_\_newest\_history\_key = None \_\_history\_n = 0 jitter\_seconds = 0
 def \_\_init\_\_(self, \*arg, \*\*kw): self.\_\_datastore\_path = kw.get('datastore\_path') if kw.get('datastore\_path'): del kw['datastore\_path'] super(model, self).\_\_init\_\_(\*arg, \*\*kw) if kw.get('default'): self.update(kw['default']) del kw['default']
 if self.get('default'): del self['default']
 # Be sure the cached timestamp is ready bump = self.history
 @property def viewed(self): # Don't return viewed when last\_viewed is 0 and newest\_key is 0 if int(self['last\_viewed']) and int(self['last\_viewed']) >= int(self.newest\_history\_key) : return True
 return False
 def ensure\_data\_dir\_exists(self): if not os.path.isdir(self.watch\_data\_dir): logger.debug(f"> Creating data dir {self.watch\_data\_dir}") os.mkdir(self.watch\_data\_dir)
 @property def link(self):
 url = self.get('url', '') if not is\_safe\_url(url): return 'DISABLED'
 ready\_url = url if '{%' in url or '{{' in url: # Jinja2 available in URLs along with https://pypi.org/project/jinja2-time/ try: ready\_url = jinja\_render(template\_str=url) except Exception as e: logger.critical(f"Invalid URL template for: '{url}' - {str(e)}") from flask import ( flash, Markup, url\_for ) message = Markup('<a href="{}#general">The URL {} is invalid and cannot be used, click to edit</a>'.format( url\_for('edit\_page', uuid=self.get('uuid')), self.get('url', ''))) flash(message, 'error') return ''
 if ready\_url.startswith('source:'): ready\_url=ready\_url.replace('source:', '')
 # Also double check it after any Jinja2 formatting just incase if not is\_safe\_url(ready\_url): return 'DISABLED' return ready\_url
 def clear\_watch(self): import pathlib
 # JSON Data, Screenshots, Textfiles (history index and snapshots), HTML in the future etc for item in pathlib.Path(str(self.watch\_data\_dir)).rglob("\*.\*"): os.unlink(item)
 # Force the attr to recalculate bump = self.history
 # Do this last because it will trigger a recheck due to last\_checked being zero self.update({ 'browser\_steps\_last\_error\_step': None, 'check\_count': 0, 'fetch\_time': 0.0, 'has\_ldjson\_price\_data': None, 'last\_checked': 0, 'last\_error': False, 'last\_notification\_error': False, 'last\_viewed': 0, 'previous\_md5': False, 'previous\_md5\_before\_filters': False, 'remote\_server\_reply': None, 'track\_ldjson\_price\_data': None }) return
 @property def is\_source\_type\_url(self): return self.get('url', '').startswith('source:')
 @property def get\_fetch\_backend(self): """ Like just using the `fetch\_backend` key but there could be some logic :return: """ # Maybe also if is\_image etc? # This is because chrome/playwright wont render the PDF in the browser and we will just fetch it and use pdf2html to see the text. if self.is\_pdf: return 'html\_requests'
 return self.get('fetch\_backend')
 @property def is\_pdf(self): # content\_type field is set in the future # https://github.com/dgtlmoon/changedetection.io/issues/1392 # Not sure the best logic here return self.get('url', '').lower().endswith('.pdf') or 'pdf' in self.get('content\_type', '').lower()
 @property def label(self): # Used for sorting return self.get('title') if self.get('title') else self.get('url')
 @property def last\_changed(self): # last\_changed will be the newest snapshot, but when we have just one snapshot, it should be 0 if self.\_\_history\_n <= 1: return 0 if self.\_\_newest\_history\_key: return int(self.\_\_newest\_history\_key) return 0
 @property def history\_n(self): return self.\_\_history\_n
 @property def history(self): """History index is just a text file as a list {watch-uuid}/history.txt
 contains a list like
 {epoch-time},{filename}\n
 We read in this list as the history information
 """ tmp\_history = {}
 # In the case we are only using the watch for processing without history if not self.watch\_data\_dir: return []
 # Read the history file as a dict fname = os.path.join(self.watch\_data\_dir, "history.txt") if os.path.isfile(fname): logger.debug(f"Reading watch history index for {self.get('uuid')}") with open(fname, "r") as f: for i in f.readlines(): if ',' in i: k, v = i.strip().split(',', 2)
 # The index history could contain a relative path, so we need to make the fullpath # so that python can read it if not '/' in v and not '\'' in v: v = os.path.join(self.watch\_data\_dir, v) else: # It's possible that they moved the datadir on older versions # So the snapshot exists but is in a different path snapshot\_fname = v.split('/')[-1] proposed\_new\_path = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(v) and os.path.exists(proposed\_new\_path): v = proposed\_new\_path
 tmp\_history[k] = v
 if len(tmp\_history): self.\_\_newest\_history\_key = list(tmp\_history.keys())[-1] else: self.\_\_newest\_history\_key = None
 self.\_\_history\_n = len(tmp\_history)
 return tmp\_history
 @property def has\_history(self): fname = os.path.join(self.watch\_data\_dir, "history.txt") return os.path.isfile(fname)
 @property def has\_browser\_steps(self): has\_browser\_steps = self.get('browser\_steps') and list(filter( lambda s: (s['operation'] and len(s['operation']) and s['operation'] != 'Choose one' and s['operation'] != 'Goto site'), self.get('browser\_steps')))
 return has\_browser\_steps
 @property def has\_restock\_info(self): if self.get('restock') and self['restock'].get('in\_stock') != None: return True
 return False
 # Returns the newest key, but if theres only 1 record, then it's counted as not being new, so return 0. @property def newest\_history\_key(self): if self.\_\_newest\_history\_key is not None: return self.\_\_newest\_history\_key
 if len(self.history) <= 1: return 0
 bump = self.history return self.\_\_newest\_history\_key
 # Given an arbitrary timestamp, find the best history key for the [diff] button so it can preset a smarter from\_version @property def get\_from\_version\_based\_on\_last\_viewed(self):
 """Unfortunately for now timestamp is stored as string key""" keys = list(self.history.keys()) if not keys: return None if len(keys) == 1: return keys[0]
 last\_viewed = int(self.get('last\_viewed')) sorted\_keys = sorted(keys, key=lambda x: int(x)) sorted\_keys.reverse()
 # When the 'last viewed' timestamp is greater than or equal the newest snapshot, return second newest if last\_viewed >= int(sorted\_keys[0]): return sorted\_keys[1]  # When the 'last viewed' timestamp is between snapshots, return the older snapshot for newer, older in list(zip(sorted\_keys[0:], sorted\_keys[1:])): if last\_viewed < int(newer) and last\_viewed >= int(older): return older
 # When the 'last viewed' timestamp is less than the oldest snapshot, return oldest return sorted\_keys[-1]
 def get\_history\_snapshot(self, timestamp): import brotli filepath = self.history[timestamp]
 # See if a brotli versions exists and switch to that if not filepath.endswith('.br') and os.path.isfile(f"{filepath}.br"): filepath = f"{filepath}.br"
 # OR in the backup case that the .br does not exist, but the plain one does if filepath.endswith('.br') and not os.path.isfile(filepath): if os.path.isfile(filepath.replace('.br', '')): filepath = filepath.replace('.br', '')
 if filepath.endswith('.br'): # Brotli doesnt have a fileheader to detect it, so we rely on filename # https://www.rfc-editor.org/rfc/rfc7932 with open(filepath, 'rb') as f: return(brotli.decompress(f.read()).decode('utf-8'))
 with open(filepath, 'r', encoding='utf-8', errors='ignore') as f: return f.read()
 # Save some text file to the appropriate path and bump the history # result\_obj from fetch\_site\_status.run() def save\_history\_text(self, contents, timestamp, snapshot\_id): import brotli
 logger.trace(f"{self.get('uuid')} - Updating history.txt with timestamp {timestamp}")
 self.ensure\_data\_dir\_exists()
 threshold = int(os.getenv('SNAPSHOT\_BROTLI\_COMPRESSION\_THRESHOLD', 1024)) skip\_brotli = strtobool(os.getenv('DISABLE\_BROTLI\_TEXT\_SNAPSHOT', 'False'))
 if not skip\_brotli and len(contents) > threshold: snapshot\_fname = f"{snapshot\_id}.txt.br" dest = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(dest): with open(dest, 'wb') as f: f.write(brotli.compress(contents.encode('utf-8'), mode=brotli.MODE\_TEXT)) else: snapshot\_fname = f"{snapshot\_id}.txt" dest = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(dest): with open(dest, 'wb') as f: f.write(contents.encode('utf-8'))
 # Append to index # @todo check last char was \n index\_fname = os.path.join(self.watch\_data\_dir, "history.txt") with open(index\_fname, 'a') as f: f.write("{},{}\n".format(timestamp, snapshot\_fname)) f.close()
 self.\_\_newest\_history\_key = timestamp self.\_\_history\_n += 1
 # @todo bump static cache of the last timestamp so we dont need to examine the file to set a proper ''viewed'' status return snapshot\_fname
 @property def has\_empty\_checktime(self): # using all() + dictionary comprehension # Check if all values are 0 in dictionary res = all(x == None or x == False or x==0 for x in self.get('time\_between\_check', {}).values()) return res
 def threshold\_seconds(self): seconds = 0 for m, n in mtable.items(): x = self.get('time\_between\_check', {}).get(m, None) if x: seconds += x \* n return seconds
 # Iterate over all history texts and see if something new exists # Always applying .strip() to start/end but optionally replace any other whitespace def lines\_contain\_something\_unique\_compared\_to\_history(self, lines: list, ignore\_whitespace=False): local\_lines = [] if lines: if ignore\_whitespace: if isinstance(lines[0], str): # Can be either str or bytes depending on what was on the disk local\_lines = set([l.translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for l in lines]) else: local\_lines = set([l.decode('utf-8').translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for l in lines]) else: if isinstance(lines[0], str): # Can be either str or bytes depending on what was on the disk local\_lines = set([l.strip().lower() for l in lines]) else: local\_lines = set([l.decode('utf-8').strip().lower() for l in lines])
 # Compare each lines (set) against each history text file (set) looking for something new.. existing\_history = set({}) for k, v in self.history.items(): content = self.get\_history\_snapshot(k)
 if ignore\_whitespace: alist = set([line.translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for line in content.splitlines()]) else: alist = set([line.strip().lower() for line in content.splitlines()])
 existing\_history = existing\_history.union(alist)
 # Check that everything in local\_lines(new stuff) already exists in existing\_history - it should # if not, something new happened return not local\_lines.issubset(existing\_history)
 def get\_screenshot(self): fname = os.path.join(self.watch\_data\_dir, "last-screenshot.png") if os.path.isfile(fname): return fname
 # False is not an option for AppRise, must be type None return None
 def \_\_get\_file\_ctime(self, filename): fname = os.path.join(self.watch\_data\_dir, filename) if os.path.isfile(fname): return int(os.path.getmtime(fname)) return False
 @property def error\_text\_ctime(self): return self.\_\_get\_file\_ctime('last-error.txt')
 @property def snapshot\_text\_ctime(self): if self.history\_n==0: return False
 timestamp = list(self.history.keys())[-1] return int(timestamp)
 @property def snapshot\_screenshot\_ctime(self): return self.\_\_get\_file\_ctime('last-screenshot.png')
 @property def snapshot\_error\_screenshot\_ctime(self): return self.\_\_get\_file\_ctime('last-error-screenshot.png')
 @property def watch\_data\_dir(self): # The base dir of the watch data return os.path.join(self.\_\_datastore\_path, self['uuid']) if self.\_\_datastore\_path else None
 def get\_error\_text(self): """Return the text saved from a previous request that resulted in a non-200 error""" fname = os.path.join(self.watch\_data\_dir, "last-error.txt") if os.path.isfile(fname): with open(fname, 'r') as f: return f.read() return False
 def get\_error\_snapshot(self): """Return path to the screenshot that resulted in a non-200 error""" fname = os.path.join(self.watch\_data\_dir, "last-error-screenshot.png") if os.path.isfile(fname): return fname return False
 def pause(self): self['paused'] = True
 def unpause(self): self['paused'] = False
 def toggle\_pause(self): self['paused'] ^= True
 def mute(self): self['notification\_muted'] = True
 def unmute(self): self['notification\_muted'] = False
 def toggle\_mute(self): self['notification\_muted'] ^= True
 def extra\_notification\_token\_values(self): # Used for providing extra tokens # return {'widget': 555} return {}
 def extra\_notification\_token\_placeholder\_info(self): # Used for providing extra tokens # return [('widget', "Get widget amounts")] return []
 def extract\_regex\_from\_all\_history(self, regex): import csv import re import datetime csv\_output\_filename = False csv\_writer = False f = None
 # self.history will be keyed with the full path for k, fname in self.history.items(): if os.path.isfile(fname): if True: contents = self.get\_history\_snapshot(k) res = re.findall(regex, contents, re.MULTILINE) if res: if not csv\_writer: # A file on the disk can be transferred much faster via flask than a string reply csv\_output\_filename = 'report.csv' f = open(os.path.join(self.watch\_data\_dir, csv\_output\_filename), 'w') # @todo some headers in the future #fieldnames = ['Epoch seconds', 'Date'] csv\_writer = csv.writer(f, delimiter=',', quotechar='"', quoting=csv.QUOTE\_MINIMAL, #fieldnames=fieldnames ) csv\_writer.writerow(['Epoch seconds', 'Date']) # csv\_writer.writeheader()
 date\_str = datetime.datetime.fromtimestamp(int(k)).strftime('%Y-%m-%d %H:%M:%S') for r in res: row = [k, date\_str] if isinstance(r, str): row.append(r) else: row+=r csv\_writer.writerow(row)
 if f: f.close()
 return csv\_output\_filename
 def has\_special\_diff\_filter\_options\_set(self):
 # All False - nothing would be done, so act like it's not processable if not self.get('filter\_text\_added', True) and not self.get('filter\_text\_replaced', True) and not self.get('filter\_text\_removed', True): return False
 # Or one is set if not self.get('filter\_text\_added', True) or not self.get('filter\_text\_replaced', True) or not self.get('filter\_text\_removed', True): return True
 # None is set return False
 def save\_error\_text(self, contents): self.ensure\_data\_dir\_exists() target\_path = os.path.join(self.watch\_data\_dir, "last-error.txt") with open(target\_path, 'w') as f: f.write(contents)
 def save\_xpath\_data(self, data, as\_error=False): import json import zlib
 if as\_error: target\_path = os.path.join(str(self.watch\_data\_dir), "elements-error.deflate") else: target\_path = os.path.join(str(self.watch\_data\_dir), "elements.deflate")
 self.ensure\_data\_dir\_exists()
 with open(target\_path, 'wb') as f: f.write(zlib.compress(json.dumps(data).encode())) f.close()
 # Save as PNG, PNG is larger but better for doing visual diff in the future def save\_screenshot(self, screenshot: bytes, as\_error=False):
 if as\_error: target\_path = os.path.join(self.watch\_data\_dir, "last-error-screenshot.png") else: target\_path = os.path.join(self.watch\_data\_dir, "last-screenshot.png")
 self.ensure\_data\_dir\_exists()
 with open(target\_path, 'wb') as f: f.write(screenshot) f.close()
 def get\_last\_fetched\_text\_before\_filters(self): import brotli filepath = os.path.join(self.watch\_data\_dir, 'last-fetched.br')
 if not os.path.isfile(filepath): # If a previous attempt doesnt yet exist, just snarf the previous snapshot instead dates = list(self.history.keys()) if len(dates): return self.get\_history\_snapshot(dates[-1]) else: return ''
 with open(filepath, 'rb') as f: return(brotli.decompress(f.read()).decode('utf-8'))
 def save\_last\_text\_fetched\_before\_filters(self, contents): import brotli filepath = os.path.join(self.watch\_data\_dir, 'last-fetched.br') with open(filepath, 'wb') as f: f.write(brotli.compress(contents, mode=brotli.MODE\_TEXT))
 def save\_last\_fetched\_html(self, timestamp, contents): import brotli
 self.ensure\_data\_dir\_exists() snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname)
 with open(filepath, 'wb') as f: contents = contents.encode('utf-8') if isinstance(contents, str) else contents try: f.write(brotli.compress(contents)) except Exception as e: logger.warning(f"{self.get('uuid')} - Unable to compress snapshot, saving as raw data to {filepath}") logger.warning(e) f.write(contents)
 self.\_prune\_last\_fetched\_html\_snapshots()
 def get\_fetched\_html(self, timestamp): import brotli
 snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname) if os.path.isfile(filepath): with open(filepath, 'rb') as f: return (brotli.decompress(f.read()).decode('utf-8'))
 return False
 def \_prune\_last\_fetched\_html\_snapshots(self):
 dates = list(self.history.keys()) dates.reverse()
 for index, timestamp in enumerate(dates): snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname)
 # Keep only the first 2 if index > 1 and os.path.isfile(filepath): os.remove(filepath)
 @property def get\_browsersteps\_available\_screenshots(self): "For knowing which screenshots are available to show the user in BrowserSteps UI" available = [] for f in Path(self.watch\_data\_dir).glob('step\_before-\*.jpeg'): step\_n=re.search(r'step\_before-(\d+)', f.name) if step\_n: available.append(step\_n.group(1)) return available

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


