
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fmodel%2FWatch.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdgtlmoon%2Fchangedetection.io%2Fblob%2Fmaster%2Fchangedetectionio%2Fmodel%2FWatch.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=dgtlmoon%2Fchangedetection.io)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dgtlmoon](/dgtlmoon)
/
**[changedetection.io](/dgtlmoon/changedetection.io)**
Public

* [Notifications](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io) You must be signed in to change notification settings
* [Fork
  1.1k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)
* [Star
   21k](/login?return_to=%2Fdgtlmoon%2Fchangedetection.io)

* [Code](/dgtlmoon/changedetection.io)
* [Issues
  223](/dgtlmoon/changedetection.io/issues)
* [Pull requests
  36](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects
  0](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

Additional navigation options

* [Code](/dgtlmoon/changedetection.io)
* [Issues](/dgtlmoon/changedetection.io/issues)
* [Pull requests](/dgtlmoon/changedetection.io/pulls)
* [Discussions](/dgtlmoon/changedetection.io/discussions)
* [Actions](/dgtlmoon/changedetection.io/actions)
* [Projects](/dgtlmoon/changedetection.io/projects)
* [Wiki](/dgtlmoon/changedetection.io/wiki)
* [Security](/dgtlmoon/changedetection.io/security)
* [Insights](/dgtlmoon/changedetection.io/pulse)

## Files

 master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[model](/dgtlmoon/changedetection.io/tree/master/changedetectionio/model)
/
# Watch.py

Copy path Blame  Blame
## Latest commit

## History

[History](/dgtlmoon/changedetection.io/commits/master/changedetectionio/model/Watch.py)636 lines (496 loc) · 22.8 KB master
## Breadcrumbs

1. [changedetection.io](/dgtlmoon/changedetection.io/tree/master)
2. /[changedetectionio](/dgtlmoon/changedetection.io/tree/master/changedetectionio)
3. /[model](/dgtlmoon/changedetection.io/tree/master/changedetectionio/model)
/
# Watch.py

Top
## File metadata and controls

* Code
* Blame

636 lines (496 loc) · 22.8 KB[Raw](https://github.com/dgtlmoon/changedetection.io/raw/refs/heads/master/changedetectionio/model/Watch.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636from changedetectionio.strtobool import strtoboolfrom changedetectionio.safe\_jinja import render as jinja\_renderfrom . import watch\_baseimport osimport refrom pathlib import Pathfrom loguru import logger
from ..html\_tools import TRANSLATE\_WHITESPACE\_TABLE
# Allowable protocols, protects against javascript: etc# file:// is further checked by ALLOW\_FILE\_URISAFE\_PROTOCOL\_REGEX='^(http|https|ftp|file):'
minimum\_seconds\_recheck\_time = int(os.getenv('MINIMUM\_SECONDS\_RECHECK\_TIME', 3))mtable = {'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'weeks': 86400 \* 7}
def is\_safe\_url(test\_url): # See https://github.com/dgtlmoon/changedetection.io/issues/1358
 # Remove 'source:' prefix so we dont get 'source:javascript:' etc # 'source:' is a valid way to tell us to return the source
 r = re.compile(re.escape('source:'), re.IGNORECASE) test\_url = r.sub('', test\_url)
 pattern = re.compile(os.getenv('SAFE\_PROTOCOL\_REGEX', SAFE\_PROTOCOL\_REGEX), re.IGNORECASE) if not pattern.match(test\_url.strip()): return False
 return True
class model(watch\_base): \_\_newest\_history\_key = None \_\_history\_n = 0 jitter\_seconds = 0
 def \_\_init\_\_(self, \*arg, \*\*kw): self.\_\_datastore\_path = kw.get('datastore\_path') if kw.get('datastore\_path'): del kw['datastore\_path'] super(model, self).\_\_init\_\_(\*arg, \*\*kw) if kw.get('default'): self.update(kw['default']) del kw['default']
 if self.get('default'): del self['default']
 # Be sure the cached timestamp is ready bump = self.history
 @property def viewed(self): # Don't return viewed when last\_viewed is 0 and newest\_key is 0 if int(self['last\_viewed']) and int(self['last\_viewed']) >= int(self.newest\_history\_key) : return True
 return False
 def ensure\_data\_dir\_exists(self): if not os.path.isdir(self.watch\_data\_dir): logger.debug(f"> Creating data dir {self.watch\_data\_dir}") os.mkdir(self.watch\_data\_dir)
 @property def link(self):
 url = self.get('url', '') if not is\_safe\_url(url): return 'DISABLED'
 ready\_url = url if '{%' in url or '{{' in url: # Jinja2 available in URLs along with https://pypi.org/project/jinja2-time/ try: ready\_url = jinja\_render(template\_str=url) except Exception as e: logger.critical(f"Invalid URL template for: '{url}' - {str(e)}") from flask import ( flash, Markup, url\_for ) message = Markup('<a href="{}#general">The URL {} is invalid and cannot be used, click to edit</a>'.format( url\_for('edit\_page', uuid=self.get('uuid')), self.get('url', ''))) flash(message, 'error') return ''
 if ready\_url.startswith('source:'): ready\_url=ready\_url.replace('source:', '')
 # Also double check it after any Jinja2 formatting just incase if not is\_safe\_url(ready\_url): return 'DISABLED' return ready\_url
 def clear\_watch(self): import pathlib
 # JSON Data, Screenshots, Textfiles (history index and snapshots), HTML in the future etc for item in pathlib.Path(str(self.watch\_data\_dir)).rglob("\*.\*"): os.unlink(item)
 # Force the attr to recalculate bump = self.history
 # Do this last because it will trigger a recheck due to last\_checked being zero self.update({ 'browser\_steps\_last\_error\_step': None, 'check\_count': 0, 'fetch\_time': 0.0, 'has\_ldjson\_price\_data': None, 'last\_checked': 0, 'last\_error': False, 'last\_notification\_error': False, 'last\_viewed': 0, 'previous\_md5': False, 'previous\_md5\_before\_filters': False, 'remote\_server\_reply': None, 'track\_ldjson\_price\_data': None }) return
 @property def is\_source\_type\_url(self): return self.get('url', '').startswith('source:')
 @property def get\_fetch\_backend(self): """ Like just using the `fetch\_backend` key but there could be some logic :return: """ # Maybe also if is\_image etc? # This is because chrome/playwright wont render the PDF in the browser and we will just fetch it and use pdf2html to see the text. if self.is\_pdf: return 'html\_requests'
 return self.get('fetch\_backend')
 @property def is\_pdf(self): # content\_type field is set in the future # https://github.com/dgtlmoon/changedetection.io/issues/1392 # Not sure the best logic here return self.get('url', '').lower().endswith('.pdf') or 'pdf' in self.get('content\_type', '').lower()
 @property def label(self): # Used for sorting return self.get('title') if self.get('title') else self.get('url')
 @property def last\_changed(self): # last\_changed will be the newest snapshot, but when we have just one snapshot, it should be 0 if self.\_\_history\_n <= 1: return 0 if self.\_\_newest\_history\_key: return int(self.\_\_newest\_history\_key) return 0
 @property def history\_n(self): return self.\_\_history\_n
 @property def history(self): """History index is just a text file as a list {watch-uuid}/history.txt
 contains a list like
 {epoch-time},{filename}\n
 We read in this list as the history information
 """ tmp\_history = {}
 # In the case we are only using the watch for processing without history if not self.watch\_data\_dir: return []
 # Read the history file as a dict fname = os.path.join(self.watch\_data\_dir, "history.txt") if os.path.isfile(fname): logger.debug(f"Reading watch history index for {self.get('uuid')}") with open(fname, "r") as f: for i in f.readlines(): if ',' in i: k, v = i.strip().split(',', 2)
 # The index history could contain a relative path, so we need to make the fullpath # so that python can read it if not '/' in v and not '\'' in v: v = os.path.join(self.watch\_data\_dir, v) else: # It's possible that they moved the datadir on older versions # So the snapshot exists but is in a different path snapshot\_fname = v.split('/')[-1] proposed\_new\_path = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(v) and os.path.exists(proposed\_new\_path): v = proposed\_new\_path
 tmp\_history[k] = v
 if len(tmp\_history): self.\_\_newest\_history\_key = list(tmp\_history.keys())[-1] else: self.\_\_newest\_history\_key = None
 self.\_\_history\_n = len(tmp\_history)
 return tmp\_history
 @property def has\_history(self): fname = os.path.join(self.watch\_data\_dir, "history.txt") return os.path.isfile(fname)
 @property def has\_browser\_steps(self): has\_browser\_steps = self.get('browser\_steps') and list(filter( lambda s: (s['operation'] and len(s['operation']) and s['operation'] != 'Choose one' and s['operation'] != 'Goto site'), self.get('browser\_steps')))
 return has\_browser\_steps
 @property def has\_restock\_info(self): if self.get('restock') and self['restock'].get('in\_stock') != None: return True
 return False
 # Returns the newest key, but if theres only 1 record, then it's counted as not being new, so return 0. @property def newest\_history\_key(self): if self.\_\_newest\_history\_key is not None: return self.\_\_newest\_history\_key
 if len(self.history) <= 1: return 0
 bump = self.history return self.\_\_newest\_history\_key
 # Given an arbitrary timestamp, find the best history key for the [diff] button so it can preset a smarter from\_version @property def get\_from\_version\_based\_on\_last\_viewed(self):
 """Unfortunately for now timestamp is stored as string key""" keys = list(self.history.keys()) if not keys: return None if len(keys) == 1: return keys[0]
 last\_viewed = int(self.get('last\_viewed')) sorted\_keys = sorted(keys, key=lambda x: int(x)) sorted\_keys.reverse()
 # When the 'last viewed' timestamp is greater than or equal the newest snapshot, return second newest if last\_viewed >= int(sorted\_keys[0]): return sorted\_keys[1]  # When the 'last viewed' timestamp is between snapshots, return the older snapshot for newer, older in list(zip(sorted\_keys[0:], sorted\_keys[1:])): if last\_viewed < int(newer) and last\_viewed >= int(older): return older
 # When the 'last viewed' timestamp is less than the oldest snapshot, return oldest return sorted\_keys[-1]
 def get\_history\_snapshot(self, timestamp): import brotli filepath = self.history[timestamp]
 # See if a brotli versions exists and switch to that if not filepath.endswith('.br') and os.path.isfile(f"{filepath}.br"): filepath = f"{filepath}.br"
 # OR in the backup case that the .br does not exist, but the plain one does if filepath.endswith('.br') and not os.path.isfile(filepath): if os.path.isfile(filepath.replace('.br', '')): filepath = filepath.replace('.br', '')
 if filepath.endswith('.br'): # Brotli doesnt have a fileheader to detect it, so we rely on filename # https://www.rfc-editor.org/rfc/rfc7932 with open(filepath, 'rb') as f: return(brotli.decompress(f.read()).decode('utf-8'))
 with open(filepath, 'r', encoding='utf-8', errors='ignore') as f: return f.read()
 # Save some text file to the appropriate path and bump the history # result\_obj from fetch\_site\_status.run() def save\_history\_text(self, contents, timestamp, snapshot\_id): import brotli
 logger.trace(f"{self.get('uuid')} - Updating history.txt with timestamp {timestamp}")
 self.ensure\_data\_dir\_exists()
 threshold = int(os.getenv('SNAPSHOT\_BROTLI\_COMPRESSION\_THRESHOLD', 1024)) skip\_brotli = strtobool(os.getenv('DISABLE\_BROTLI\_TEXT\_SNAPSHOT', 'False'))
 if not skip\_brotli and len(contents) > threshold: snapshot\_fname = f"{snapshot\_id}.txt.br" dest = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(dest): with open(dest, 'wb') as f: f.write(brotli.compress(contents.encode('utf-8'), mode=brotli.MODE\_TEXT)) else: snapshot\_fname = f"{snapshot\_id}.txt" dest = os.path.join(self.watch\_data\_dir, snapshot\_fname) if not os.path.exists(dest): with open(dest, 'wb') as f: f.write(contents.encode('utf-8'))
 # Append to index # @todo check last char was \n index\_fname = os.path.join(self.watch\_data\_dir, "history.txt") with open(index\_fname, 'a') as f: f.write("{},{}\n".format(timestamp, snapshot\_fname)) f.close()
 self.\_\_newest\_history\_key = timestamp self.\_\_history\_n += 1
 # @todo bump static cache of the last timestamp so we dont need to examine the file to set a proper ''viewed'' status return snapshot\_fname
 @property def has\_empty\_checktime(self): # using all() + dictionary comprehension # Check if all values are 0 in dictionary res = all(x == None or x == False or x==0 for x in self.get('time\_between\_check', {}).values()) return res
 def threshold\_seconds(self): seconds = 0 for m, n in mtable.items(): x = self.get('time\_between\_check', {}).get(m, None) if x: seconds += x \* n return seconds
 # Iterate over all history texts and see if something new exists # Always applying .strip() to start/end but optionally replace any other whitespace def lines\_contain\_something\_unique\_compared\_to\_history(self, lines: list, ignore\_whitespace=False): local\_lines = [] if lines: if ignore\_whitespace: if isinstance(lines[0], str): # Can be either str or bytes depending on what was on the disk local\_lines = set([l.translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for l in lines]) else: local\_lines = set([l.decode('utf-8').translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for l in lines]) else: if isinstance(lines[0], str): # Can be either str or bytes depending on what was on the disk local\_lines = set([l.strip().lower() for l in lines]) else: local\_lines = set([l.decode('utf-8').strip().lower() for l in lines])
 # Compare each lines (set) against each history text file (set) looking for something new.. existing\_history = set({}) for k, v in self.history.items(): content = self.get\_history\_snapshot(k)
 if ignore\_whitespace: alist = set([line.translate(TRANSLATE\_WHITESPACE\_TABLE).lower() for line in content.splitlines()]) else: alist = set([line.strip().lower() for line in content.splitlines()])
 existing\_history = existing\_history.union(alist)
 # Check that everything in local\_lines(new stuff) already exists in existing\_history - it should # if not, something new happened return not local\_lines.issubset(existing\_history)
 def get\_screenshot(self): fname = os.path.join(self.watch\_data\_dir, "last-screenshot.png") if os.path.isfile(fname): return fname
 # False is not an option for AppRise, must be type None return None
 def \_\_get\_file\_ctime(self, filename): fname = os.path.join(self.watch\_data\_dir, filename) if os.path.isfile(fname): return int(os.path.getmtime(fname)) return False
 @property def error\_text\_ctime(self): return self.\_\_get\_file\_ctime('last-error.txt')
 @property def snapshot\_text\_ctime(self): if self.history\_n==0: return False
 timestamp = list(self.history.keys())[-1] return int(timestamp)
 @property def snapshot\_screenshot\_ctime(self): return self.\_\_get\_file\_ctime('last-screenshot.png')
 @property def snapshot\_error\_screenshot\_ctime(self): return self.\_\_get\_file\_ctime('last-error-screenshot.png')
 @property def watch\_data\_dir(self): # The base dir of the watch data return os.path.join(self.\_\_datastore\_path, self['uuid']) if self.\_\_datastore\_path else None
 def get\_error\_text(self): """Return the text saved from a previous request that resulted in a non-200 error""" fname = os.path.join(self.watch\_data\_dir, "last-error.txt") if os.path.isfile(fname): with open(fname, 'r') as f: return f.read() return False
 def get\_error\_snapshot(self): """Return path to the screenshot that resulted in a non-200 error""" fname = os.path.join(self.watch\_data\_dir, "last-error-screenshot.png") if os.path.isfile(fname): return fname return False
 def pause(self): self['paused'] = True
 def unpause(self): self['paused'] = False
 def toggle\_pause(self): self['paused'] ^= True
 def mute(self): self['notification\_muted'] = True
 def unmute(self): self['notification\_muted'] = False
 def toggle\_mute(self): self['notification\_muted'] ^= True
 def extra\_notification\_token\_values(self): # Used for providing extra tokens # return {'widget': 555} return {}
 def extra\_notification\_token\_placeholder\_info(self): # Used for providing extra tokens # return [('widget', "Get widget amounts")] return []
 def extract\_regex\_from\_all\_history(self, regex): import csv import re import datetime csv\_output\_filename = False csv\_writer = False f = None
 # self.history will be keyed with the full path for k, fname in self.history.items(): if os.path.isfile(fname): if True: contents = self.get\_history\_snapshot(k) res = re.findall(regex, contents, re.MULTILINE) if res: if not csv\_writer: # A file on the disk can be transferred much faster via flask than a string reply csv\_output\_filename = 'report.csv' f = open(os.path.join(self.watch\_data\_dir, csv\_output\_filename), 'w') # @todo some headers in the future #fieldnames = ['Epoch seconds', 'Date'] csv\_writer = csv.writer(f, delimiter=',', quotechar='"', quoting=csv.QUOTE\_MINIMAL, #fieldnames=fieldnames ) csv\_writer.writerow(['Epoch seconds', 'Date']) # csv\_writer.writeheader()
 date\_str = datetime.datetime.fromtimestamp(int(k)).strftime('%Y-%m-%d %H:%M:%S') for r in res: row = [k, date\_str] if isinstance(r, str): row.append(r) else: row+=r csv\_writer.writerow(row)
 if f: f.close()
 return csv\_output\_filename
 def has\_special\_diff\_filter\_options\_set(self):
 # All False - nothing would be done, so act like it's not processable if not self.get('filter\_text\_added', True) and not self.get('filter\_text\_replaced', True) and not self.get('filter\_text\_removed', True): return False
 # Or one is set if not self.get('filter\_text\_added', True) or not self.get('filter\_text\_replaced', True) or not self.get('filter\_text\_removed', True): return True
 # None is set return False
 def save\_error\_text(self, contents): self.ensure\_data\_dir\_exists() target\_path = os.path.join(self.watch\_data\_dir, "last-error.txt") with open(target\_path, 'w') as f: f.write(contents)
 def save\_xpath\_data(self, data, as\_error=False): import json import zlib
 if as\_error: target\_path = os.path.join(str(self.watch\_data\_dir), "elements-error.deflate") else: target\_path = os.path.join(str(self.watch\_data\_dir), "elements.deflate")
 self.ensure\_data\_dir\_exists()
 with open(target\_path, 'wb') as f: f.write(zlib.compress(json.dumps(data).encode())) f.close()
 # Save as PNG, PNG is larger but better for doing visual diff in the future def save\_screenshot(self, screenshot: bytes, as\_error=False):
 if as\_error: target\_path = os.path.join(self.watch\_data\_dir, "last-error-screenshot.png") else: target\_path = os.path.join(self.watch\_data\_dir, "last-screenshot.png")
 self.ensure\_data\_dir\_exists()
 with open(target\_path, 'wb') as f: f.write(screenshot) f.close()
 def get\_last\_fetched\_text\_before\_filters(self): import brotli filepath = os.path.join(self.watch\_data\_dir, 'last-fetched.br')
 if not os.path.isfile(filepath): # If a previous attempt doesnt yet exist, just snarf the previous snapshot instead dates = list(self.history.keys()) if len(dates): return self.get\_history\_snapshot(dates[-1]) else: return ''
 with open(filepath, 'rb') as f: return(brotli.decompress(f.read()).decode('utf-8'))
 def save\_last\_text\_fetched\_before\_filters(self, contents): import brotli filepath = os.path.join(self.watch\_data\_dir, 'last-fetched.br') with open(filepath, 'wb') as f: f.write(brotli.compress(contents, mode=brotli.MODE\_TEXT))
 def save\_last\_fetched\_html(self, timestamp, contents): import brotli
 self.ensure\_data\_dir\_exists() snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname)
 with open(filepath, 'wb') as f: contents = contents.encode('utf-8') if isinstance(contents, str) else contents try: f.write(brotli.compress(contents)) except Exception as e: logger.warning(f"{self.get('uuid')} - Unable to compress snapshot, saving as raw data to {filepath}") logger.warning(e) f.write(contents)
 self.\_prune\_last\_fetched\_html\_snapshots()
 def get\_fetched\_html(self, timestamp): import brotli
 snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname) if os.path.isfile(filepath): with open(filepath, 'rb') as f: return (brotli.decompress(f.read()).decode('utf-8'))
 return False
 def \_prune\_last\_fetched\_html\_snapshots(self):
 dates = list(self.history.keys()) dates.reverse()
 for index, timestamp in enumerate(dates): snapshot\_fname = f"{timestamp}.html.br" filepath = os.path.join(self.watch\_data\_dir, snapshot\_fname)
 # Keep only the first 2 if index > 1 and os.path.isfile(filepath): os.remove(filepath)
 @property def get\_browsersteps\_available\_screenshots(self): "For knowing which screenshots are available to show the user in BrowserSteps UI" available = [] for f in Path(self.watch\_data\_dir).glob('step\_before-\*.jpeg'): step\_n=re.search(r'step\_before-(\d+)', f.name) if step\_n: available.append(step\_n.group(1)) return available

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

