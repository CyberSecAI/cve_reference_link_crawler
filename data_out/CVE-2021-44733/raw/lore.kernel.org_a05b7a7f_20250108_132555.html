<html><head><title>[PATCH v2] tee: handle lookup of shm with reference count 0 - Jens Wiklander</title><link
rel=alternate
title="Atom feed"
href="../new.atom"
type="application/atom+xml"/><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link
type=text/css
rel=stylesheet
href=../216light.css?66c655cb
media=screen,print /><link
type=text/css
rel=stylesheet
media="screen and (prefers-color-scheme:dark)"
href=../216dark.css?66c655cb /></head><body><form
action="../"><pre><a
href="../?t=20211215092555"><b>linux-kernel.vger.kernel.org archive mirror</b></a>
<input
name=q
type=text /><input
type=submit
value=search /> <a
href="../_/text/help/">help</a> / <a
href="../_/text/color/">color</a> / <a
id=mirror
href="../_/text/mirror/">mirror</a> / <a
href="../new.atom">Atom feed</a></pre></form><pre
id=b>From: Jens Wiklander &lt;jens.wiklander@linaro.org&gt;
To: <a
href="../../lkml/?t=20211215092555">linux-kernel@vger.kernel.org</a>, op-tee@lists.trustedfirmware.org
Cc: &#34;Sumit Garg&#34; &lt;sumit.garg@linaro.org&gt;,
	&#34;Christian K&#246;nig&#34; &lt;christian.koenig@amd.com&gt;,
	&#34;Rijo Thomas&#34; &lt;Rijo-john.Thomas@amd.com&gt;,
	&#34;Devaraj Rangasamy&#34; &lt;Devaraj.Rangasamy@amd.com&gt;,
	&#34;Greg KH&#34; &lt;gregkh@linuxfoundation.org&gt;,
	&#34;Jens Wiklander&#34; &lt;jens.wiklander@linaro.org&gt;,
	<a
href="../../stable/?t=20211215092555">stable@vger.kernel.org</a>, &#34;Lars Persson&#34; &lt;larper@axis.com&gt;,
	&#34;Patrik Lantz&#34; &lt;patrik.lantz@axis.com&gt;
Subject: <a
href="#r"
id=t>[PATCH v2] tee: handle lookup of shm with reference count 0</a>
Date: Wed, 15 Dec 2021 10:25:01 +0100	<a
href="#r">[thread overview]</a>
Message-ID: &lt;20211215092501.1861229-1-jens.wiklander@linaro.org&gt; (<a href="raw">raw</a>)

Since the tee subsystem does not keep a strong reference to its idle
shared memory buffers, it races with other threads that try to destroy a
shared memory through a close of its dma-buf fd or by unmapping the
memory.

In tee_shm_get_from_id() when a lookup in teedev-&gt;idr has been
successful, it is possible that the tee_shm is in the dma-buf teardown
path, but that path is blocked by the teedev mutex. Since we don&#39;t have
an API to tell if the tee_shm is in the dma-buf teardown path or not we
must find another way of detecting this condition.

Fix this by doing the reference counting directly on the tee_shm using a
new refcount_t refcount field. dma-buf is replaced by using
anon_inode_getfd() instead, this separates the life-cycle of the
underlying file from the tee_shm. tee_shm_put() is updated to hold the
mutex when decreasing the refcount to 0 and then remove the tee_shm from
teedev-&gt;idr before releasing the mutex. This means that the tee_shm can
never be found unless it has a refcount larger than 0.

Fixes: 967c9cca2cc5 (&#34;tee: generic TEE subsystem&#34;)
Cc: stable@vger.kernel.org
Reviewed-by: Lars Persson &lt;larper@axis.com&gt;
Reviewed-by: Sumit Garg &lt;sumit.garg@linaro.org&gt;
Reported-by: Patrik Lantz &lt;patrik.lantz@axis.com&gt;
Signed-off-by: Jens Wiklander &lt;jens.wiklander@linaro.org&gt;
---
v1-&gt;v2
* fix copyright years in drivers/tee/tee_shm.c
* update kerneldoc comment for struct tee_shm with the reference counter

 <a
id=iZ31drivers:tee:tee_shm.c
href=#Z31drivers:tee:tee_shm.c>drivers/tee/tee_shm.c</a>   | 174 +++++++++++++++-------------------------
 <a
id=iZ31include:linux:tee_drv.h
href=#Z31include:linux:tee_drv.h>include/linux/tee_drv.h</a> |   4 +-
 2 files <a href="#related">changed</a>, 68 insertions(+), 110 deletions(-)

<span
class="head"><a
href=#iZ31drivers:tee:tee_shm.c
id=Z31drivers:tee:tee_shm.c>diff</a> --git a/drivers/tee/tee_shm.c b/drivers/tee/tee_shm.c
index 8a8deb95e918..499fccba3d74 100644
--- a/drivers/tee/tee_shm.c
+++ b/drivers/tee/tee_shm.c
</span><span
class="hunk">@@ -1,20 +1,17 @@
</span> // SPDX-License-Identifier: GPL-2.0-only
 /*
<span
class="del">- * Copyright (c) 2015-2016, Linaro Limited
</span><span
class="add">+ * Copyright (c) 2015-2017, 2019-2021 Linaro Limited
</span>  */
<span
class="add">+#include &lt;linux/anon_inodes.h&gt;
</span> #include &lt;linux/device.h&gt;
<span
class="del">-#include &lt;linux/dma-buf.h&gt;
-#include &lt;linux/fdtable.h&gt;
</span> #include &lt;linux/idr.h&gt;
<span
class="add">+#include &lt;linux/mm.h&gt;
</span> #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/tee_drv.h&gt;
 #include &lt;linux/uio.h&gt;
<span
class="del">-#include &lt;linux/module.h&gt;
</span> #include &#34;tee_private.h&#34;
 
<span
class="del">-MODULE_IMPORT_NS(DMA_BUF);
-
</span> static void release_registered_pages(struct tee_shm *shm)
 {
 	if (shm-&gt;pages) {
<span
class="hunk">@@ -31,16 +28,8 @@ static void release_registered_pages(struct tee_shm *shm)
</span> 	}
 }
 
<span
class="del">-static void tee_shm_release(struct tee_shm *shm)
</span><span
class="add">+static void tee_shm_release(struct tee_device *teedev, struct tee_shm *shm)
</span> {
<span
class="del">-	struct tee_device *teedev = shm-&gt;ctx-&gt;teedev;
-
-	if (shm-&gt;flags &#38; TEE_SHM_DMA_BUF) {
-		mutex_lock(&#38;teedev-&gt;mutex);
-		idr_remove(&#38;teedev-&gt;idr, shm-&gt;id);
-		mutex_unlock(&#38;teedev-&gt;mutex);
-	}
-
</span> 	if (shm-&gt;flags &#38; TEE_SHM_POOL) {
 		struct tee_shm_pool_mgr *poolm;
 
<span
class="hunk">@@ -67,45 +56,6 @@ static void tee_shm_release(struct tee_shm *shm)
</span> 	tee_device_put(teedev);
 }
 
<span
class="del">-static struct sg_table *tee_shm_op_map_dma_buf(struct dma_buf_attachment
-			*attach, enum dma_data_direction dir)
-{
-	return NULL;
-}
-
-static void tee_shm_op_unmap_dma_buf(struct dma_buf_attachment *attach,
-				     struct sg_table *table,
-				     enum dma_data_direction dir)
-{
-}
-
-static void tee_shm_op_release(struct dma_buf *dmabuf)
-{
-	struct tee_shm *shm = dmabuf-&gt;priv;
-
-	tee_shm_release(shm);
-}
-
-static int tee_shm_op_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
-{
-	struct tee_shm *shm = dmabuf-&gt;priv;
-	size_t size = vma-&gt;vm_end - vma-&gt;vm_start;
-
-	/* Refuse sharing shared memory provided by application */
-	if (shm-&gt;flags &#38; TEE_SHM_USER_MAPPED)
-		return -EINVAL;
-
-	return remap_pfn_range(vma, vma-&gt;vm_start, shm-&gt;paddr &gt;&gt; PAGE_SHIFT,
-			       size, vma-&gt;vm_page_prot);
-}
-
-static const struct dma_buf_ops tee_shm_dma_buf_ops = {
-	.map_dma_buf = tee_shm_op_map_dma_buf,
-	.unmap_dma_buf = tee_shm_op_unmap_dma_buf,
-	.release = tee_shm_op_release,
-	.mmap = tee_shm_op_mmap,
-};
-
</span> struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 {
 	struct tee_device *teedev = ctx-&gt;teedev;
<span
class="hunk">@@ -140,6 +90,7 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
</span> 		goto err_dev_put;
 	}
 
<span
class="add">+	refcount_set(&#38;shm-&gt;refcount, 1);
</span> 	shm-&gt;flags = flags | TEE_SHM_POOL;
 	shm-&gt;ctx = ctx;
 	if (flags &#38; TEE_SHM_DMA_BUF)
<span
class="hunk">@@ -153,10 +104,7 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
</span> 		goto err_kfree;
 	}
 
<span
class="del">-
</span> 	if (flags &#38; TEE_SHM_DMA_BUF) {
<span
class="del">-		DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
-
</span> 		mutex_lock(&#38;teedev-&gt;mutex);
 		shm-&gt;id = idr_alloc(&#38;teedev-&gt;idr, shm, 1, 0, GFP_KERNEL);
 		mutex_unlock(&#38;teedev-&gt;mutex);
<span
class="hunk">@@ -164,28 +112,11 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
</span> 			ret = ERR_PTR(shm-&gt;id);
 			goto err_pool_free;
 		}
<span
class="del">-
-		exp_info.ops = &#38;tee_shm_dma_buf_ops;
-		exp_info.size = shm-&gt;size;
-		exp_info.flags = O_RDWR;
-		exp_info.priv = shm;
-
-		shm-&gt;dmabuf = dma_buf_export(&#38;exp_info);
-		if (IS_ERR(shm-&gt;dmabuf)) {
-			ret = ERR_CAST(shm-&gt;dmabuf);
-			goto err_rem;
-		}
</span> 	}
 
 	teedev_ctx_get(ctx);
 
 	return shm;
<span
class="del">-err_rem:
-	if (flags &#38; TEE_SHM_DMA_BUF) {
-		mutex_lock(&#38;teedev-&gt;mutex);
-		idr_remove(&#38;teedev-&gt;idr, shm-&gt;id);
-		mutex_unlock(&#38;teedev-&gt;mutex);
-	}
</span> err_pool_free:
 	poolm-&gt;ops-&gt;free(poolm, shm);
 err_kfree:
<span
class="hunk">@@ -246,6 +177,7 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
</span> 		goto err;
 	}
 
<span
class="add">+	refcount_set(&#38;shm-&gt;refcount, 1);
</span> 	shm-&gt;flags = flags | TEE_SHM_REGISTER;
 	shm-&gt;ctx = ctx;
 	shm-&gt;id = -1;
<span
class="hunk">@@ -306,22 +238,6 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
</span> 		goto err;
 	}
 
<span
class="del">-	if (flags &#38; TEE_SHM_DMA_BUF) {
-		DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
-
-		exp_info.ops = &#38;tee_shm_dma_buf_ops;
-		exp_info.size = shm-&gt;size;
-		exp_info.flags = O_RDWR;
-		exp_info.priv = shm;
-
-		shm-&gt;dmabuf = dma_buf_export(&#38;exp_info);
-		if (IS_ERR(shm-&gt;dmabuf)) {
-			ret = ERR_CAST(shm-&gt;dmabuf);
-			teedev-&gt;desc-&gt;ops-&gt;shm_unregister(ctx, shm);
-			goto err;
-		}
-	}
-
</span> 	return shm;
 err:
 	if (shm) {
<span
class="hunk">@@ -339,6 +255,35 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
</span> }
 EXPORT_SYMBOL_GPL(tee_shm_register);
 
<span
class="add">+static int tee_shm_fop_release(struct inode *inode, struct file *filp)
+{
+	tee_shm_put(filp-&gt;private_data);
+	return 0;
+}
+
+static int tee_shm_fop_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct tee_shm *shm = filp-&gt;private_data;
+	size_t size = vma-&gt;vm_end - vma-&gt;vm_start;
+
+	/* Refuse sharing shared memory provided by application */
+	if (shm-&gt;flags &#38; TEE_SHM_USER_MAPPED)
+		return -EINVAL;
+
+	/* check for overflowing the buffer&#39;s size */
+	if (vma-&gt;vm_pgoff + vma_pages(vma) &gt; shm-&gt;size &gt;&gt; PAGE_SHIFT)
+		return -EINVAL;
+
+	return remap_pfn_range(vma, vma-&gt;vm_start, shm-&gt;paddr &gt;&gt; PAGE_SHIFT,
+			       size, vma-&gt;vm_page_prot);
+}
+
+static const struct file_operations tee_shm_fops = {
+	.owner = THIS_MODULE,
+	.release = tee_shm_fop_release,
+	.mmap = tee_shm_fop_mmap,
+};
+
</span> /**
  * tee_shm_get_fd() - Increase reference count and return file descriptor
  * @shm:	Shared memory handle
<span
class="hunk">@@ -351,10 +296,11 @@ int tee_shm_get_fd(struct tee_shm *shm)
</span> 	if (!(shm-&gt;flags &#38; TEE_SHM_DMA_BUF))
 		return -EINVAL;
 
<span
class="del">-	get_dma_buf(shm-&gt;dmabuf);
-	fd = dma_buf_fd(shm-&gt;dmabuf, O_CLOEXEC);
</span><span
class="add">+	/* matched by tee_shm_put() in tee_shm_op_release() */
+	refcount_inc(&#38;shm-&gt;refcount);
+	fd = anon_inode_getfd(&#34;tee_shm&#34;, &#38;tee_shm_fops, shm, O_RDWR);
</span> 	if (fd &lt; 0)
<span
class="del">-		dma_buf_put(shm-&gt;dmabuf);
</span><span
class="add">+		tee_shm_put(shm);
</span> 	return fd;
 }
 
<span
class="hunk">@@ -364,17 +310,7 @@ int tee_shm_get_fd(struct tee_shm *shm)
</span>  */
 void tee_shm_free(struct tee_shm *shm)
 {
<span
class="del">-	/*
-	 * dma_buf_put() decreases the dmabuf reference counter and will
-	 * call tee_shm_release() when the last reference is gone.
-	 *
-	 * In the case of driver private memory we call tee_shm_release
-	 * directly instead as it doesn&#39;t have a reference counter.
-	 */
-	if (shm-&gt;flags &#38; TEE_SHM_DMA_BUF)
-		dma_buf_put(shm-&gt;dmabuf);
-	else
-		tee_shm_release(shm);
</span><span
class="add">+	tee_shm_put(shm);
</span> }
 EXPORT_SYMBOL_GPL(tee_shm_free);
 
<span
class="hunk">@@ -481,10 +417,15 @@ struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)
</span> 	teedev = ctx-&gt;teedev;
 	mutex_lock(&#38;teedev-&gt;mutex);
 	shm = idr_find(&#38;teedev-&gt;idr, id);
<span
class="add">+	/*
+	 * If the tee_shm was found in the IDR it must have a refcount
+	 * larger than 0 due to the guarantee in tee_shm_put() below. So
+	 * it&#39;s safe to use refcount_inc().
+	 */
</span> 	if (!shm || shm-&gt;ctx != ctx)
 		shm = ERR_PTR(-EINVAL);
<span
class="del">-	else if (shm-&gt;flags &#38; TEE_SHM_DMA_BUF)
-		get_dma_buf(shm-&gt;dmabuf);
</span><span
class="add">+	else
+		refcount_inc(&#38;shm-&gt;refcount);
</span> 	mutex_unlock(&#38;teedev-&gt;mutex);
 	return shm;
 }
<span
class="hunk">@@ -496,7 +437,24 @@ EXPORT_SYMBOL_GPL(tee_shm_get_from_id);
</span>  */
 void tee_shm_put(struct tee_shm *shm)
 {
<span
class="del">-	if (shm-&gt;flags &#38; TEE_SHM_DMA_BUF)
-		dma_buf_put(shm-&gt;dmabuf);
</span><span
class="add">+	struct tee_device *teedev = shm-&gt;ctx-&gt;teedev;
+	bool do_release = false;
+
+	mutex_lock(&#38;teedev-&gt;mutex);
+	if (refcount_dec_and_test(&#38;shm-&gt;refcount)) {
+		/*
+		 * refcount has reached 0, we must now remove it from the
+		 * IDR before releasing the mutex. This will guarantee that
+		 * the refcount_inc() in tee_shm_get_from_id() never starts
+		 * from 0.
+		 */
+		if (shm-&gt;flags &#38; TEE_SHM_DMA_BUF)
+			idr_remove(&#38;teedev-&gt;idr, shm-&gt;id);
+		do_release = true;
+	}
+	mutex_unlock(&#38;teedev-&gt;mutex);
+
+	if (do_release)
+		tee_shm_release(teedev, shm);
</span> }
 EXPORT_SYMBOL_GPL(tee_shm_put);
<span
class="head"><a
href=#iZ31include:linux:tee_drv.h
id=Z31include:linux:tee_drv.h>diff</a> --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index a1f03461369b..cf5999626e28 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
</span><span
class="hunk">@@ -195,7 +195,7 @@ int tee_session_calc_client_uuid(uuid_t *uuid, u32 connection_method,
</span>  * @offset:	offset of buffer in user space
  * @pages:	locked pages from userspace
  * @num_pages:	number of locked pages
<span
class="del">- * @dmabuf:	dmabuf used to for exporting to user space
</span><span
class="add">+ * @refcount:	reference counter
</span>  * @flags:	defined by TEE_SHM_* in tee_drv.h
  * @id:		unique id of a shared memory object on this device, shared
  *		with user space
<span
class="hunk">@@ -214,7 +214,7 @@ struct tee_shm {
</span> 	unsigned int offset;
 	struct page **pages;
 	size_t num_pages;
<span
class="del">-	struct dma_buf *dmabuf;
</span><span
class="add">+	refcount_t refcount;
</span> 	u32 flags;
 	int id;
 	u64 sec_world_id;
-- 
2.31.1

</pre><hr><pre><a
href="../YbnlFf8930RuLkU8@kroah.com/"
rel=next>next</a>             <a
href="#R">reply</a>	other threads:[<a
href="../?t=20211215092555">~2021-12-15  9:25 UTC</a>|<a
href="../">newest</a>]

<b>Thread overview: </b>3+ messages / expand[<a
href="T/#u">flat</a>|<a
href="t/#u">nested</a>]  <a
href="t.mbox.gz">mbox.gz</a>  <a
href="t.atom">Atom feed</a>  <a
href="#b">top</a>
<b>2021-12-15  9:25 <a
id=r
href="#t">Jens Wiklander [this message]</a></b>
2021-12-15 12:52 ` <a
href="../YbnlFf8930RuLkU8@kroah.com/">[PATCH v2] tee: handle lookup of shm with reference count 0</a> Greg KH
2021-12-16 14:56   ` <a
href="../CAHUa44GqvZS1AY-C45K7kvHxryUu-hUEuCnR3z14BKE0iu34Qw@mail.gmail.com/">Jens Wiklander</a>
</pre><form id=related
action=../
><pre>find likely ancestor, descendant, or conflicting patches for <a
href=#t>this message</a>:
<textarea name=q cols=72 rows=4>( dfblob:8a8deb95e91 dfblob:499fccba3d7 dfblob:a1f03461369
dfblob:cf5999626e2 )
 OR (
bs:&#34;[PATCH v2] tee: handle lookup of shm with reference count 0&#34; )</textarea>
<input type=submit value=search
/>	(<a href=../_/text/help/#search>help</a>)</pre></form>
<hr><pre
id=R><b>Reply instructions:</b>

You may reply publicly to <a
href=#t>this message</a> via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: <a
href=raw>mbox</a>

  Avoid top-posting and favor interleaved quoting:
  <a
href="https://en.wikipedia.org/wiki/Posting_style#Interleaved_style">https://en.wikipedia.org/wiki/Posting_style#Interleaved_style</a>

* Reply using the <b>--to</b>, <b>--cc</b>, and <b>--in-reply-to</b>
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20211215092501.1861229-1-jens.wiklander@linaro.org \
    --to=jens.wiklander@linaro.org \
    --cc=Devaraj.Rangasamy@amd.com \
    --cc=Rijo-john.Thomas@amd.com \
    --cc=christian.koenig@amd.com \
    --cc=gregkh@linuxfoundation.org \
    --cc=larper@axis.com \
    --cc=linux-kernel@vger.kernel.org \
    --cc=op-tee@lists.trustedfirmware.org \
    --cc=patrik.lantz@axis.com \
    --cc=stable@vger.kernel.org \
    --cc=sumit.garg@linaro.org \
    /path/to/YOUR_REPLY

  <a
href="https://kernel.org/pub/software/scm/git/docs/git-send-email.html">https://kernel.org/pub/software/scm/git/docs/git-send-email.html</a>

* If your mail client supports setting the <b>In-Reply-To</b> header
  via mailto: links, try the <a
href="mailto:jens.wiklander@linaro.org?In-Reply-To=%3C20211215092501.1861229-1-jens.wiklander@linaro.org%3E&#38;Cc=Devaraj.Rangasamy%40amd.com%2CRijo-john.Thomas%40amd.com%2Cchristian.koenig%40amd.com%2Cgregkh%40linuxfoundation.org%2Clarper%40axis.com%2Clinux-kernel%40vger.kernel.org%2Cop-tee%40lists.trustedfirmware.org%2Cpatrik.lantz%40axis.com%2Cstable%40vger.kernel.org%2Csumit.garg%40linaro.org&#38;Subject=Re%3A%20%5BPATCH%20v2%5D%20tee%3A%20handle%20lookup%20of%20shm%20with%20reference%20count%200">mailto: link</a>
</pre>

  Be sure your reply has a <b>Subject:</b> header at the top and a blank line
  before the message body.
<hr><pre>This is a public inbox, see <a
href="../_/text/mirror/">mirroring instructions</a>
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).</pre></body></html>