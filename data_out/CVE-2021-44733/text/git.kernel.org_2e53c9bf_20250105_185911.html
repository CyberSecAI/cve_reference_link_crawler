

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Wiklander <jens.wiklander@linaro.org> | 2021-12-09 15:59:37 +0100 |
| --- | --- | --- |
| committer | Jens Wiklander <jens.wiklander@linaro.org> | 2021-12-16 09:30:14 +0100 |
| commit | [dfd0743f1d9ea76931510ed150334d571fbab49d](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=dfd0743f1d9ea76931510ed150334d571fbab49d) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)) | |
| tree | [2db1935462851b541f55042896f7b2a52056105f](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | |
| parent | [d58071a8a76d779eedab38033ae4c821c30295a5](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d58071a8a76d779eedab38033ae4c821c30295a5) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d&id2=d58071a8a76d779eedab38033ae4c821c30295a5)) | |
| download | [linux-dfd0743f1d9ea76931510ed150334d571fbab49d.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-dfd0743f1d9ea76931510ed150334d571fbab49d.tar.gz) | |

tee: handle lookup of shm with reference count 0Since the tee subsystem does not keep a strong reference to its idle
shared memory buffers, it races with other threads that try to destroy a
shared memory through a close of its dma-buf fd or by unmapping the
memory.
In tee\_shm\_get\_from\_id() when a lookup in teedev->idr has been
successful, it is possible that the tee\_shm is in the dma-buf teardown
path, but that path is blocked by the teedev mutex. Since we don't have
an API to tell if the tee\_shm is in the dma-buf teardown path or not we
must find another way of detecting this condition.
Fix this by doing the reference counting directly on the tee\_shm using a
new refcount\_t refcount field. dma-buf is replaced by using
anon\_inode\_getfd() instead, this separates the life-cycle of the
underlying file from the tee\_shm. tee\_shm\_put() is updated to hold the
mutex when decreasing the refcount to 0 and then remove the tee\_shm from
teedev->idr before releasing the mutex. This means that the tee\_shm can
never be found unless it has a refcount larger than 0.
Fixes: 967c9cca2cc5 ("tee: generic TEE subsystem")
Cc: stable@vger.kernel.org
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Reviewed-by: Lars Persson <larper@axis.com>
Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
Reported-by: Patrik Lantz <patrik.lantz@axis.com>
Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)

| -rw-r--r-- | [drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/tee/tee_shm.c?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | 174 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/tee_drv.h?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | 4 | |  |  |  | | --- | --- | --- | |

2 files changed, 68 insertions, 110 deletions

| diff --git a/drivers/tee/tee\_shm.c b/drivers/tee/tee\_shm.cindex 8a8deb95e918e9..499fccba3d74bd 100644--- a/[drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/tee_shm.c?id=d58071a8a76d779eedab38033ae4c821c30295a5)+++ b/[drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/tee_shm.c?id=dfd0743f1d9ea76931510ed150334d571fbab49d)@@ -1,20 +1,17 @@ // SPDX-License-Identifier: GPL-2.0-only /\*- \* Copyright (c) 2015-2016, Linaro Limited+ \* Copyright (c) 2015-2017, 2019-2021 Linaro Limited \*/+#include <linux/anon\_inodes.h> #include <linux/device.h>-#include <linux/dma-buf.h>-#include <linux/fdtable.h> #include <linux/idr.h>+#include <linux/mm.h> #include <linux/sched.h> #include <linux/slab.h> #include <linux/tee\_drv.h> #include <linux/uio.h>-#include <linux/module.h> #include "tee\_private.h" -MODULE\_IMPORT\_NS(DMA\_BUF);- static void release\_registered\_pages(struct tee\_shm \*shm) { if (shm->pages) {@@ -31,16 +28,8 @@ static void release\_registered\_pages(struct tee\_shm \*shm) } } -static void tee\_shm\_release(struct tee\_shm \*shm)+static void tee\_shm\_release(struct tee\_device \*teedev, struct tee\_shm \*shm) {- struct tee\_device \*teedev = shm->ctx->teedev;-- if (shm->flags & TEE\_SHM\_DMA\_BUF) {- mutex\_lock(&teedev->mutex);- idr\_remove(&teedev->idr, shm->id);- mutex\_unlock(&teedev->mutex);- }- if (shm->flags & TEE\_SHM\_POOL) { struct tee\_shm\_pool\_mgr \*poolm; @@ -67,45 +56,6 @@ static void tee\_shm\_release(struct tee\_shm \*shm) tee\_device\_put(teedev); } -static struct sg\_table \*tee\_shm\_op\_map\_dma\_buf(struct dma\_buf\_attachment- \*attach, enum dma\_data\_direction dir)-{- return NULL;-}--static void tee\_shm\_op\_unmap\_dma\_buf(struct dma\_buf\_attachment \*attach,- struct sg\_table \*table,- enum dma\_data\_direction dir)-{-}--static void tee\_shm\_op\_release(struct dma\_buf \*dmabuf)-{- struct tee\_shm \*shm = dmabuf->priv;-- tee\_shm\_release(shm);-}--static int tee\_shm\_op\_mmap(struct dma\_buf \*dmabuf, struct vm\_area\_struct \*vma)-{- struct tee\_shm \*shm = dmabuf->priv;- size\_t size = vma->vm\_end - vma->vm\_start;-- /\* Refuse sharing shared memory provided by application \*/- if (shm->flags & TEE\_SHM\_USER\_MAPPED)- return -EINVAL;-- return remap\_pfn\_range(vma, vma->vm\_start, shm->paddr >> PAGE\_SHIFT,- size, vma->vm\_page\_prot);-}--static const struct dma\_buf\_ops tee\_shm\_dma\_buf\_ops = {- .map\_dma\_buf = tee\_shm\_op\_map\_dma\_buf,- .unmap\_dma\_buf = tee\_shm\_op\_unmap\_dma\_buf,- .release = tee\_shm\_op\_release,- .mmap = tee\_shm\_op\_mmap,-};- struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) { struct tee\_device \*teedev = ctx->teedev;@@ -140,6 +90,7 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) goto err\_dev\_put; } + refcount\_set(&shm->refcount, 1); shm->flags = flags | TEE\_SHM\_POOL; shm->ctx = ctx; if (flags & TEE\_SHM\_DMA\_BUF)@@ -153,10 +104,7 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) goto err\_kfree; } - if (flags & TEE\_SHM\_DMA\_BUF) {- DEFINE\_DMA\_BUF\_EXPORT\_INFO(exp\_info);- mutex\_lock(&teedev->mutex); shm->id = idr\_alloc(&teedev->idr, shm, 1, 0, GFP\_KERNEL); mutex\_unlock(&teedev->mutex);@@ -164,28 +112,11 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) ret = ERR\_PTR(shm->id); goto err\_pool\_free; }-- exp\_info.ops = &tee\_shm\_dma\_buf\_ops;- exp\_info.size = shm->size;- exp\_info.flags = O\_RDWR;- exp\_info.priv = shm;-- shm->dmabuf = dma\_buf\_export(&exp\_info);- if (IS\_ERR(shm->dmabuf)) {- ret = ERR\_CAST(shm->dmabuf);- goto err\_rem;- } }  teedev\_ctx\_get(ctx);  return shm;-err\_rem:- if (flags & TEE\_SHM\_DMA\_BUF) {- mutex\_lock(&teedev->mutex);- idr\_remove(&teedev->idr, shm->id);- mutex\_unlock(&teedev->mutex);- } err\_pool\_free: poolm->ops->free(poolm, shm); err\_kfree:@@ -246,6 +177,7 @@ struct tee\_shm \*tee\_shm\_register(struct tee\_context \*ctx, unsigned long addr, goto err; } + refcount\_set(&shm->refcount, 1); shm->flags = flags | TEE\_SHM\_REGISTER; shm->ctx = ctx; shm->id = -1;@@ -306,22 +238,6 @@ struct tee\_shm \*tee\_shm\_register(struct tee\_context \*ctx, unsigned long addr, goto err; } - if (flags & TEE\_SHM\_DMA\_BUF) {- DEFINE\_DMA\_BUF\_EXPORT\_INFO(exp\_info);-- exp\_info.ops = &tee\_shm\_dma\_buf\_ops;- exp\_info.size = shm->size;- exp\_info.flags = O\_RDWR;- exp\_info.priv = shm;-- shm->dmabuf = dma\_buf\_export(&exp\_info);- if (IS\_ERR(shm->dmabuf)) {- ret = ERR\_CAST(shm->dmabuf);- teedev->desc->ops->shm\_unregister(ctx, shm);- goto err;- }- }- return shm; err: if (shm) {@@ -339,6 +255,35 @@ err: } EXPORT\_SYMBOL\_GPL(tee\_shm\_register); +static int tee\_shm\_fop\_release(struct inode \*inode, struct file \*filp)+{+ tee\_shm\_put(filp->private\_data);+ return 0;+}++static int tee\_shm\_fop\_mmap(struct file \*filp, struct vm\_area\_struct \*vma)+{+ struct tee\_shm \*shm = filp->private\_data;+ size\_t size = vma->vm\_end - vma->vm\_start;++ /\* Refuse sharing shared memory provided by application \*/+ if (shm->flags & TEE\_SHM\_USER\_MAPPED)+ return -EINVAL;++ /\* check for overflowing the buffer's size \*/+ if (vma->vm\_pgoff + vma\_pages(vma) > shm->size >> PAGE\_SHIFT)+ return -EINVAL;++ return remap\_pfn\_range(vma, vma->vm\_start, shm->paddr >> PAGE\_SHIFT,+ size, vma->vm\_page\_prot);+}++static const struct file\_operations tee\_shm\_fops = {+ .owner = THIS\_MODULE,+ .release = tee\_shm\_fop\_release,+ .mmap = tee\_shm\_fop\_mmap,+};+ /\*\* \* tee\_shm\_get\_fd() - Increase reference count and return file descriptor \* @shm: Shared memory handle@@ -351,10 +296,11 @@ int tee\_shm\_get\_fd(struct tee\_shm \*shm) if (!(shm->flags & TEE\_SHM\_DMA\_BUF)) return -EINVAL; - get\_dma\_buf(shm->dmabuf);- fd = dma\_buf\_fd(shm->dmabuf, O\_CLOEXEC);+ /\* matched by tee\_shm\_put() in tee\_shm\_op\_release() \*/+ refcount\_inc(&shm->refcount);+ fd = anon\_inode\_getfd("tee\_shm", &tee\_shm\_fops, shm, O\_RDWR); if (fd < 0)- dma\_buf\_put(shm->dmabuf);+ tee\_shm\_put(shm); return fd; } @@ -364,17 +310,7 @@ int tee\_shm\_get\_fd(struct tee\_shm \*shm) \*/ void tee\_shm\_free(struct tee\_shm \*shm) {- /\*- \* dma\_buf\_put() decreases the dmabuf reference counter and will- \* call tee\_shm\_release() when the last reference is gone.- \*- \* In the case of driver private memory we call tee\_shm\_release- \* directly instead as it doesn't have a reference counter.- \*/- if (shm->flags & TEE\_SHM\_DMA\_BUF)- dma\_buf\_put(shm->dmabuf);- else- tee\_shm\_release(shm);+ tee\_shm\_put(shm); } EXPORT\_SYMBOL\_GPL(tee\_shm\_free); @@ -481,10 +417,15 @@ struct tee\_shm \*tee\_shm\_get\_from\_id(struct tee\_context \*ctx, int id) teedev = ctx->teedev; mutex\_lock(&teedev->mutex); shm = idr\_find(&teedev->idr, id);+ /\*+ \* If the tee\_shm was found in the IDR it must have a refcount+ \* larger than 0 due to the guarantee in tee\_shm\_put() below. So+ \* it's safe to use refcount\_inc().+ \*/ if (!shm || shm->ctx != ctx) shm = ERR\_PTR(-EINVAL);- else if (shm->flags & TEE\_SHM\_DMA\_BUF)- get\_dma\_buf(shm->dmabuf);+ else+ refcount\_inc(&shm->refcount); mutex\_unlock(&teedev->mutex); return shm; }@@ -496,7 +437,24 @@ EXPORT\_SYMBOL\_GPL(tee\_shm\_get\_from\_id); \*/ void tee\_shm\_put(struct tee\_shm \*shm) {- if (shm->flags & TEE\_SHM\_DMA\_BUF)- dma\_buf\_put(shm->dmabuf);+ struct tee\_device \*teedev = shm->ctx->teedev;+ bool do\_release = false;++ mutex\_lock(&teedev->mutex);+ if (refcount\_dec\_and\_test(&shm->refcount)) {+ /\*+ \* refcount has reached 0, we must now remove it from the+ \* IDR before releasing the mutex. This will guarantee that+ \* the refcount\_inc() in tee\_shm\_get\_from\_id() never starts+ \* from 0.+ \*/+ if (shm->flags & TEE\_SHM\_DMA\_BUF)+ idr\_remove(&teedev->idr, shm->id);+ do\_release = true;+ }+ mutex\_unlock(&teedev->mutex);++ if (do\_release)+ tee\_shm\_release(teedev, shm); } EXPORT\_SYMBOL\_GPL(tee\_shm\_put);diff --git a/include/linux/tee\_drv.h b/include/linux/tee\_drv.hindex a1f03461369bd9..cf5999626e28d9 100644--- a/[include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/tee_drv.h?id=d58071a8a76d779eedab38033ae4c821c30295a5)+++ b/[include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/tee_drv.h?id=dfd0743f1d9ea76931510ed150334d571fbab49d)@@ -195,7 +195,7 @@ int tee\_session\_calc\_client\_uuid(uuid\_t \*uuid, u32 connection\_method, \* @offset: offset of buffer in user space \* @pages: locked pages from userspace \* @num\_pages: number of locked pages- \* @dmabuf: dmabuf used to for exporting to user space+ \* @refcount: reference counter \* @flags: defined by TEE\_SHM\_\* in tee\_drv.h \* @id: unique id of a shared memory object on this device, shared \* with user space@@ -214,7 +214,7 @@ struct tee\_shm { unsigned int offset; struct page \*\*pages; size\_t num\_pages;- struct dma\_buf \*dmabuf;+ refcount\_t refcount; u32 flags; int id; u64 sec\_world\_id; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-05 18:52:23 +0000

