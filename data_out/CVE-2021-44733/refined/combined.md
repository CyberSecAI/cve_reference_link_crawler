=== Content from git.kernel.org_2e53c9bf_20250108_132553.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jens Wiklander <jens.wiklander@linaro.org> | 2021-12-09 15:59:37 +0100 |
| --- | --- | --- |
| committer | Jens Wiklander <jens.wiklander@linaro.org> | 2021-12-16 09:30:14 +0100 |
| commit | [dfd0743f1d9ea76931510ed150334d571fbab49d](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=dfd0743f1d9ea76931510ed150334d571fbab49d) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)) | |
| tree | [2db1935462851b541f55042896f7b2a52056105f](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | |
| parent | [d58071a8a76d779eedab38033ae4c821c30295a5](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d58071a8a76d779eedab38033ae4c821c30295a5) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d&id2=d58071a8a76d779eedab38033ae4c821c30295a5)) | |
| download | [linux-dfd0743f1d9ea76931510ed150334d571fbab49d.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-dfd0743f1d9ea76931510ed150334d571fbab49d.tar.gz) | |

tee: handle lookup of shm with reference count 0Since the tee subsystem does not keep a strong reference to its idle
shared memory buffers, it races with other threads that try to destroy a
shared memory through a close of its dma-buf fd or by unmapping the
memory.
In tee\_shm\_get\_from\_id() when a lookup in teedev->idr has been
successful, it is possible that the tee\_shm is in the dma-buf teardown
path, but that path is blocked by the teedev mutex. Since we don't have
an API to tell if the tee\_shm is in the dma-buf teardown path or not we
must find another way of detecting this condition.
Fix this by doing the reference counting directly on the tee\_shm using a
new refcount\_t refcount field. dma-buf is replaced by using
anon\_inode\_getfd() instead, this separates the life-cycle of the
underlying file from the tee\_shm. tee\_shm\_put() is updated to hold the
mutex when decreasing the refcount to 0 and then remove the tee\_shm from
teedev->idr before releasing the mutex. This means that the tee\_shm can
never be found unless it has a refcount larger than 0.
Fixes: 967c9cca2cc5 ("tee: generic TEE subsystem")
Cc: stable@vger.kernel.org
Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Reviewed-by: Lars Persson <larper@axis.com>
Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
Reported-by: Patrik Lantz <patrik.lantz@axis.com>
Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=dfd0743f1d9ea76931510ed150334d571fbab49d)

| -rw-r--r-- | [drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/tee/tee_shm.c?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | 174 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/tee_drv.h?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | 4 | |  |  |  | | --- | --- | --- | |

2 files changed, 68 insertions, 110 deletions

| diff --git a/drivers/tee/tee\_shm.c b/drivers/tee/tee\_shm.cindex 8a8deb95e918e9..499fccba3d74bd 100644--- a/[drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/tee_shm.c?id=d58071a8a76d779eedab38033ae4c821c30295a5)+++ b/[drivers/tee/tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/tee_shm.c?id=dfd0743f1d9ea76931510ed150334d571fbab49d)@@ -1,20 +1,17 @@ // SPDX-License-Identifier: GPL-2.0-only /\*- \* Copyright (c) 2015-2016, Linaro Limited+ \* Copyright (c) 2015-2017, 2019-2021 Linaro Limited \*/+#include <linux/anon\_inodes.h> #include <linux/device.h>-#include <linux/dma-buf.h>-#include <linux/fdtable.h> #include <linux/idr.h>+#include <linux/mm.h> #include <linux/sched.h> #include <linux/slab.h> #include <linux/tee\_drv.h> #include <linux/uio.h>-#include <linux/module.h> #include "tee\_private.h" -MODULE\_IMPORT\_NS(DMA\_BUF);- static void release\_registered\_pages(struct tee\_shm \*shm) { if (shm->pages) {@@ -31,16 +28,8 @@ static void release\_registered\_pages(struct tee\_shm \*shm) } } -static void tee\_shm\_release(struct tee\_shm \*shm)+static void tee\_shm\_release(struct tee\_device \*teedev, struct tee\_shm \*shm) {- struct tee\_device \*teedev = shm->ctx->teedev;-- if (shm->flags & TEE\_SHM\_DMA\_BUF) {- mutex\_lock(&teedev->mutex);- idr\_remove(&teedev->idr, shm->id);- mutex\_unlock(&teedev->mutex);- }- if (shm->flags & TEE\_SHM\_POOL) { struct tee\_shm\_pool\_mgr \*poolm; @@ -67,45 +56,6 @@ static void tee\_shm\_release(struct tee\_shm \*shm) tee\_device\_put(teedev); } -static struct sg\_table \*tee\_shm\_op\_map\_dma\_buf(struct dma\_buf\_attachment- \*attach, enum dma\_data\_direction dir)-{- return NULL;-}--static void tee\_shm\_op\_unmap\_dma\_buf(struct dma\_buf\_attachment \*attach,- struct sg\_table \*table,- enum dma\_data\_direction dir)-{-}--static void tee\_shm\_op\_release(struct dma\_buf \*dmabuf)-{- struct tee\_shm \*shm = dmabuf->priv;-- tee\_shm\_release(shm);-}--static int tee\_shm\_op\_mmap(struct dma\_buf \*dmabuf, struct vm\_area\_struct \*vma)-{- struct tee\_shm \*shm = dmabuf->priv;- size\_t size = vma->vm\_end - vma->vm\_start;-- /\* Refuse sharing shared memory provided by application \*/- if (shm->flags & TEE\_SHM\_USER\_MAPPED)- return -EINVAL;-- return remap\_pfn\_range(vma, vma->vm\_start, shm->paddr >> PAGE\_SHIFT,- size, vma->vm\_page\_prot);-}--static const struct dma\_buf\_ops tee\_shm\_dma\_buf\_ops = {- .map\_dma\_buf = tee\_shm\_op\_map\_dma\_buf,- .unmap\_dma\_buf = tee\_shm\_op\_unmap\_dma\_buf,- .release = tee\_shm\_op\_release,- .mmap = tee\_shm\_op\_mmap,-};- struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) { struct tee\_device \*teedev = ctx->teedev;@@ -140,6 +90,7 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) goto err\_dev\_put; } + refcount\_set(&shm->refcount, 1); shm->flags = flags | TEE\_SHM\_POOL; shm->ctx = ctx; if (flags & TEE\_SHM\_DMA\_BUF)@@ -153,10 +104,7 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) goto err\_kfree; } - if (flags & TEE\_SHM\_DMA\_BUF) {- DEFINE\_DMA\_BUF\_EXPORT\_INFO(exp\_info);- mutex\_lock(&teedev->mutex); shm->id = idr\_alloc(&teedev->idr, shm, 1, 0, GFP\_KERNEL); mutex\_unlock(&teedev->mutex);@@ -164,28 +112,11 @@ struct tee\_shm \*tee\_shm\_alloc(struct tee\_context \*ctx, size\_t size, u32 flags) ret = ERR\_PTR(shm->id); goto err\_pool\_free; }-- exp\_info.ops = &tee\_shm\_dma\_buf\_ops;- exp\_info.size = shm->size;- exp\_info.flags = O\_RDWR;- exp\_info.priv = shm;-- shm->dmabuf = dma\_buf\_export(&exp\_info);- if (IS\_ERR(shm->dmabuf)) {- ret = ERR\_CAST(shm->dmabuf);- goto err\_rem;- } }  teedev\_ctx\_get(ctx);  return shm;-err\_rem:- if (flags & TEE\_SHM\_DMA\_BUF) {- mutex\_lock(&teedev->mutex);- idr\_remove(&teedev->idr, shm->id);- mutex\_unlock(&teedev->mutex);- } err\_pool\_free: poolm->ops->free(poolm, shm); err\_kfree:@@ -246,6 +177,7 @@ struct tee\_shm \*tee\_shm\_register(struct tee\_context \*ctx, unsigned long addr, goto err; } + refcount\_set(&shm->refcount, 1); shm->flags = flags | TEE\_SHM\_REGISTER; shm->ctx = ctx; shm->id = -1;@@ -306,22 +238,6 @@ struct tee\_shm \*tee\_shm\_register(struct tee\_context \*ctx, unsigned long addr, goto err; } - if (flags & TEE\_SHM\_DMA\_BUF) {- DEFINE\_DMA\_BUF\_EXPORT\_INFO(exp\_info);-- exp\_info.ops = &tee\_shm\_dma\_buf\_ops;- exp\_info.size = shm->size;- exp\_info.flags = O\_RDWR;- exp\_info.priv = shm;-- shm->dmabuf = dma\_buf\_export(&exp\_info);- if (IS\_ERR(shm->dmabuf)) {- ret = ERR\_CAST(shm->dmabuf);- teedev->desc->ops->shm\_unregister(ctx, shm);- goto err;- }- }- return shm; err: if (shm) {@@ -339,6 +255,35 @@ err: } EXPORT\_SYMBOL\_GPL(tee\_shm\_register); +static int tee\_shm\_fop\_release(struct inode \*inode, struct file \*filp)+{+ tee\_shm\_put(filp->private\_data);+ return 0;+}++static int tee\_shm\_fop\_mmap(struct file \*filp, struct vm\_area\_struct \*vma)+{+ struct tee\_shm \*shm = filp->private\_data;+ size\_t size = vma->vm\_end - vma->vm\_start;++ /\* Refuse sharing shared memory provided by application \*/+ if (shm->flags & TEE\_SHM\_USER\_MAPPED)+ return -EINVAL;++ /\* check for overflowing the buffer's size \*/+ if (vma->vm\_pgoff + vma\_pages(vma) > shm->size >> PAGE\_SHIFT)+ return -EINVAL;++ return remap\_pfn\_range(vma, vma->vm\_start, shm->paddr >> PAGE\_SHIFT,+ size, vma->vm\_page\_prot);+}++static const struct file\_operations tee\_shm\_fops = {+ .owner = THIS\_MODULE,+ .release = tee\_shm\_fop\_release,+ .mmap = tee\_shm\_fop\_mmap,+};+ /\*\* \* tee\_shm\_get\_fd() - Increase reference count and return file descriptor \* @shm: Shared memory handle@@ -351,10 +296,11 @@ int tee\_shm\_get\_fd(struct tee\_shm \*shm) if (!(shm->flags & TEE\_SHM\_DMA\_BUF)) return -EINVAL; - get\_dma\_buf(shm->dmabuf);- fd = dma\_buf\_fd(shm->dmabuf, O\_CLOEXEC);+ /\* matched by tee\_shm\_put() in tee\_shm\_op\_release() \*/+ refcount\_inc(&shm->refcount);+ fd = anon\_inode\_getfd("tee\_shm", &tee\_shm\_fops, shm, O\_RDWR); if (fd < 0)- dma\_buf\_put(shm->dmabuf);+ tee\_shm\_put(shm); return fd; } @@ -364,17 +310,7 @@ int tee\_shm\_get\_fd(struct tee\_shm \*shm) \*/ void tee\_shm\_free(struct tee\_shm \*shm) {- /\*- \* dma\_buf\_put() decreases the dmabuf reference counter and will- \* call tee\_shm\_release() when the last reference is gone.- \*- \* In the case of driver private memory we call tee\_shm\_release- \* directly instead as it doesn't have a reference counter.- \*/- if (shm->flags & TEE\_SHM\_DMA\_BUF)- dma\_buf\_put(shm->dmabuf);- else- tee\_shm\_release(shm);+ tee\_shm\_put(shm); } EXPORT\_SYMBOL\_GPL(tee\_shm\_free); @@ -481,10 +417,15 @@ struct tee\_shm \*tee\_shm\_get\_from\_id(struct tee\_context \*ctx, int id) teedev = ctx->teedev; mutex\_lock(&teedev->mutex); shm = idr\_find(&teedev->idr, id);+ /\*+ \* If the tee\_shm was found in the IDR it must have a refcount+ \* larger than 0 due to the guarantee in tee\_shm\_put() below. So+ \* it's safe to use refcount\_inc().+ \*/ if (!shm || shm->ctx != ctx) shm = ERR\_PTR(-EINVAL);- else if (shm->flags & TEE\_SHM\_DMA\_BUF)- get\_dma\_buf(shm->dmabuf);+ else+ refcount\_inc(&shm->refcount); mutex\_unlock(&teedev->mutex); return shm; }@@ -496,7 +437,24 @@ EXPORT\_SYMBOL\_GPL(tee\_shm\_get\_from\_id); \*/ void tee\_shm\_put(struct tee\_shm \*shm) {- if (shm->flags & TEE\_SHM\_DMA\_BUF)- dma\_buf\_put(shm->dmabuf);+ struct tee\_device \*teedev = shm->ctx->teedev;+ bool do\_release = false;++ mutex\_lock(&teedev->mutex);+ if (refcount\_dec\_and\_test(&shm->refcount)) {+ /\*+ \* refcount has reached 0, we must now remove it from the+ \* IDR before releasing the mutex. This will guarantee that+ \* the refcount\_inc() in tee\_shm\_get\_from\_id() never starts+ \* from 0.+ \*/+ if (shm->flags & TEE\_SHM\_DMA\_BUF)+ idr\_remove(&teedev->idr, shm->id);+ do\_release = true;+ }+ mutex\_unlock(&teedev->mutex);++ if (do\_release)+ tee\_shm\_release(teedev, shm); } EXPORT\_SYMBOL\_GPL(tee\_shm\_put);diff --git a/include/linux/tee\_drv.h b/include/linux/tee\_drv.hindex a1f03461369bd9..cf5999626e28d9 100644--- a/[include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/tee_drv.h?id=d58071a8a76d779eedab38033ae4c821c30295a5)+++ b/[include/linux/tee\_drv.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/tee_drv.h?id=dfd0743f1d9ea76931510ed150334d571fbab49d)@@ -195,7 +195,7 @@ int tee\_session\_calc\_client\_uuid(uuid\_t \*uuid, u32 connection\_method, \* @offset: offset of buffer in user space \* @pages: locked pages from userspace \* @num\_pages: number of locked pages- \* @dmabuf: dmabuf used to for exporting to user space+ \* @refcount: reference counter \* @flags: defined by TEE\_SHM\_\* in tee\_drv.h \* @id: unique id of a shared memory object on this device, shared \* with user space@@ -214,7 +214,7 @@ struct tee\_shm { unsigned int offset; struct page \*\*pages; size\_t num\_pages;- struct dma\_buf \*dmabuf;+ refcount\_t refcount; u32 flags; int id; u64 sec\_world\_id; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 13:24:30 +0000



=== Content from lore.kernel.org_a05b7a7f_20250108_132555.html ===

```
[linux-kernel.vger.kernel.org archive mirror](../?t=20211215092555)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Jens Wiklander <jens.wiklander@linaro.org>
To: [linux-kernel@vger.kernel.org](../../lkml/?t=20211215092555), op-tee@lists.trustedfirmware.org
Cc: "Sumit Garg" <sumit.garg@linaro.org>,
	"Christian König" <christian.koenig@amd.com>,
	"Rijo Thomas" <Rijo-john.Thomas@amd.com>,
	"Devaraj Rangasamy" <Devaraj.Rangasamy@amd.com>,
	"Greg KH" <gregkh@linuxfoundation.org>,
	"Jens Wiklander" <jens.wiklander@linaro.org>,
	[stable@vger.kernel.org](../../stable/?t=20211215092555), "Lars Persson" <larper@axis.com>,
	"Patrik Lantz" <patrik.lantz@axis.com>
Subject: [[PATCH v2] tee: handle lookup of shm with reference count 0](#r)
Date: Wed, 15 Dec 2021 10:25:01 +0100	[[thread overview]](#r)
Message-ID: <20211215092501.1861229-1-jens.wiklander@linaro.org> (<raw>)

Since the tee subsystem does not keep a strong reference to its idle
shared memory buffers, it races with other threads that try to destroy a
shared memory through a close of its dma-buf fd or by unmapping the
memory.

In tee_shm_get_from_id() when a lookup in teedev->idr has been
successful, it is possible that the tee_shm is in the dma-buf teardown
path, but that path is blocked by the teedev mutex. Since we don't have
an API to tell if the tee_shm is in the dma-buf teardown path or not we
must find another way of detecting this condition.

Fix this by doing the reference counting directly on the tee_shm using a
new refcount_t refcount field. dma-buf is replaced by using
anon_inode_getfd() instead, this separates the life-cycle of the
underlying file from the tee_shm. tee_shm_put() is updated to hold the
mutex when decreasing the refcount to 0 and then remove the tee_shm from
teedev->idr before releasing the mutex. This means that the tee_shm can
never be found unless it has a refcount larger than 0.

Fixes: 967c9cca2cc5 ("tee: generic TEE subsystem")
Cc: stable@vger.kernel.org
Reviewed-by: Lars Persson <larper@axis.com>
Reviewed-by: Sumit Garg <sumit.garg@linaro.org>
Reported-by: Patrik Lantz <patrik.lantz@axis.com>
Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
---
v1->v2
* fix copyright years in drivers/tee/tee_shm.c
* update kerneldoc comment for struct tee_shm with the reference counter

 [drivers/tee/tee_shm.c](#Z31drivers:tee:tee_shm.c)   | 174 +++++++++++++++-------------------------
 [include/linux/tee_drv.h](#Z31include:linux:tee_drv.h) |   4 +-
 2 files [changed](#related), 68 insertions(+), 110 deletions(-)

[diff](#iZ31drivers:tee:tee_shm.c) --git a/drivers/tee/tee_shm.c b/drivers/tee/tee_shm.c
index 8a8deb95e918..499fccba3d74 100644
--- a/drivers/tee/tee_shm.c
+++ b/drivers/tee/tee_shm.c
@@ -1,20 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2015-2016, Linaro Limited
+ * Copyright (c) 2015-2017, 2019-2021 Linaro Limited
  */
+#include <linux/anon_inodes.h>
 #include <linux/device.h>
-#include <linux/dma-buf.h>
-#include <linux/fdtable.h>
 #include <linux/idr.h>
+#include <linux/mm.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/tee_drv.h>
 #include <linux/uio.h>
-#include <linux/module.h>
 #include "tee_private.h"

-MODULE_IMPORT_NS(DMA_BUF);
-
 static void release_registered_pages(struct tee_shm *shm)
 {
 	if (shm->pages) {
@@ -31,16 +28,8 @@ static void release_registered_pages(struct tee_shm *shm)
 	}
 }

-static void tee_shm_release(struct tee_shm *shm)
+static void tee_shm_release(struct tee_device *teedev, struct tee_shm *shm)
 {
-	struct tee_device *teedev = shm->ctx->teedev;
-
-	if (shm->flags & TEE_SHM_DMA_BUF) {
-		mutex_lock(&teedev->mutex);
-		idr_remove(&teedev->idr, shm->id);
-		mutex_unlock(&teedev->mutex);
-	}
-
 	if (shm->flags & TEE_SHM_POOL) {
 		struct tee_shm_pool_mgr *poolm;

@@ -67,45 +56,6 @@ static void tee_shm_release(struct tee_shm *shm)
 	tee_device_put(teedev);
 }

-static struct sg_table *tee_shm_op_map_dma_buf(struct dma_buf_attachment
-			*attach, enum dma_data_direction dir)
-{
-	return NULL;
-}
-
-static void tee_shm_op_unmap_dma_buf(struct dma_buf_attachment *attach,
-				     struct sg_table *table,
-				     enum dma_data_direction dir)
-{
-}
-
-static void tee_shm_op_release(struct dma_buf *dmabuf)
-{
-	struct tee_shm *shm = dmabuf->priv;
-
-	tee_shm_release(shm);
-}
-
-static int tee_shm_op_mmap(struct dma_buf *dmabuf, struct vm_area_struct *vma)
-{
-	struct tee_shm *shm = dmabuf->priv;
-	size_t size = vma->vm_end - vma->vm_start;
-
-	/* Refuse sharing shared memory provided by application */
-	if (shm->flags & TEE_SHM_USER_MAPPED)
-		return -EINVAL;
-
-	return remap_pfn_range(vma, vma->vm_start, shm->paddr >> PAGE_SHIFT,
-			       size, vma->vm_page_prot);
-}
-
-static const struct dma_buf_ops tee_shm_dma_buf_ops = {
-	.map_dma_buf = tee_shm_op_map_dma_buf,
-	.unmap_dma_buf = tee_shm_op_unmap_dma_buf,
-	.release = tee_shm_op_release,
-	.mmap = tee_shm_op_mmap,
-};
-
 struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 {
 	struct tee_device *teedev = ctx->teedev;
@@ -140,6 +90,7 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 		goto err_dev_put;
 	}

+	refcount_set(&shm->refcount, 1);
 	shm->flags = flags | TEE_SHM_POOL;
 	shm->ctx = ctx;
 	if (flags & TEE_SHM_DMA_BUF)
@@ -153,10 +104,7 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 		goto err_kfree;
 	}

-
 	if (flags & TEE_SHM_DMA_BUF) {
-		DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
-
 		mutex_lock(&teedev->mutex);
 		shm->id = idr_alloc(&teedev->idr, shm, 1, 0, GFP_KERNEL);
 		mutex_unlock(&teedev->mutex);
@@ -164,28 +112,11 @@ struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 			ret = ERR_PTR(shm->id);
 			goto err_pool_free;
 		}
-
-		exp_info.ops = &tee_shm_dma_buf_ops;
-		exp_info.size = shm->size;
-		exp_info.flags = O_RDWR;
-		exp_info.priv = shm;
-
-		shm->dmabuf = dma_buf_export(&exp_info);
-		if (IS_ERR(shm->dmabuf)) {
-			ret = ERR_CAST(shm->dmabuf);
-			goto err_rem;
-		}
 	}

 	teedev_ctx_get(ctx);

 	return shm;
-err_rem:
-	if (flags & TEE_SHM_DMA_BUF) {
-		mutex_lock(&teedev->mutex);
-		idr_remove(&teedev->idr, shm->id);
-		mutex_unlock(&teedev->mutex);
-	}
 err_pool_free:
 	poolm->ops->free(poolm, shm);
 err_kfree:
@@ -246,6 +177,7 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
 		goto err;
 	}

+	refcount_set(&shm->refcount, 1);
 	shm->flags = flags | TEE_SHM_REGISTER;
 	shm->ctx = ctx;
 	shm->id = -1;
@@ -306,22 +238,6 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
 		goto err;
 	}

-	if (flags & TEE_SHM_DMA_BUF) {
-		DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
-
-		exp_info.ops = &tee_shm_dma_buf_ops;
-		exp_info.size = shm->size;
-		exp_info.flags = O_RDWR;
-		exp_info.priv = shm;
-
-		shm->dmabuf = dma_buf_export(&exp_info);
-		if (IS_ERR(shm->dmabuf)) {
-			ret = ERR_CAST(shm->dmabuf);
-			teedev->desc->ops->shm_unregister(ctx, shm);
-			goto err;
-		}
-	}
-
 	return shm;
 err:
 	if (shm) {
@@ -339,6 +255,35 @@ struct tee_shm *tee_shm_register(struct tee_context *ctx, unsigned long addr,
 }
 EXPORT_SYMBOL_GPL(tee_shm_register);

+static int tee_shm_fop_release(struct inode *inode, struct file *filp)
+{
+	tee_shm_put(filp->private_data);
+	return 0;
+}
+
+static int tee_shm_fop_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct tee_shm *shm = filp->private_data;
+	size_t size = vma->vm_end - vma->vm_start;
+
+	/* Refuse sharing shared memory provided by application */
+	if (shm->flags & TEE_SHM_USER_MAPPED)
+		return -EINVAL;
+
+	/* check for overflowing the buffer's size */
+	if (vma->vm_pgoff + vma_pages(vma) > shm->size >> PAGE_SHIFT)
+		return -EINVAL;
+
+	return remap_pfn_range(vma, vma->vm_start, shm->paddr >> PAGE_SHIFT,
+			       size, vma->vm_page_prot);
+}
+
+static const struct file_operations tee_shm_fops = {
+	.owner = THIS_MODULE,
+	.release = tee_shm_fop_release,
+	.mmap = tee_shm_fop_mmap,
+};
+
 /**
  * tee_shm_get_fd() - Increase reference count and return file descriptor
  * @shm:	Shared memory handle
@@ -351,10 +296,11 @@ int tee_shm_get_fd(struct tee_shm *shm)
 	if (!(shm->flags & TEE_SHM_DMA_BUF))
 		return -EINVAL;

-	get_dma_buf(shm->dmabuf);
-	fd = dma_buf_fd(shm->dmabuf, O_CLOEXEC);
+	/* matched by tee_shm_put() in tee_shm_op_release() */
+	refcount_inc(&shm->refcount);
+	fd = anon_inode_getfd("tee_shm", &tee_shm_fops, shm, O_RDWR);
 	if (fd < 0)
-		dma_buf_put(shm->dmabuf);
+		tee_shm_put(shm);
 	return fd;
 }

@@ -364,17 +310,7 @@ int tee_shm_get_fd(struct tee_shm *shm)
  */
 void tee_shm_free(struct tee_shm *shm)
 {
-	/*
-	 * dma_buf_put() decreases the dmabuf reference counter and will
-	 * call tee_shm_release() when the last reference is gone.
-	 *
-	 * In the case of driver private memory we call tee_shm_release
-	 * directly instead as it doesn't have a reference counter.
-	 */
-	if (shm->flags & TEE_SHM_DMA_BUF)
-		dma_buf_put(shm->dmabuf);
-	else
-		tee_shm_release(shm);
+	tee_shm_put(shm);
 }
 EXPORT_SYMBOL_GPL(tee_shm_free);

@@ -481,10 +417,15 @@ struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)
 	teedev = ctx->teedev;
 	mutex_lock(&teedev->mutex);
 	shm = idr_find(&teedev->idr, id);
+	/*
+	 * If the tee_shm was found in the IDR it must have a refcount
+	 * larger than 0 due to the guarantee in tee_shm_put() below. So
+	 * it's safe to use refcount_inc().
+	 */
 	if (!shm || shm->ctx != ctx)
 		shm = ERR_PTR(-EINVAL);
-	else if (shm->flags & TEE_SHM_DMA_BUF)
-		get_dma_buf(shm->dmabuf);
+	else
+		refcount_inc(&shm->refcount);
 	mutex_unlock(&teedev->mutex);
 	return shm;
 }
@@ -496,7 +437,24 @@ EXPORT_SYMBOL_GPL(tee_shm_get_from_id);
  */
 void tee_shm_put(struct tee_shm *shm)
 {
-	if (shm->flags & TEE_SHM_DMA_BUF)
-		dma_buf_put(shm->dmabuf);
+	struct tee_device *teedev = shm->ctx->teedev;
+	bool do_release = false;
+
+	mutex_lock(&teedev->mutex);
+	if (refcount_dec_and_test(&shm->refcount)) {
+		/*
+		 * refcount has reached 0, we must now remove it from the
+		 * IDR before releasing the mutex. This will guarantee that
+		 * the refcount_inc() in tee_shm_get_from_id() never starts
+		 * from 0.
+		 */
+		if (shm->flags & TEE_SHM_DMA_BUF)
+			idr_remove(&teedev->idr, shm->id);
+		do_release = true;
+	}
+	mutex_unlock(&teedev->mutex);
+
+	if (do_release)
+		tee_shm_release(teedev, shm);
 }
 EXPORT_SYMBOL_GPL(tee_shm_put);
[diff](#iZ31include:linux:tee_drv.h) --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index a1f03461369b..cf5999626e28 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -195,7 +195,7 @@ int tee_session_calc_client_uuid(uuid_t *uuid, u32 connection_method,
  * @offset:	offset of buffer in user space
  * @pages:	locked pages from userspace
  * @num_pages:	number of locked pages
- * @dmabuf:	dmabuf used to for exporting to user space
+ * @refcount:	reference counter
  * @flags:	defined by TEE_SHM_* in tee_drv.h
  * @id:		unique id of a shared memory object on this device, shared
  *		with user space
@@ -214,7 +214,7 @@ struct tee_shm {
 	unsigned int offset;
 	struct page **pages;
 	size_t num_pages;
-	struct dma_buf *dmabuf;
+	refcount_t refcount;
 	u32 flags;
 	int id;
 	u64 sec_world_id;
--
2.31.1

```

---

```
[next](../YbnlFf8930RuLkU8%40kroah.com/)             [reply](#R)	other threads:[[~2021-12-15  9:25 UTC](../?t=20211215092555)|[newest](../)]

Thread overview: 3+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2021-12-15  9:25 [Jens Wiklander [this message]](#t)
2021-12-15 12:52 ` [[PATCH v2] tee: handle lookup of shm with reference count 0](../YbnlFf8930RuLkU8%40kroah.com/) Greg KH
2021-12-16 14:56   ` [Jens Wiklander](../CAHUa44GqvZS1AY-C45K7kvHxryUu-hUEuCnR3z14BKE0iu34Qw%40mail.gmail.com/)

```
```
find likely ancestor, descendant, or conflicting patches for [this message](#t):
( dfblob:8a8deb95e91 dfblob:499fccba3d7 dfblob:a1f03461369
dfblob:cf5999626e2 )
 OR (
bs:"[PATCH v2] tee: handle lookup of shm with reference count 0" )
	([help](../_/text/help/#search))
```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20211215092501.1861229-1-jens.wiklander@linaro.org \
    --to=jens.wiklander@linaro.org \
    --cc=Devaraj.Rangasamy@amd.com \
    --cc=Rijo-john.Thomas@amd.com \
    --cc=christian.koenig@amd.com \
    --cc=gregkh@linuxfoundation.org \
    --cc=larper@axis.com \
    --cc=linux-kernel@vger.kernel.org \
    --cc=op-tee@lists.trustedfirmware.org \
    --cc=patrik.lantz@axis.com \
    --cc=stable@vger.kernel.org \
    --cc=sumit.garg@linaro.org \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from github.com_9e9480e0_20250108_132555.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpjlantz%2Foptee-qemu%2Fblob%2Fmain%2FREADME.md)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpjlantz%2Foptee-qemu%2Fblob%2Fmain%2FREADME.md)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=pjlantz%2Foptee-qemu)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[pjlantz](/pjlantz)
/
**[optee-qemu](/pjlantz/optee-qemu)**
Public

* [Notifications](/login?return_to=%2Fpjlantz%2Foptee-qemu) You must be signed in to change notification settings
* [Fork
  13](/login?return_to=%2Fpjlantz%2Foptee-qemu)
* [Star
   74](/login?return_to=%2Fpjlantz%2Foptee-qemu)

* [Code](/pjlantz/optee-qemu)
* [Issues
  1](/pjlantz/optee-qemu/issues)
* [Pull requests
  0](/pjlantz/optee-qemu/pulls)
* [Actions](/pjlantz/optee-qemu/actions)
* [Projects
  0](/pjlantz/optee-qemu/projects)
* [Security](/pjlantz/optee-qemu/security)
* [Insights](/pjlantz/optee-qemu/pulse)

Additional navigation options

* [Code](/pjlantz/optee-qemu)
* [Issues](/pjlantz/optee-qemu/issues)
* [Pull requests](/pjlantz/optee-qemu/pulls)
* [Actions](/pjlantz/optee-qemu/actions)
* [Projects](/pjlantz/optee-qemu/projects)
* [Security](/pjlantz/optee-qemu/security)
* [Insights](/pjlantz/optee-qemu/pulse)

## Files

 main
## Breadcrumbs

1. [optee-qemu](/pjlantz/optee-qemu/tree/main)
/
# README.md

 Blame  Blame
## Latest commit

## History

[History](/pjlantz/optee-qemu/commits/main/README.md)493 lines (367 loc) · 23.6 KB main
## Breadcrumbs

1. [optee-qemu](/pjlantz/optee-qemu/tree/main)
/
# README.md

Top
## File metadata and controls

* Preview
* Code
* Blame

493 lines (367 loc) · 23.6 KB[Raw](https://github.com/pjlantz/optee-qemu/raw/refs/heads/main/README.md)
# CVE-2021-44733: Fuzzing and exploitation of a use-after-free in the Linux kernel TEE subsystem

Recently a use-after-free vulnerability was discovered in the Linux kernel TEE subsystem, up to and including version 5.15.11, and was assigned CVE-2021-44733 [1].

At a first glance it did not seem to be exploitable for several reasons, however after some further analysis of the vulnerable code path and by implementing a crude proof-of-concept exploit it was possible to overwrite a function pointer in the kernel. No privilege escalation payload is presented in this post, however the entire environment for running OPTEE and the exploit is available for further testing, see 'Setting up the environment'.

## Background

A TEE (Trusted Execution Environment) is a trusted OS running in some secure environment, for example, TrustZone on ARM CPUs. A TEE driver handles the details needed to communicate with the TEE. Some of the more important duties of the driver is to provide a generic API towards the TEE based on the Globalplatform TEE Client API specification [3], but also to manage the shared memory between Linux and the TEE. This subsystem can be enabled by configuring `CONFIG_OPTEE` in the kernel configurations for ARM architectures.

The secure world contains the trusted OS denoted OP-TEE OS [4]. On top of this OS it is possible to have so called Trusted Applications (TAs) running which can perform some operations in the isolated environment, see Figure 1.

[![TEE overview](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/overview.png?raw=true)](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/overview.png?raw=true)

*Figure 1: Overview of TEE - from Linaro's presentation [5]*

The normal world (Linux userspace/kernel) can interact with these applications using client applications (CAs) and the API exposed by the TEE subsystem. A CA can open a session towards a specific TA and invoke functions that the TA implements. Passing of any arguments back and forth between the TA and CA is done using shared memory.
The interaction between a CA and TA using all relevant syscalls is described next.

1. A CA opens up `/dev/tee[0-9]` to communicate with the driver. Note, that for the conventional way of using these APIs, this is done implicitly using the libteec.
2. The shared memory can be registered by the CA using the `IOCTL TEE_IOC_SHM_ALLOC`. This allocates shared memory and returns a file descriptor which user space can use as part of mmap.
3. The next step is to establish a session using the `IOCTL TEE_IOC_OPEN_SESSION` and specifying the uuid for a specific TA. This uuid is hardcoded during the compilation of the TA.
4. In order to invoke any specific function in the TA, the CA invokes this by specifying the identifier of a function along with any input arguments, this is done using `TEE_IOC_INVOKE`.
5. When the CA is finished with all requests, the session can be closed using `TEE_IOC_CLOSE_SESSION`.

[![Session between CA and TA](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/overview2.png?raw=true)](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/overview2.png?raw=true)

*Figure 2: Session between CA and TA - from Linaro's presentation [5]*

Much of the communication between clients and the TEE is opaque to the driver. The main job for the driver is to manage the context, receive requests from the clients, forward them to the TEE and send back the results [2].

## Fuzzing of the TEE driver

CVE-2021-44733 was discovered using fuzzing with syzkaller. The description file used for this is provided below. Note that `ioctl$TEE_SHM_REGISTER_FD` is only part of Linaro (maintainers) kernel tree and not in upstream. The environment provided in 'Setting up the environment' could be used for fuzzing if configured properly according to syzkaller documentation [6]

```
#include <uapi/linux/tee.h>

resource fd_tee0[fd]
resource session_resource[int32]

openat$tee0(fd const[AT_FDCWD], dev ptr[in, string["/dev/tee0"]], flags flags[open_flags], mode flags[open_mode]) fd_tee0
ioctl$TEE_OPEN_SESSION(fd fd_tee0, cmd const[0x8010a402], arg ptr[inout, tee_ioctl_buf_data_session])
ioctl$TEE_INVOKE(fd fd_tee0, cmd const[0x8010a403], arg ptr[inout, tee_ioctl_buf_data_invoke])
ioctl$TEE_CANCEL(fd fd_tee0, cmd const[0x8008a404], arg ptr[in, tee_ioctl_buf_data_cancel])
ioctl$TEE_CLOSE_SESSION(fd fd_tee0, cmd const[0x8004a405], arg ptr[in, tee_ioctl_buf_data_close])
ioctl$TEE_VERSION(fd fd_tee0, cmd const[0x800ca400], arg ptr[out, tee_ioctl_buf_data_version])
ioctl$TEE_SHM_ALLOC(fd fd_tee0, cmd const[0xc010a401], arg ptr[inout, tee_ioctl_buf_data_shm_alloc])
ioctl$TEE_SHM_REGISTER(fd fd_tee0, cmd const[0xc018a409], arg ptr[inout, tee_ioctl_buf_data_shm_register])
ioctl$TEE_SHM_REGISTER_FD(fd fd_tee0, cmd const[0xc018a408], arg ptr[inout, tee_ioctl_buf_data_shm_register_fd])
ioctl$TEE_SUPPL_RECV(fd fd_tee0, cmd const[0x8010a406], arg ptr[inout, tee_ioctl_buf_suppl_recv])
ioctl$TEE_SUPPL_SEND(fd fd_tee0, cmd const[0x8010a407], arg ptr[inout, tee_ioctl_buf_suppl_send])

# COMMON
#=======================================================

define TEE_IOCTL_UUID_LEN   16

tee_ioctl_param_struct {
    attr    flags[TEE_IOCTL_PARAM_ATTR_TYPE, int64]
    a       int64
    b       int64
    c       int64
}

TEE_IOCTL_PARAM_ATTR_TYPE = 0, 1, 2, 3, 5, 6, 7
TEE_LOGIN = 0, 1, 2, 4, 5, 6

# OPEN SESSION
#=======================================================

tee_ioctl_buf_data_session {
    buf_ptr ptr64[inout, tee_ioctl_open_session_struct]
    buf_len len[buf_ptr, int64]
}

tee_ioctl_open_session_struct {
    uuid        array[int8, TEE_IOCTL_UUID_LEN] (in)
    clnt_uuid   array[int8, TEE_IOCTL_UUID_LEN] (in)
    clnt_login  flags[TEE_LOGIN, int32]         (in)
    cancel_id   int32                           (in)
    session     session_resource                (out)
    ret         int32                           (out)
    ret_origin  int32                           (out)
    num_params  len[params, int32]              (in)
    params      array[tee_ioctl_param_struct]   (in)
}

# INVOKE
#=======================================================

tee_ioctl_buf_data_invoke {
    buf_ptr ptr64[inout, tee_ioctl_invoke_struct]
    buf_len len[buf_ptr, int64]
}

tee_ioctl_invoke_struct {
    func        int32                           (in)
    session     session_resource                (in)
    cancel_id   int32                           (in)
    ret         int32                           (out)
    ret_origin  int32                           (out)
    num_params  len[params, int32]              (in)
    params      array[tee_ioctl_param_struct]   (in)
}

# CANCEL SESSION
#=======================================================

tee_ioctl_buf_data_cancel {
    cancel_id   int32               (in)
    session     session_resource    (in)
}

# CLOSE SESSION
#=======================================================

tee_ioctl_buf_data_close {
    session session_resource    (in)
}

# VERSION
#=======================================================

tee_ioctl_buf_data_version {
    impl_id     int32   (out)
    impl_caps   int32   (out)
    gen_caps    int32   (out)
}

# SHM ALLOC
#=======================================================

tee_ioctl_buf_data_shm_alloc {
    size        int64               (inout)
    flags       const[0, int32]     (inout)
    id          int32               (out)
}

# SHM REGISTER
#=======================================================

tee_ioctl_buf_data_shm_register {
    addr    int64               (in)
    length  int64               (inout)
    flags   const[0, int32]     (inout)
    id      int32               (out)
}

# SHM REGISTER FD
#=======================================================

tee_ioctl_buf_data_shm_register_fd {
    fd      int64               (in)
    size    int64               (out)
    flags   const[0, int32]     (in)
    id      int32               (out)
} [align[8]]

# SUPPLICANT RECV
#=======================================================

tee_ioctl_buf_suppl_recv {
    func        int32                           (in)
    num_params  len[params, int32]              (inout)
    params      array[tee_ioctl_param_struct]   (inout)
}

# SUPPLICANT SEND
#=======================================================

tee_ioctl_buf_suppl_send {
    ret         int32                           (out)
    num_params  len[params, int32]              (in)
    params      array[tee_ioctl_param_struct]   (in)
}

```

During fuzzing, the crash that caught the attention was related to a use-after-free of a task\_struct object while a mutex was held:

```
==================================================================
BUG: KASAN: use-after-free in __mutex_lock.constprop.0+0x118c/0x11c4
Read of size 4 at addr 863b0714 by task optee_example_r/244

CPU: 0 PID: 244 Comm: optee_example_r Tainted: G      D           5.14.0 #151
Hardware name: Generic DT based system
[<8012b204>] (unwind_backtrace) from [<8011f460>] (show_stack+0x20/0x24)
[<8011f460>] (show_stack) from [<81cf0108>] (dump_stack_lvl+0x5c/0x68)
[<81cf0108>] (dump_stack_lvl) from [<80650f04>] (print_address_description.constprop.0+0x38/0x304)
[<80650f04>] (print_address_description.constprop.0) from [<80651548>] (kasan_report+0x1c0/0x1dc)
[<80651548>] (kasan_report) from [<81d0a9b4>] (__mutex_lock.constprop.0+0x118c/0x11c4)
[<81d0a9b4>] (__mutex_lock.constprop.0) from [<81d0ada4>] (mutex_lock+0x128/0x13c)
[<81d0ada4>] (mutex_lock) from [<817424b0>] (tee_shm_release+0x4b0/0x6cc)
[<817424b0>] (tee_shm_release) from [<81303674>] (dma_buf_release+0x1b8/0x2f0)
[<81303674>] (dma_buf_release) from [<806d5ac0>] (__dentry_kill+0x4c4/0x678)
[<806d5ac0>] (__dentry_kill) from [<806d8a68>] (dput+0x630/0xba4)
[<806d8a68>] (dput) from [<8067d890>] (__fput+0x3b4/0x900)
[<8067d890>] (__fput) from [<801dd1d8>] (task_work_run+0x15c/0x230)
[<801dd1d8>] (task_work_run) from [<80172b70>] (do_exit+0x103c/0x3770)
[<80172b70>] (do_exit) from [<80179aec>] (do_group_exit+0x134/0x3ac)
[<80179aec>] (do_group_exit) from [<801a7658>] (get_signal+0x7d8/0x2f28)
[<801a7658>] (get_signal) from [<8011dea4>] (do_work_pending+0x984/0x154c)
[<8011dea4>] (do_work_pending) from [<801000d0>] (slow_work_pending+0xc/0x20)
Exception stack(0x85743fb0 to 0x85743ff8)
3fa0:                                     00023108 00000080 00000000 00000000
3fc0: 66bca2d0 66bca2d0 66bca2d0 000000f0 66bca2d0 66bca340 00000000 6ec00b0c
3fe0: 66bc9cc8 66bc9cb8 00011655 66c80c20 000e0130 00023108

Allocated by task 242:
 set_alloc_info+0x48/0x50
 __kasan_slab_alloc+0x48/0x58
 kmem_cache_alloc+0x14c/0x314
 copy_process+0x2014/0x7b18
 kernel_clone+0x244/0xfc8
 sys_clone+0xc8/0xec
 ret_fast_syscall+0x0/0x58
 0x6ec00a10

Freed by task 67:
 kasan_set_track+0x28/0x30
 kasan_set_free_info+0x20/0x34
 __kasan_slab_free+0xdc/0x108
 kmem_cache_free+0x80/0x394
 __put_task_struct+0x2b4/0x35c
 delayed_put_task_struct+0x104/0x384
 rcu_core+0x91c/0x2a68
 __do_softirq+0x2fc/0xfb8

Last potentially related work creation:
 kasan_record_aux_stack+0xb8/0xc0
 call_rcu+0x9c/0xfd0
 put_task_struct_rcu_user+0x9c/0xbc
 finish_task_switch+0x534/0xa10
 __schedule+0x934/0x1adc
 schedule_idle+0x9c/0x120
 do_idle+0x2ec/0x434
 cpu_startup_entry+0x18/0x1c
 start_kernel+0x3ec/0x430

The buggy address belongs to the object at 863b0700
 which belongs to the cache task_struct of size 1664
The buggy address is located 20 bytes inside of
 1664-byte region [863b0700, 863b0d80)
The buggy address belongs to the page:
page:f09c9565 refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x463b0
head:f09c9565 order:3 compound_mapcount:0 compound_pincount:0
flags: 0x10200(slab|head|zone=0)
raw: 00010200 00000000 00000122 82802e00 00000000 80120012 ffffffff 00000001
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 863b0600: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 863b0680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>863b0700: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                 ^
 863b0780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 863b0800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================

```

This was triggered by closing all file descriptors from `TEE_IOC_SHM_ALLOC` while a different thread opens a session towards in our case, a non-existing TA. Syzkaller managed to reproduce it and by experimenting with the reproducer code and slightly delaying the call to `TEE_IOC_OPEN_SESSION`, a different UAF occurred for an object belonging to the kmalloc-64 cache:

```

==================================================================
BUG: KASAN: use-after-free in tee_shm_put+0x8c/0x98
Read of size 4 at addr 86467020 by task optee_example_h/216

CPU: 0 PID: 216 Comm: optee_example_h Not tainted 5.14.0 #21
Hardware name: Generic DT based system
[<80122584>] (unwind_backtrace) from [<80117fd4>] (show_stack+0x10/0x14)
[<80117fd4>] (show_stack) from [<819d57a0>] (dump_stack_lvl+0x40/0x4c)
[<819d57a0>] (dump_stack_lvl) from [<819ced74>] (print_address_description.constprop.0+0x5c/0x2d8)
[<819ced74>] (print_address_description.constprop.0) from [<805a12c4>] (kasan_report+0x1b4/0x1d0)
[<805a12c4>] (kasan_report) from [<814cc6b0>] (tee_shm_put+0x8c/0x98)
[<814cc6b0>] (tee_shm_put) from [<814c9b2c>] (tee_ioctl+0x1578/0x2e44)
[<814c9b2c>] (tee_ioctl) from [<806038ec>] (sys_ioctl+0x918/0x1e70)
[<806038ec>] (sys_ioctl) from [<80100060>] (ret_fast_syscall+0x0/0x58)
Exception stack(0x86417fa8 to 0x86417ff0)
7fa0:                   00000080 00000000 00000003 8010a402 200001c0 00000003
7fc0: 00000080 00000000 00423018 00000036 66c562d0 66c55e10 66c562d0 6ebebafc
7fe0: 66c55cb0 66c55ca0 004114bd 66cebd72

Allocated by task 216:
 tee_shm_alloc+0x15c/0x7e8
 tee_ioctl+0x8d0/0x2e44
 sys_ioctl+0x918/0x1e70
 ret_fast_syscall+0x0/0x58
 0x66c55ca0

Freed by task 215:
 kasan_set_free_info+0x20/0x34
 __kasan_slab_free+0xdc/0x108
 kfree+0x98/0x294
 tee_shm_release+0x1dc/0x610
 dma_buf_release+0x180/0x2a0
 __dentry_kill+0x488/0x6ac
 __fput+0x2f0/0x7b4
 task_work_run+0x178/0x230
 do_work_pending+0xaf8/0x10a8
 slow_work_pending+0xc/0x20
 0x66d5bd16

The buggy address belongs to the object at 86467000
 which belongs to the cache kmalloc-64 of size 64
The buggy address is located 32 bytes inside of
 64-byte region [86467000, 86467040)
The buggy address belongs to the page:
page:(ptrval) refcount:1 mapcount:0 mapping:00000000 index:0x0 pfn:0x46467
flags: 0x200(slab|zone=0)
raw: 00000200 00000000 00000122 82401200 00000000 00200020 ffffffff 00000001
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 86466f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 86466f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>86467000: fa fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc
                       ^
 86467080: fa fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc
 86467100: fa fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc
==================================================================

```

This vulnerability was discovered by fuzzing the TEE driver without any session being established with an existing TA running on the system. This could be further extended with so called pseudo syscalls in syzkaller in order to setup and initiate a session towards some TA.

## Root cause analysis

The conclusion is a design issue with the lifetime tracking of a `tee_shm:dmabuf` object. The driver is designed to let userspace keep the one-and-only reference count after a call to `tee_ioctl_shm_alloc()`.

It is assumed that if the object still is found in the driver’s IDR object, then the reference to the dmabuf is still valid and its reference count can be incremented. It turns out this is only partially true. The dmabuf memory is still owned by the dmabuf driver, but it may be in the process of being destroyed and that cannot be stopped by making the reference count non-zero again.

The scenario that triggers the problem is a multi-threaded application where one thread closes the dmabuf file-descriptor at the same time that another thread makes a call to the IOCTL command `TEE_IOC_OPEN_SESSION` or `TEE_IOC_INVOKE` referencing that shared memory.

Tracing the destruction of the dmabuf when user-space closes the fd will run this code in the kernel:

1. `fput()`
2. `fput_many()` >> File reference count reaches zero. Race window opens.
3. `[task_work gets scheduled]`
4. `__fput`
5. `dput`
6. `dma_buf_release`
7. `tee_shm_release`

   8. `mutex_lock(teedev->mutex)`
   9. `idr_remove(teedev->idr, shm->id)` >> Now the shm object can no longer be referenced from userspace. Race window closes.
   10. `mutex_unlock()`

This means that the IDR table and its mutex lock cannot guarantee that the dmabuf and corresponding `tee_shm` is still alive. A process racing `fput()` by calling `tee_shm_get_from_id()` can get a reference to a shm that is about to go dead.

```
/**
 * tee_shm_get_from_id() - Find shared memory object and increase reference
 * count
 * @ctx:    Context owning the shared memory
 * @id:     Id of shared memory object
 * @returns a pointer to 'struct tee_shm' on success or an ERR_PTR on failure
 */
struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)
{
    struct tee_device *teedev;
    struct tee_shm *shm;

    if (!ctx)
        return ERR_PTR(-EINVAL);

    teedev = ctx->teedev;
    mutex_lock(&teedev->mutex);
    shm = idr_find(&teedev->idr, id);
    if (!shm || shm->ctx != ctx)
        shm = ERR_PTR(-EINVAL);
    else if (shm->flags & TEE_SHM_DMA_BUF)
        get_dma_buf(shm->dmabuf);
    mutex_unlock(&teedev->mutex);
    return shm;
}

```

## Exploiting the UAF

In order to exploit this, a reallocation must be made after the object has been free'd and before triggering the UAF. After the call to `tee_shm_get_from_id()`, the function `tee_shm_put()` (for which the second UAF crash from syzkaller occurs) is called which dereferences the `tee_shm:dmabuf` object used as input argument to `dma_buf_put()`.

```
/**
 * tee_shm_put() - Decrease reference count on a shared memory handle
 * @shm:    Shared memory handle
 */
void tee_shm_put(struct tee_shm *shm)
{
    if (shm->flags & TEE_SHM_DMA_BUF)
        dma_buf_put(shm->dmabuf);
}
EXPORT_SYMBOL_GPL(tee_shm_put);

```

The `tee_shm` object could be reallocated before the UAF as it belongs to the kmalloc-64 cache. It would have to be reallocated with:

1. fake `tee_shm`, `tee_shm:dmabuf`, `dma_buf:file` objects
2. set `file->f_count = 1`
3. craft a `file:file_operations` object that has the `fasync` function pointer set to an arbitrary address

This function is then invoked in `__fput()` after the call to `dma_buf_put()` when `file->f_count` reaches zero.

PAN (Privileged Access Never) mitigates this as fake objects must be referenced in userspace memory in order to set an arbitrary function pointer in the `file:f_ops` structure. Therefore `CONFIG_CPU_SW_DOMAIN_PAN` must be disabled for this to work which it is in the provided environment. There are some open questions left as whether PAN can be bypassed in this vulnerability, e.g., using ret2dir.

Also, in order to perform a successful reallocation of the free'd shm object, the IOCTL call `TEE_IOC_OPEN_SESSION` or `TEE_IOC_INVOKE` must be preemted by a thread performing the file descriptor close and heap spraying thread that fills the kmalloc-64 cache. For this to work the kernel must be configured with `CONFIG_PREEMPT`. In this PoC the heap spray from Nicolas Fabretti's blog post [7] was utilized based on blocking `sendmsg()`.

To summarize, the issue in regards to exploitation is that both the free and UAF must occur within the same system call. In addition to this, freeing is hard to trigger as it is requires racing within the syscall. After freeing, the time between it and the actual UAF is a small time window where a heap spray must be performed to reallocate the free'd object. The following Figure shows the threads involved in the exploit code and their role.

[![Threads involved](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/Threads.png?raw=true)](https://github.com/pjlantz/pjlantz.github.io/raw/master/docs/assets/Threads.png?raw=true)

*Figure 3: Threads involved in the exploit code*

Three type of threads are running continuously. In order to preempt the system calling thread, it is running with the lowest possible priority, `SCHED_IDLE` while the others have the priority set to `SCHED_OTHER`. Because we are using blocking `sendmsg()`, each spray attempt must run in its own thread and it must run on the same CPU core that triggers the UAF since each core keeps their own kmalloc caches. There are also a number of freeing threads that close the file descriptor from the shared memory allocation in step 1b). Full source code for this UAF trigger and function pointer overwrite can be found at [10].

## Setting up the new environment

To reproduce the environment with a vulnerable kernel and OPTEE, it can be cloned from the following repository and built using:

```
$ mkdir optee-qemu && cd optee-qemu
$ repo init -u https://github.com/pjlantz/optee-qemu.git
$ repo sync
$ cd build
$ make toolchains -j2
$ make run

```

After successful build, it will spawn three consoles, one for QEMU - press 'c' in the QEMU console in order to boot. A second console shows output from the secure world and the final one will boot into Linux. Login as root (no password).

Run the exploit code until the `fasync` function pointer of the `file_operations` structure is set to `0x22000000`.

```
until optee_exploit | grep "0x22000000" /var/log/messages; do sleep 0.01; done

```

This will stop due to Privileged execute-never (PXN) blocking the execution at `PC=0x22000000`. From here on, exploitation strategies can vary depending on the kernel version, but it might be possible to execute a kernel ROP and do stack pivoting, or make vDSO area writable and place the payload there. It might also be interesting for future work to investigate whether PAN can be bypassed using ret2dir and some physmap spraying. PAN can be enabled in the kernel by setting `CONFIG_CPU_SW_DOMAIN_PAN=y` in `linux/.config`. On real hardware, it is enabled by default on ARMv8.1 and AArch64, for ARMv7 and AArch32 it is possible to have software emulated PAN using this setting [8].

**Note**: This exploit is not very well optimized and may occasionally hang the driver if it manage to free the shared memory object too early, in this case PC will be at `tee_shm_get_from_id()`. If this happens, issue a `system_reset` in the QEMU console to reboot the environment.

## Acknowledgments

Thanks to Lars Persson at Axis Communications for help with the root cause analysis and Jens Wiklander at Linaro and maintainer of the TEE subsystem for a smooth communication and quick resolving of this issue [9].

## References

[1] CVE-2021-44733 - <https://nvd.nist.gov/vuln/detail/CVE-2021-44733>

[2] TEE subsystem - <https://www.kernel.org/doc/html/latest/staging/tee.html>

[3] Globalplatform TEE API - <https://globalplatform.org/specs-library/?filter-committee=tee>

[4] OP-TEE OS - <https://github.com/OP-TEE/optee_os>

[5] BKK16-110: A Gentle Introduction to Trusted Execution and OP-TEE - <https://connect.linaro.org/resources/bkk16/bkk16-110/>

[6] Syzkaller - <https://github.com/google/syzkaller>

[7] Lexfo's security blog, by Nicolas Fabretti: CVE-2017-11176: A step-by-step Linux Kernel exploitation - <https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html>

[8] Linux Kernel Security Subsystem: Exploit Methods/Userspace data usage - <http://kernsec.org/wiki/index.php/Exploit_Methods/Userspace_data_usage>

[9] [PATCH v2] tee: handle lookup of shm with reference count 0 - [https://lore.kernel.org/lkml/20211215092501.1861229-1-jens.wiklander@linaro.org/T/](https://lore.kernel.org/lkml/20211215092501.1861229-1-jens.wiklander%40linaro.org/T/)

[10] Proof of concept exploit - <https://github.com/pjlantz/optee_examples/tree/master/exploit/host>

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from lists.debian.org_1447e1a3_20250108_132555.html ===


---

[[Date Prev](msg00011.html)][[Date Next](msg00013.html)]
[[Thread Prev](msg00011.html)][[Thread Next](msg00013.html)]
[[Date Index](maillist.html#00012)]
[[Thread Index](threads.html#00012)]

# [SECURITY] [DLA 2941-1] linux-4.19 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 2941-1] linux-4.19 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Wed, 9 Mar 2022 13:40:55 +0100
* *Message-id*: <[[🔎]](/msgid-search/YiigV99QQ%2BwYNpB3%40decadent.org.uk) [YiigV99QQ+wYNpB3@decadent.org.uk](msg00012.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-2941-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
March 09, 2022                                <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-4.19
Version        : 4.19.232-1~deb9u1
CVE ID         : CVE-2020-29374 CVE-2020-36322 CVE-2021-3640 CVE-2021-3744
                 CVE-2021-3752 CVE-2021-3760 CVE-2021-3764 CVE-2021-3772
                 CVE-2021-4002 CVE-2021-4083 CVE-2021-4135 CVE-2021-4155
                 CVE-2021-4203 CVE-2021-20317 CVE-2021-20321 CVE-2021-20322
                 CVE-2021-22600 CVE-2021-28711 CVE-2021-28712 CVE-2021-28713
                 CVE-2021-28714 CVE-2021-28715 CVE-2021-28950 CVE-2021-38300
                 CVE-2021-39685 CVE-2021-39686 CVE-2021-39698 CVE-2021-39713
                 CVE-2021-41864 CVE-2021-42739 CVE-2021-43389 CVE-2021-43975
                 CVE-2021-43976 CVE-2021-44733 CVE-2021-45095 CVE-2021-45469
                 CVE-2021-45480 CVE-2022-0001 CVE-2022-0002 CVE-2022-0322
                 CVE-2022-0330 CVE-2022-0435 CVE-2022-0487 CVE-2022-0492
                 CVE-2022-0617 CVE-2022-0644 CVE-2022-22942 CVE-2022-24448
                 CVE-2022-24959 CVE-2022-25258 CVE-2022-25375
Debian Bug     : 988044 989285 990411 994050

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2020-29374

    Jann Horn of Google reported a flaw in Linux's virtual memory
    management.  A parent and child process initially share all their
    memory, but when either writes to a shared page, the page is
    duplicated and unshared (copy-on-write).  However, in case an
    operation such as vmsplice() required the kernel to take an
    additional reference to a shared page, and a copy-on-write occurs
    during this operation, the kernel might have accessed the wrong
    process's memory.  For some programs, this could lead to an
    information leak or data corruption.

    This issue was already fixed for most architectures, but not on
    MIPS and System z.  This update corrects that.

CVE-2020-36322, CVE-2021-28950

    The syzbot tool found that the FUSE (filesystem-in-user-space)
    implementation did not correctly handle a FUSE server returning
    invalid attributes for a file.  A local user permitted to run a
    FUSE server could use this to cause a denial of service (crash).

    The original fix for this introduced a different potential denial
    of service (infinite loop in kernel space), which has also been
    fixed.

CVE-2021-3640

    Lin Ma discovered a race condiiton in the Bluetooth protocol
    implementation that can lead to a use-after-free.  A local
    user could exploit this to cause a denial of service (memory
    corruption or crash) or possibly for privilege escalation.

CVE-2021-3744, CVE-2021-3764

    minihanshen reported bugs in the ccp driver for AMD
    Cryptographic Coprocessors that could lead to a resource leak.
    On systems using this driver, a local user could exploit this to
    cause a denial of service.

CVE-2021-3752

    Likang Luo of NSFOCUS Security Team discovered a flaw in the
    Bluetooth L2CAP implementation that can lead to a user-after-free.
    A local user could exploit this to cause a denial of service
    (memory corruption or crash) or possibly for privilege escalation.

CVE-2021-3760, CVE-2021-4202

    Lin Ma discovered race conditions in the NCI (NFC Controller
    Interface) driver, which could lead to a use-after-free.  A local
    user could exploit this to cause a denial of service (memory
    corruption or crash) or possibly for privilege escalation.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2021-3772

    A flaw was found in the SCTP protocol implementation, which would
    allow a networked attacker to break an SCTP association.  The
    attacker would only need to know or guess the IP addresses and
    ports for the association.

CVE-2021-4002

    It was discovered that hugetlbfs, the virtual filesystem used by
    applications to allocate huge pages in RAM, did not flush the
    CPU's TLB in one case where it was necessary.  In some
    circumstances a local user would be able to read and write huge
    pages after they are freed and reallocated to a different process.
    This could lead to privilege escalation, denial of service or
    information leaks.

CVE-2021-4083

    Jann Horn reported a race condition in the local (Unix) sockets
    garbage collector, that can lead to use-after-free.  A local user
    could exploit this to cause a denial of service (memory corruption
    or crash) or possibly for privilege escalation.

CVE-2021-4135

    A flaw was found in the netdevsim driver which would lead to an
    information leak.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2021-4155

    Kirill Tkhai discovered a data leak in the way the XFS_IOC_ALLOCSP
    IOCTL in the XFS filesystem allowed for a size increase of files
    with unaligned size. A local attacker can take advantage of this
    flaw to leak data on the XFS filesystem.

CVE-2021-4203

    Jann Horn reported a race condition in the local (Unix) sockets
    implementation that can lead to a use-after-free.  A local user
    could exploit this to leak sensitive information from the kernel.

CVE-2021-20317

    It was discovered that the timer queue structure could become
    corrupt, leading to waiting tasks never being woken up.  A local
    user with certain privileges could exploit this to cause a denial
    of service (system hang).

CVE-2021-20321

    A race condition was discovered in the overlayfs filesystem
    driver.  A local user with access to an overlayfs mount and to its
    underlying upper directory could exploit this for privilege
    escalation.

CVE-2021-20322

    An information leak was discovered in the IPv4 implementation.  A
    remote attacker could exploit this to quickly discover which UDP
    ports a system is using, making it easier for them to carry out a
    DNS poisoning attack against that system.

CVE-2021-22600

    The syzbot tool found a flaw in the packet socket (AF_PACKET)
    implementation which could lead to incorrectly freeing memory.  A
    local user with CAP_NET_RAW capability (in any user namespace)
    could exploit this for denial of service (memory corruption or
    crash) or possibly for privilege escalation.

CVE-2021-28711, CVE-2021-28712, CVE-2021-28713 (XSA-391)

    Juergen Gross reported that malicious PV backends can cause a denial
    of service to guests being serviced by those backends via high
    frequency events, even if those backends are running in a less
    privileged environment.

CVE-2021-28714, CVE-2021-28715 (XSA-392)

    Juergen Gross discovered that Xen guests can force the Linux
    netback driver to hog large amounts of kernel memory, resulting in
    denial of service.

CVE-2021-38300

    Piotr Krysiuk discovered a flaw in the classic BPF (cBPF) JIT
    compiler for MIPS architectures.  A local user could exploit
    this to excute arbitrary code in the kernel.

    This issue is mitigated by setting sysctl
    net.core.bpf_jit_enable=0, which is the default.  It is *not*
    mitigated by disabling unprivileged use of eBPF.

CVE-2021-39685

    Szymon Heidrich discovered a buffer overflow vulnerability in the
    USB gadget subsystem, resulting in information disclosure, denial of
    service or privilege escalation.

CVE-2021-39686

    A race condition was discovered in the Android binder driver, that
    could lead to incorrect security checks.  On systems where the
    binder driver is loaded, a local user could exploit this for
    privilege escalation.

CVE-2021-39698

    Linus Torvalds reported a flaw in the file polling implementation,
    which could lead to a use-after-free.  A local user could exploit
    this for denial of service (memory corruption or crash) or
    possibly for privilege escalation.

CVE-2021-39713

    The syzbot tool found a race condition in the network scheduling
    subsystem which could lead to a use-after-free.  A local user
    could exploit this for denial of service (memory corruption or
    crash) or possibly for privilege escalation.

CVE-2021-41864

    An integer overflow was discovered in the Extended BPF (eBPF)
    subsystem.  A local user could exploit this for denial of service
    (memory corruption or crash), or possibly for privilege
    escalation.

    This can be mitigated by setting sysctl
    kernel.unprivileged_bpf_disabled=1, which disables eBPF use by
    unprivileged users.

CVE-2021-42739

    A heap buffer overflow was discovered in the firedtv driver for
    FireWire-connected DVB receivers.  A local user with access to a
    firedtv device could exploit this for denial of service (memory
    corruption or crash), or possibly for privilege escalation.

CVE-2021-43389

    The Active Defense Lab of Venustech discovered a flaw in the CMTP
    subsystem as used by Bluetooth, which could lead to an
    out-of-bounds read and object type confusion.  A local user with
    CAP_NET_ADMIN capability in the initial user namespace could
    exploit this for denial of service (memory corruption or crash),
    or possibly for privilege escalation.

CVE-2021-43975

    Brendan Dolan-Gavitt reported a flaw in the
    hw_atl_utils_fw_rpc_wait() function in the aQuantia AQtion ethernet
    device driver which can result in denial of service or the execution
    of arbitrary code.

CVE-2021-43976

    Zekun Shen and Brendan Dolan-Gavitt discovered a flaw in the
    mwifiex_usb_recv() function of the Marvell WiFi-Ex USB Driver. An
    attacker able to connect a crafted USB device can take advantage of
    this flaw to cause a denial of service.

CVE-2021-44733

    A race condition was discovered in the Trusted Execution
    Environment (TEE) subsystem for Arm processors, which could lead
    to a use-after-free.  A local user permitted to access a TEE
    device could exploit this for denial of service (memory corruption
    or crash) or possibly for privilege escalation.

CVE-2021-45095

    It was discovered that the Phone Network protocol (PhoNet) driver
    has a reference count leak in the pep_sock_accept() function.

CVE-2021-45469

    Wenqing Liu reported an out-of-bounds memory access in the f2fs
    implementation if an inode has an invalid last xattr entry. An
    attacker able to mount a specially crafted image can take advantage
    of this flaw for denial of service.

CVE-2021-45480

    A memory leak flaw was discovered in the __rds_conn_create()
    function in the RDS (Reliable Datagram Sockets) protocol subsystem.

CVE-2022-0001 (INTEL-SA-00598)

    Researchers at VUSec discovered that the Branch History Buffer in
    Intel processors can be exploited to create information side-
    channels with speculative execution.  This issue is similar to
    Spectre variant 2, but requires additional mitigations on some
    processors.

    This can be exploited to obtain sensitive information from a
    different security context, such as from user-space to the kernel,
    or from a KVM guest to the kernel.

CVE-2022-0002 (INTEL-SA-00598)

    This is a similar issue to CVE-2022-0001, but covers exploitation
    within a security context, such as from JIT-compiled code in a
    sandbox to hosting code in the same process.

    This can be partly mitigated by disabling eBPF for unprivileged
    users with the sysctl: kernel.unprivileged_bpf_disabled=2.  This
    update does that by default.

CVE-2022-0322

    Eiichi Tsukata discovered a flaw in the sctp_make_strreset_req()
    function in the SCTP network protocol implementation which can
    result in denial of service.

CVE-2022-0330

    Sushma Venkatesh Reddy discovered a missing GPU TLB flush in the
    i915 driver, resulting in denial of service or privilege escalation.

CVE-2022-0435

    Samuel Page and Eric Dumazet reported a stack overflow in the
    networking module for the Transparent Inter-Process Communication
    (TIPC) protocol, resulting in denial of service or potentially the
    execution of arbitrary code.

CVE-2022-0487

    A use-after-free was discovered in the MOXART SD/MMC Host Controller
    support driver. This flaw does not impact the Debian binary packages
    as CONFIG_MMC_MOXART is not set.

CVE-2022-0492

    Yiqi Sun and Kevin Wang reported that the cgroup-v1 subsystem does
    not properly restrict access to the release-agent feature. A local
    user can take advantage of this flaw for privilege escalation and
    bypass of namespace isolation.

CVE-2022-0617

    butt3rflyh4ck discovered a NULL pointer dereference in the UDF
    filesystem. A local user that can mount a specially crafted UDF
    image can use this flaw to crash the system.

CVE-2022-0644

    Hao Sun reported a missing check for file read permission in the
    finit_module() and kexec_file_load() system calls.  The security
    impact of this is unclear, since these system calls are usually
    only available to the root user.

CVE-2022-22942

    It was discovered that wrong file file descriptor handling in the
    VMware Virtual GPU driver (vmwgfx) could result in information leak
    or privilege escalation.

CVE-2022-24448

    Lyu Tao reported a flaw in the NFS implementation in the Linux
    kernel when handling requests to open a directory on a regular file,
    which could result in a information leak.

CVE-2022-24959

    A memory leak was discovered in the yam_siocdevprivate() function of
    the YAM driver for AX.25, which could result in denial of service.

CVE-2022-25258

    Szymon Heidrich reported the USB Gadget subsystem lacks certain
    validation of interface OS descriptor requests, resulting in memory
    corruption.

CVE-2022-25375

    Szymon Heidrich reported that the RNDIS USB gadget lacks validation
    of the size of the RNDIS_MSG_SET command, resulting in information
    leak from kernel memory.

For Debian 9 stretch, these problems have been fixed in version
4.19.232-1~deb9u1.  This update additionally includes many more bug
fixes from stable updates 4.19.209-4.19.232 inclusive.

We recommend that you upgrade your linux-4.19 packages.

For the detailed security status of linux-4.19 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-4.19>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpTZkVodrlDJ.pgp)**

*Description:* PGP signature

---



=== Content from www.debian.org_9dfdb833_20250108_132556.html ===


---

[[Date Prev](msg00062.html)][[Date Next](msg00064.html)]
[[Thread Prev](msg00062.html)][[Thread Next](msg00064.html)]
[[Date Index](maillist.html#00063)]
[[Thread Index](threads.html#00063)]

# [SECURITY] [DSA 5096-1] linux security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5096-1] linux security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Wed, 09 Mar 2022 15:30:58 +0000
* *Message-id*: <[[🔎]](/msgid-search/E1nRyHC-0004Le-Lx%40seger.debian.org) [E1nRyHC-0004Le-Lx@seger.debian.org](msg00063.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5096-1                   security@debian.org
<https://www.debian.org/security/>                     Salvatore Bonaccorso
March 09, 2022                        <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : linux
CVE ID         : CVE-2020-29374 CVE-2020-36322 CVE-2021-3640 CVE-2021-3744
                 CVE-2021-3752 CVE-2021-3760 CVE-2021-3764 CVE-2021-3772
                 CVE-2021-4002 CVE-2021-4083 CVE-2021-4135 CVE-2021-4155
                 CVE-2021-4203 CVE-2021-20317 CVE-2021-20321 CVE-2021-20322
                 CVE-2021-22600 CVE-2021-28711 CVE-2021-28712 CVE-2021-28713
                 CVE-2021-28714 CVE-2021-28715 CVE-2021-28950 CVE-2021-38300
                 CVE-2021-39685 CVE-2021-39686 CVE-2021-39698 CVE-2021-39713
                 CVE-2021-41864 CVE-2021-42739 CVE-2021-43389 CVE-2021-43975
                 CVE-2021-43976 CVE-2021-44733 CVE-2021-45095 CVE-2021-45469
                 CVE-2021-45480 CVE-2022-0001 CVE-2022-0002 CVE-2022-0322
                 CVE-2022-0330 CVE-2022-0435 CVE-2022-0487 CVE-2022-0492
                 CVE-2022-0617 CVE-2022-0644 CVE-2022-22942 CVE-2022-24448
                 CVE-2022-24959 CVE-2022-25258 CVE-2022-25375
Debian Bug     : 988044 989285 990411 994050

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2020-29374

    Jann Horn of Google reported a flaw in Linux's virtual memory
    management.  A parent and child process initially share all their
    memory, but when either writes to a shared page, the page is
    duplicated and unshared (copy-on-write).  However, in case an
    operation such as vmsplice() required the kernel to take an
    additional reference to a shared page, and a copy-on-write occurs
    during this operation, the kernel might have accessed the wrong
    process's memory.  For some programs, this could lead to an
    information leak or data corruption.

    This issue was already fixed for most architectures, but not on
    MIPS and System z.  This update corrects that.

CVE-2020-36322, CVE-2021-28950

    The syzbot tool found that the FUSE (filesystem-in-user-space)
    implementation did not correctly handle a FUSE server returning
    invalid attributes for a file.  A local user permitted to run a
    FUSE server could use this to cause a denial of service (crash).

    The original fix for this introduced a different potential denial
    of service (infinite loop in kernel space), which has also been
    fixed.

CVE-2021-3640

    Lin Ma discovered a race condiiton in the Bluetooth protocol
    implementation that can lead to a use-after-free.  A local
    user could exploit this to cause a denial of service (memory
    corruption or crash) or possibly for privilege escalation.

CVE-2021-3744, CVE-2021-3764

    minihanshen reported bugs in the ccp driver for AMD
    Cryptographic Coprocessors that could lead to a resource leak.
    On systems using this driver, a local user could exploit this to
    cause a denial of service.

CVE-2021-3752

    Likang Luo of NSFOCUS Security Team discovered a flaw in the
    Bluetooth L2CAP implementation that can lead to a user-after-free.
    A local user could exploit this to cause a denial of service
    (memory corruption or crash) or possibly for privilege escalation.

CVE-2021-3760, CVE-2021-4202

    Lin Ma discovered race conditions in the NCI (NFC Controller
    Interface) driver, which could lead to a use-after-free.  A local
    user could exploit this to cause a denial of service (memory
    corruption or crash) or possibly for privilege escalation.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2021-3772

    A flaw was found in the SCTP protocol implementation, which would
    allow a networked attacker to break an SCTP association.  The
    attacker would only need to know or guess the IP addresses and
    ports for the association.

CVE-2021-4002

    It was discovered that hugetlbfs, the virtual filesystem used by
    applications to allocate huge pages in RAM, did not flush the
    CPU's TLB in one case where it was necessary.  In some
    circumstances a local user would be able to read and write huge
    pages after they are freed and reallocated to a different process.
    This could lead to privilege escalation, denial of service or
    information leaks.

CVE-2021-4083

    Jann Horn reported a race condition in the local (Unix) sockets
    garbage collector, that can lead to use-after-free.  A local user
    could exploit this to cause a denial of service (memory corruption
    or crash) or possibly for privilege escalation.

CVE-2021-4135

    A flaw was found in the netdevsim driver which would lead to an
    information leak.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2021-4155

    Kirill Tkhai discovered a data leak in the way the XFS_IOC_ALLOCSP
    IOCTL in the XFS filesystem allowed for a size increase of files
    with unaligned size. A local attacker can take advantage of this
    flaw to leak data on the XFS filesystem.

CVE-2021-4203

    Jann Horn reported a race condition in the local (Unix) sockets
    implementation that can lead to a use-after-free.  A local user
    could exploit this to leak sensitive information from the kernel.

CVE-2021-20317

    It was discovered that the timer queue structure could become
    corrupt, leading to waiting tasks never being woken up.  A local
    user with certain privileges could exploit this to cause a denial
    of service (system hang).

CVE-2021-20321

    A race condition was discovered in the overlayfs filesystem
    driver.  A local user with access to an overlayfs mount and to its
    underlying upper directory could exploit this for privilege
    escalation.

CVE-2021-20322

    An information leak was discovered in the IPv4 implementation.  A
    remote attacker could exploit this to quickly discover which UDP
    ports a system is using, making it easier for them to carry out a
    DNS poisoning attack against that system.

CVE-2021-22600

    The syzbot tool found a flaw in the packet socket (AF_PACKET)
    implementation which could lead to incorrectly freeing memory.  A
    local user with CAP_NET_RAW capability (in any user namespace)
    could exploit this for denial of service (memory corruption or
    crash) or possibly for privilege escalation.

CVE-2021-28711, CVE-2021-28712, CVE-2021-28713 (XSA-391)

    Juergen Gross reported that malicious PV backends can cause a denial
    of service to guests being serviced by those backends via high
    frequency events, even if those backends are running in a less
    privileged environment.

CVE-2021-28714, CVE-2021-28715 (XSA-392)

    Juergen Gross discovered that Xen guests can force the Linux
    netback driver to hog large amounts of kernel memory, resulting in
    denial of service.

CVE-2021-38300

    Piotr Krysiuk discovered a flaw in the classic BPF (cBPF) JIT
    compiler for MIPS architectures.  A local user could exploit
    this to excute arbitrary code in the kernel.

    This issue is mitigated by setting sysctl
    net.core.bpf_jit_enable=0, which is the default.  It is *not*
    mitigated by disabling unprivileged use of eBPF.

CVE-2021-39685

    Szymon Heidrich discovered a buffer overflow vulnerability in the
    USB gadget subsystem, resulting in information disclosure, denial of
    service or privilege escalation.

CVE-2021-39686

    A race condition was discovered in the Android binder driver, that
    could lead to incorrect security checks.  On systems where the
    binder driver is loaded, a local user could exploit this for
    privilege escalation.

CVE-2021-39698

    Linus Torvalds reported a flaw in the file polling implementation,
    which could lead to a use-after-free.  A local user could exploit
    this for denial of service (memory corruption or crash) or
    possibly for privilege escalation.

CVE-2021-39713

    The syzbot tool found a race condition in the network scheduling
    subsystem which could lead to a use-after-free.  A local user
    could exploit this for denial of service (memory corruption or
    crash) or possibly for privilege escalation.

CVE-2021-41864

    An integer overflow was discovered in the Extended BPF (eBPF)
    subsystem.  A local user could exploit this for denial of service
    (memory corruption or crash), or possibly for privilege
    escalation.

    This can be mitigated by setting sysctl
    kernel.unprivileged_bpf_disabled=1, which disables eBPF use by
    unprivileged users.

CVE-2021-42739

    A heap buffer overflow was discovered in the firedtv driver for
    FireWire-connected DVB receivers.  A local user with access to a
    firedtv device could exploit this for denial of service (memory
    corruption or crash), or possibly for privilege escalation.

CVE-2021-43389

    The Active Defense Lab of Venustech discovered a flaw in the CMTP
    subsystem as used by Bluetooth, which could lead to an
    out-of-bounds read and object type confusion.  A local user with
    CAP_NET_ADMIN capability in the initial user namespace could
    exploit this for denial of service (memory corruption or crash),
    or possibly for privilege escalation.

CVE-2021-43975

    Brendan Dolan-Gavitt reported a flaw in the
    hw_atl_utils_fw_rpc_wait() function in the aQuantia AQtion ethernet
    device driver which can result in denial of service or the execution
    of arbitrary code.

CVE-2021-43976

    Zekun Shen and Brendan Dolan-Gavitt discovered a flaw in the
    mwifiex_usb_recv() function of the Marvell WiFi-Ex USB Driver. An
    attacker able to connect a crafted USB device can take advantage of
    this flaw to cause a denial of service.

CVE-2021-44733

    A race condition was discovered in the Trusted Execution
    Environment (TEE) subsystem for Arm processors, which could lead
    to a use-after-free.  A local user permitted to access a TEE
    device could exploit this for denial of service (memory corruption
    or crash) or possibly for privilege escalation.

CVE-2021-45095

    It was discovered that the Phone Network protocol (PhoNet) driver
    has a reference count leak in the pep_sock_accept() function.

CVE-2021-45469

    Wenqing Liu reported an out-of-bounds memory access in the f2fs
    implementation if an inode has an invalid last xattr entry. An
    attacker able to mount a specially crafted image can take advantage
    of this flaw for denial of service.

CVE-2021-45480

    A memory leak flaw was discovered in the __rds_conn_create()
    function in the RDS (Reliable Datagram Sockets) protocol subsystem.

CVE-2022-0001 (INTEL-SA-00598)

    Researchers at VUSec discovered that the Branch History Buffer in
    Intel processors can be exploited to create information side-
    channels with speculative execution.  This issue is similar to
    Spectre variant 2, but requires additional mitigations on some
    processors.

    This can be exploited to obtain sensitive information from a
    different security context, such as from user-space to the kernel,
    or from a KVM guest to the kernel.

CVE-2022-0002 (INTEL-SA-00598)

    This is a similar issue to CVE-2022-0001, but covers exploitation
    within a security context, such as from JIT-compiled code in a
    sandbox to hosting code in the same process.

    This can be partly mitigated by disabling eBPF for unprivileged
    users with the sysctl: kernel.unprivileged_bpf_disabled=2.  This
    update does that by default.

CVE-2022-0322

    Eiichi Tsukata discovered a flaw in the sctp_make_strreset_req()
    function in the SCTP network protocol implementation which can
    result in denial of service.

CVE-2022-0330

    Sushma Venkatesh Reddy discovered a missing GPU TLB flush in the
    i915 driver, resulting in denial of service or privilege escalation.

CVE-2022-0435

    Samuel Page and Eric Dumazet reported a stack overflow in the
    networking module for the Transparent Inter-Process Communication
    (TIPC) protocol, resulting in denial of service or potentially the
    execution of arbitrary code.

CVE-2022-0487

    A use-after-free was discovered in the MOXART SD/MMC Host Controller
    support driver. This flaw does not impact the Debian binary packages
    as CONFIG_MMC_MOXART is not set.

CVE-2022-0492

    Yiqi Sun and Kevin Wang reported that the cgroup-v1 subsystem does
    not properly restrict access to the release-agent feature. A local
    user can take advantage of this flaw for privilege escalation and
    bypass of namespace isolation.

CVE-2022-0617

    butt3rflyh4ck discovered a NULL pointer dereference in the UDF
    filesystem. A local user that can mount a specially crafted UDF
    image can use this flaw to crash the system.

CVE-2022-0644

    Hao Sun reported a missing check for file read permission in the
    finit_module() and kexec_file_load() system calls.  The security
    impact of this is unclear, since these system calls are usually
    only available to the root user.

CVE-2022-22942

    It was discovered that wrong file file descriptor handling in the
    VMware Virtual GPU driver (vmwgfx) could result in information leak
    or privilege escalation.

CVE-2022-24448

    Lyu Tao reported a flaw in the NFS implementation in the Linux
    kernel when handling requests to open a directory on a regular file,
    which could result in a information leak.

CVE-2022-24959

    A memory leak was discovered in the yam_siocdevprivate() function of
    the YAM driver for AX.25, which could result in denial of service.

CVE-2022-25258

    Szymon Heidrich reported the USB Gadget subsystem lacks certain
    validation of interface OS descriptor requests, resulting in memory
    corruption.

CVE-2022-25375

    Szymon Heidrich reported that the RNDIS USB gadget lacks validation
    of the size of the RNDIS_MSG_SET command, resulting in information
    leak from kernel memory.

For the oldstable distribution (buster), these problems have been
fixed in version 4.19.232-1.  This update additionally includes many
more bug fixes from stable updates 4.19.209-4.19.232 inclusive.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmIotm1fFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0RcGg//QBgf4RfElxd+11a+BZ9HWJFBjA5Wp2VStf1+inoZ7X/En7W9QBpVvmks
Jum5QFpvA1waEP0zk0/O5MKXHtMbRMFdj0UUYQM7Vi3/vfeP73C10YmXv2yfG2Fw
dTGnVHpvvdJSbNzxMG4jruNY5b0Bf/WEQSqtuOM6V2aBiI7Y2pSI6Ak/dvexiu+0
ycz6PTDkX66e/p7NONw+B33L8yTMj9yu1cCdoYdrDihVlrESgbMLHUWO9JKRQykk
tsI2a79OIEkaj+yQwfkJu9njoPUTn6OZYUYxD8XaN8XtkDpwx1oVsiyqpslJEmgR
vaS1DOEnIZXsq2pscSPeKfFM30uFgqAxkQm/zUpjGGSXib58xaaf/c61LCQoMU2g
cSc+8+N1S2Lbcscdxd9TumvrOGJVuP/q/FqcOl4npcz1WLZRmc9f9IprdqUEy2iJ
+YLSrFFOfhgMMP0El6KJvG/8Jz60UEAiWuYutT508w1jIRrvMRLW4i6V3NXHrNkx
GDofOfPF8jNdt2Www+2sqEY51f+w2kffOSAnHGGPCASvWpuXFOw9ZyxnuyRRKKBE
no9PH0X71a636sZGh8bIU25PSKQlhtlAfCP+0Fef7PeEKTz1MJf8Nvo+vgCIsani
eGWa9jzdkVxHDEjxplX0stsByglCYyud7JSI1ZE9oLtJU1/xDBc=
=5fQT
-----END PGP SIGNATURE-----

```

---



=== Content from git.kernel.org_e86d7a95_20250108_132554.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/tee/tee_shm.c)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tee/tee_shm.c)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/tee/tee_shm.c)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/drivers/tee/tee_shm.c) | log msg author committer range |
| --- | --- |

path: [root](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)/[drivers](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers)/[tee](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/tee)/[tee\_shm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/tee/tee_shm.c)

| Age | Commit message ([Expand](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/tee/tee_shm.c?showmsg=1)) | Author | Files | Lines |
| --- | --- | --- | --- | --- |
| 2024-04-03 | [tee: optee: Move pool\_op helper functions](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=cf4441503e20a0c0a36e0a98dcf57de3d3844c91) | Balint Dobszay | 1 | -0/+65 |
| 2024-04-03 | [tee: Refactor TEE subsystem header files](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=0439fcff304acdedfc493dbf900dce86922fd31f) | Sumit Garg | 1 | -1/+1 |
| 2023-12-13 | [tee: Use iov\_iter to better support shared buffer registration](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=7bdee41575919773818e525ea19e54eb817770af) | Arnaud Pouliquen | 1 | -36/+42 |
| 2023-03-30 | [tee: Pass a pointer to virt\_to\_page()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=8671133082176d1388e20ac33d61cf7e3b05adf5) | Linus Walleij | 1 | -1/+1 |
| 2023-02-13 | [tee: Remove call to get\_kernel\_pages()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=0249a75b365911f91b87935bc08a4795a6fa7dd0) | Ira Weiny | 1 | -13/+8 |
| 2023-02-13 | [tee: Remove vmalloc page support](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=c83900393aa133d5fefdbf2ab3377c7fbeec0c07) | Ira Weiny | 1 | -24/+12 |
| 2022-08-25 | [tee: fix compiler warning in tee\_shm\_register()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=eccd7439709810127563e7e3e49b8b44c7b2791d) | Jens Wiklander | 1 | -0/+1 |
| 2022-08-18 | [tee: add overflow check in register\_shm\_helper()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=573ae4f13f630d6660008f1974c0a8a29c30e18a) | Jens Wiklander | 1 | -0/+3 |
| 2022-05-06 | [Merge tag 'tee-cleanup-for-v5.19' of https://git.linaro.org/people/jens.wikla...](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=728c0d29415a3a0ac998175e0e3ad470edbfbfa8) | Arnd Bergmann | 1 | -50/+0 |
| 2022-04-26 | [tee: remove tee\_shm\_va2pa() and tee\_shm\_pa2va()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=66eb6df79aefd6b3f7d2e749da7104e90cedc0ff) | Andrew Davis | 1 | -50/+0 |
| 2022-04-05 | [tee: make tee\_shm\_register\_kernel\_buf vmalloc supported](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=3e47235eaee09488c7e467b9aaccb7c93c862c6b) | Phil Chang | 1 | -10/+25 |
| 2022-02-16 | [tee: refactor TEE\_SHM\_\* flags](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=a45ea4efa358577c623d7353a6ba9af3c17f6ca0) | Jens Wiklander | 1 | -12/+11 |
| 2022-02-16 | [tee: replace tee\_shm\_register()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=53e16519c2eccdb2e1b123405466a29aaea1132e) | Jens Wiklander | 1 | -66/+90 |
| 2022-02-16 | [tee: add tee\_shm\_register\_{user,kernel}\_buf()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=056d3fed3d1ff3f5d699be337f048f9eed2befaf) | Jens Wiklander | 1 | -0/+33 |
| 2022-02-16 | [tee: replace tee\_shm\_alloc()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=5d41f1b3e3282909b6bbceacb9aebe1d3c849a49) | Jens Wiklander | 1 | -40/+68 |
| 2022-02-16 | [tee: simplify shm pool handling](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=d88e0493a054c9fe72ade41a42d42e958ee6503d) | Jens Wiklander | 1 | -15/+14 |
| 2022-02-16 | [tee: add tee\_shm\_alloc\_user\_buf()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=71cc47d4cc1f7a333584e0f2f7c863c71a6d3ced) | Jens Wiklander | 1 | -0/+17 |
| 2021-12-16 | [tee: handle lookup of shm with reference count 0](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=dfd0743f1d9ea76931510ed150334d571fbab49d) | Jens Wiklander | 1 | -108/+66 |
| 2021-10-25 | [dma-buf: move dma-buf symbols into the DMA\_BUF module namespace](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=16b0314aa746be6c84c0bc6eca9dde0dce2e99df) | Greg Kroah-Hartman | 1 | -0/+3 |
| 2021-07-21 | [tee: Correct inappropriate usage of TEE\_SHM\_DMA\_BUF flag](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=376e4199e327a5cf29b8ec8fb0f64f3d8b429819) | Sumit Garg | 1 | -2/+2 |
| 2021-07-21 | [tee: add tee\_shm\_alloc\_kernel\_buf()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=dc7019b7d0e188d4093b34bd0747ed0d668c63bf) | Jens Wiklander | 1 | -0/+18 |
| 2020-08-25 | [tee: convert get\_user\_pages() --> pin\_user\_pages()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=4300cd6374a5192a2c8122a4a48ed647bdcb0214) | John Hubbard | 1 | -13/+19 |
| 2020-05-25 | [Merge tag 'tee-smatch-for-5.8' of git://git.linaro.org/people/jens.wiklander/...](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=6d83d800b2456122299dcfce4a7da4b86d7cec8e) | Arnd Bergmann | 1 | -2/+1 |
| 2020-04-20 | [tee: enable support to register kernel memory](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=2a6ba3f794e892c37d67b8ebb19487ce105eabc2) | Sumit Garg | 1 | -3/+25 |
| 2020-04-20 | [tee: remove unnecessary NULL check in tee\_shm\_alloc()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=1115899e7aad71bc36100c3fa1d0b99cff9263e6) | Dan Carpenter | 1 | -2/+1 |
| 2020-02-28 | [tee: tee\_shm\_op\_mmap(): use TEE\_SHM\_USER\_MAPPED](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=758ecf13a41a9dc4f019c1381566132ef46c08ee) | Jens Wiklander | 1 | -1/+1 |
| 2020-02-28 | [tee: remove redundant teedev in struct tee\_shm](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=5271b2011e448f1be7433554e4684e91951476fa) | Jens Wiklander | 1 | -5/+2 |
| 2020-02-28 | [tee: don't assign shm id for private shms](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=f1bbacedb0af640a93e47799203e556be2825da3) | Jens Wiklander | 1 | -13/+18 |
| 2020-02-28 | [tee: remove unused tee\_shm\_priv\_alloc()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=c180f9bbe29a403459dd76422f435382aec6adaa) | Jens Wiklander | 1 | -31/+2 |
| 2020-02-28 | [tee: remove linked list of struct tee\_shm](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=59a135f6fb669f4f79f43160c7b8c8d6bfb37f75) | Jens Wiklander | 1 | -11/+1 |
| 2019-11-25 | [drm/tee\_shm: Drop dma\_buf\_k(unmap) support](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=42aa7c6eb3ebfc280cc116978a3c003bcadb3440) | Daniel Vetter | 1 | -6/+0 |
| 2019-09-25 | [tee/shm: untag user pointers in tee\_shm\_register](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=78063a9dd9637c0450cf6eacc03f42eb1295917f) | Andrey Konovalov | 1 | -0/+1 |
| 2019-06-05 | [treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=9c92ab61914157664a2fbdf926df0eb937838e45) | Thomas Gleixner | 1 | -10/+1 |
| 2019-05-14 | [mm/gup: change GUP fast to use flags rather than a write 'bool'](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=73b0140bf0fe9df90fb267c00673c4b9bf285430) | Ira Weiny | 1 | -1/+1 |
| 2018-06-22 | [Merge tag 'drm-misc-next-2018-06-21' of git://anongit.freedesktop.org/drm/drm...](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=f4366e44efeb895c358fddd11f9ecee81bdad06b) | Dave Airlie | 1 | -6/+0 |
| 2018-06-20 | [dma-buf: remove kmap\_atomic interface](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=f664a52695429b68afb4e130a0f69cd5fd1fec86) | Christian König | 1 | -6/+0 |
| 2018-05-07 | [tee: shm: fix use-after-free via temporarily dropped reference](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=bb765d1c331f62b59049d35607ed2e365802bef9) | Jann Horn | 1 | -2/+3 |
| 2018-01-09 | [tee: shm: Potential NULL dereference calling tee\_shm\_register()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=2490cdf6435b1d3cac0dbf710cd752487c67c296) | Dan Carpenter | 1 | -1/+1 |
| 2017-12-28 | [tee: shm: don't put\_page on null shm->pages](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=c94f31b526fe658c25dd2d07c90486a85437f01c) | Colin Ian King | 1 | -3/+5 |
| 2017-12-28 | [tee: shm: make function \_\_tee\_shm\_alloc static](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=80ec6f5de60b6934f145b2f7e5369592bcab85f3) | Colin Ian King | 1 | -3/+3 |
| 2017-12-28 | [tee: add start argument to shm\_register callback](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=95ffe4ca43877eea176d7e95aa0d38bbdc3d2903) | Jens Wiklander | 1 | -1/+1 |
| 2017-12-15 | [tee: shm: inline tee\_shm\_get\_id()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=ef8e08d24ca84846ce639b835ebd2f15a943f42b) | Volodymyr Babchuk | 1 | -11/+0 |
| 2017-12-15 | [tee: use reference counting for tee\_context](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=217e0250cccb9e54d457991446cd3fab413085e1) | Volodymyr Babchuk | 1 | -0/+7 |
| 2017-12-15 | [tee: add register user memory](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=033ddf12bcf5326b93bd604f50a7474a434a35f9) | Jens Wiklander | 1 | -26/+180 |
| 2017-12-15 | [tee: flexible shared memory pool creation](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=e2aca5d8928acb9cc9a87802b02102d4f9b9b596) | Jens Wiklander | 1 | -4/+4 |
| 2017-08-04 | [tee: tee\_shm: Constify dma\_buf\_ops structures.](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=53e3ca5cee24f5fafe4e9ff5fe4b230e1a1b85ed) | Arvind Yadav | 1 | -1/+1 |
| 2017-05-10 | [Merge tag 'armsoc-tee' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/a...](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=a2d9214c730f54ff72c2940bcd7f22d1fccb26ec) | Linus Torvalds | 1 | -0/+358 |
| 2017-03-09 | [tee: generic TEE subsystem](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/tee/tee_shm.c?id=967c9cca2cc50569efc65945325c173cecba83bd) | Jens Wiklander | 1 | -0/+358 |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-08 13:24:31 +0000



=== Content from security.netapp.com_c732dab7_20250108_132556.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
æ¥æ¬èª

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [January 2022 Linux Kernel Vulnerabilities in NetApp Products](https://security.netapp.com/advisory/ntap-20220114-0003)

## January 2022 Linux Kernel Vulnerabilities in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close ×

#### Subscribe to NTAP-20220114-0003 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20220114-0003 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close ×

#### Unsubscribe from NTAP-20220114-0003 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20220114-0003 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20220114-0003
**Version:**
7.0

**Last updated:**
06/09/2022

**Status:**
Final.

**CVEs:** CVE-2021-44733, CVE-2021-45469

Overview
#### Summary

Multiple NetApp products incorporate Linux Kernel. Linux Kernel versions through 5.15.11 are susceptible to vulnerabilities which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of these vulnerabilities could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2021-44733](https://nvd.nist.gov/vuln/detail/CVE-2021-44733) | 7.0 (HIGH) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2021-45469](https://nvd.nist.gov/vuln/detail/CVE-2021-45469) | 7.8 (HIGH) | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

#### References

* [https://lore.kernel.org/lkml/20211215092501.1861229-1-jens.wiklander@linaro.org/](https://lore.kernel.org/lkml/20211215092501.1861229-1-jens.wiklander%40linaro.org/)
* <https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/tee/tee_shm.c>
* <https://bugzilla.kernel.org/show_bug.cgi?id=215235>

Affected Products
#### Affected Products

* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H300E/H500E/H700E/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C

#### Products Not Affected

* 7-Mode Transition Tool
* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 6500N
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* BeeGFS CSI Driver
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Data Sense
* Cloud Insights Acquisition Unit
* Cloud Insights Telegraf Agent
* Cloud Manager
* Cloud Secure Agent
* Cloud Volumes ONTAP Mediator
* Clustered Data ONTAP
* Clustered Data ONTAP Antivirus Connector
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Storage Manager
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f
* FAS/AFF Baseboard Management Controller (BMC) - A320/C190/A220/FAS2720/FAS2750/A800
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* Inventory Collect Tool
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* NetApp Cloud Backup OST Plug-in (formerly AltaVault OST Plug-in)
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Performance Analyzer
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp SANtricity SMI-S Provider
* NetApp SMI-S Provider
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire BIOS
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp SolidFire, Enterprise SDS & HCI Storage Node (Element Software)
* NetApp Virtual Desktop Service (VDS)
* NetApp XCP NFS
* NetApp XCP SMB
* NextGen API
* ONTAP Mediator
* ONTAP Select Deploy administration utility
* ONTAP tools for VMware vSphere
* OnCommand Insight
* OnCommand Workflow Automation
* Open Systems SnapVault Agent
* SANtricity Storage Plugin for vCenter
* SAS Firmware
* SRA Plugin for Linux
* SRA Plugin for Windows
* Service Processor
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere
* SnapDrive for Unix
* SnapManager for Hyper-V
* SnapManager for Oracle
* SnapManager for Oracle Windows
* SnapManager for SAP
* SolidFire Storage Replication Adapter
* Storage Services Connector
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024
* StorageGRID Baseboard Management Controller (BMC)
* StorageGRID9 (9.x and prior)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **NetApp HCI Baseboard Management Controller (BMC) - H410C** | NetApp HCI Baseboard Management Controller (BMC) - H410C has no plans to address this vulnerability. |
| **NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H300E/H500E/H700E/H410S** | NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H300E/H500E/H700E/H410S has no plans to address this vulnerability. |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20220114-0003>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20220114 | Initial Public Release |
| 2.0 | 20220117 | Cloud Secure Agent, Cloud Volumes ONTAP Mediator, FAS/AFF Baseboard Management Controller (BMC) - A320/C190/A220/FAS2720/FAS2750/A800, NetApp Converged Systems Advisor Agent, and Service Processor moved to Products Not Affected |
| 3.0 | 20220118 | ONTAP Tools for VMware vSphere moved to Products Not Affected |
| 4.0 | 20220121 | FAS/AFF Baseboard Management Controller (BMC) - A250/500f moved to Products Not Affected |
| 5.0 | 20220216 | NetApp HCI Baseboard Management Controller (BMC) - H610C, NetApp HCI Baseboard Management Controller (BMC) - H610S, and NetApp HCI Baseboard Management Controller (BMC) - H615C moved to Products Not Affected |
| 6.0 | 20220301 | Brocade Fabric Operating System Firmware moved to Affected Products |
| 7.0 | 20220609 | After additional review Brocade Fabric Operating System Firmware moved to Products Not Affected, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppâs current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 ©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)


