

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=f263a81451c12da5a342d90572e317e611846f2c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f263a81451c12da5a342d90572e317e611846f2c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f263a81451c12da5a342d90572e317e611846f2c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f263a81451c12da5a342d90572e317e611846f2c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | John Fastabend <john.fastabend@gmail.com> | 2021-07-07 15:38:47 -0700 |
| --- | --- | --- |
| committer | Daniel Borkmann <daniel@iogearbox.net> | 2021-07-09 12:08:27 +0200 |
| commit | [f263a81451c12da5a342d90572e317e611846f2c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f263a81451c12da5a342d90572e317e611846f2c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=f263a81451c12da5a342d90572e317e611846f2c)) | |
| tree | [8790d3d6d4d9fc3a9d352cd5b0a9581726f783e7](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=f263a81451c12da5a342d90572e317e611846f2c) | |
| parent | [1d719254c139fb62fb8056fb496b6fd007e71550](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=1d719254c139fb62fb8056fb496b6fd007e71550) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f263a81451c12da5a342d90572e317e611846f2c&id2=1d719254c139fb62fb8056fb496b6fd007e71550)) | |
| download | [linux-f263a81451c12da5a342d90572e317e611846f2c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-f263a81451c12da5a342d90572e317e611846f2c.tar.gz) | |

bpf: Track subprog poke descriptors correctly and fix use-after-freeSubprograms are calling map\_poke\_track(), but on program release there is no
hook to call map\_poke\_untrack(). However, on program release, the aux memory
(and poke descriptor table) is freed even though we still have a reference to
it in the element list of the map aux data. When we run map\_poke\_run(), we then
end up accessing free'd memory, triggering KASAN in prog\_array\_map\_poke\_run():
[...]
[ 402.824689] BUG: KASAN: use-after-free in prog\_array\_map\_poke\_run+0xc2/0x34e
[ 402.824698] Read of size 4 at addr ffff8881905a7940 by task hubble-fgs/4337
[ 402.824705] CPU: 1 PID: 4337 Comm: hubble-fgs Tainted: G I 5.12.0+ #399
[ 402.824715] Call Trace:
[ 402.824719] dump\_stack+0x93/0xc2
[ 402.824727] print\_address\_description.constprop.0+0x1a/0x140
[ 402.824736] ? prog\_array\_map\_poke\_run+0xc2/0x34e
[ 402.824740] ? prog\_array\_map\_poke\_run+0xc2/0x34e
[ 402.824744] kasan\_report.cold+0x7c/0xd8
[ 402.824752] ? prog\_array\_map\_poke\_run+0xc2/0x34e
[ 402.824757] prog\_array\_map\_poke\_run+0xc2/0x34e
[ 402.824765] bpf\_fd\_array\_map\_update\_elem+0x124/0x1a0
[...]
The elements concerned are walked as follows:
for (i = 0; i < elem->aux->size\_poke\_tab; i++) {
poke = &elem->aux->poke\_tab[i];
[...]
The access to size\_poke\_tab is a 4 byte read, verified by checking offsets
in the KASAN dump:
[ 402.825004] The buggy address belongs to the object at ffff8881905a7800
which belongs to the cache kmalloc-1k of size 1024
[ 402.825008] The buggy address is located 320 bytes inside of
1024-byte region [ffff8881905a7800, ffff8881905a7c00)
The pahole output of bpf\_prog\_aux:
struct bpf\_prog\_aux {
[...]
/\* --- cacheline 5 boundary (320 bytes) --- \*/
u32 size\_poke\_tab; /\* 320 4 \*/
[...]
In general, subprograms do not necessarily manage their own data structures.
For example, BTF func\_info and linfo are just pointers to the main program
structure. This allows reference counting and cleanup to be done on the latter
which simplifies their management a bit. The aux->poke\_tab struct, however,
did not follow this logic. The initial proposed fix for this use-after-free
bug further embedded poke data tracking into the subprogram with proper
reference counting. However, Daniel and Alexei questioned why we were treating
these objects special; I agree, its unnecessary. The fix here removes the per
subprogram poke table allocation and map tracking and instead simply points
the aux->poke\_tab pointer at the main programs poke table. This way, map
tracking is simplified to the main program and we do not need to manage them
per subprogram.
This also means, bpf\_prog\_free\_deferred(), which unwinds the program reference
counting and kfrees objects, needs to ensure that we don't try to double free
the poke\_tab when free'ing the subprog structures. This is easily solved by
NULL'ing the poke\_tab pointer. The second detail is to ensure that per
subprogram JIT logic only does fixups on poke\_tab[] entries it owns. To do
this, we add a pointer in the poke structure to point at the subprogram value
so JITs can easily check while walking the poke\_tab structure if the current
entry belongs to the current program. The aux pointer is stable and therefore
suitable for such comparison. On the jit\_subprogs() error path, we omit
cleaning up the poke->aux field because these are only ever referenced from
the JIT side, but on error we will never make it to the JIT, so its fine to
leave them dangling. Removing these pointers would complicate the error path
for no reason. However, we do need to untrack all poke descriptors from the
main program as otherwise they could race with the freeing of JIT memory from
the subprograms. Lastly, a748c6975dea3 ("bpf: propagate poke descriptors to
subprograms") had an off-by-one on the subprogram instruction index range
check as it was testing 'insn\_idx >= subprog\_start && insn\_idx <= subprog\_end'.
However, subprog\_end is the next subprogram's start instruction.
Fixes: a748c6975dea3 ("bpf: propagate poke descriptors to subprograms")
Signed-off-by: John Fastabend <john.fastabend@gmail.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Co-developed-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: [https://lore.kernel.org/bpf/20210707223848.14580-2-john.fastabend@gmail.com](https://lore.kernel.org/bpf/20210707223848.14580-2-john.fastabend%40gmail.com)
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=f263a81451c12da5a342d90572e317e611846f2c)

| -rw-r--r-- | [arch/x86/net/bpf\_jit\_comp.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/net/bpf_jit_comp.c?id=f263a81451c12da5a342d90572e317e611846f2c) | 3 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/linux/bpf.h?id=f263a81451c12da5a342d90572e317e611846f2c) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/core.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/core.c?id=f263a81451c12da5a342d90572e317e611846f2c) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/kernel/bpf/verifier.c?id=f263a81451c12da5a342d90572e317e611846f2c) | 60 | |  |  |  | | --- | --- | --- | |

4 files changed, 32 insertions, 40 deletions

| diff --git a/arch/x86/net/bpf\_jit\_comp.c b/arch/x86/net/bpf\_jit\_comp.cindex e835164189f160..4b951458c9fc99 100644--- a/[arch/x86/net/bpf\_jit\_comp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=1d719254c139fb62fb8056fb496b6fd007e71550)+++ b/[arch/x86/net/bpf\_jit\_comp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/net/bpf_jit_comp.c?id=f263a81451c12da5a342d90572e317e611846f2c)@@ -570,6 +570,9 @@ static void bpf\_tail\_call\_direct\_fixup(struct bpf\_prog \*prog)  for (i = 0; i < prog->aux->size\_poke\_tab; i++) { poke = &prog->aux->poke\_tab[i];+ if (poke->aux && poke->aux != prog->aux)+ continue;+ WARN\_ON\_ONCE(READ\_ONCE(poke->tailcall\_target\_stable));  if (poke->reason != BPF\_POKE\_REASON\_TAIL\_CALL)diff --git a/include/linux/bpf.h b/include/linux/bpf.hindex f309fc1509f2cb..e8e2b0393ca934 100644--- a/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=1d719254c139fb62fb8056fb496b6fd007e71550)+++ b/[include/linux/bpf.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/bpf.h?id=f263a81451c12da5a342d90572e317e611846f2c)@@ -780,6 +780,7 @@ struct bpf\_jit\_poke\_descriptor { void \*tailcall\_target; void \*tailcall\_bypass; void \*bypass\_addr;+ void \*aux; union { struct { struct bpf\_map \*map;diff --git a/kernel/bpf/core.c b/kernel/bpf/core.cindex 034ad93a1ad717..9b15774983738d 100644--- a/[kernel/bpf/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/core.c?id=1d719254c139fb62fb8056fb496b6fd007e71550)+++ b/[kernel/bpf/core.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/core.c?id=f263a81451c12da5a342d90572e317e611846f2c)@@ -2236,8 +2236,14 @@ static void bpf\_prog\_free\_deferred(struct work\_struct \*work) #endif if (aux->dst\_trampoline) bpf\_trampoline\_put(aux->dst\_trampoline);- for (i = 0; i < aux->func\_cnt; i++)+ for (i = 0; i < aux->func\_cnt; i++) {+ /\* We can just unlink the subprog poke descriptor table as+ \* it was originally linked to the main program and is also+ \* released along with it.+ \*/+ aux->func[i]->aux->poke\_tab = NULL; bpf\_jit\_free(aux->func[i]);+ } if (aux->func\_cnt) { kfree(aux->func); bpf\_prog\_unlock\_free(aux->prog);diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.cindex be38bb930bf1e0..42a4063de7cd24 100644--- a/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=1d719254c139fb62fb8056fb496b6fd007e71550)+++ b/[kernel/bpf/verifier.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/bpf/verifier.c?id=f263a81451c12da5a342d90572e317e611846f2c)@@ -12121,33 +12121,19 @@ static int jit\_subprogs(struct bpf\_verifier\_env \*env) goto out\_free; func[i]->is\_func = 1; func[i]->aux->func\_idx = i;- /\* the btf and func\_info will be freed only at prog->aux \*/+ /\* Below members will be freed only at prog->aux \*/ func[i]->aux->btf = prog->aux->btf; func[i]->aux->func\_info = prog->aux->func\_info;+ func[i]->aux->poke\_tab = prog->aux->poke\_tab;+ func[i]->aux->size\_poke\_tab = prog->aux->size\_poke\_tab;  for (j = 0; j < prog->aux->size\_poke\_tab; j++) {- u32 insn\_idx = prog->aux->poke\_tab[j].insn\_idx;- int ret;+ struct bpf\_jit\_poke\_descriptor \*poke; - if (!(insn\_idx >= subprog\_start &&- insn\_idx <= subprog\_end))- continue;-- ret = bpf\_jit\_add\_poke\_descriptor(func[i],- &prog->aux->poke\_tab[j]);- if (ret < 0) {- verbose(env, "adding tail call poke descriptor failed\n");- goto out\_free;- }-- func[i]->insnsi[insn\_idx - subprog\_start].imm = ret + 1;-- map\_ptr = func[i]->aux->poke\_tab[ret].tail\_call.map;- ret = map\_ptr->ops->map\_poke\_track(map\_ptr, func[i]->aux);- if (ret < 0) {- verbose(env, "tracking tail call prog failed\n");- goto out\_free;- }+ poke = &prog->aux->poke\_tab[j];+ if (poke->insn\_idx < subprog\_end &&+ poke->insn\_idx >= subprog\_start)+ poke->aux = func[i]->aux; }  /\* Use bpf\_prog\_F\_tag to indicate functions in stack traces.@@ -12178,18 +12164,6 @@ static int jit\_subprogs(struct bpf\_verifier\_env \*env) cond\_resched(); } - /\* Untrack main program's aux structs so that during map\_poke\_run()- \* we will not stumble upon the unfilled poke descriptors; each- \* of the main program's poke descs got distributed across subprogs- \* and got tracked onto map, so we are sure that none of them will- \* be missed after the operation below- \*/- for (i = 0; i < prog->aux->size\_poke\_tab; i++) {- map\_ptr = prog->aux->poke\_tab[i].tail\_call.map;-- map\_ptr->ops->map\_poke\_untrack(map\_ptr, prog->aux);- }- /\* at this point all bpf functions were successfully JITed \* now populate all bpf\_calls with correct addresses and \* run last pass of JIT@@ -12267,14 +12241,22 @@ static int jit\_subprogs(struct bpf\_verifier\_env \*env) bpf\_prog\_jit\_attempt\_done(prog); return 0; out\_free:+ /\* We failed JIT'ing, so at this point we need to unregister poke+ \* descriptors from subprogs, so that kernel is not attempting to+ \* patch it anymore as we're freeing the subprog JIT memory.+ \*/+ for (i = 0; i < prog->aux->size\_poke\_tab; i++) {+ map\_ptr = prog->aux->poke\_tab[i].tail\_call.map;+ map\_ptr->ops->map\_poke\_untrack(map\_ptr, prog->aux);+ }+ /\* At this point we're guaranteed that poke descriptors are not+ \* live anymore. We can just unlink its descriptor table as it's+ \* released with the main prog.+ \*/ for (i = 0; i < env->subprog\_cnt; i++) { if (!func[i]) continue;-- for (j = 0; j < func[i]->aux->size\_poke\_tab; j++) {- map\_ptr = func[i]->aux->poke\_tab[j].tail\_call.map;- map\_ptr->ops->map\_poke\_untrack(map\_ptr, func[i]->aux);- }+ func[i]->aux->poke\_tab = NULL; bpf\_jit\_free(func[i]); } kfree(func); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 19:12:34 +0000

