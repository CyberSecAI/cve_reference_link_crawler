

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=a7722921adb046e3836eb84372241f32584bdb07)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a7722921adb046e3836eb84372241f32584bdb07)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a7722921adb046e3836eb84372241f32584bdb07)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a7722921adb046e3836eb84372241f32584bdb07)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Eric Dumazet <edumazet@google.com> | 2024-08-29 14:46:39 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-04 16:33:41 +0200 |
| commit | [a7722921adb046e3836eb84372241f32584bdb07](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a7722921adb046e3836eb84372241f32584bdb07) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=a7722921adb046e3836eb84372241f32584bdb07)) | |
| tree | [ea42f2be0e4b2cff53ad329be4a7387bf2c79724](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=a7722921adb046e3836eb84372241f32584bdb07) | |
| parent | [7679db85a8140b178b155a43ae8a8706bb478dc5](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=7679db85a8140b178b155a43ae8a8706bb478dc5) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a7722921adb046e3836eb84372241f32584bdb07&id2=7679db85a8140b178b155a43ae8a8706bb478dc5)) | |
| download | [linux-a7722921adb046e3836eb84372241f32584bdb07.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-a7722921adb046e3836eb84372241f32584bdb07.tar.gz) | |

icmp: change the order of rate limitscommit 8c2bd38b95f75f3d2a08c93e35303e26d480d24e upstream.
ICMP messages are ratelimited :
After the blamed commits, the two rate limiters are applied in this order:
1) host wide ratelimit (icmp\_global\_allow())
2) Per destination ratelimit (inetpeer based)
In order to avoid side-channels attacks, we need to apply
the per destination check first.
This patch makes the following change :
1) icmp\_global\_allow() checks if the host wide limit is reached.
But credits are not yet consumed. This is deferred to 3)
2) The per destination limit is checked/updated.
This might add a new node in inetpeer tree.
3) icmp\_global\_consume() consumes tokens if prior operations succeeded.
This means that host wide ratelimit is still effective
in keeping inetpeer tree small even under DDOS.
As a bonus, I removed icmp\_global.lock as the fast path
can use a lock-free operation.
Fixes: c0303efeab73 ("net: reduce cycles spend on ICMP replies that gets rate limited")
Fixes: 4cdf507d5452 ("icmp: add a global rate limitation")
Reported-by: Keyu Man <keyu.man@email.ucr.edu>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reviewed-by: David Ahern <dsahern@kernel.org>
Cc: Jesper Dangaard Brouer <hawk@kernel.org>
Cc: stable@vger.kernel.org
Link: [https://patch.msgid.link/20240829144641.3880376-2-edumazet@google.com](https://patch.msgid.link/20240829144641.3880376-2-edumazet%40google.com)
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=a7722921adb046e3836eb84372241f32584bdb07)

| -rw-r--r-- | [include/net/ip.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/include/net/ip.h?id=a7722921adb046e3836eb84372241f32584bdb07) | 2 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/ipv4/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv4/icmp.c?id=a7722921adb046e3836eb84372241f32584bdb07) | 103 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/ipv6/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/net/ipv6/icmp.c?id=a7722921adb046e3836eb84372241f32584bdb07) | 28 | |  |  |  | | --- | --- | --- | |

3 files changed, 76 insertions, 57 deletions

| diff --git a/include/net/ip.h b/include/net/ip.hindex c5606cadb1a552..82248813619e3f 100644--- a/[include/net/ip.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/ip.h?id=7679db85a8140b178b155a43ae8a8706bb478dc5)+++ b/[include/net/ip.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/include/net/ip.h?id=a7722921adb046e3836eb84372241f32584bdb07)@@ -795,6 +795,8 @@ static inline void ip\_cmsg\_recv(struct msghdr \*msg, struct sk\_buff \*skb) }  bool icmp\_global\_allow(void);+void icmp\_global\_consume(void);+ extern int sysctl\_icmp\_msgs\_per\_sec; extern int sysctl\_icmp\_msgs\_burst; diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.cindex ab6d0d98dbc34c..336518e623b280 100644--- a/[net/ipv4/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/icmp.c?id=7679db85a8140b178b155a43ae8a8706bb478dc5)+++ b/[net/ipv4/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv4/icmp.c?id=a7722921adb046e3836eb84372241f32584bdb07)@@ -224,57 +224,59 @@ int sysctl\_icmp\_msgs\_per\_sec \_\_read\_mostly = 1000; int sysctl\_icmp\_msgs\_burst \_\_read\_mostly = 50;  static struct {- spinlock\_t lock;- u32 credit;+ atomic\_t credit; u32 stamp;-} icmp\_global = {- .lock = \_\_SPIN\_LOCK\_UNLOCKED(icmp\_global.lock),-};+} icmp\_global;  /\*\* \* icmp\_global\_allow - Are we allowed to send one more ICMP message ? \* \* Uses a token bucket to limit our ICMP messages to ~sysctl\_icmp\_msgs\_per\_sec. \* Returns false if we reached the limit and can not send another packet.- \* Note: called with BH disabled+ \* Works in tandem with icmp\_global\_consume(). \*/ bool icmp\_global\_allow(void) {- u32 credit, delta, incr = 0, now = (u32)jiffies;- bool rc = false;+ u32 delta, now, oldstamp;+ int incr, new, old; - /\* Check if token bucket is empty and cannot be refilled- \* without taking the spinlock. The READ\_ONCE() are paired- \* with the following WRITE\_ONCE() in this same function.+ /\* Note: many cpus could find this condition true.+ \* Then later icmp\_global\_consume() could consume more credits,+ \* this is an acceptable race. \*/- if (!READ\_ONCE(icmp\_global.credit)) {- delta = min\_t(u32, now - READ\_ONCE(icmp\_global.stamp), HZ);- if (delta < HZ / 50)- return false;- }+ if (atomic\_read(&icmp\_global.credit) > 0)+ return true; - spin\_lock(&icmp\_global.lock);- delta = min\_t(u32, now - icmp\_global.stamp, HZ);- if (delta >= HZ / 50) {- incr = READ\_ONCE(sysctl\_icmp\_msgs\_per\_sec) \* delta / HZ;- if (incr)- WRITE\_ONCE(icmp\_global.stamp, now);- }- credit = min\_t(u32, icmp\_global.credit + incr,- READ\_ONCE(sysctl\_icmp\_msgs\_burst));- if (credit) {- /\* We want to use a credit of one in average, but need to randomize- \* it for security reasons.- \*/- credit = max\_t(int, credit - get\_random\_u32\_below(3), 0);- rc = true;+ now = jiffies;+ oldstamp = READ\_ONCE(icmp\_global.stamp);+ delta = min\_t(u32, now - oldstamp, HZ);+ if (delta < HZ / 50)+ return false;++ incr = READ\_ONCE(sysctl\_icmp\_msgs\_per\_sec) \* delta / HZ;+ if (!incr)+ return false;++ if (cmpxchg(&icmp\_global.stamp, oldstamp, now) == oldstamp) {+ old = atomic\_read(&icmp\_global.credit);+ do {+ new = min(old + incr, READ\_ONCE(sysctl\_icmp\_msgs\_burst));+ } while (!atomic\_try\_cmpxchg(&icmp\_global.credit, &old, new)); }- WRITE\_ONCE(icmp\_global.credit, credit);- spin\_unlock(&icmp\_global.lock);- return rc;+ return true; } EXPORT\_SYMBOL(icmp\_global\_allow); +void icmp\_global\_consume(void)+{+ int credits = get\_random\_u32\_below(3);++ /\* Note: this might make icmp\_global.credit negative. \*/+ if (credits)+ atomic\_sub(credits, &icmp\_global.credit);+}+EXPORT\_SYMBOL(icmp\_global\_consume);+ static bool icmpv4\_mask\_allow(struct net \*net, int type, int code) { if (type > NR\_ICMP\_TYPES)@@ -291,14 +293,16 @@ static bool icmpv4\_mask\_allow(struct net \*net, int type, int code) return false; } -static bool icmpv4\_global\_allow(struct net \*net, int type, int code)+static bool icmpv4\_global\_allow(struct net \*net, int type, int code,+ bool \*apply\_ratelimit) { if (icmpv4\_mask\_allow(net, type, code)) return true; - if (icmp\_global\_allow())+ if (icmp\_global\_allow()) {+ \*apply\_ratelimit = true; return true;-+ } \_\_ICMP\_INC\_STATS(net, ICMP\_MIB\_RATELIMITGLOBAL); return false; }@@ -308,15 +312,16 @@ static bool icmpv4\_global\_allow(struct net \*net, int type, int code) \*/  static bool icmpv4\_xrlim\_allow(struct net \*net, struct rtable \*rt,- struct flowi4 \*fl4, int type, int code)+ struct flowi4 \*fl4, int type, int code,+ bool apply\_ratelimit) { struct dst\_entry \*dst = &rt->dst; struct inet\_peer \*peer; bool rc = true; int vif; - if (icmpv4\_mask\_allow(net, type, code))- goto out;+ if (!apply\_ratelimit)+ return true;  /\* No rate limit on loopback \*/ if (dst->dev && (dst->dev->flags&IFF\_LOOPBACK))@@ -331,6 +336,8 @@ static bool icmpv4\_xrlim\_allow(struct net \*net, struct rtable \*rt, out: if (!rc) \_\_ICMP\_INC\_STATS(net, ICMP\_MIB\_RATELIMITHOST);+ else+ icmp\_global\_consume(); return rc; } @@ -402,6 +409,7 @@ static void icmp\_reply(struct icmp\_bxm \*icmp\_param, struct sk\_buff \*skb) struct ipcm\_cookie ipc; struct rtable \*rt = skb\_rtable(skb); struct net \*net = dev\_net(rt->dst.dev);+ bool apply\_ratelimit = false; struct flowi4 fl4; struct sock \*sk; struct inet\_sock \*inet;@@ -413,11 +421,11 @@ static void icmp\_reply(struct icmp\_bxm \*icmp\_param, struct sk\_buff \*skb) if (ip\_options\_echo(net, &icmp\_param->replyopts.opt.opt, skb)) return; - /\* Needed by both icmp\_global\_allow and icmp\_xmit\_lock \*/+ /\* Needed by both icmpv4\_global\_allow and icmp\_xmit\_lock \*/ local\_bh\_disable(); - /\* global icmp\_msgs\_per\_sec \*/- if (!icmpv4\_global\_allow(net, type, code))+ /\* is global icmp\_msgs\_per\_sec exhausted ? \*/+ if (!icmpv4\_global\_allow(net, type, code, &apply\_ratelimit)) goto out\_bh\_enable;  sk = icmp\_xmit\_lock(net);@@ -450,7 +458,7 @@ static void icmp\_reply(struct icmp\_bxm \*icmp\_param, struct sk\_buff \*skb) rt = ip\_route\_output\_key(net, &fl4); if (IS\_ERR(rt)) goto out\_unlock;- if (icmpv4\_xrlim\_allow(net, rt, &fl4, type, code))+ if (icmpv4\_xrlim\_allow(net, rt, &fl4, type, code, apply\_ratelimit)) icmp\_push\_reply(sk, icmp\_param, &fl4, &ipc, &rt); ip\_rt\_put(rt); out\_unlock:@@ -596,6 +604,7 @@ void \_\_icmp\_send(struct sk\_buff \*skb\_in, int type, int code, \_\_be32 info, int room; struct icmp\_bxm icmp\_param; struct rtable \*rt = skb\_rtable(skb\_in);+ bool apply\_ratelimit = false; struct ipcm\_cookie ipc; struct flowi4 fl4; \_\_be32 saddr;@@ -677,7 +686,7 @@ void \_\_icmp\_send(struct sk\_buff \*skb\_in, int type, int code, \_\_be32 info, } } - /\* Needed by both icmp\_global\_allow and icmp\_xmit\_lock \*/+ /\* Needed by both icmpv4\_global\_allow and icmp\_xmit\_lock \*/ local\_bh\_disable();  /\* Check global sysctl\_icmp\_msgs\_per\_sec ratelimit, unless@@ -685,7 +694,7 @@ void \_\_icmp\_send(struct sk\_buff \*skb\_in, int type, int code, \_\_be32 info, \* loopback, then peer ratelimit still work (in icmpv4\_xrlim\_allow) \*/ if (!(skb\_in->dev && (skb\_in->dev->flags&IFF\_LOOPBACK)) &&- !icmpv4\_global\_allow(net, type, code))+ !icmpv4\_global\_allow(net, type, code, &apply\_ratelimit)) goto out\_bh\_enable;  sk = icmp\_xmit\_lock(net);@@ -744,7 +753,7 @@ void \_\_icmp\_send(struct sk\_buff \*skb\_in, int type, int code, \_\_be32 info, goto out\_unlock;  /\* peer icmp\_ratelimit \*/- if (!icmpv4\_xrlim\_allow(net, rt, &fl4, type, code))+ if (!icmpv4\_xrlim\_allow(net, rt, &fl4, type, code, apply\_ratelimit)) goto ende;  /\* RFC says return as much as we can without exceeding 576 bytes. \*/diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.cindex 7b31674644efc3..46f70e4a835139 100644--- a/[net/ipv6/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/icmp.c?id=7679db85a8140b178b155a43ae8a8706bb478dc5)+++ b/[net/ipv6/icmp.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/net/ipv6/icmp.c?id=a7722921adb046e3836eb84372241f32584bdb07)@@ -175,14 +175,16 @@ static bool icmpv6\_mask\_allow(struct net \*net, int type) return false; } -static bool icmpv6\_global\_allow(struct net \*net, int type)+static bool icmpv6\_global\_allow(struct net \*net, int type,+ bool \*apply\_ratelimit) { if (icmpv6\_mask\_allow(net, type)) return true; - if (icmp\_global\_allow())+ if (icmp\_global\_allow()) {+ \*apply\_ratelimit = true; return true;-+ } \_\_ICMP\_INC\_STATS(net, ICMP\_MIB\_RATELIMITGLOBAL); return false; }@@ -191,13 +193,13 @@ static bool icmpv6\_global\_allow(struct net \*net, int type) \* Check the ICMP output rate limit \*/ static bool icmpv6\_xrlim\_allow(struct sock \*sk, u8 type,- struct flowi6 \*fl6)+ struct flowi6 \*fl6, bool apply\_ratelimit) { struct net \*net = sock\_net(sk); struct dst\_entry \*dst; bool res = false; - if (icmpv6\_mask\_allow(net, type))+ if (!apply\_ratelimit) return true;  /\*@@ -228,6 +230,8 @@ static bool icmpv6\_xrlim\_allow(struct sock \*sk, u8 type, if (!res) \_\_ICMP6\_INC\_STATS(net, ip6\_dst\_idev(dst), ICMP6\_MIB\_RATELIMITHOST);+ else+ icmp\_global\_consume(); dst\_release(dst); return res; }@@ -452,6 +456,7 @@ void icmp6\_send(struct sk\_buff \*skb, u8 type, u8 code, \_\_u32 info, struct net \*net; struct ipv6\_pinfo \*np; const struct in6\_addr \*saddr = NULL;+ bool apply\_ratelimit = false; struct dst\_entry \*dst; struct icmp6hdr tmp\_hdr; struct flowi6 fl6;@@ -533,11 +538,12 @@ void icmp6\_send(struct sk\_buff \*skb, u8 type, u8 code, \_\_u32 info, return; } - /\* Needed by both icmp\_global\_allow and icmpv6\_xmit\_lock \*/+ /\* Needed by both icmpv6\_global\_allow and icmpv6\_xmit\_lock \*/ local\_bh\_disable();  /\* Check global sysctl\_icmp\_msgs\_per\_sec ratelimit \*/- if (!(skb->dev->flags & IFF\_LOOPBACK) && !icmpv6\_global\_allow(net, type))+ if (!(skb->dev->flags & IFF\_LOOPBACK) &&+ !icmpv6\_global\_allow(net, type, &apply\_ratelimit)) goto out\_bh\_enable;  mip6\_addr\_swap(skb, parm);@@ -575,7 +581,7 @@ void icmp6\_send(struct sk\_buff \*skb, u8 type, u8 code, \_\_u32 info,  np = inet6\_sk(sk); - if (!icmpv6\_xrlim\_allow(sk, type, &fl6))+ if (!icmpv6\_xrlim\_allow(sk, type, &fl6, apply\_ratelimit)) goto out;  tmp\_hdr.icmp6\_type = type;@@ -717,6 +723,7 @@ static enum skb\_drop\_reason icmpv6\_echo\_reply(struct sk\_buff \*skb) struct ipv6\_pinfo \*np; const struct in6\_addr \*saddr = NULL; struct icmp6hdr \*icmph = icmp6\_hdr(skb);+ bool apply\_ratelimit = false; struct icmp6hdr tmp\_hdr; struct flowi6 fl6; struct icmpv6\_msg msg;@@ -781,8 +788,9 @@ static enum skb\_drop\_reason icmpv6\_echo\_reply(struct sk\_buff \*skb) goto out;  /\* Check the ratelimit \*/- if ((!(skb->dev->flags & IFF\_LOOPBACK) && !icmpv6\_global\_allow(net, ICMPV6\_ECHO\_REPLY)) ||- !icmpv6\_xrlim\_allow(sk, ICMPV6\_ECHO\_REPLY, &fl6))+ if ((!(skb->dev->flags & IFF\_LOOPBACK) &&+ !icmpv6\_global\_allow(net, ICMPV6\_ECHO\_REPLY, &apply\_ratelimit)) ||+ !icmpv6\_xrlim\_allow(sk, ICMPV6\_ECHO\_REPLY, &fl6, apply\_ratelimit)) goto out\_dst\_release;  idev = \_\_in6\_dev\_get(skb->dev); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 21:14:28 +0000

