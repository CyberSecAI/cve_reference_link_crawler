

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Przemyslaw Patynowski <przemyslawx.patynowski@intel.com> | 2022-08-11 12:09:22 +0200 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2022-09-15 10:47:15 +0200 |
| commit | [07f40e9f0ff342eb3e97d5c544783b7cb641689c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)) | |
| tree | [d05474aac000ec25dfa9840a7ae94438a2bb66cc](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) | |
| parent | [6730c48ed6b0cd939fc9b30b2d621ce0b89bea83](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c&id2=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83)) | |
| download | [linux-07f40e9f0ff342eb3e97d5c544783b7cb641689c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-07f40e9f0ff342eb3e97d5c544783b7cb641689c.tar.gz) | |

ice: Fix DMA mappings leak[ Upstream commit 7e753eb675f0523207b184558638ee2eed6c9ac2 ]
Fix leak, when user changes ring parameters.
During reallocation of RX buffers, new DMA mappings are created for
those buffers. New buffers with different RX ring count should
substitute older ones, but those buffers were freed in ice\_vsi\_cfg\_rxq
and reallocated again with ice\_alloc\_rx\_buf. kfree on rx\_buf caused
leak of already mapped DMA.
Reallocate ZC with xdp\_buf struct, when BPF program loads. Reallocate
back to rx\_buf, when BPF program unloads.
If BPF program is loaded/unloaded and XSK pools are created, reallocate
RX queues accordingly in XDP\_SETUP\_XSK\_POOL handler.
Steps for reproduction:
while :
do
for ((i=0; i<=8160; i=i+32))
do
ethtool -G enp130s0f0 rx $i tx $i
sleep 0.5
ethtool -g enp130s0f0
done
done
Fixes: 617f3e1b588c ("ice: xsk: allocate separate memory for XDP SW ring")
Signed-off-by: Przemyslaw Patynowski <przemyslawx.patynowski@intel.com>
Signed-off-by: Mateusz Palczewski <mateusz.palczewski@intel.com>
Tested-by: Chandan <chandanx.rout@intel.com> (A Contingent Worker at Intel)
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)

| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_base.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) | 17 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_main.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_xsk.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) | 63 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/net/ethernet/intel/ice/ice\_xsk.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/ice/ice_xsk.h?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c) | 8 | |  |  |  | | --- | --- | --- | |

4 files changed, 79 insertions, 17 deletions

| diff --git a/drivers/net/ethernet/intel/ice/ice\_base.c b/drivers/net/ethernet/intel/ice/ice\_base.cindex 136d7911adb489..1e324380817808 100644--- a/[drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_base.c?id=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83)+++ b/[drivers/net/ethernet/intel/ice/ice\_base.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_base.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)@@ -7,18 +7,6 @@ #include "ice\_dcb\_lib.h" #include "ice\_sriov.h" -static bool ice\_alloc\_rx\_buf\_zc(struct ice\_rx\_ring \*rx\_ring)-{- rx\_ring->xdp\_buf = kcalloc(rx\_ring->count, sizeof(\*rx\_ring->xdp\_buf), GFP\_KERNEL);- return !!rx\_ring->xdp\_buf;-}--static bool ice\_alloc\_rx\_buf(struct ice\_rx\_ring \*rx\_ring)-{- rx\_ring->rx\_buf = kcalloc(rx\_ring->count, sizeof(\*rx\_ring->rx\_buf), GFP\_KERNEL);- return !!rx\_ring->rx\_buf;-}- /\*\* \* \_\_ice\_vsi\_get\_qs\_contig - Assign a contiguous chunk of queues to VSI \* @qs\_cfg: gathered variables needed for PF->VSI queues assignment@@ -519,11 +507,8 @@ int ice\_vsi\_cfg\_rxq(struct ice\_rx\_ring \*ring) xdp\_rxq\_info\_reg(&ring->xdp\_rxq, ring->netdev, ring->q\_index, ring->q\_vector->napi.napi\_id); - kfree(ring->rx\_buf); ring->xsk\_pool = ice\_xsk\_pool(ring); if (ring->xsk\_pool) {- if (!ice\_alloc\_rx\_buf\_zc(ring))- return -ENOMEM; xdp\_rxq\_info\_unreg\_mem\_model(&ring->xdp\_rxq);  ring->rx\_buf\_len =@@ -538,8 +523,6 @@ int ice\_vsi\_cfg\_rxq(struct ice\_rx\_ring \*ring) dev\_info(dev, "Registered XDP mem model MEM\_TYPE\_XSK\_BUFF\_POOL on Rx ring %d\n", ring->q\_index); } else {- if (!ice\_alloc\_rx\_buf(ring))- return -ENOMEM; if (!xdp\_rxq\_info\_is\_reg(&ring->xdp\_rxq)) /\* coverity[check\_return] \*/ xdp\_rxq\_info\_reg(&ring->xdp\_rxq,diff --git a/drivers/net/ethernet/intel/ice/ice\_main.c b/drivers/net/ethernet/intel/ice/ice\_main.cindex 3d45e075204e35..abc5d2b91f32b9 100644--- a/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83)+++ b/[drivers/net/ethernet/intel/ice/ice\_main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_main.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)@@ -2898,10 +2898,18 @@ ice\_xdp\_setup\_prog(struct ice\_vsi \*vsi, struct bpf\_prog \*prog, if (xdp\_ring\_err) NL\_SET\_ERR\_MSG\_MOD(extack, "Setting up XDP Tx resources failed"); }+ /\* reallocate Rx queues that are used for zero-copy \*/+ xdp\_ring\_err = ice\_realloc\_zc\_buf(vsi, true);+ if (xdp\_ring\_err)+ NL\_SET\_ERR\_MSG\_MOD(extack, "Setting up XDP Rx resources failed"); } else if (ice\_is\_xdp\_ena\_vsi(vsi) && !prog) { xdp\_ring\_err = ice\_destroy\_xdp\_rings(vsi); if (xdp\_ring\_err) NL\_SET\_ERR\_MSG\_MOD(extack, "Freeing XDP Tx resources failed");+ /\* reallocate Rx queues that were used for zero-copy \*/+ xdp\_ring\_err = ice\_realloc\_zc\_buf(vsi, false);+ if (xdp\_ring\_err)+ NL\_SET\_ERR\_MSG\_MOD(extack, "Freeing XDP Rx resources failed"); } else { /\* safe to call even when prog == vsi->xdp\_prog as \* dev\_xdp\_install in net/core/dev.c incremented prog'sdiff --git a/drivers/net/ethernet/intel/ice/ice\_xsk.c b/drivers/net/ethernet/intel/ice/ice\_xsk.cindex e48e29258450f8..03ce85f6e6df8f 100644--- a/[drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.c?id=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83)+++ b/[drivers/net/ethernet/intel/ice/ice\_xsk.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.c?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)@@ -192,6 +192,7 @@ static int ice\_qp\_dis(struct ice\_vsi \*vsi, u16 q\_idx) err = ice\_vsi\_ctrl\_one\_rx\_ring(vsi, false, q\_idx, true); if (err) return err;+ ice\_clean\_rx\_ring(rx\_ring);  ice\_qvec\_toggle\_napi(vsi, q\_vector, false); ice\_qp\_clean\_rings(vsi, q\_idx);@@ -317,6 +318,62 @@ ice\_xsk\_pool\_enable(struct ice\_vsi \*vsi, struct xsk\_buff\_pool \*pool, u16 qid) }  /\*\*+ \* ice\_realloc\_rx\_xdp\_bufs - reallocate for either XSK or normal buffer+ \* @rx\_ring: Rx ring+ \* @pool\_present: is pool for XSK present+ \*+ \* Try allocating memory and return ENOMEM, if failed to allocate.+ \* If allocation was successful, substitute buffer with allocated one.+ \* Returns 0 on success, negative on failure+ \*/+static int+ice\_realloc\_rx\_xdp\_bufs(struct ice\_rx\_ring \*rx\_ring, bool pool\_present)+{+ size\_t elem\_size = pool\_present ? sizeof(\*rx\_ring->xdp\_buf) :+ sizeof(\*rx\_ring->rx\_buf);+ void \*sw\_ring = kcalloc(rx\_ring->count, elem\_size, GFP\_KERNEL);++ if (!sw\_ring)+ return -ENOMEM;++ if (pool\_present) {+ kfree(rx\_ring->rx\_buf);+ rx\_ring->rx\_buf = NULL;+ rx\_ring->xdp\_buf = sw\_ring;+ } else {+ kfree(rx\_ring->xdp\_buf);+ rx\_ring->xdp\_buf = NULL;+ rx\_ring->rx\_buf = sw\_ring;+ }++ return 0;+}++/\*\*+ \* ice\_realloc\_zc\_buf - reallocate XDP ZC queue pairs+ \* @vsi: Current VSI+ \* @zc: is zero copy set+ \*+ \* Reallocate buffer for rx\_rings that might be used by XSK.+ \* XDP requires more memory, than rx\_buf provides.+ \* Returns 0 on success, negative on failure+ \*/+int ice\_realloc\_zc\_buf(struct ice\_vsi \*vsi, bool zc)+{+ struct ice\_rx\_ring \*rx\_ring;+ unsigned long q;++ for\_each\_set\_bit(q, vsi->af\_xdp\_zc\_qps,+ max\_t(int, vsi->alloc\_txq, vsi->alloc\_rxq)) {+ rx\_ring = vsi->rx\_rings[q];+ if (ice\_realloc\_rx\_xdp\_bufs(rx\_ring, zc))+ return -ENOMEM;+ }++ return 0;+}++/\*\* \* ice\_xsk\_pool\_setup - enable/disable a buffer pool region depending on its state \* @vsi: Current VSI \* @pool: buffer pool to enable/associate to a ring, NULL to disable@@ -345,11 +402,17 @@ int ice\_xsk\_pool\_setup(struct ice\_vsi \*vsi, struct xsk\_buff\_pool \*pool, u16 qid) if\_running = netif\_running(vsi->netdev) && ice\_is\_xdp\_ena\_vsi(vsi);  if (if\_running) {+ struct ice\_rx\_ring \*rx\_ring = vsi->rx\_rings[qid];+ ret = ice\_qp\_dis(vsi, qid); if (ret) { netdev\_err(vsi->netdev, "ice\_qp\_dis error = %d\n", ret); goto xsk\_pool\_if\_up; }++ ret = ice\_realloc\_rx\_xdp\_bufs(rx\_ring, pool\_present);+ if (ret)+ goto xsk\_pool\_if\_up; }  pool\_failure = pool\_present ? ice\_xsk\_pool\_enable(vsi, pool, qid) :diff --git a/drivers/net/ethernet/intel/ice/ice\_xsk.h b/drivers/net/ethernet/intel/ice/ice\_xsk.hindex 21faec8e97db1c..4edbe81eb6460e 100644--- a/[drivers/net/ethernet/intel/ice/ice\_xsk.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.h?id=6730c48ed6b0cd939fc9b30b2d621ce0b89bea83)+++ b/[drivers/net/ethernet/intel/ice/ice\_xsk.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/ice/ice_xsk.h?id=07f40e9f0ff342eb3e97d5c544783b7cb641689c)@@ -27,6 +27,7 @@ bool ice\_xsk\_any\_rx\_ring\_ena(struct ice\_vsi \*vsi); void ice\_xsk\_clean\_rx\_ring(struct ice\_rx\_ring \*rx\_ring); void ice\_xsk\_clean\_xdp\_ring(struct ice\_tx\_ring \*xdp\_ring); bool ice\_xmit\_zc(struct ice\_tx\_ring \*xdp\_ring, u32 budget, int napi\_budget);+int ice\_realloc\_zc\_buf(struct ice\_vsi \*vsi, bool zc); #else static inline bool ice\_xmit\_zc(struct ice\_tx\_ring \_\_always\_unused \*xdp\_ring,@@ -72,5 +73,12 @@ ice\_xsk\_wakeup(struct net\_device \_\_always\_unused \*netdev,  static inline void ice\_xsk\_clean\_rx\_ring(struct ice\_rx\_ring \*rx\_ring) { } static inline void ice\_xsk\_clean\_xdp\_ring(struct ice\_tx\_ring \*xdp\_ring) { }++static inline int+ice\_realloc\_zc\_buf(struct ice\_vsi \_\_always\_unused \*vsi,+ bool \_\_always\_unused zc)+{+ return 0;+} #endif /\* CONFIG\_XDP\_SOCKETS \*/ #endif /\* !\_ICE\_XSK\_H\_ \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 23:34:47 +0000

