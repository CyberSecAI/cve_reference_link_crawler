

[Skip to content](#main)

[WordPress.org](https://wordpress.org/)

* [News](https://wordpress.org/news/)
* [Download & Extend](https://wordpress.org/download/)
  + [Get WordPress](https://wordpress.org/download/)
  + [Themes](https://wordpress.org/themes/)
  + [Patterns](https://wordpress.org/patterns/)
  + [Plugins](https://wordpress.org/plugins/)
  + [Mobile](https://wordpress.org/mobile/)
  + [Hosting](https://wordpress.org/hosting/)
  + [Openverse ↗︎](https://openverse.org/)
* [Learn](https://learn.wordpress.org/)
  + [Learn WordPress](https://learn.wordpress.org/)
  + [Documentation](https://wordpress.org/documentation/)
  + [Forums](https://wordpress.org/support/forums/)
  + [Developers](https://developer.wordpress.org/)
  + [WordPress.tv ↗︎](https://wordpress.tv/)
* [Community](https://make.wordpress.org/)
  + [Make WordPress](https://make.wordpress.org/)
  + [Photo Directory](https://wordpress.org/photos/)
  + [Five for the Future](https://wordpress.org/five-for-the-future/)
  + [WordCamp ↗︎](https://central.wordcamp.org/)
  + [Meetups ↗︎](https://www.meetup.com/pro/wordpress/)
  + [Job Board ↗︎](https://jobs.wordpress.net/)
* [About](https://wordpress.org/about/)
  + [About WordPress](https://wordpress.org/about/)
  + [Showcase](https://wordpress.org/showcase/)
  + [Enterprise](https://wordpress.org/enterprise/)
  + [Gutenberg ↗︎](https://wordpress.org/gutenberg/)
  + [WordPress Swag Store ↗︎](https://mercantile.wordpress.org/)
* [Get WordPress](https://wordpress.org/download/)

Search Trac

[Get WordPress](https://wordpress.org/download/)

## [Plugin Directory](//wordpress.org/plugins/)

Search:

* [Login](https://login.wordpress.org/?redirect_to=http%3A%2F%2Fplugins.trac.wordpress.org%2Fbrowser%2Fbdthemes-element-pack-lite%2Ftrunk%2Fassets%2Fjs%2Fbdt-uikit.js)

* [Timeline](/timeline)
* [View Tickets](/report)
* [Browse Source](/browser)

## Context Navigation

* ← [Previous Revision](/browser/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js?rev=3117663 "Revision 3117663")
* Next Revision →
* [Blame](/browser/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js?annotate=blame "Annotate each line with the last changed revision (this can be time consuming...)")
* [Revision Log](/log/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js)

---

# [source:](/browser?order=name "Go to repository root") [bdthemes-element-pack-lite](/browser/bdthemes-element-pack-lite?order=name "View bdthemes-element-pack-lite")/[trunk](/browser/bdthemes-element-pack-lite/trunk?order=name "View trunk")/[assets](/browser/bdthemes-element-pack-lite/trunk/assets?order=name "View assets")/[js](/browser/bdthemes-element-pack-lite/trunk/assets/js?order=name "View js")/[bdt-uikit.js](/browser/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js?order=name "View bdt-uikit.js")

View diff against:

View revision:

| [Last change](/changeset/3126487/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js "View differences") on this file was [3126487](/changeset/3126487/ "View changeset 3126487"), checked in by mohammaadfarid, [6 months ago](/timeline?from=2024-07-27T11%3A20%3A40Z&precision=second "See timeline at 07/27/2024 11:20:40 AM") |
| --- |
| readme.txt |
| **File size:** 317.7 KB | |

| Line |  |
| --- | --- |
| [1](#L1) | /\*! bdtUIkit 3.21.7 | https://www.getuikit.com | (c) 2014 - 2024 YOOtheme | MIT License \*/ |
| [2](#L2) |  |
| [3](#L3) | (function (global, factory) { |
| [4](#L4) | typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : |
| [5](#L5) | typeof define === 'function' && define.amd ? define('uikit', factory) : |
| [6](#L6) | (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bdtUIkit = factory()); |
| [7](#L7) | })(this, (function () { 'use strict'; |
| [8](#L8) |  |
| [9](#L9) | const { hasOwnProperty, toString } = Object.prototype; |
| [10](#L10) | function hasOwn(obj, key) { |
| [11](#L11) | return hasOwnProperty.call(obj, key); |
| [12](#L12) | } |
| [13](#L13) | const hyphenateRe = /\B([A-Z])/g; |
| [14](#L14) | const hyphenate = memoize((str) => str.replace(hyphenateRe, "-$1").toLowerCase()); |
| [15](#L15) | const camelizeRe = /-(\w)/g; |
| [16](#L16) | const camelize = memoize( |
| [17](#L17) | (str) => (str.charAt(0).toLowerCase() + str.slice(1)).replace(camelizeRe, (\_, c) => c.toUpperCase()) |
| [18](#L18) | ); |
| [19](#L19) | const ucfirst = memoize((str) => str.charAt(0).toUpperCase() + str.slice(1)); |
| [20](#L20) | function startsWith(str, search) { |
| [21](#L21) | var \_a; |
| [22](#L22) | return (\_a = str == null ? void 0 : str.startsWith) == null ? void 0 : \_a.call(str, search); |
| [23](#L23) | } |
| [24](#L24) | function endsWith(str, search) { |
| [25](#L25) | var \_a; |
| [26](#L26) | return (\_a = str == null ? void 0 : str.endsWith) == null ? void 0 : \_a.call(str, search); |
| [27](#L27) | } |
| [28](#L28) | function includes(obj, search) { |
| [29](#L29) | var \_a; |
| [30](#L30) | return (\_a = obj == null ? void 0 : obj.includes) == null ? void 0 : \_a.call(obj, search); |
| [31](#L31) | } |
| [32](#L32) | function findIndex(array, predicate) { |
| [33](#L33) | var \_a; |
| [34](#L34) | return (\_a = array == null ? void 0 : array.findIndex) == null ? void 0 : \_a.call(array, predicate); |
| [35](#L35) | } |
| [36](#L36) | const { isArray, from: toArray } = Array; |
| [37](#L37) | const { assign } = Object; |
| [38](#L38) | function isFunction(obj) { |
| [39](#L39) | return typeof obj === "function"; |
| [40](#L40) | } |
| [41](#L41) | function isObject(obj) { |
| [42](#L42) | return obj !== null && typeof obj === "object"; |
| [43](#L43) | } |
| [44](#L44) | function isPlainObject(obj) { |
| [45](#L45) | return toString.call(obj) === "[object Object]"; |
| [46](#L46) | } |
| [47](#L47) | function isWindow(obj) { |
| [48](#L48) | return isObject(obj) && obj === obj.window; |
| [49](#L49) | } |
| [50](#L50) | function isDocument(obj) { |
| [51](#L51) | return nodeType(obj) === 9; |
| [52](#L52) | } |
| [53](#L53) | function isNode(obj) { |
| [54](#L54) | return nodeType(obj) >= 1; |
| [55](#L55) | } |
| [56](#L56) | function isElement(obj) { |
| [57](#L57) | return nodeType(obj) === 1; |
| [58](#L58) | } |
| [59](#L59) | function nodeType(obj) { |
| [60](#L60) | return !isWindow(obj) && isObject(obj) && obj.nodeType; |
| [61](#L61) | } |
| [62](#L62) | function isBoolean(value) { |
| [63](#L63) | return typeof value === "boolean"; |
| [64](#L64) | } |
| [65](#L65) | function isString(value) { |
| [66](#L66) | return typeof value === "string"; |
| [67](#L67) | } |
| [68](#L68) | function isNumber(value) { |
| [69](#L69) | return typeof value === "number"; |
| [70](#L70) | } |
| [71](#L71) | function isNumeric(value) { |
| [72](#L72) | return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value)); |
| [73](#L73) | } |
| [74](#L74) | function isEmpty(obj) { |
| [75](#L75) | return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false); |
| [76](#L76) | } |
| [77](#L77) | function isUndefined(value) { |
| [78](#L78) | return value === void 0; |
| [79](#L79) | } |
| [80](#L80) | function toBoolean(value) { |
| [81](#L81) | return isBoolean(value) ? value : value === "true" || value === "1" || value === "" ? true : value === "false" || value === "0" ? false : value; |
| [82](#L82) | } |
| [83](#L83) | function toNumber(value) { |
| [84](#L84) | const number = Number(value); |
| [85](#L85) | return isNaN(number) ? false : number; |
| [86](#L86) | } |
| [87](#L87) | function toFloat(value) { |
| [88](#L88) | return parseFloat(value) || 0; |
| [89](#L89) | } |
| [90](#L90) | function toNode(element) { |
| [91](#L91) | return element && toNodes(element)[0]; |
| [92](#L92) | } |
| [93](#L93) | function toNodes(element) { |
| [94](#L94) | return isNode(element) ? [element] : Array.from(element || []).filter(isNode); |
| [95](#L95) | } |
| [96](#L96) | function toWindow(element) { |
| [97](#L97) | if (isWindow(element)) { |
| [98](#L98) | return element; |
| [99](#L99) | } |
| [100](#L100) | element = toNode(element); |
| [101](#L101) | const document = isDocument(element) ? element : element == null ? void 0 : element.ownerDocument; |
| [102](#L102) | return (document == null ? void 0 : document.defaultView) || window; |
| [103](#L103) | } |
| [104](#L104) | function isEqual(value, other) { |
| [105](#L105) | return value === other || isObject(value) && isObject(other) && Object.keys(value).length === Object.keys(other).length && each(value, (val, key) => val === other[key]); |
| [106](#L106) | } |
| [107](#L107) | function swap(value, a, b) { |
| [108](#L108) | return value.replace(new RegExp(`${a}|${b}`, "g"), (match) => match === a ? b : a); |
| [109](#L109) | } |
| [110](#L110) | function last(array) { |
| [111](#L111) | return array[array.length - 1]; |
| [112](#L112) | } |
| [113](#L113) | function each(obj, cb) { |
| [114](#L114) | for (const key in obj) { |
| [115](#L115) | if (false === cb(obj[key], key)) { |
| [116](#L116) | return false; |
| [117](#L117) | } |
| [118](#L118) | } |
| [119](#L119) | return true; |
| [120](#L120) | } |
| [121](#L121) | function sortBy(array, prop) { |
| [122](#L122) | return array.slice().sort( |
| [123](#L123) | ({ [prop]: propA = 0 }, { [prop]: propB = 0 }) => propA > propB ? 1 : propB > propA ? -1 : 0 |
| [124](#L124) | ); |
| [125](#L125) | } |
| [126](#L126) | function sumBy(array, iteratee) { |
| [127](#L127) | return array.reduce( |
| [128](#L128) | (sum, item) => sum + toFloat(isFunction(iteratee) ? iteratee(item) : item[iteratee]), |
| [129](#L129) | 0 |
| [130](#L130) | ); |
| [131](#L131) | } |
| [132](#L132) | function uniqueBy(array, prop) { |
| [133](#L133) | const seen = /\* @\_\_PURE\_\_ \*/ new Set(); |
| [134](#L134) | return array.filter(({ [prop]: check }) => seen.has(check) ? false : seen.add(check)); |
| [135](#L135) | } |
| [136](#L136) | function pick(obj, props) { |
| [137](#L137) | return props.reduce((res, prop) => ({ ...res, [prop]: obj[prop] }), {}); |
| [138](#L138) | } |
| [139](#L139) | function clamp(number, min = 0, max = 1) { |
| [140](#L140) | return Math.min(Math.max(toNumber(number) || 0, min), max); |
| [141](#L141) | } |
| [142](#L142) | function noop() { |
| [143](#L143) | } |
| [144](#L144) | function intersectRect(...rects) { |
| [145](#L145) | return [ |
| [146](#L146) | ["bottom", "top"], |
| [147](#L147) | ["right", "left"] |
| [148](#L148) | ].every( |
| [149](#L149) | ([minProp, maxProp]) => Math.min(...rects.map(({ [minProp]: min }) => min)) - Math.max(...rects.map(({ [maxProp]: max }) => max)) > 0 |
| [150](#L150) | ); |
| [151](#L151) | } |
| [152](#L152) | function pointInRect(point, rect) { |
| [153](#L153) | return point.x <= rect.right && point.x >= rect.left && point.y <= rect.bottom && point.y >= rect.top; |
| [154](#L154) | } |
| [155](#L155) | function ratio(dimensions, prop, value) { |
| [156](#L156) | const aProp = prop === "width" ? "height" : "width"; |
| [157](#L157) | return { |
| [158](#L158) | [aProp]: dimensions[prop] ? Math.round(value \* dimensions[aProp] / dimensions[prop]) : dimensions[aProp], |
| [159](#L159) | [prop]: value |
| [160](#L160) | }; |
| [161](#L161) | } |
| [162](#L162) | function contain(dimensions, maxDimensions) { |
| [163](#L163) | dimensions = { ...dimensions }; |
| [164](#L164) | for (const prop in dimensions) { |
| [165](#L165) | dimensions = dimensions[prop] > maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions; |
| [166](#L166) | } |
| [167](#L167) | return dimensions; |
| [168](#L168) | } |
| [169](#L169) | function cover$1(dimensions, maxDimensions) { |
| [170](#L170) | dimensions = contain(dimensions, maxDimensions); |
| [171](#L171) | for (const prop in dimensions) { |
| [172](#L172) | dimensions = dimensions[prop] < maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions; |
| [173](#L173) | } |
| [174](#L174) | return dimensions; |
| [175](#L175) | } |
| [176](#L176) | const Dimensions = { ratio, contain, cover: cover$1 }; |
| [177](#L177) | function getIndex(i, elements, current = 0, finite = false) { |
| [178](#L178) | elements = toNodes(elements); |
| [179](#L179) | const { length } = elements; |
| [180](#L180) | if (!length) { |
| [181](#L181) | return -1; |
| [182](#L182) | } |
| [183](#L183) | i = isNumeric(i) ? toNumber(i) : i === "next" ? current + 1 : i === "previous" ? current - 1 : i === "last" ? length - 1 : elements.indexOf(toNode(i)); |
| [184](#L184) | if (finite) { |
| [185](#L185) | return clamp(i, 0, length - 1); |
| [186](#L186) | } |
| [187](#L187) | i %= length; |
| [188](#L188) | return i < 0 ? i + length : i; |
| [189](#L189) | } |
| [190](#L190) | function memoize(fn) { |
| [191](#L191) | const cache = /\* @\_\_PURE\_\_ \*/ Object.create(null); |
| [192](#L192) | return (key, ...args) => cache[key] || (cache[key] = fn(key, ...args)); |
| [193](#L193) | } |
| [194](#L194) |  |
| [195](#L195) | function addClass(element, ...classes) { |
| [196](#L196) | for (const node of toNodes(element)) { |
| [197](#L197) | const add = toClasses(classes).filter((cls) => !hasClass(node, cls)); |
| [198](#L198) | if (add.length) { |
| [199](#L199) | node.classList.add(...add); |
| [200](#L200) | } |
| [201](#L201) | } |
| [202](#L202) | } |
| [203](#L203) | function removeClass(element, ...classes) { |
| [204](#L204) | for (const node of toNodes(element)) { |
| [205](#L205) | const remove = toClasses(classes).filter((cls) => hasClass(node, cls)); |
| [206](#L206) | if (remove.length) { |
| [207](#L207) | node.classList.remove(...remove); |
| [208](#L208) | } |
| [209](#L209) | } |
| [210](#L210) | } |
| [211](#L211) | function replaceClass(element, oldClass, newClass) { |
| [212](#L212) | newClass = toClasses(newClass); |
| [213](#L213) | oldClass = toClasses(oldClass).filter((cls) => !includes(newClass, cls)); |
| [214](#L214) | removeClass(element, oldClass); |
| [215](#L215) | addClass(element, newClass); |
| [216](#L216) | } |
| [217](#L217) | function hasClass(element, cls) { |
| [218](#L218) | [cls] = toClasses(cls); |
| [219](#L219) | return toNodes(element).some((node) => node.classList.contains(cls)); |
| [220](#L220) | } |
| [221](#L221) | function toggleClass(element, cls, force) { |
| [222](#L222) | const classes = toClasses(cls); |
| [223](#L223) | if (!isUndefined(force)) { |
| [224](#L224) | force = !!force; |
| [225](#L225) | } |
| [226](#L226) | for (const node of toNodes(element)) { |
| [227](#L227) | for (const cls2 of classes) { |
| [228](#L228) | node.classList.toggle(cls2, force); |
| [229](#L229) | } |
| [230](#L230) | } |
| [231](#L231) | } |
| [232](#L232) | function toClasses(str) { |
| [233](#L233) | return str ? isArray(str) ? str.map(toClasses).flat() : String(str).split(" ").filter(Boolean) : []; |
| [234](#L234) | } |
| [235](#L235) |  |
| [236](#L236) | function attr(element, name, value) { |
| [237](#L237) | var \_a; |
| [238](#L238) | if (isObject(name)) { |
| [239](#L239) | for (const key in name) { |
| [240](#L240) | attr(element, key, name[key]); |
| [241](#L241) | } |
| [242](#L242) | return; |
| [243](#L243) | } |
| [244](#L244) | if (isUndefined(value)) { |
| [245](#L245) | return (\_a = toNode(element)) == null ? void 0 : \_a.getAttribute(name); |
| [246](#L246) | } else { |
| [247](#L247) | for (const el of toNodes(element)) { |
| [248](#L248) | if (isFunction(value)) { |
| [249](#L249) | value = value.call(el, attr(el, name)); |
| [250](#L250) | } |
| [251](#L251) | if (value === null) { |
| [252](#L252) | removeAttr(el, name); |
| [253](#L253) | } else { |
| [254](#L254) | el.setAttribute(name, value); |
| [255](#L255) | } |
| [256](#L256) | } |
| [257](#L257) | } |
| [258](#L258) | } |
| [259](#L259) | function hasAttr(element, name) { |
| [260](#L260) | return toNodes(element).some((element2) => element2.hasAttribute(name)); |
| [261](#L261) | } |
| [262](#L262) | function removeAttr(element, name) { |
| [263](#L263) | toNodes(element).forEach((element2) => element2.removeAttribute(name)); |
| [264](#L264) | } |
| [265](#L265) | function data(element, attribute) { |
| [266](#L266) | for (const name of [attribute, `data-${attribute}`]) { |
| [267](#L267) | if (hasAttr(element, name)) { |
| [268](#L268) | return attr(element, name); |
| [269](#L269) | } |
| [270](#L270) | } |
| [271](#L271) | } |
| [272](#L272) |  |
| [273](#L273) | const inBrowser = typeof window !== "undefined"; |
| [274](#L274) | const isRtl = inBrowser && document.dir === "rtl"; |
| [275](#L275) | const hasTouch = inBrowser && "ontouchstart" in window; |
| [276](#L276) | const hasPointerEvents = inBrowser && window.PointerEvent; |
| [277](#L277) | const pointerDown$1 = hasPointerEvents ? "pointerdown" : hasTouch ? "touchstart" : "mousedown"; |
| [278](#L278) | const pointerMove$1 = hasPointerEvents ? "pointermove" : hasTouch ? "touchmove" : "mousemove"; |
| [279](#L279) | const pointerUp$1 = hasPointerEvents ? "pointerup" : hasTouch ? "touchend" : "mouseup"; |
| [280](#L280) | const pointerEnter = hasPointerEvents ? "pointerenter" : hasTouch ? "" : "mouseenter"; |
| [281](#L281) | const pointerLeave = hasPointerEvents ? "pointerleave" : hasTouch ? "" : "mouseleave"; |
| [282](#L282) | const pointerCancel = hasPointerEvents ? "pointercancel" : "touchcancel"; |
| [283](#L283) |  |
| [284](#L284) | const voidElements = { |
| [285](#L285) | area: true, |
| [286](#L286) | base: true, |
| [287](#L287) | br: true, |
| [288](#L288) | col: true, |
| [289](#L289) | embed: true, |
| [290](#L290) | hr: true, |
| [291](#L291) | img: true, |
| [292](#L292) | input: true, |
| [293](#L293) | keygen: true, |
| [294](#L294) | link: true, |
| [295](#L295) | meta: true, |
| [296](#L296) | param: true, |
| [297](#L297) | source: true, |
| [298](#L298) | track: true, |
| [299](#L299) | wbr: true |
| [300](#L300) | }; |
| [301](#L301) | function isVoidElement(element) { |
| [302](#L302) | return toNodes(element).some((element2) => voidElements[element2.tagName.toLowerCase()]); |
| [303](#L303) | } |
| [304](#L304) | const isVisibleFn = inBrowser && Element.prototype.checkVisibility || function() { |
| [305](#L305) | return this.offsetWidth || this.offsetHeight || this.getClientRects().length; |
| [306](#L306) | }; |
| [307](#L307) | function isVisible(element) { |
| [308](#L308) | return toNodes(element).some((element2) => isVisibleFn.call(element2)); |
| [309](#L309) | } |
| [310](#L310) | const selInput = "input,select,textarea,button"; |
| [311](#L311) | function isInput(element) { |
| [312](#L312) | return toNodes(element).some((element2) => matches(element2, selInput)); |
| [313](#L313) | } |
| [314](#L314) | const selFocusable = `${selInput},a[href],[tabindex]`; |
| [315](#L315) | function isFocusable(element) { |
| [316](#L316) | return matches(element, selFocusable); |
| [317](#L317) | } |
| [318](#L318) | function parent(element) { |
| [319](#L319) | var \_a; |
| [320](#L320) | return (\_a = toNode(element)) == null ? void 0 : \_a.parentElement; |
| [321](#L321) | } |
| [322](#L322) | function filter$1(element, selector) { |
| [323](#L323) | return toNodes(element).filter((element2) => matches(element2, selector)); |
| [324](#L324) | } |
| [325](#L325) | function matches(element, selector) { |
| [326](#L326) | return toNodes(element).some((element2) => element2.matches(selector)); |
| [327](#L327) | } |
| [328](#L328) | function parents(element, selector) { |
| [329](#L329) | const elements = []; |
| [330](#L330) | while (element = parent(element)) { |
| [331](#L331) | if (!selector || matches(element, selector)) { |
| [332](#L332) | elements.push(element); |
| [333](#L333) | } |
| [334](#L334) | } |
| [335](#L335) | return elements; |
| [336](#L336) | } |
| [337](#L337) | function children(element, selector) { |
| [338](#L338) | element = toNode(element); |
| [339](#L339) | const children2 = element ? toArray(element.children) : []; |
| [340](#L340) | return selector ? filter$1(children2, selector) : children2; |
| [341](#L341) | } |
| [342](#L342) | function index(element, ref) { |
| [343](#L343) | return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element); |
| [344](#L344) | } |
| [345](#L345) | function isSameSiteAnchor(el) { |
| [346](#L346) | el = toNode(el); |
| [347](#L347) | return el && ["origin", "pathname", "search"].every((part) => el[part] === location[part]); |
| [348](#L348) | } |
| [349](#L349) | function getTargetedElement(el) { |
| [350](#L350) | if (isSameSiteAnchor(el)) { |
| [351](#L351) | const { hash, ownerDocument } = toNode(el); |
| [352](#L352) | const id = decodeURIComponent(hash).slice(1); |
| [353](#L353) | return ownerDocument.getElementById(id) || ownerDocument.getElementsByName(id)[0]; |
| [354](#L354) | } |
| [355](#L355) | } |
| [356](#L356) |  |
| [357](#L357) | function query(selector, context) { |
| [358](#L358) | return find(selector, getContext(selector, context)); |
| [359](#L359) | } |
| [360](#L360) | function queryAll(selector, context) { |
| [361](#L361) | return findAll(selector, getContext(selector, context)); |
| [362](#L362) | } |
| [363](#L363) | function find(selector, context) { |
| [364](#L364) | return toNode(\_query(selector, toNode(context), "querySelector")); |
| [365](#L365) | } |
| [366](#L366) | function findAll(selector, context) { |
| [367](#L367) | return toNodes(\_query(selector, toNode(context), "querySelectorAll")); |
| [368](#L368) | } |
| [369](#L369) | function getContext(selector, context = document) { |
| [370](#L370) | return isString(selector) && parseSelector(selector).isContextSelector || isDocument(context) ? context : context.ownerDocument; |
| [371](#L371) | } |
| [372](#L372) | const addStarRe = /([!>+~-])(?=\s+[!>+~-]|\s\*$)/g; |
| [373](#L373) | const splitSelectorRe = /(\([^)]\*\)|[^,])+/g; |
| [374](#L374) | const parseSelector = memoize((selector) => { |
| [375](#L375) | selector = selector.replace(addStarRe, "$1 \*"); |
| [376](#L376) | let isContextSelector = false; |
| [377](#L377) | const selectors = []; |
| [378](#L378) | for (let sel of selector.match(splitSelectorRe)) { |
| [379](#L379) | sel = sel.trim(); |
| [380](#L380) | isContextSelector || (isContextSelector = ["!", "+", "~", "-", ">"].includes(sel[0])); |
| [381](#L381) | selectors.push(sel); |
| [382](#L382) | } |
| [383](#L383) | return { |
| [384](#L384) | selector: selectors.join(","), |
| [385](#L385) | selectors, |
| [386](#L386) | isContextSelector |
| [387](#L387) | }; |
| [388](#L388) | }); |
| [389](#L389) | const positionRe = /(\([^)]\*\)|\S)\*/; |
| [390](#L390) | const parsePositionSelector = memoize((selector) => { |
| [391](#L391) | selector = selector.slice(1).trim(); |
| [392](#L392) | const [position] = selector.match(positionRe); |
| [393](#L393) | return [position, selector.slice(position.length + 1)]; |
| [394](#L394) | }); |
| [395](#L395) | function \_query(selector, context = document, queryFn) { |
| [396](#L396) | if (!selector || !isString(selector)) { |
| [397](#L397) | return selector; |
| [398](#L398) | } |
| [399](#L399) | const parsed = parseSelector(selector); |
| [400](#L400) | if (!parsed.isContextSelector) { |
| [401](#L401) | return \_doQuery(context, queryFn, parsed.selector); |
| [402](#L402) | } |
| [403](#L403) | selector = ""; |
| [404](#L404) | const isSingle = parsed.selectors.length === 1; |
| [405](#L405) | for (let sel of parsed.selectors) { |
| [406](#L406) | let positionSel; |
| [407](#L407) | let ctx = context; |
| [408](#L408) | if (sel[0] === "!") { |
| [409](#L409) | [positionSel, sel] = parsePositionSelector(sel); |
| [410](#L410) | ctx = context.parentElement.closest(positionSel); |
| [411](#L411) | if (!sel && isSingle) { |
| [412](#L412) | return ctx; |
| [413](#L413) | } |
| [414](#L414) | } |
| [415](#L415) | if (ctx && sel[0] === "-") { |
| [416](#L416) | [positionSel, sel] = parsePositionSelector(sel); |
| [417](#L417) | ctx = ctx.previousElementSibling; |
| [418](#L418) | ctx = matches(ctx, positionSel) ? ctx : null; |
| [419](#L419) | if (!sel && isSingle) { |
| [420](#L420) | return ctx; |
| [421](#L421) | } |
| [422](#L422) | } |
| [423](#L423) | if (!ctx) { |
| [424](#L424) | continue; |
| [425](#L425) | } |
| [426](#L426) | if (isSingle) { |
| [427](#L427) | if (sel[0] === "~" || sel[0] === "+") { |
| [428](#L428) | sel = `:scope > :nth-child(${index(ctx) + 1}) ${sel}`; |
| [429](#L429) | ctx = ctx.parentElement; |
| [430](#L430) | } else if (sel[0] === ">") { |
| [431](#L431) | sel = `:scope ${sel}`; |
| [432](#L432) | } |
| [433](#L433) | return \_doQuery(ctx, queryFn, sel); |
| [434](#L434) | } |
| [435](#L435) | selector += `${selector ? "," : ""}${domPath(ctx)} ${sel}`; |
| [436](#L436) | } |
| [437](#L437) | if (!isDocument(context)) { |
| [438](#L438) | context = context.ownerDocument; |
| [439](#L439) | } |
| [440](#L440) | return \_doQuery(context, queryFn, selector); |
| [441](#L441) | } |
| [442](#L442) | function \_doQuery(context, queryFn, selector) { |
| [443](#L443) | try { |
| [444](#L444) | return context[queryFn](selector); |
| [445](#L445) | } catch (e) { |
| [446](#L446) | return null; |
| [447](#L447) | } |
| [448](#L448) | } |
| [449](#L449) | function domPath(element) { |
| [450](#L450) | const names = []; |
| [451](#L451) | while (element.parentNode) { |
| [452](#L452) | const id = attr(element, "id"); |
| [453](#L453) | if (id) { |
| [454](#L454) | names.unshift(`#${escape(id)}`); |
| [455](#L455) | break; |
| [456](#L456) | } else { |
| [457](#L457) | let { tagName } = element; |
| [458](#L458) | if (tagName !== "HTML") { |
| [459](#L459) | tagName += `:nth-child(${index(element) + 1})`; |
| [460](#L460) | } |
| [461](#L461) | names.unshift(tagName); |
| [462](#L462) | element = element.parentNode; |
| [463](#L463) | } |
| [464](#L464) | } |
| [465](#L465) | return names.join(" > "); |
| [466](#L466) | } |
| [467](#L467) | function escape(css) { |
| [468](#L468) | return isString(css) ? CSS.escape(css) : ""; |
| [469](#L469) | } |
| [470](#L470) |  |
| [471](#L471) | function on(...args) { |
| [472](#L472) | let [targets, types, selector, listener, useCapture = false] = getArgs(args); |
| [473](#L473) | if (listener.length > 1) { |
| [474](#L474) | listener = detail(listener); |
| [475](#L475) | } |
| [476](#L476) | if (useCapture == null ? void 0 : useCapture.self) { |
| [477](#L477) | listener = selfFilter(listener); |
| [478](#L478) | } |
| [479](#L479) | if (selector) { |
| [480](#L480) | listener = delegate(selector, listener); |
| [481](#L481) | } |
| [482](#L482) | for (const type of types) { |
| [483](#L483) | for (const target of targets) { |
| [484](#L484) | target.addEventListener(type, listener, useCapture); |
| [485](#L485) | } |
| [486](#L486) | } |
| [487](#L487) | return () => off(targets, types, listener, useCapture); |
| [488](#L488) | } |
| [489](#L489) | function off(...args) { |
| [490](#L490) | let [targets, types, , listener, useCapture = false] = getArgs(args); |
| [491](#L491) | for (const type of types) { |
| [492](#L492) | for (const target of targets) { |
| [493](#L493) | target.removeEventListener(type, listener, useCapture); |
| [494](#L494) | } |
| [495](#L495) | } |
| [496](#L496) | } |
| [497](#L497) | function once(...args) { |
| [498](#L498) | const [element, types, selector, listener, useCapture = false, condition] = getArgs(args); |
| [499](#L499) | const off2 = on( |
| [500](#L500) | element, |
| [501](#L501) | types, |
| [502](#L502) | selector, |
| [503](#L503) | (e) => { |
| [504](#L504) | const result = !condition || condition(e); |
| [505](#L505) | if (result) { |
| [506](#L506) | off2(); |
| [507](#L507) | listener(e, result); |
| [508](#L508) | } |
| [509](#L509) | }, |
| [510](#L510) | useCapture |
| [511](#L511) | ); |
| [512](#L512) | return off2; |
| [513](#L513) | } |
| [514](#L514) | function trigger(targets, event, detail2) { |
| [515](#L515) | return toEventTargets(targets).every( |
| [516](#L516) | (target) => target.dispatchEvent(createEvent(event, true, true, detail2)) |
| [517](#L517) | ); |
| [518](#L518) | } |
| [519](#L519) | function createEvent(e, bubbles = true, cancelable = false, detail2) { |
| [520](#L520) | if (isString(e)) { |
| [521](#L521) | e = new CustomEvent(e, { bubbles, cancelable, detail: detail2 }); |
| [522](#L522) | } |
| [523](#L523) | return e; |
| [524](#L524) | } |
| [525](#L525) | function getArgs(args) { |
| [526](#L526) | args[0] = toEventTargets(args[0]); |
| [527](#L527) | if (isString(args[1])) { |
| [528](#L528) | args[1] = args[1].split(" "); |
| [529](#L529) | } |
| [530](#L530) | if (isFunction(args[2])) { |
| [531](#L531) | args.splice(2, 0, false); |
| [532](#L532) | } |
| [533](#L533) | return args; |
| [534](#L534) | } |
| [535](#L535) | function delegate(selector, listener) { |
| [536](#L536) | return (e) => { |
| [537](#L537) | const current = selector[0] === ">" ? findAll(selector, e.currentTarget).reverse().find((element) => element.contains(e.target)) : e.target.closest(selector); |
| [538](#L538) | if (current) { |
| [539](#L539) | e.current = current; |
| [540](#L540) | listener.call(this, e); |
| [541](#L541) | delete e.current; |
| [542](#L542) | } |
| [543](#L543) | }; |
| [544](#L544) | } |
| [545](#L545) | function detail(listener) { |
| [546](#L546) | return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e); |
| [547](#L547) | } |
| [548](#L548) | function selfFilter(listener) { |
| [549](#L549) | return function(e) { |
| [550](#L550) | if (e.target === e.currentTarget || e.target === e.current) { |
| [551](#L551) | return listener.call(null, e); |
| [552](#L552) | } |
| [553](#L553) | }; |
| [554](#L554) | } |
| [555](#L555) | function isEventTarget(target) { |
| [556](#L556) | return target && "addEventListener" in target; |
| [557](#L557) | } |
| [558](#L558) | function toEventTarget(target) { |
| [559](#L559) | return isEventTarget(target) ? target : toNode(target); |
| [560](#L560) | } |
| [561](#L561) | function toEventTargets(target) { |
| [562](#L562) | return isArray(target) ? target.map(toEventTarget).filter(Boolean) : isString(target) ? findAll(target) : isEventTarget(target) ? [target] : toNodes(target); |
| [563](#L563) | } |
| [564](#L564) | function isTouch(e) { |
| [565](#L565) | return e.pointerType === "touch" || !!e.touches; |
| [566](#L566) | } |
| [567](#L567) | function getEventPos(e) { |
| [568](#L568) | var \_a, \_b; |
| [569](#L569) | const { clientX: x, clientY: y } = ((\_a = e.touches) == null ? void 0 : \_a[0]) || ((\_b = e.changedTouches) == null ? void 0 : \_b[0]) || e; |
| [570](#L570) | return { x, y }; |
| [571](#L571) | } |
| [572](#L572) |  |
| [573](#L573) | const cssNumber = { |
| [574](#L574) | "animation-iteration-count": true, |
| [575](#L575) | "column-count": true, |
| [576](#L576) | "fill-opacity": true, |
| [577](#L577) | "flex-grow": true, |
| [578](#L578) | "flex-shrink": true, |
| [579](#L579) | "font-weight": true, |
| [580](#L580) | "line-height": true, |
| [581](#L581) | opacity: true, |
| [582](#L582) | order: true, |
| [583](#L583) | orphans: true, |
| [584](#L584) | "stroke-dasharray": true, |
| [585](#L585) | "stroke-dashoffset": true, |
| [586](#L586) | widows: true, |
| [587](#L587) | "z-index": true, |
| [588](#L588) | zoom: true |
| [589](#L589) | }; |
| [590](#L590) | function css(element, property, value, priority) { |
| [591](#L591) | const elements = toNodes(element); |
| [592](#L592) | for (const element2 of elements) { |
| [593](#L593) | if (isString(property)) { |
| [594](#L594) | property = propName(property); |
| [595](#L595) | if (isUndefined(value)) { |
| [596](#L596) | return getComputedStyle(element2).getPropertyValue(property); |
| [597](#L597) | } else { |
| [598](#L598) | element2.style.setProperty( |
| [599](#L599) | property, |
| [600](#L600) | isNumeric(value) && !cssNumber[property] ? `${value}px` : value || isNumber(value) ? value : "", |
| [601](#L601) | priority |
| [602](#L602) | ); |
| [603](#L603) | } |
| [604](#L604) | } else if (isArray(property)) { |
| [605](#L605) | const props = {}; |
| [606](#L606) | for (const prop of property) { |
| [607](#L607) | props[prop] = css(element2, prop); |
| [608](#L608) | } |
| [609](#L609) | return props; |
| [610](#L610) | } else if (isObject(property)) { |
| [611](#L611) | for (const prop in property) { |
| [612](#L612) | css(element2, prop, property[prop], value); |
| [613](#L613) | } |
| [614](#L614) | } |
| [615](#L615) | } |
| [616](#L616) | return elements[0]; |
| [617](#L617) | } |
| [618](#L618) | const propName = memoize((name) => { |
| [619](#L619) | if (startsWith(name, "--")) { |
| [620](#L620) | return name; |
| [621](#L621) | } |
| [622](#L622) | name = hyphenate(name); |
| [623](#L623) | const { style } = document.documentElement; |
| [624](#L624) | if (name in style) { |
| [625](#L625) | return name; |
| [626](#L626) | } |
| [627](#L627) | for (const prefix of ["webkit", "moz"]) { |
| [628](#L628) | const prefixedName = `-${prefix}-${name}`; |
| [629](#L629) | if (prefixedName in style) { |
| [630](#L630) | return prefixedName; |
| [631](#L631) | } |
| [632](#L632) | } |
| [633](#L633) | }); |
| [634](#L634) |  |
| [635](#L635) | const clsTransition = "bdt-transition"; |
| [636](#L636) | const transitionEnd = "transitionend"; |
| [637](#L637) | const transitionCanceled = "transitioncanceled"; |
| [638](#L638) | function transition$1(element, props, duration = 400, timing = "linear") { |
| [639](#L639) | duration = Math.round(duration); |
| [640](#L640) | return Promise.all( |
| [641](#L641) | toNodes(element).map( |
| [642](#L642) | (element2) => new Promise((resolve, reject) => { |
| [643](#L643) | for (const name in props) { |
| [644](#L644) | css(element2, name); |
| [645](#L645) | } |
| [646](#L646) | const timer = setTimeout(() => trigger(element2, transitionEnd), duration); |
| [647](#L647) | once( |
| [648](#L648) | element2, |
| [649](#L649) | [transitionEnd, transitionCanceled], |
| [650](#L650) | ({ type }) => { |
| [651](#L651) | clearTimeout(timer); |
| [652](#L652) | removeClass(element2, clsTransition); |
| [653](#L653) | css(element2, { |
| [654](#L654) | transitionProperty: "", |
| [655](#L655) | transitionDuration: "", |
| [656](#L656) | transitionTimingFunction: "" |
| [657](#L657) | }); |
| [658](#L658) | type === transitionCanceled ? reject() : resolve(element2); |
| [659](#L659) | }, |
| [660](#L660) | { self: true } |
| [661](#L661) | ); |
| [662](#L662) | addClass(element2, clsTransition); |
| [663](#L663) | css(element2, { |
| [664](#L664) | transitionProperty: Object.keys(props).map(propName).join(","), |
| [665](#L665) | transitionDuration: `${duration}ms`, |
| [666](#L666) | transitionTimingFunction: timing, |
| [667](#L667) | ...props |
| [668](#L668) | }); |
| [669](#L669) | }) |
| [670](#L670) | ) |
| [671](#L671) | ); |
| [672](#L672) | } |
| [673](#L673) | const Transition = { |
| [674](#L674) | start: transition$1, |
| [675](#L675) | async stop(element) { |
| [676](#L676) | trigger(element, transitionEnd); |
| [677](#L677) | await Promise.resolve(); |
| [678](#L678) | }, |
| [679](#L679) | async cancel(element) { |
| [680](#L680) | trigger(element, transitionCanceled); |
| [681](#L681) | await Promise.resolve(); |
| [682](#L682) | }, |
| [683](#L683) | inProgress(element) { |
| [684](#L684) | return hasClass(element, clsTransition); |
| [685](#L685) | } |
| [686](#L686) | }; |
| [687](#L687) | const clsAnimation = "bdt-animation"; |
| [688](#L688) | const animationEnd = "animationend"; |
| [689](#L689) | const animationCanceled = "animationcanceled"; |
| [690](#L690) | function animate$2(element, animation, duration = 200, origin, out) { |
| [691](#L691) | return Promise.all( |
| [692](#L692) | toNodes(element).map( |
| [693](#L693) | (element2) => new Promise((resolve, reject) => { |
| [694](#L694) | if (hasClass(element2, clsAnimation)) { |
| [695](#L695) | trigger(element2, animationCanceled); |
| [696](#L696) | } |
| [697](#L697) | const classes = [ |
| [698](#L698) | animation, |
| [699](#L699) | clsAnimation, |
| [700](#L700) | `${clsAnimation}-${out ? "leave" : "enter"}`, |
| [701](#L701) | origin && `bdt-transform-origin-${origin}`, |
| [702](#L702) | out && `${clsAnimation}-reverse` |
| [703](#L703) | ]; |
| [704](#L704) | const timer = setTimeout(() => trigger(element2, animationEnd), duration); |
| [705](#L705) | once( |
| [706](#L706) | element2, |
| [707](#L707) | [animationEnd, animationCanceled], |
| [708](#L708) | ({ type }) => { |
| [709](#L709) | clearTimeout(timer); |
| [710](#L710) | type === animationCanceled ? reject() : resolve(element2); |
| [711](#L711) | css(element2, "animationDuration", ""); |
| [712](#L712) | removeClass(element2, classes); |
| [713](#L713) | }, |
| [714](#L714) | { self: true } |
| [715](#L715) | ); |
| [716](#L716) | css(element2, "animationDuration", `${duration}ms`); |
| [717](#L717) | addClass(element2, classes); |
| [718](#L718) | }) |
| [719](#L719) | ) |
| [720](#L720) | ); |
| [721](#L721) | } |
| [722](#L722) | const Animation = { |
| [723](#L723) | in: animate$2, |
| [724](#L724) | out(element, animation, duration, origin) { |
| [725](#L725) | return animate$2(element, animation, duration, origin, true); |
| [726](#L726) | }, |
| [727](#L727) | inProgress(element) { |
| [728](#L728) | return hasClass(element, clsAnimation); |
| [729](#L729) | }, |
| [730](#L730) | cancel(element) { |
| [731](#L731) | trigger(element, animationCanceled); |
| [732](#L732) | } |
| [733](#L733) | }; |
| [734](#L734) |  |
| [735](#L735) | function ready(fn) { |
| [736](#L736) | if (document.readyState !== "loading") { |
| [737](#L737) | fn(); |
| [738](#L738) | return; |
| [739](#L739) | } |
| [740](#L740) | once(document, "DOMContentLoaded", fn); |
| [741](#L741) | } |
| [742](#L742) | function isTag(element, ...tagNames) { |
| [743](#L743) | return tagNames.some((tagName) => { |
| [744](#L744) | var \_a; |
| [745](#L745) | return ((\_a = element == null ? void 0 : element.tagName) == null ? void 0 : \_a.toLowerCase()) === tagName.toLowerCase(); |
| [746](#L746) | }); |
| [747](#L747) | } |
| [748](#L748) | function empty(element) { |
| [749](#L749) | element = $(element); |
| [750](#L750) | element.innerHTML = ""; |
| [751](#L751) | return element; |
| [752](#L752) | } |
| [753](#L753) | function html(parent2, html2) { |
| [754](#L754) | return isUndefined(html2) ? $(parent2).innerHTML : append(empty(parent2), html2); |
| [755](#L755) | } |
| [756](#L756) | const prepend = applyFn("prepend"); |
| [757](#L757) | const append = applyFn("append"); |
| [758](#L758) | const before = applyFn("before"); |
| [759](#L759) | const after = applyFn("after"); |
| [760](#L760) | function applyFn(fn) { |
| [761](#L761) | return function(ref, element) { |
| [762](#L762) | var \_a; |
| [763](#L763) | const nodes = toNodes(isString(element) ? fragment(element) : element); |
| [764](#L764) | (\_a = $(ref)) == null ? void 0 : \_a[fn](...nodes); |
| [765](#L765) | return unwrapSingle(nodes); |
| [766](#L766) | }; |
| [767](#L767) | } |
| [768](#L768) | function remove$1(element) { |
| [769](#L769) | toNodes(element).forEach((element2) => element2.remove()); |
| [770](#L770) | } |
| [771](#L771) | function wrapAll(element, structure) { |
| [772](#L772) | structure = toNode(before(element, structure)); |
| [773](#L773) | while (structure.firstElementChild) { |
| [774](#L774) | structure = structure.firstElementChild; |
| [775](#L775) | } |
| [776](#L776) | append(structure, element); |
| [777](#L777) | return structure; |
| [778](#L778) | } |
| [779](#L779) | function wrapInner(element, structure) { |
| [780](#L780) | return toNodes( |
| [781](#L781) | toNodes(element).map( |
| [782](#L782) | (element2) => element2.hasChildNodes() ? wrapAll(toArray(element2.childNodes), structure) : append(element2, structure) |
| [783](#L783) | ) |
| [784](#L784) | ); |
| [785](#L785) | } |
| [786](#L786) | function unwrap(element) { |
| [787](#L787) | toNodes(element).map(parent).filter((value, index, self) => self.indexOf(value) === index).forEach((parent2) => parent2.replaceWith(...parent2.childNodes)); |
| [788](#L788) | } |
| [789](#L789) | const singleTagRe = /^<(\w+)\s\*\/?>(?:<\/\1>)?$/; |
| [790](#L790) | function fragment(html2) { |
| [791](#L791) | const matches = singleTagRe.exec(html2); |
| [792](#L792) | if (matches) { |
| [793](#L793) | return document.createElement(matches[1]); |
| [794](#L794) | } |
| [795](#L795) | const container = document.createElement("template"); |
| [796](#L796) | container.innerHTML = html2.trim(); |
| [797](#L797) | return unwrapSingle(container.content.childNodes); |
| [798](#L798) | } |
| [799](#L799) | function unwrapSingle(nodes) { |
| [800](#L800) | return nodes.length > 1 ? nodes : nodes[0]; |
| [801](#L801) | } |
| [802](#L802) | function apply(node, fn) { |
| [803](#L803) | if (!isElement(node)) { |
| [804](#L804) | return; |
| [805](#L805) | } |
| [806](#L806) | fn(node); |
| [807](#L807) | node = node.firstElementChild; |
| [808](#L808) | while (node) { |
| [809](#L809) | apply(node, fn); |
| [810](#L810) | node = node.nextElementSibling; |
| [811](#L811) | } |
| [812](#L812) | } |
| [813](#L813) | function $(selector, context) { |
| [814](#L814) | return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context); |
| [815](#L815) | } |
| [816](#L816) | function $$(selector, context) { |
| [817](#L817) | return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context); |
| [818](#L818) | } |
| [819](#L819) | function isHtml(str) { |
| [820](#L820) | return isString(str) && startsWith(str.trim(), "<"); |
| [821](#L821) | } |
| [822](#L822) |  |
| [823](#L823) | const dirs$1 = { |
| [824](#L824) | width: ["left", "right"], |
| [825](#L825) | height: ["top", "bottom"] |
| [826](#L826) | }; |
| [827](#L827) | function dimensions$1(element) { |
| [828](#L828) | const rect = isElement(element) ? toNode(element).getBoundingClientRect() : { height: height(element), width: width(element), top: 0, left: 0 }; |
| [829](#L829) | return { |
| [830](#L830) | height: rect.height, |
| [831](#L831) | width: rect.width, |
| [832](#L832) | top: rect.top, |
| [833](#L833) | left: rect.left, |
| [834](#L834) | bottom: rect.top + rect.height, |
| [835](#L835) | right: rect.left + rect.width |
| [836](#L836) | }; |
| [837](#L837) | } |
| [838](#L838) | function offset(element, coordinates) { |
| [839](#L839) | if (coordinates) { |
| [840](#L840) | css(element, { left: 0, top: 0 }); |
| [841](#L841) | } |
| [842](#L842) | const currentOffset = dimensions$1(element); |
| [843](#L843) | if (element) { |
| [844](#L844) | const { scrollY, scrollX } = toWindow(element); |
| [845](#L845) | const offsetBy = { height: scrollY, width: scrollX }; |
| [846](#L846) | for (const dir in dirs$1) { |
| [847](#L847) | for (const prop of dirs$1[dir]) { |
| [848](#L848) | currentOffset[prop] += offsetBy[dir]; |
| [849](#L849) | } |
| [850](#L850) | } |
| [851](#L851) | } |
| [852](#L852) | if (!coordinates) { |
| [853](#L853) | return currentOffset; |
| [854](#L854) | } |
| [855](#L855) | for (const prop of ["left", "top"]) { |
| [856](#L856) | css(element, prop, coordinates[prop] - currentOffset[prop]); |
| [857](#L857) | } |
| [858](#L858) | } |
| [859](#L859) | function position(element) { |
| [860](#L860) | let { top, left } = offset(element); |
| [861](#L861) | const { |
| [862](#L862) | ownerDocument: { body, documentElement }, |
| [863](#L863) | offsetParent |
| [864](#L864) | } = toNode(element); |
| [865](#L865) | let parent = offsetParent || documentElement; |
| [866](#L866) | while (parent && (parent === body || parent === documentElement) && css(parent, "position") === "static") { |
| [867](#L867) | parent = parent.parentNode; |
| [868](#L868) | } |
| [869](#L869) | if (isElement(parent)) { |
| [870](#L870) | const parentOffset = offset(parent); |
| [871](#L871) | top -= parentOffset.top + toFloat(css(parent, "borderTopWidth")); |
| [872](#L872) | left -= parentOffset.left + toFloat(css(parent, "borderLeftWidth")); |
| [873](#L873) | } |
| [874](#L874) | return { |
| [875](#L875) | top: top - toFloat(css(element, "marginTop")), |
| [876](#L876) | left: left - toFloat(css(element, "marginLeft")) |
| [877](#L877) | }; |
| [878](#L878) | } |
| [879](#L879) | function offsetPosition(element) { |
| [880](#L880) | element = toNode(element); |
| [881](#L881) | const offset2 = [element.offsetTop, element.offsetLeft]; |
| [882](#L882) | while (element = element.offsetParent) { |
| [883](#L883) | offset2[0] += element.offsetTop + toFloat(css(element, `borderTopWidth`)); |
| [884](#L884) | offset2[1] += element.offsetLeft + toFloat(css(element, `borderLeftWidth`)); |
| [885](#L885) | if (css(element, "position") === "fixed") { |
| [886](#L886) | const win = toWindow(element); |
| [887](#L887) | offset2[0] += win.scrollY; |
| [888](#L888) | offset2[1] += win.scrollX; |
| [889](#L889) | return offset2; |
| [890](#L890) | } |
| [891](#L891) | } |
| [892](#L892) | return offset2; |
| [893](#L893) | } |
| [894](#L894) | const height = dimension("height"); |
| [895](#L895) | const width = dimension("width"); |
| [896](#L896) | function dimension(prop) { |
| [897](#L897) | const propName = ucfirst(prop); |
| [898](#L898) | return (element, value) => { |
| [899](#L899) | if (isUndefined(value)) { |
| [900](#L900) | if (isWindow(element)) { |
| [901](#L901) | return element[`inner${propName}`]; |
| [902](#L902) | } |
| [903](#L903) | if (isDocument(element)) { |
| [904](#L904) | const doc = element.documentElement; |
| [905](#L905) | return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]); |
| [906](#L906) | } |
| [907](#L907) | element = toNode(element); |
| [908](#L908) | value = css(element, prop); |
| [909](#L909) | value = value === "auto" ? element[`offset${propName}`] : toFloat(value) || 0; |
| [910](#L910) | return value - boxModelAdjust(element, prop); |
| [911](#L911) | } else { |
| [912](#L912) | return css( |
| [913](#L913) | element, |
| [914](#L914) | prop, |
| [915](#L915) | !value && value !== 0 ? "" : +value + boxModelAdjust(element, prop) + "px" |
| [916](#L916) | ); |
| [917](#L917) | } |
| [918](#L918) | }; |
| [919](#L919) | } |
| [920](#L920) | function boxModelAdjust(element, prop, sizing = "border-box") { |
| [921](#L921) | return css(element, "boxSizing") === sizing ? sumBy( |
| [922](#L922) | dirs$1[prop].map(ucfirst), |
| [923](#L923) | (prop2) => toFloat(css(element, `padding${prop2}`)) + toFloat(css(element, `border${prop2}Width`)) |
| [924](#L924) | ) : 0; |
| [925](#L925) | } |
| [926](#L926) | function flipPosition(pos) { |
| [927](#L927) | for (const dir in dirs$1) { |
| [928](#L928) | for (const i in dirs$1[dir]) { |
| [929](#L929) | if (dirs$1[dir][i] === pos) { |
| [930](#L930) | return dirs$1[dir][1 - i]; |
| [931](#L931) | } |
| [932](#L932) | } |
| [933](#L933) | } |
| [934](#L934) | return pos; |
| [935](#L935) | } |
| [936](#L936) | function toPx(value, property = "width", element = window, offsetDim = false) { |
| [937](#L937) | if (!isString(value)) { |
| [938](#L938) | return toFloat(value); |
| [939](#L939) | } |
| [940](#L940) | return sumBy(parseCalc(value), (value2) => { |
| [941](#L941) | const unit = parseUnit(value2); |
| [942](#L942) | return unit ? percent( |
| [943](#L943) | unit === "vh" ? getViewportHeight() : unit === "vw" ? width(toWindow(element)) : offsetDim ? element[`offset${ucfirst(property)}`] : dimensions$1(element)[property], |
| [944](#L944) | value2 |
| [945](#L945) | ) : value2; |
| [946](#L946) | }); |
| [947](#L947) | } |
| [948](#L948) | const calcRe = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g; |
| [949](#L949) | const parseCalc = memoize((calc) => calc.toString().replace(/\s/g, "").match(calcRe) || []); |
| [950](#L950) | const unitRe$1 = /(?:v[hw]|%)$/; |
| [951](#L951) | const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]); |
| [952](#L952) | function percent(base, value) { |
| [953](#L953) | return base \* toFloat(value) / 100; |
| [954](#L954) | } |
| [955](#L955) | let vh; |
| [956](#L956) | let vhEl; |
| [957](#L957) | function getViewportHeight() { |
| [958](#L958) | if (vh) { |
| [959](#L959) | return vh; |
| [960](#L960) | } |
| [961](#L961) | if (!vhEl) { |
| [962](#L962) | vhEl = $("<div>"); |
| [963](#L963) | css(vhEl, { |
| [964](#L964) | height: "100vh", |
| [965](#L965) | position: "fixed" |
| [966](#L966) | }); |
| [967](#L967) | on(window, "resize", () => vh = null); |
| [968](#L968) | } |
| [969](#L969) | append(document.body, vhEl); |
| [970](#L970) | vh = vhEl.clientHeight; |
| [971](#L971) | remove$1(vhEl); |
| [972](#L972) | return vh; |
| [973](#L973) | } |
| [974](#L974) |  |
| [975](#L975) | const fastdom = { read, write, clear, flush }; |
| [976](#L976) | const reads = []; |
| [977](#L977) | const writes = []; |
| [978](#L978) | function read(task) { |
| [979](#L979) | reads.push(task); |
| [980](#L980) | scheduleFlush(); |
| [981](#L981) | return task; |
| [982](#L982) | } |
| [983](#L983) | function write(task) { |
| [984](#L984) | writes.push(task); |
| [985](#L985) | scheduleFlush(); |
| [986](#L986) | return task; |
| [987](#L987) | } |
| [988](#L988) | function clear(task) { |
| [989](#L989) | remove(reads, task); |
| [990](#L990) | remove(writes, task); |
| [991](#L991) | } |
| [992](#L992) | let scheduled = false; |
| [993](#L993) | function flush() { |
| [994](#L994) | runTasks(reads); |
| [995](#L995) | runTasks(writes.splice(0)); |
| [996](#L996) | scheduled = false; |
| [997](#L997) | if (reads.length || writes.length) { |
| [998](#L998) | scheduleFlush(); |
| [999](#L999) | } |
| [1000](#L1000) | } |
| [1001](#L1001) | function scheduleFlush() { |
| [1002](#L1002) | if (!scheduled) { |
| [1003](#L1003) | scheduled = true; |
| [1004](#L1004) | queueMicrotask(flush); |
| [1005](#L1005) | } |
| [1006](#L1006) | } |
| [1007](#L1007) | function runTasks(tasks) { |
| [1008](#L1008) | let task; |
| [1009](#L1009) | while (task = tasks.shift()) { |
| [1010](#L1010) | try { |
| [1011](#L1011) | task(); |
| [1012](#L1012) | } catch (e) { |
| [1013](#L1013) | console.error(e); |
| [1014](#L1014) | } |
| [1015](#L1015) | } |
| [1016](#L1016) | } |
| [1017](#L1017) | function remove(array, item) { |
| [1018](#L1018) | const index = array.indexOf(item); |
| [1019](#L1019) | return ~index && array.splice(index, 1); |
| [1020](#L1020) | } |
| [1021](#L1021) |  |
| [1022](#L1022) | class MouseTracker { |
| [1023](#L1023) | init() { |
| [1024](#L1024) | this.positions = []; |
| [1025](#L1025) | let position; |
| [1026](#L1026) | this.unbind = on(document, "mousemove", (e) => position = getEventPos(e)); |
| [1027](#L1027) | this.interval = setInterval(() => { |
| [1028](#L1028) | if (!position) { |
| [1029](#L1029) | return; |
| [1030](#L1030) | } |
| [1031](#L1031) | this.positions.push(position); |
| [1032](#L1032) | if (this.positions.length > 5) { |
| [1033](#L1033) | this.positions.shift(); |
| [1034](#L1034) | } |
| [1035](#L1035) | }, 50); |
| [1036](#L1036) | } |
| [1037](#L1037) | cancel() { |
| [1038](#L1038) | var \_a; |
| [1039](#L1039) | (\_a = this.unbind) == null ? void 0 : \_a.call(this); |
| [1040](#L1040) | clearInterval(this.interval); |
| [1041](#L1041) | } |
| [1042](#L1042) | movesTo(target) { |
| [1043](#L1043) | if (!this.positions || this.positions.length < 2) { |
| [1044](#L1044) | return false; |
| [1045](#L1045) | } |
| [1046](#L1046) | const p = dimensions$1(target); |
| [1047](#L1047) | const { left, right, top, bottom } = p; |
| [1048](#L1048) | const [prevPosition] = this.positions; |
| [1049](#L1049) | const position = last(this.positions); |
| [1050](#L1050) | const path = [prevPosition, position]; |
| [1051](#L1051) | if (pointInRect(position, p)) { |
| [1052](#L1052) | return false; |
| [1053](#L1053) | } |
| [1054](#L1054) | const diagonals = [ |
| [1055](#L1055) | [ |
| [1056](#L1056) | { x: left, y: top }, |
| [1057](#L1057) | { x: right, y: bottom } |
| [1058](#L1058) | ], |
| [1059](#L1059) | [ |
| [1060](#L1060) | { x: left, y: bottom }, |
| [1061](#L1061) | { x: right, y: top } |
| [1062](#L1062) | ] |
| [1063](#L1063) | ]; |
| [1064](#L1064) | return diagonals.some((diagonal) => { |
| [1065](#L1065) | const intersection = intersect(path, diagonal); |
| [1066](#L1066) | return intersection && pointInRect(intersection, p); |
| [1067](#L1067) | }); |
| [1068](#L1068) | } |
| [1069](#L1069) | } |
| [1070](#L1070) | function intersect([{ x: x1, y: y1 }, { x: x2, y: y2 }], [{ x: x3, y: y3 }, { x: x4, y: y4 }]) { |
| [1071](#L1071) | const denominator = (y4 - y3) \* (x2 - x1) - (x4 - x3) \* (y2 - y1); |
| [1072](#L1072) | if (denominator === 0) { |
| [1073](#L1073) | return false; |
| [1074](#L1074) | } |
| [1075](#L1075) | const ua = ((x4 - x3) \* (y1 - y3) - (y4 - y3) \* (x1 - x3)) / denominator; |
| [1076](#L1076) | if (ua < 0) { |
| [1077](#L1077) | return false; |
| [1078](#L1078) | } |
| [1079](#L1079) | return { x: x1 + ua \* (x2 - x1), y: y1 + ua \* (y2 - y1) }; |
| [1080](#L1080) | } |
| [1081](#L1081) |  |
| [1082](#L1082) | function observeIntersection(targets, cb, options = {}, { intersecting = true } = {}) { |
| [1083](#L1083) | const observer = new IntersectionObserver( |
| [1084](#L1084) | intersecting ? (entries, observer2) => { |
| [1085](#L1085) | if (entries.some((entry) => entry.isIntersecting)) { |
| [1086](#L1086) | cb(entries, observer2); |
| [1087](#L1087) | } |
| [1088](#L1088) | } : cb, |
| [1089](#L1089) | options |
| [1090](#L1090) | ); |
| [1091](#L1091) | for (const el of toNodes(targets)) { |
| [1092](#L1092) | observer.observe(el); |
| [1093](#L1093) | } |
| [1094](#L1094) | return observer; |
| [1095](#L1095) | } |
| [1096](#L1096) | const hasResizeObserver = inBrowser && window.ResizeObserver; |
| [1097](#L1097) | function observeResize(targets, cb, options = { box: "border-box" }) { |
| [1098](#L1098) | if (hasResizeObserver) { |
| [1099](#L1099) | return observe$1(ResizeObserver, targets, cb, options); |
| [1100](#L1100) | } |
| [1101](#L1101) | const off = [on(window, "load resize", cb), on(document, "loadedmetadata load", cb, true)]; |
| [1102](#L1102) | return { disconnect: () => off.map((cb2) => cb2()) }; |
| [1103](#L1103) | } |
| [1104](#L1104) | function observeViewportResize(cb) { |
| [1105](#L1105) | return { disconnect: on([window, window.visualViewport], "resize", cb) }; |
| [1106](#L1106) | } |
| [1107](#L1107) | function observeMutation(targets, cb, options) { |
| [1108](#L1108) | return observe$1(MutationObserver, targets, cb, options); |
| [1109](#L1109) | } |
| [1110](#L1110) | function observe$1(Observer, targets, cb, options) { |
| [1111](#L1111) | const observer = new Observer(cb); |
| [1112](#L1112) | for (const el of toNodes(targets)) { |
| [1113](#L1113) | observer.observe(el, options); |
| [1114](#L1114) | } |
| [1115](#L1115) | return observer; |
| [1116](#L1116) | } |
| [1117](#L1117) |  |
| [1118](#L1118) | function play(el) { |
| [1119](#L1119) | if (isIFrame(el)) { |
| [1120](#L1120) | call(el, { func: "playVideo", method: "play" }); |
| [1121](#L1121) | } |
| [1122](#L1122) | if (isHTML5(el)) { |
| [1123](#L1123) | el.play().catch(noop); |
| [1124](#L1124) | } |
| [1125](#L1125) | } |
| [1126](#L1126) | function pause(el) { |
| [1127](#L1127) | if (isIFrame(el)) { |
| [1128](#L1128) | call(el, { func: "pauseVideo", method: "pause" }); |
| [1129](#L1129) | } |
| [1130](#L1130) | if (isHTML5(el)) { |
| [1131](#L1131) | el.pause(); |
| [1132](#L1132) | } |
| [1133](#L1133) | } |
| [1134](#L1134) | function mute(el) { |
| [1135](#L1135) | if (isIFrame(el)) { |
| [1136](#L1136) | call(el, { func: "mute", method: "setVolume", value: 0 }); |
| [1137](#L1137) | } |
| [1138](#L1138) | if (isHTML5(el)) { |
| [1139](#L1139) | el.muted = true; |
| [1140](#L1140) | } |
| [1141](#L1141) | } |
| [1142](#L1142) | function isVideo(el) { |
| [1143](#L1143) | return isHTML5(el) || isIFrame(el); |
| [1144](#L1144) | } |
| [1145](#L1145) | function isHTML5(el) { |
| [1146](#L1146) | return isTag(el, "video"); |
| [1147](#L1147) | } |
| [1148](#L1148) | function isIFrame(el) { |
| [1149](#L1149) | return isTag(el, "iframe") && (isYoutube(el) || isVimeo(el)); |
| [1150](#L1150) | } |
| [1151](#L1151) | function isYoutube(el) { |
| [1152](#L1152) | return !!el.src.match( |
| [1153](#L1153) | /\/\/.\*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.\*/ |
| [1154](#L1154) | ); |
| [1155](#L1155) | } |
| [1156](#L1156) | function isVimeo(el) { |
| [1157](#L1157) | return !!el.src.match(/vimeo\.com\/video\/.\*/); |
| [1158](#L1158) | } |
| [1159](#L1159) | async function call(el, cmd) { |
| [1160](#L1160) | await enableApi(el); |
| [1161](#L1161) | post(el, cmd); |
| [1162](#L1162) | } |
| [1163](#L1163) | function post(el, cmd) { |
| [1164](#L1164) | el.contentWindow.postMessage(JSON.stringify({ event: "command", ...cmd }), "\*"); |
| [1165](#L1165) | } |
| [1166](#L1166) | const stateKey = "\_ukPlayer"; |
| [1167](#L1167) | let counter = 0; |
| [1168](#L1168) | function enableApi(el) { |
| [1169](#L1169) | if (el[stateKey]) { |
| [1170](#L1170) | return el[stateKey]; |
| [1171](#L1171) | } |
| [1172](#L1172) | const youtube = isYoutube(el); |
| [1173](#L1173) | const vimeo = isVimeo(el); |
| [1174](#L1174) | const id = ++counter; |
| [1175](#L1175) | let poller; |
| [1176](#L1176) | return el[stateKey] = new Promise((resolve) => { |
| [1177](#L1177) | youtube && once(el, "load", () => { |
| [1178](#L1178) | const listener = () => post(el, { event: "listening", id }); |
| [1179](#L1179) | poller = setInterval(listener, 100); |
| [1180](#L1180) | listener(); |
| [1181](#L1181) | }); |
| [1182](#L1182) | once(window, "message", resolve, false, ({ data }) => { |
| [1183](#L1183) | try { |
| [1184](#L1184) | data = JSON.parse(data); |
| [1185](#L1185) | return youtube && (data == null ? void 0 : data.id) === id && data.event === "onReady" || vimeo && Number(data == null ? void 0 : data.player\_id) === id; |
| [1186](#L1186) | } catch (e) { |
| [1187](#L1187) | } |
| [1188](#L1188) | }); |
| [1189](#L1189) | el.src = `${el.src}${includes(el.src, "?") ? "&" : "?"}${youtube ? "enablejsapi=1" : `api=1&player\_id=${id}`}`; |
| [1190](#L1190) | }).then(() => clearInterval(poller)); |
| [1191](#L1191) | } |
| [1192](#L1192) |  |
| [1193](#L1193) | function isInView(element, offsetTop = 0, offsetLeft = 0) { |
| [1194](#L1194) | if (!isVisible(element)) { |
| [1195](#L1195) | return false; |
| [1196](#L1196) | } |
| [1197](#L1197) | return intersectRect( |
| [1198](#L1198) | ...overflowParents(element).map((parent2) => { |
| [1199](#L1199) | const { top, left, bottom, right } = offsetViewport(parent2); |
| [1200](#L1200) | return { |
| [1201](#L1201) | top: top - offsetTop, |
| [1202](#L1202) | left: left - offsetLeft, |
| [1203](#L1203) | bottom: bottom + offsetTop, |
| [1204](#L1204) | right: right + offsetLeft |
| [1205](#L1205) | }; |
| [1206](#L1206) | }).concat(offset(element)) |
| [1207](#L1207) | ); |
| [1208](#L1208) | } |
| [1209](#L1209) | function scrollIntoView(element, { offset: offsetBy = 0 } = {}) { |
| [1210](#L1210) | const parents2 = isVisible(element) ? scrollParents(element, false, ["hidden"]) : []; |
| [1211](#L1211) | return parents2.reduce( |
| [1212](#L1212) | (fn, scrollElement, i) => { |
| [1213](#L1213) | const { scrollTop, scrollHeight, offsetHeight } = scrollElement; |
| [1214](#L1214) | const viewport = offsetViewport(scrollElement); |
| [1215](#L1215) | const maxScroll = scrollHeight - viewport.height; |
| [1216](#L1216) | const { height: elHeight, top: elTop } = parents2[i - 1] ? offsetViewport(parents2[i - 1]) : offset(element); |
| [1217](#L1217) | let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop); |
| [1218](#L1218) | if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) { |
| [1219](#L1219) | top += offsetBy; |
| [1220](#L1220) | } else { |
| [1221](#L1221) | offsetBy = 0; |
| [1222](#L1222) | } |
| [1223](#L1223) | if (top > maxScroll) { |
| [1224](#L1224) | offsetBy -= top - maxScroll; |
| [1225](#L1225) | top = maxScroll; |
| [1226](#L1226) | } else if (top < 0) { |
| [1227](#L1227) | offsetBy -= top; |
| [1228](#L1228) | top = 0; |
| [1229](#L1229) | } |
| [1230](#L1230) | return () => scrollTo(scrollElement, top - scrollTop, element, maxScroll).then(fn); |
| [1231](#L1231) | }, |
| [1232](#L1232) | () => Promise.resolve() |
| [1233](#L1233) | )(); |
| [1234](#L1234) | function scrollTo(element2, top, targetEl, maxScroll) { |
| [1235](#L1235) | return new Promise((resolve) => { |
| [1236](#L1236) | const scroll = element2.scrollTop; |
| [1237](#L1237) | const duration = getDuration(Math.abs(top)); |
| [1238](#L1238) | const start = Date.now(); |
| [1239](#L1239) | const isScrollingElement = scrollingElement(element2) === element2; |
| [1240](#L1240) | const targetTop = offset(targetEl).top + (isScrollingElement ? 0 : scroll); |
| [1241](#L1241) | let prev = 0; |
| [1242](#L1242) | let frames = 15; |
| [1243](#L1243) | (function step() { |
| [1244](#L1244) | const percent = ease(clamp((Date.now() - start) / duration)); |
| [1245](#L1245) | let diff = 0; |
| [1246](#L1246) | if (parents2[0] === element2 && scroll + top < maxScroll) { |
| [1247](#L1247) | diff = offset(targetEl).top + (isScrollingElement ? 0 : element2.scrollTop) - targetTop - dimensions$1(getCoveringElement(targetEl)).height; |
| [1248](#L1248) | } |
| [1249](#L1249) | element2.scrollTop = scroll + (top + diff) \* percent; |
| [1250](#L1250) | if (percent === 1 && (prev === diff || !frames--)) { |
| [1251](#L1251) | resolve(); |
| [1252](#L1252) | } else { |
| [1253](#L1253) | prev = diff; |
| [1254](#L1254) | requestAnimationFrame(step); |
| [1255](#L1255) | } |
| [1256](#L1256) | })(); |
| [1257](#L1257) | }); |
| [1258](#L1258) | } |
| [1259](#L1259) | function getDuration(dist) { |
| [1260](#L1260) | return 40 \* Math.pow(dist, 0.375); |
| [1261](#L1261) | } |
| [1262](#L1262) | function ease(k) { |
| [1263](#L1263) | return 0.5 \* (1 - Math.cos(Math.PI \* k)); |
| [1264](#L1264) | } |
| [1265](#L1265) | } |
| [1266](#L1266) | function scrolledOver(element, startOffset = 0, endOffset = 0) { |
| [1267](#L1267) | if (!isVisible(element)) { |
| [1268](#L1268) | return 0; |
| [1269](#L1269) | } |
| [1270](#L1270) | const scrollElement = scrollParent(element, true); |
| [1271](#L1271) | const { scrollHeight, scrollTop } = scrollElement; |
| [1272](#L1272) | const { height: viewportHeight } = offsetViewport(scrollElement); |
| [1273](#L1273) | const maxScroll = scrollHeight - viewportHeight; |
| [1274](#L1274) | const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0]; |
| [1275](#L1275) | const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset); |
| [1276](#L1276) | const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset); |
| [1277](#L1277) | return start < end ? clamp((scrollTop - start) / (end - start)) : 1; |
| [1278](#L1278) | } |
| [1279](#L1279) | function scrollParents(element, scrollable = false, props = []) { |
| [1280](#L1280) | const scrollEl = scrollingElement(element); |
| [1281](#L1281) | let ancestors = parents(element).reverse(); |
| [1282](#L1282) | ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1); |
| [1283](#L1283) | const fixedIndex = findIndex(ancestors, (el) => css(el, "position") === "fixed"); |
| [1284](#L1284) | if (~fixedIndex) { |
| [1285](#L1285) | ancestors = ancestors.slice(fixedIndex); |
| [1286](#L1286) | } |
| [1287](#L1287) | return [scrollEl].concat( |
| [1288](#L1288) | ancestors.filter( |
| [1289](#L1289) | (parent2) => css(parent2, "overflow").split(" ").some((prop) => includes(["auto", "scroll", ...props], prop)) && (!scrollable || parent2.scrollHeight > offsetViewport(parent2).height) |
| [1290](#L1290) | ) |
| [1291](#L1291) | ).reverse(); |
| [1292](#L1292) | } |
| [1293](#L1293) | function scrollParent(...args) { |
| [1294](#L1294) | return scrollParents(...args)[0]; |
| [1295](#L1295) | } |
| [1296](#L1296) | function overflowParents(element) { |
| [1297](#L1297) | return scrollParents(element, false, ["hidden", "clip"]); |
| [1298](#L1298) | } |
| [1299](#L1299) | function offsetViewport(scrollElement) { |
| [1300](#L1300) | const window = toWindow(scrollElement); |
| [1301](#L1301) | const documentScrollingElement = scrollingElement(scrollElement); |
| [1302](#L1302) | const useWindow = scrollElement.contains(documentScrollingElement); |
| [1303](#L1303) | if (useWindow && window.visualViewport) { |
| [1304](#L1304) | let { height, width, scale, pageTop: top, pageLeft: left } = window.visualViewport; |
| [1305](#L1305) | height = Math.round(height \* scale); |
| [1306](#L1306) | width = Math.round(width \* scale); |
| [1307](#L1307) | return { height, width, top, left, bottom: top + height, right: left + width }; |
| [1308](#L1308) | } |
| [1309](#L1309) | let rect = offset(useWindow ? window : scrollElement); |
| [1310](#L1310) | if (css(scrollElement, "display") === "inline") { |
| [1311](#L1311) | return rect; |
| [1312](#L1312) | } |
| [1313](#L1313) | const { body, documentElement } = window.document; |
| [1314](#L1314) | const viewportElement = useWindow ? documentScrollingElement === documentElement || // In quirks mode the scrolling element is body, even though the viewport is html |
| [1315](#L1315) | documentScrollingElement.clientHeight < body.clientHeight ? documentScrollingElement : body : scrollElement; |
| [1316](#L1316) | for (let [prop, dir, start, end] of [ |
| [1317](#L1317) | ["width", "x", "left", "right"], |
| [1318](#L1318) | ["height", "y", "top", "bottom"] |
| [1319](#L1319) | ]) { |
| [1320](#L1320) | const subpixel = rect[prop] % 1; |
| [1321](#L1321) | rect[start] += toFloat(css(viewportElement, `border-${start}-width`)); |
| [1322](#L1322) | rect[prop] = rect[dir] = viewportElement[`client${ucfirst(prop)}`] - (subpixel ? subpixel < 0.5 ? -subpixel : 1 - subpixel : 0); |
| [1323](#L1323) | rect[end] = rect[prop] + rect[start]; |
| [1324](#L1324) | } |
| [1325](#L1325) | return rect; |
| [1326](#L1326) | } |
| [1327](#L1327) | function getCoveringElement(target) { |
| [1328](#L1328) | const { left, width, top } = dimensions$1(target); |
| [1329](#L1329) | for (const position of top ? [0, top] : [0]) { |
| [1330](#L1330) | let coverEl; |
| [1331](#L1331) | for (const el of toWindow(target).document.elementsFromPoint(left + width / 2, position)) { |
| [1332](#L1332) | if (!el.contains(target) && // If e.g. Offcanvas is not yet closed |
| [1333](#L1333) | !hasClass(el, "bdt-togglable-leave") && (hasPosition(el, "fixed") && zIndex( |
| [1334](#L1334) | parents(target).reverse().find( |
| [1335](#L1335) | (parent2) => !parent2.contains(el) && !hasPosition(parent2, "static") |
| [1336](#L1336) | ) |
| [1337](#L1337) | ) < zIndex(el) || hasPosition(el, "sticky") && parent(el).contains(target)) && (!coverEl || dimensions$1(coverEl).height < dimensions$1(el).height)) { |
| [1338](#L1338) | coverEl = el; |
| [1339](#L1339) | } |
| [1340](#L1340) | } |
| [1341](#L1341) | if (coverEl) { |
| [1342](#L1342) | return coverEl; |
| [1343](#L1343) | } |
| [1344](#L1344) | } |
| [1345](#L1345) | } |
| [1346](#L1346) | function zIndex(element) { |
| [1347](#L1347) | return toFloat(css(element, "zIndex")); |
| [1348](#L1348) | } |
| [1349](#L1349) | function hasPosition(element, position) { |
| [1350](#L1350) | return css(element, "position") === position; |
| [1351](#L1351) | } |
| [1352](#L1352) | function scrollingElement(element) { |
| [1353](#L1353) | return toWindow(element).document.scrollingElement; |
| [1354](#L1354) | } |
| [1355](#L1355) |  |
| [1356](#L1356) | const dirs = [ |
| [1357](#L1357) | ["width", "x", "left", "right"], |
| [1358](#L1358) | ["height", "y", "top", "bottom"] |
| [1359](#L1359) | ]; |
| [1360](#L1360) | function positionAt(element, target, options) { |
| [1361](#L1361) | options = { |
| [1362](#L1362) | attach: { |
| [1363](#L1363) | element: ["left", "top"], |
| [1364](#L1364) | target: ["left", "top"], |
| [1365](#L1365) | ...options.attach |
| [1366](#L1366) | }, |
| [1367](#L1367) | offset: [0, 0], |
| [1368](#L1368) | placement: [], |
| [1369](#L1369) | ...options |
| [1370](#L1370) | }; |
| [1371](#L1371) | if (!isArray(target)) { |
| [1372](#L1372) | target = [target, target]; |
| [1373](#L1373) | } |
| [1374](#L1374) | offset(element, getPosition(element, target, options)); |
| [1375](#L1375) | } |
| [1376](#L1376) | function getPosition(element, target, options) { |
| [1377](#L1377) | const position = attachTo(element, target, options); |
| [1378](#L1378) | const { boundary, viewportOffset = 0, placement } = options; |
| [1379](#L1379) | let offsetPosition = position; |
| [1380](#L1380) | for (const [i, [prop, , start, end]] of Object.entries(dirs)) { |
| [1381](#L1381) | const viewport = getViewport$2(element, target[i], viewportOffset, boundary, i); |
| [1382](#L1382) | if (isWithin(position, viewport, i)) { |
| [1383](#L1383) | continue; |
| [1384](#L1384) | } |
| [1385](#L1385) | let offsetBy = 0; |
| [1386](#L1386) | if (placement[i] === "flip") { |
| [1387](#L1387) | const attach = options.attach.target[i]; |
| [1388](#L1388) | if (attach === end && position[end] <= viewport[end] || attach === start && position[start] >= viewport[start]) { |
| [1389](#L1389) | continue; |
| [1390](#L1390) | } |
| [1391](#L1391) | offsetBy = flip(element, target, options, i)[start] - position[start]; |
| [1392](#L1392) | const scrollArea = getScrollArea(element, target[i], viewportOffset, i); |
| [1393](#L1393) | if (!isWithin(applyOffset(position, offsetBy, i), scrollArea, i)) { |
| [1394](#L1394) | if (isWithin(position, scrollArea, i)) { |
| [1395](#L1395) | continue; |
| [1396](#L1396) | } |
| [1397](#L1397) | if (options.recursion) { |
| [1398](#L1398) | return false; |
| [1399](#L1399) | } |
| [1400](#L1400) | const newPos = flipAxis(element, target, options); |
| [1401](#L1401) | if (newPos && isWithin(newPos, scrollArea, 1 - i)) { |
| [1402](#L1402) | return newPos; |
| [1403](#L1403) | } |
| [1404](#L1404) | continue; |
| [1405](#L1405) | } |
| [1406](#L1406) | } else if (placement[i] === "shift") { |
| [1407](#L1407) | const targetDim = offset(target[i]); |
| [1408](#L1408) | const { offset: elOffset } = options; |
| [1409](#L1409) | offsetBy = clamp( |
| [1410](#L1410) | clamp(position[start], viewport[start], viewport[end] - position[prop]), |
| [1411](#L1411) | targetDim[start] - position[prop] + elOffset[i], |
| [1412](#L1412) | targetDim[end] - elOffset[i] |
| [1413](#L1413) | ) - position[start]; |
| [1414](#L1414) | } |
| [1415](#L1415) | offsetPosition = applyOffset(offsetPosition, offsetBy, i); |
| [1416](#L1416) | } |
| [1417](#L1417) | return offsetPosition; |
| [1418](#L1418) | } |
| [1419](#L1419) | function attachTo(element, target, options) { |
| [1420](#L1420) | let { attach, offset: offsetBy } = { |
| [1421](#L1421) | attach: { |
| [1422](#L1422) | element: ["left", "top"], |
| [1423](#L1423) | target: ["left", "top"], |
| [1424](#L1424) | ...options.attach |
| [1425](#L1425) | }, |
| [1426](#L1426) | offset: [0, 0], |
| [1427](#L1427) | ...options |
| [1428](#L1428) | }; |
| [1429](#L1429) | let elOffset = offset(element); |
| [1430](#L1430) | for (const [i, [prop, , start, end]] of Object.entries(dirs)) { |
| [1431](#L1431) | const targetOffset = attach.target[i] === attach.element[i] ? offsetViewport(target[i]) : offset(target[i]); |
| [1432](#L1432) | elOffset = applyOffset( |
| [1433](#L1433) | elOffset, |
| [1434](#L1434) | targetOffset[start] - elOffset[start] + moveBy(attach.target[i], end, targetOffset[prop]) - moveBy(attach.element[i], end, elOffset[prop]) + +offsetBy[i], |
| [1435](#L1435) | i |
| [1436](#L1436) | ); |
| [1437](#L1437) | } |
| [1438](#L1438) | return elOffset; |
| [1439](#L1439) | } |
| [1440](#L1440) | function applyOffset(position, offset2, i) { |
| [1441](#L1441) | const [, dir, start, end] = dirs[i]; |
| [1442](#L1442) | const newPos = { ...position }; |
| [1443](#L1443) | newPos[start] = position[dir] = position[start] + offset2; |
| [1444](#L1444) | newPos[end] += offset2; |
| [1445](#L1445) | return newPos; |
| [1446](#L1446) | } |
| [1447](#L1447) | function moveBy(attach, end, dim) { |
| [1448](#L1448) | return attach === "center" ? dim / 2 : attach === end ? dim : 0; |
| [1449](#L1449) | } |
| [1450](#L1450) | function getViewport$2(element, target, viewportOffset, boundary, i) { |
| [1451](#L1451) | let viewport = getIntersectionArea(...commonScrollParents(element, target).map(offsetViewport)); |
| [1452](#L1452) | if (viewportOffset) { |
| [1453](#L1453) | viewport[dirs[i][2]] += viewportOffset; |
| [1454](#L1454) | viewport[dirs[i][3]] -= viewportOffset; |
| [1455](#L1455) | } |
| [1456](#L1456) | if (boundary) { |
| [1457](#L1457) | viewport = getIntersectionArea( |
| [1458](#L1458) | viewport, |
| [1459](#L1459) | offset(isArray(boundary) ? boundary[i] : boundary) |
| [1460](#L1460) | ); |
| [1461](#L1461) | } |
| [1462](#L1462) | return viewport; |
| [1463](#L1463) | } |
| [1464](#L1464) | function getScrollArea(element, target, viewportOffset, i) { |
| [1465](#L1465) | const [prop, axis, start, end] = dirs[i]; |
| [1466](#L1466) | const [scrollElement] = commonScrollParents(element, target); |
| [1467](#L1467) | const viewport = offsetViewport(scrollElement); |
| [1468](#L1468) | if (["auto", "scroll"].includes(css(scrollElement, `overflow-${axis}`))) { |
| [1469](#L1469) | viewport[start] -= scrollElement[`scroll${ucfirst(start)}`]; |
| [1470](#L1470) | viewport[end] = viewport[start] + scrollElement[`scroll${ucfirst(prop)}`]; |
| [1471](#L1471) | } |
| [1472](#L1472) | viewport[start] += viewportOffset; |
| [1473](#L1473) | viewport[end] -= viewportOffset; |
| [1474](#L1474) | return viewport; |
| [1475](#L1475) | } |
| [1476](#L1476) | function commonScrollParents(element, target) { |
| [1477](#L1477) | return overflowParents(target).filter((parent) => parent.contains(element)); |
| [1478](#L1478) | } |
| [1479](#L1479) | function getIntersectionArea(...rects) { |
| [1480](#L1480) | let area = {}; |
| [1481](#L1481) | for (const rect of rects) { |
| [1482](#L1482) | for (const [, , start, end] of dirs) { |
| [1483](#L1483) | area[start] = Math.max(area[start] || 0, rect[start]); |
| [1484](#L1484) | area[end] = Math.min(...[area[end], rect[end]].filter(Boolean)); |
| [1485](#L1485) | } |
| [1486](#L1486) | } |
| [1487](#L1487) | return area; |
| [1488](#L1488) | } |
| [1489](#L1489) | function isWithin(positionA, positionB, i) { |
| [1490](#L1490) | const [, , start, end] = dirs[i]; |
| [1491](#L1491) | return positionA[start] >= positionB[start] && positionA[end] <= positionB[end]; |
| [1492](#L1492) | } |
| [1493](#L1493) | function flip(element, target, { offset: offset2, attach }, i) { |
| [1494](#L1494) | return attachTo(element, target, { |
| [1495](#L1495) | attach: { |
| [1496](#L1496) | element: flipAttach(attach.element, i), |
| [1497](#L1497) | target: flipAttach(attach.target, i) |
| [1498](#L1498) | }, |
| [1499](#L1499) | offset: flipOffset(offset2, i) |
| [1500](#L1500) | }); |
| [1501](#L1501) | } |
| [1502](#L1502) | function flipAxis(element, target, options) { |
| [1503](#L1503) | return getPosition(element, target, { |
| [1504](#L1504) | ...options, |
| [1505](#L1505) | attach: { |
| [1506](#L1506) | element: options.attach.element.map(flipAttachAxis).reverse(), |
| [1507](#L1507) | target: options.attach.target.map(flipAttachAxis).reverse() |
| [1508](#L1508) | }, |
| [1509](#L1509) | offset: options.offset.reverse(), |
| [1510](#L1510) | placement: options.placement.reverse(), |
| [1511](#L1511) | recursion: true |
| [1512](#L1512) | }); |
| [1513](#L1513) | } |
| [1514](#L1514) | function flipAttach(attach, i) { |
| [1515](#L1515) | const newAttach = [...attach]; |
| [1516](#L1516) | const index = dirs[i].indexOf(attach[i]); |
| [1517](#L1517) | if (~index) { |
| [1518](#L1518) | newAttach[i] = dirs[i][1 - index % 2 + 2]; |
| [1519](#L1519) | } |
| [1520](#L1520) | return newAttach; |
| [1521](#L1521) | } |
| [1522](#L1522) | function flipAttachAxis(prop) { |
| [1523](#L1523) | for (let i = 0; i < dirs.length; i++) { |
| [1524](#L1524) | const index = dirs[i].indexOf(prop); |
| [1525](#L1525) | if (~index) { |
| [1526](#L1526) | return dirs[1 - i][index % 2 + 2]; |
| [1527](#L1527) | } |
| [1528](#L1528) | } |
| [1529](#L1529) | } |
| [1530](#L1530) | function flipOffset(offset2, i) { |
| [1531](#L1531) | offset2 = [...offset2]; |
| [1532](#L1532) | offset2[i] \*= -1; |
| [1533](#L1533) | return offset2; |
| [1534](#L1534) | } |
| [1535](#L1535) |  |
| [1536](#L1536) | var util = /\*#\_\_PURE\_\_\*/Object.freeze({ |
| [1537](#L1537) | \_\_proto\_\_: null, |
| [1538](#L1538) | $: $, |
| [1539](#L1539) | $$: $$, |
| [1540](#L1540) | Animation: Animation, |
| [1541](#L1541) | Dimensions: Dimensions, |
| [1542](#L1542) | MouseTracker: MouseTracker, |
| [1543](#L1543) | Transition: Transition, |
| [1544](#L1544) | addClass: addClass, |
| [1545](#L1545) | after: after, |
| [1546](#L1546) | append: append, |
| [1547](#L1547) | apply: apply, |
| [1548](#L1548) | assign: assign, |
| [1549](#L1549) | attr: attr, |
| [1550](#L1550) | before: before, |
| [1551](#L1551) | boxModelAdjust: boxModelAdjust, |
| [1552](#L1552) | camelize: camelize, |
| [1553](#L1553) | children: children, |
| [1554](#L1554) | clamp: clamp, |
| [1555](#L1555) | createEvent: createEvent, |
| [1556](#L1556) | css: css, |
| [1557](#L1557) | data: data, |
| [1558](#L1558) | dimensions: dimensions$1, |
| [1559](#L1559) | each: each, |
| [1560](#L1560) | empty: empty, |
| [1561](#L1561) | endsWith: endsWith, |
| [1562](#L1562) | escape: escape, |
| [1563](#L1563) | fastdom: fastdom, |
| [1564](#L1564) | filter: filter$1, |
| [1565](#L1565) | find: find, |
| [1566](#L1566) | findAll: findAll, |
| [1567](#L1567) | findIndex: findIndex, |
| [1568](#L1568) | flipPosition: flipPosition, |
| [1569](#L1569) | fragment: fragment, |
| [1570](#L1570) | getCoveringElement: getCoveringElement, |
| [1571](#L1571) | getEventPos: getEventPos, |
| [1572](#L1572) | getIndex: getIndex, |
| [1573](#L1573) | getTargetedElement: getTargetedElement, |
| [1574](#L1574) | hasAttr: hasAttr, |
| [1575](#L1575) | hasClass: hasClass, |
| [1576](#L1576) | hasOwn: hasOwn, |
| [1577](#L1577) | hasTouch: hasTouch, |
| [1578](#L1578) | height: height, |
| [1579](#L1579) | html: html, |
| [1580](#L1580) | hyphenate: hyphenate, |
| [1581](#L1581) | inBrowser: inBrowser, |
| [1582](#L1582) | includes: includes, |
| [1583](#L1583) | index: index, |
| [1584](#L1584) | intersectRect: intersectRect, |
| [1585](#L1585) | isArray: isArray, |
| [1586](#L1586) | isBoolean: isBoolean, |
| [1587](#L1587) | isDocument: isDocument, |
| [1588](#L1588) | isElement: isElement, |
| [1589](#L1589) | isEmpty: isEmpty, |
| [1590](#L1590) | isEqual: isEqual, |
| [1591](#L1591) | isFocusable: isFocusable, |
| [1592](#L1592) | isFunction: isFunction, |
| [1593](#L1593) | isInView: isInView, |
| [1594](#L1594) | isInput: isInput, |
| [1595](#L1595) | isNode: isNode, |
| [1596](#L1596) | isNumber: isNumber, |
| [1597](#L1597) | isNumeric: isNumeric, |
| [1598](#L1598) | isObject: isObject, |
| [1599](#L1599) | isPlainObject: isPlainObject, |
| [1600](#L1600) | isRtl: isRtl, |
| [1601](#L1601) | isSameSiteAnchor: isSameSiteAnchor, |
| [1602](#L1602) | isString: isString, |
| [1603](#L1603) | isTag: isTag, |
| [1604](#L1604) | isTouch: isTouch, |
| [1605](#L1605) | isUndefined: isUndefined, |
| [1606](#L1606) | isVideo: isVideo, |
| [1607](#L1607) | isVisible: isVisible, |
| [1608](#L1608) | isVoidElement: isVoidElement, |
| [1609](#L1609) | isWindow: isWindow, |
| [1610](#L1610) | last: last, |
| [1611](#L1611) | matches: matches, |
| [1612](#L1612) | memoize: memoize, |
| [1613](#L1613) | mute: mute, |
| [1614](#L1614) | noop: noop, |
| [1615](#L1615) | observeIntersection: observeIntersection, |
| [1616](#L1616) | observeMutation: observeMutation, |
| [1617](#L1617) | observeResize: observeResize, |
| [1618](#L1618) | observeViewportResize: observeViewportResize, |
| [1619](#L1619) | off: off, |
| [1620](#L1620) | offset: offset, |
| [1621](#L1621) | offsetPosition: offsetPosition, |
| [1622](#L1622) | offsetViewport: offsetViewport, |
| [1623](#L1623) | on: on, |
| [1624](#L1624) | once: once, |
| [1625](#L1625) | overflowParents: overflowParents, |
| [1626](#L1626) | parent: parent, |
| [1627](#L1627) | parents: parents, |
| [1628](#L1628) | pause: pause, |
| [1629](#L1629) | pick: pick, |
| [1630](#L1630) | play: play, |
| [1631](#L1631) | pointInRect: pointInRect, |
| [1632](#L1632) | pointerCancel: pointerCancel, |
| [1633](#L1633) | pointerDown: pointerDown$1, |
| [1634](#L1634) | pointerEnter: pointerEnter, |
| [1635](#L1635) | pointerLeave: pointerLeave, |
| [1636](#L1636) | pointerMove: pointerMove$1, |
| [1637](#L1637) | pointerUp: pointerUp$1, |
| [1638](#L1638) | position: position, |
| [1639](#L1639) | positionAt: positionAt, |
| [1640](#L1640) | prepend: prepend, |
| [1641](#L1641) | propName: propName, |
| [1642](#L1642) | query: query, |
| [1643](#L1643) | queryAll: queryAll, |
| [1644](#L1644) | ready: ready, |
| [1645](#L1645) | remove: remove$1, |
| [1646](#L1646) | removeAttr: removeAttr, |
| [1647](#L1647) | removeClass: removeClass, |
| [1648](#L1648) | replaceClass: replaceClass, |
| [1649](#L1649) | scrollIntoView: scrollIntoView, |
| [1650](#L1650) | scrollParent: scrollParent, |
| [1651](#L1651) | scrollParents: scrollParents, |
| [1652](#L1652) | scrolledOver: scrolledOver, |
| [1653](#L1653) | selFocusable: selFocusable, |
| [1654](#L1654) | selInput: selInput, |
| [1655](#L1655) | sortBy: sortBy, |
| [1656](#L1656) | startsWith: startsWith, |
| [1657](#L1657) | sumBy: sumBy, |
| [1658](#L1658) | swap: swap, |
| [1659](#L1659) | toArray: toArray, |
| [1660](#L1660) | toBoolean: toBoolean, |
| [1661](#L1661) | toEventTargets: toEventTargets, |
| [1662](#L1662) | toFloat: toFloat, |
| [1663](#L1663) | toNode: toNode, |
| [1664](#L1664) | toNodes: toNodes, |
| [1665](#L1665) | toNumber: toNumber, |
| [1666](#L1666) | toPx: toPx, |
| [1667](#L1667) | toWindow: toWindow, |
| [1668](#L1668) | toggleClass: toggleClass, |
| [1669](#L1669) | trigger: trigger, |
| [1670](#L1670) | ucfirst: ucfirst, |
| [1671](#L1671) | uniqueBy: uniqueBy, |
| [1672](#L1672) | unwrap: unwrap, |
| [1673](#L1673) | width: width, |
| [1674](#L1674) | wrapAll: wrapAll, |
| [1675](#L1675) | wrapInner: wrapInner |
| [1676](#L1676) | }); |
| [1677](#L1677) |  |
| [1678](#L1678) | var Class = { |
| [1679](#L1679) | connected() { |
| [1680](#L1680) | addClass(this.$el, this.$options.id); |
| [1681](#L1681) | } |
| [1682](#L1682) | }; |
| [1683](#L1683) |  |
| [1684](#L1684) | const units = ["days", "hours", "minutes", "seconds"]; |
| [1685](#L1685) | var countdown = { |
| [1686](#L1686) | mixins: [Class], |
| [1687](#L1687) | props: { |
| [1688](#L1688) | date: String, |
| [1689](#L1689) | clsWrapper: String, |
| [1690](#L1690) | role: String |
| [1691](#L1691) | }, |
| [1692](#L1692) | data: { |
| [1693](#L1693) | date: "", |
| [1694](#L1694) | clsWrapper: ".bdt-countdown-%unit%", |
| [1695](#L1695) | role: "timer" |
| [1696](#L1696) | }, |
| [1697](#L1697) | connected() { |
| [1698](#L1698) | attr(this.$el, "role", this.role); |
| [1699](#L1699) | this.date = toFloat(Date.parse(this.$props.date)); |
| [1700](#L1700) | this.end = false; |
| [1701](#L1701) | this.start(); |
| [1702](#L1702) | }, |
| [1703](#L1703) | disconnected() { |
| [1704](#L1704) | this.stop(); |
| [1705](#L1705) | }, |
| [1706](#L1706) | events: { |
| [1707](#L1707) | name: "visibilitychange", |
| [1708](#L1708) | el: () => document, |
| [1709](#L1709) | handler() { |
| [1710](#L1710) | if (document.hidden) { |
| [1711](#L1711) | this.stop(); |
| [1712](#L1712) | } else { |
| [1713](#L1713) | this.start(); |
| [1714](#L1714) | } |
| [1715](#L1715) | } |
| [1716](#L1716) | }, |
| [1717](#L1717) | methods: { |
| [1718](#L1718) | start() { |
| [1719](#L1719) | this.stop(); |
| [1720](#L1720) | this.update(); |
| [1721](#L1721) | if (!this.timer) { |
| [1722](#L1722) | trigger(this.$el, "countdownstart"); |
| [1723](#L1723) | this.timer = setInterval(this.update, 1e3); |
| [1724](#L1724) | } |
| [1725](#L1725) | }, |
| [1726](#L1726) | stop() { |
| [1727](#L1727) | if (this.timer) { |
| [1728](#L1728) | clearInterval(this.timer); |
| [1729](#L1729) | trigger(this.$el, "countdownstop"); |
| [1730](#L1730) | this.timer = null; |
| [1731](#L1731) | } |
| [1732](#L1732) | }, |
| [1733](#L1733) | update() { |
| [1734](#L1734) | const timespan = getTimeSpan(this.date); |
| [1735](#L1735) | if (!timespan.total) { |
| [1736](#L1736) | this.stop(); |
| [1737](#L1737) | if (!this.end) { |
| [1738](#L1738) | trigger(this.$el, "countdownend"); |
| [1739](#L1739) | this.end = true; |
| [1740](#L1740) | } |
| [1741](#L1741) | } |
| [1742](#L1742) | for (const unit of units) { |
| [1743](#L1743) | const el = $(this.clsWrapper.replace("%unit%", unit), this.$el); |
| [1744](#L1744) | if (!el) { |
| [1745](#L1745) | continue; |
| [1746](#L1746) | } |
| [1747](#L1747) | let digits = Math.trunc(timespan[unit]).toString().padStart(2, "0"); |
| [1748](#L1748) | if (el.textContent !== digits) { |
| [1749](#L1749) | digits = digits.split(""); |
| [1750](#L1750) | if (digits.length !== el.children.length) { |
| [1751](#L1751) | html(el, digits.map(() => "<span></span>").join("")); |
| [1752](#L1752) | } |
| [1753](#L1753) | digits.forEach((digit, i) => el.children[i].textContent = digit); |
| [1754](#L1754) | } |
| [1755](#L1755) | } |
| [1756](#L1756) | } |
| [1757](#L1757) | } |
| [1758](#L1758) | }; |
| [1759](#L1759) | function getTimeSpan(date) { |
| [1760](#L1760) | const total = Math.max(0, date - Date.now()) / 1e3; |
| [1761](#L1761) | return { |
| [1762](#L1762) | total, |
| [1763](#L1763) | seconds: total % 60, |
| [1764](#L1764) | minutes: total / 60 % 60, |
| [1765](#L1765) | hours: total / 60 / 60 % 24, |
| [1766](#L1766) | days: total / 60 / 60 / 24 |
| [1767](#L1767) | }; |
| [1768](#L1768) | } |
| [1769](#L1769) |  |
| [1770](#L1770) | const strats = {}; |
| [1771](#L1771) | strats.events = strats.watch = strats.observe = strats.created = strats.beforeConnect = strats.connected = strats.beforeDisconnect = strats.disconnected = strats.destroy = concatStrat; |
| [1772](#L1772) | strats.args = function(parentVal, childVal) { |
| [1773](#L1773) | return childVal !== false && concatStrat(childVal || parentVal); |
| [1774](#L1774) | }; |
| [1775](#L1775) | strats.update = function(parentVal, childVal) { |
| [1776](#L1776) | return sortBy( |
| [1777](#L1777) | concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal), |
| [1778](#L1778) | "order" |
| [1779](#L1779) | ); |
| [1780](#L1780) | }; |
| [1781](#L1781) | strats.props = function(parentVal, childVal) { |
| [1782](#L1782) | if (isArray(childVal)) { |
| [1783](#L1783) | const value = {}; |
| [1784](#L1784) | for (const key of childVal) { |
| [1785](#L1785) | value[key] = String; |
| [1786](#L1786) | } |
| [1787](#L1787) | childVal = value; |
| [1788](#L1788) | } |
| [1789](#L1789) | return strats.methods(parentVal, childVal); |
| [1790](#L1790) | }; |
| [1791](#L1791) | strats.computed = strats.methods = function(parentVal, childVal) { |
| [1792](#L1792) | return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal; |
| [1793](#L1793) | }; |
| [1794](#L1794) | strats.i18n = strats.data = function(parentVal, childVal, vm) { |
| [1795](#L1795) | if (!vm) { |
| [1796](#L1796) | if (!childVal) { |
| [1797](#L1797) | return parentVal; |
| [1798](#L1798) | } |
| [1799](#L1799) | if (!parentVal) { |
| [1800](#L1800) | return childVal; |
| [1801](#L1801) | } |
| [1802](#L1802) | return function(vm2) { |
| [1803](#L1803) | return mergeFnData(parentVal, childVal, vm2); |
| [1804](#L1804) | }; |
| [1805](#L1805) | } |
| [1806](#L1806) | return mergeFnData(parentVal, childVal, vm); |
| [1807](#L1807) | }; |
| [1808](#L1808) | function mergeFnData(parentVal, childVal, vm) { |
| [1809](#L1809) | return strats.computed( |
| [1810](#L1810) | isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal, |
| [1811](#L1811) | isFunction(childVal) ? childVal.call(vm, vm) : childVal |
| [1812](#L1812) | ); |
| [1813](#L1813) | } |
| [1814](#L1814) | function concatStrat(parentVal, childVal) { |
| [1815](#L1815) | parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal; |
| [1816](#L1816) | return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal; |
| [1817](#L1817) | } |
| [1818](#L1818) | function defaultStrat(parentVal, childVal) { |
| [1819](#L1819) | return isUndefined(childVal) ? parentVal : childVal; |
| [1820](#L1820) | } |
| [1821](#L1821) | function mergeOptions(parent, child, vm) { |
| [1822](#L1822) | const options = {}; |
| [1823](#L1823) | if (isFunction(child)) { |
| [1824](#L1824) | child = child.options; |
| [1825](#L1825) | } |
| [1826](#L1826) | if (child.extends) { |
| [1827](#L1827) | parent = mergeOptions(parent, child.extends, vm); |
| [1828](#L1828) | } |
| [1829](#L1829) | if (child.mixins) { |
| [1830](#L1830) | for (const mixin of child.mixins) { |
| [1831](#L1831) | parent = mergeOptions(parent, mixin, vm); |
| [1832](#L1832) | } |
| [1833](#L1833) | } |
| [1834](#L1834) | for (const key in parent) { |
| [1835](#L1835) | mergeKey(key); |
| [1836](#L1836) | } |
| [1837](#L1837) | for (const key in child) { |
| [1838](#L1838) | if (!hasOwn(parent, key)) { |
| [1839](#L1839) | mergeKey(key); |
| [1840](#L1840) | } |
| [1841](#L1841) | } |
| [1842](#L1842) | function mergeKey(key) { |
| [1843](#L1843) | options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm); |
| [1844](#L1844) | } |
| [1845](#L1845) | return options; |
| [1846](#L1846) | } |
| [1847](#L1847) | function parseOptions(options, args = []) { |
| [1848](#L1848) | try { |
| [1849](#L1849) | return options ? startsWith(options, "{") ? JSON.parse(options) : args.length && !includes(options, ":") ? { [args[0]]: options } : options.split(";").reduce((options2, option) => { |
| [1850](#L1850) | const [key, value] = option.split(/:(.\*)/); |
| [1851](#L1851) | if (key && !isUndefined(value)) { |
| [1852](#L1852) | options2[key.trim()] = value.trim(); |
| [1853](#L1853) | } |
| [1854](#L1854) | return options2; |
| [1855](#L1855) | }, {}) : {}; |
| [1856](#L1856) | } catch (e) { |
| [1857](#L1857) | return {}; |
| [1858](#L1858) | } |
| [1859](#L1859) | } |
| [1860](#L1860) | function coerce$1(type, value) { |
| [1861](#L1861) | if (type === Boolean) { |
| [1862](#L1862) | return toBoolean(value); |
| [1863](#L1863) | } else if (type === Number) { |
| [1864](#L1864) | return toNumber(value); |
| [1865](#L1865) | } else if (type === "list") { |
| [1866](#L1866) | return toList(value); |
| [1867](#L1867) | } else if (type === Object && isString(value)) { |
| [1868](#L1868) | return parseOptions(value); |
| [1869](#L1869) | } |
| [1870](#L1870) | return type ? type(value) : value; |
| [1871](#L1871) | } |
| [1872](#L1872) | const listRe = /,(?![^(]\*\))/; |
| [1873](#L1873) | function toList(value) { |
| [1874](#L1874) | return isArray(value) ? value : isString(value) ? value.split(listRe).map((value2) => isNumeric(value2) ? toNumber(value2) : toBoolean(value2.trim())) : [value]; |
| [1875](#L1875) | } |
| [1876](#L1876) |  |
| [1877](#L1877) | function initUpdates(instance) { |
| [1878](#L1878) | instance.\_data = {}; |
| [1879](#L1879) | instance.\_updates = [...instance.$options.update || []]; |
| [1880](#L1880) | } |
| [1881](#L1881) | function prependUpdate(instance, update) { |
| [1882](#L1882) | instance.\_updates.unshift(update); |
| [1883](#L1883) | } |
| [1884](#L1884) | function clearUpdateData(instance) { |
| [1885](#L1885) | instance.\_data = null; |
| [1886](#L1886) | } |
| [1887](#L1887) | function callUpdate(instance, e = "update") { |
| [1888](#L1888) | if (!instance.\_connected) { |
| [1889](#L1889) | return; |
| [1890](#L1890) | } |
| [1891](#L1891) | if (!instance.\_updates.length) { |
| [1892](#L1892) | return; |
| [1893](#L1893) | } |
| [1894](#L1894) | if (!instance.\_queued) { |
| [1895](#L1895) | instance.\_queued = /\* @\_\_PURE\_\_ \*/ new Set(); |
| [1896](#L1896) | fastdom.read(() => { |
| [1897](#L1897) | if (instance.\_connected) { |
| [1898](#L1898) | runUpdates(instance, instance.\_queued); |
| [1899](#L1899) | } |
| [1900](#L1900) | instance.\_queued = null; |
| [1901](#L1901) | }); |
| [1902](#L1902) | } |
| [1903](#L1903) | instance.\_queued.add(e.type || e); |
| [1904](#L1904) | } |
| [1905](#L1905) | function runUpdates(instance, types) { |
| [1906](#L1906) | for (const { read, write, events = [] } of instance.\_updates) { |
| [1907](#L1907) | if (!types.has("update") && !events.some((type) => types.has(type))) { |
| [1908](#L1908) | continue; |
| [1909](#L1909) | } |
| [1910](#L1910) | let result; |
| [1911](#L1911) | if (read) { |
| [1912](#L1912) | result = read.call(instance, instance.\_data, types); |
| [1913](#L1913) | if (result && isPlainObject(result)) { |
| [1914](#L1914) | assign(instance.\_data, result); |
| [1915](#L1915) | } |
| [1916](#L1916) | } |
| [1917](#L1917) | if (write && result !== false) { |
| [1918](#L1918) | fastdom.write(() => { |
| [1919](#L1919) | if (instance.\_connected) { |
| [1920](#L1920) | write.call(instance, instance.\_data, types); |
| [1921](#L1921) | } |
| [1922](#L1922) | }); |
| [1923](#L1923) | } |
| [1924](#L1924) | } |
| [1925](#L1925) | } |
| [1926](#L1926) |  |
| [1927](#L1927) | function resize(options) { |
| [1928](#L1928) | return observe(observeResize, options, "resize"); |
| [1929](#L1929) | } |
| [1930](#L1930) | function intersection(options) { |
| [1931](#L1931) | return observe(observeIntersection, options); |
| [1932](#L1932) | } |
| [1933](#L1933) | function mutation(options) { |
| [1934](#L1934) | return observe(observeMutation, options); |
| [1935](#L1935) | } |
| [1936](#L1936) | function lazyload(options = {}) { |
| [1937](#L1937) | return intersection({ |
| [1938](#L1938) | handler: function(entries, observer) { |
| [1939](#L1939) | const { targets = this.$el, preload = 5 } = options; |
| [1940](#L1940) | for (const el of toNodes(isFunction(targets) ? targets(this) : targets)) { |
| [1941](#L1941) | $$('[loading="lazy"]', el).slice(0, preload - 1).forEach((el2) => removeAttr(el2, "loading")); |
| [1942](#L1942) | } |
| [1943](#L1943) | for (const el of entries.filter(({ isIntersecting }) => isIntersecting).map(({ target }) => target)) { |
| [1944](#L1944) | observer.unobserve(el); |
| [1945](#L1945) | } |
| [1946](#L1946) | }, |
| [1947](#L1947) | ...options |
| [1948](#L1948) | }); |
| [1949](#L1949) | } |
| [1950](#L1950) | function viewport(options) { |
| [1951](#L1951) | return observe((target, handler) => observeViewportResize(handler), options, "resize"); |
| [1952](#L1952) | } |
| [1953](#L1953) | function scroll$1(options) { |
| [1954](#L1954) | return observe( |
| [1955](#L1955) | (target, handler) => ({ |
| [1956](#L1956) | disconnect: on(toScrollTargets(target), "scroll", handler, { passive: true }) |
| [1957](#L1957) | }), |
| [1958](#L1958) | options, |
| [1959](#L1959) | "scroll" |
| [1960](#L1960) | ); |
| [1961](#L1961) | } |
| [1962](#L1962) | function swipe(options) { |
| [1963](#L1963) | return { |
| [1964](#L1964) | observe(target, handler) { |
| [1965](#L1965) | return { |
| [1966](#L1966) | observe: noop, |
| [1967](#L1967) | unobserve: noop, |
| [1968](#L1968) | disconnect: on(target, pointerDown$1, handler, { passive: true }) |
| [1969](#L1969) | }; |
| [1970](#L1970) | }, |
| [1971](#L1971) | handler(e) { |
| [1972](#L1972) | if (!isTouch(e)) { |
| [1973](#L1973) | return; |
| [1974](#L1974) | } |
| [1975](#L1975) | const pos = getEventPos(e); |
| [1976](#L1976) | const target = "tagName" in e.target ? e.target : parent(e.target); |
| [1977](#L1977) | once(document, `${pointerUp$1} ${pointerCancel} scroll`, (e2) => { |
| [1978](#L1978) | const { x, y } = getEventPos(e2); |
| [1979](#L1979) | if (e2.type !== "scroll" && target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) { |
| [1980](#L1980) | setTimeout(() => { |
| [1981](#L1981) | trigger(target, "swipe"); |
| [1982](#L1982) | trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`); |
| [1983](#L1983) | }); |
| [1984](#L1984) | } |
| [1985](#L1985) | }); |
| [1986](#L1986) | }, |
| [1987](#L1987) | ...options |
| [1988](#L1988) | }; |
| [1989](#L1989) | } |
| [1990](#L1990) | function observe(observe2, options, emit) { |
| [1991](#L1991) | return { |
| [1992](#L1992) | observe: observe2, |
| [1993](#L1993) | handler() { |
| [1994](#L1994) | callUpdate(this, emit); |
| [1995](#L1995) | }, |
| [1996](#L1996) | ...options |
| [1997](#L1997) | }; |
| [1998](#L1998) | } |
| [1999](#L1999) | function swipeDirection(x1, y1, x2, y2) { |
| [2000](#L2000) | return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? "Left" : "Right" : y1 - y2 > 0 ? "Up" : "Down"; |
| [2001](#L2001) | } |
| [2002](#L2002) | function toScrollTargets(elements) { |
| [2003](#L2003) | return toNodes(elements).map((node) => { |
| [2004](#L2004) | const { ownerDocument } = node; |
| [2005](#L2005) | const parent2 = scrollParent(node, true); |
| [2006](#L2006) | return parent2 === ownerDocument.scrollingElement ? ownerDocument : parent2; |
| [2007](#L2007) | }); |
| [2008](#L2008) | } |
| [2009](#L2009) |  |
| [2010](#L2010) | var Margin = { |
| [2011](#L2011) | props: { |
| [2012](#L2012) | margin: String, |
| [2013](#L2013) | firstColumn: Boolean |
| [2014](#L2014) | }, |
| [2015](#L2015) | data: { |
| [2016](#L2016) | margin: "bdt-margin-small-top", |
| [2017](#L2017) | firstColumn: "bdt-first-column" |
| [2018](#L2018) | }, |
| [2019](#L2019) | observe: [ |
| [2020](#L2020) | mutation({ |
| [2021](#L2021) | options: { |
| [2022](#L2022) | childList: true |
| [2023](#L2023) | } |
| [2024](#L2024) | }), |
| [2025](#L2025) | mutation({ |
| [2026](#L2026) | options: { |
| [2027](#L2027) | attributes: true, |
| [2028](#L2028) | attributeFilter: ["style"] |
| [2029](#L2029) | }, |
| [2030](#L2030) | target: ({ $el }) => [$el, ...children($el)] |
| [2031](#L2031) | }), |
| [2032](#L2032) | resize({ |
| [2033](#L2033) | target: ({ $el }) => [$el, ...children($el)] |
| [2034](#L2034) | }) |
| [2035](#L2035) | ], |
| [2036](#L2036) | update: { |
| [2037](#L2037) | read() { |
| [2038](#L2038) | return { |
| [2039](#L2039) | rows: getRows(children(this.$el)) |
| [2040](#L2040) | }; |
| [2041](#L2041) | }, |
| [2042](#L2042) | write({ rows }) { |
| [2043](#L2043) | for (const row of rows) { |
| [2044](#L2044) | for (const el of row) { |
| [2045](#L2045) | toggleClass(el, this.margin, rows[0] !== row); |
| [2046](#L2046) | toggleClass(el, this.firstColumn, row[isRtl ? row.length - 1 : 0] === el); |
| [2047](#L2047) | } |
| [2048](#L2048) | } |
| [2049](#L2049) | }, |
| [2050](#L2050) | events: ["resize"] |
| [2051](#L2051) | } |
| [2052](#L2052) | }; |
| [2053](#L2053) | function getRows(elements) { |
| [2054](#L2054) | const sorted = [[]]; |
| [2055](#L2055) | const withOffset = elements.some( |
| [2056](#L2056) | (el, i) => i && elements[i - 1].offsetParent !== el.offsetParent |
| [2057](#L2057) | ); |
| [2058](#L2058) | for (const el of elements) { |
| [2059](#L2059) | if (!isVisible(el)) { |
| [2060](#L2060) | continue; |
| [2061](#L2061) | } |
| [2062](#L2062) | const offset = getOffset(el, withOffset); |
| [2063](#L2063) | for (let i = sorted.length - 1; i >= 0; i--) { |
| [2064](#L2064) | const current = sorted[i]; |
| [2065](#L2065) | if (!current[0]) { |
| [2066](#L2066) | current.push(el); |
| [2067](#L2067) | break; |
| [2068](#L2068) | } |
| [2069](#L2069) | const offsetCurrent = getOffset(current[0], withOffset); |
| [2070](#L2070) | if (offset.top >= offsetCurrent.bottom - 1 && offset.top !== offsetCurrent.top) { |
| [2071](#L2071) | sorted.push([el]); |
| [2072](#L2072) | break; |
| [2073](#L2073) | } |
| [2074](#L2074) | if (offset.bottom - 1 > offsetCurrent.top || offset.top === offsetCurrent.top) { |
| [2075](#L2075) | let j = current.length - 1; |
| [2076](#L2076) | for (; j >= 0; j--) { |
| [2077](#L2077) | const offsetCurrent2 = getOffset(current[j], withOffset); |
| [2078](#L2078) | if (offset.left >= offsetCurrent2.left) { |
| [2079](#L2079) | break; |
| [2080](#L2080) | } |
| [2081](#L2081) | } |
| [2082](#L2082) | current.splice(j + 1, 0, el); |
| [2083](#L2083) | break; |
| [2084](#L2084) | } |
| [2085](#L2085) | if (i === 0) { |
| [2086](#L2086) | sorted.unshift([el]); |
| [2087](#L2087) | break; |
| [2088](#L2088) | } |
| [2089](#L2089) | } |
| [2090](#L2090) | } |
| [2091](#L2091) | return sorted; |
| [2092](#L2092) | } |
| [2093](#L2093) | function getOffset(element, offset = false) { |
| [2094](#L2094) | let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element; |
| [2095](#L2095) | if (offset) { |
| [2096](#L2096) | [offsetTop, offsetLeft] = offsetPosition(element); |
| [2097](#L2097) | } |
| [2098](#L2098) | return { |
| [2099](#L2099) | top: offsetTop, |
| [2100](#L2100) | left: offsetLeft, |
| [2101](#L2101) | bottom: offsetTop + offsetHeight, |
| [2102](#L2102) | right: offsetLeft + offsetWidth |
| [2103](#L2103) | }; |
| [2104](#L2104) | } |
| [2105](#L2105) |  |
| [2106](#L2106) | async function slide(action, target, duration) { |
| [2107](#L2107) | await awaitFrame(); |
| [2108](#L2108) | let nodes = children(target); |
| [2109](#L2109) | const currentProps = nodes.map((el) => getProps$1(el, true)); |
| [2110](#L2110) | const targetProps = { ...css(target, ["height", "padding"]), display: "block" }; |
| [2111](#L2111) | const targets = nodes.concat(target); |
| [2112](#L2112) | await Promise.all(targets.map(Transition.cancel)); |
| [2113](#L2113) | css(targets, "transitionProperty", "none"); |
| [2114](#L2114) | await action(); |
| [2115](#L2115) | nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el))); |
| [2116](#L2116) | await Promise.resolve(); |
| [2117](#L2117) | css(targets, "transitionProperty", ""); |
| [2118](#L2118) | const targetStyle = attr(target, "style"); |
| [2119](#L2119) | const targetPropsTo = css(target, ["height", "padding"]); |
| [2120](#L2120) | const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps); |
| [2121](#L2121) | const attrsTo = nodes.map((el) => ({ style: attr(el, "style") })); |
| [2122](#L2122) | nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i])); |
| [2123](#L2123) | css(target, targetProps); |
| [2124](#L2124) | trigger(target, "scroll"); |
| [2125](#L2125) | await awaitFrame(); |
| [2126](#L2126) | const transitions = nodes.map((el, i) => parent(el) === target && Transition.start(el, propsTo[i], duration, "ease")).concat(Transition.start(target, targetPropsTo, duration, "ease")); |
| [2127](#L2127) | try { |
| [2128](#L2128) | await Promise.all(transitions); |
| [2129](#L2129) | nodes.forEach((el, i) => { |
| [2130](#L2130) | attr(el, attrsTo[i]); |
| [2131](#L2131) | if (parent(el) === target) { |
| [2132](#L2132) | css(el, "display", propsTo[i].opacity === 0 ? "none" : ""); |
| [2133](#L2133) | } |
| [2134](#L2134) | }); |
| [2135](#L2135) | attr(target, "style", targetStyle); |
| [2136](#L2136) | } catch (e) { |
| [2137](#L2137) | attr(nodes, "style", ""); |
| [2138](#L2138) | resetProps(target, targetProps); |
| [2139](#L2139) | } |
| [2140](#L2140) | } |
| [2141](#L2141) | function getProps$1(el, opacity) { |
| [2142](#L2142) | const zIndex = css(el, "zIndex"); |
| [2143](#L2143) | return isVisible(el) ? { |
| [2144](#L2144) | display: "", |
| [2145](#L2145) | opacity: opacity ? css(el, "opacity") : "0", |
| [2146](#L2146) | pointerEvents: "none", |
| [2147](#L2147) | position: "absolute", |
| [2148](#L2148) | zIndex: zIndex === "auto" ? index(el) : zIndex, |
| [2149](#L2149) | ...getPositionWithMargin(el) |
| [2150](#L2150) | } : false; |
| [2151](#L2151) | } |
| [2152](#L2152) | function getTransitionProps(target, nodes, currentProps) { |
| [2153](#L2153) | const propsTo = nodes.map( |
| [2154](#L2154) | (el, i) => parent(el) && i in currentProps ? currentProps[i] ? isVisible(el) ? getPositionWithMargin(el) : { opacity: 0 } : { opacity: isVisible(el) ? 1 : 0 } : false |
| [2155](#L2155) | ); |
| [2156](#L2156) | const propsFrom = propsTo.map((props, i) => { |
| [2157](#L2157) | const from = parent(nodes[i]) === target && (currentProps[i] || getProps$1(nodes[i])); |
| [2158](#L2158) | if (!from) { |
| [2159](#L2159) | return false; |
| [2160](#L2160) | } |
| [2161](#L2161) | if (!props) { |
| [2162](#L2162) | delete from.opacity; |
| [2163](#L2163) | } else if (!("opacity" in props)) { |
| [2164](#L2164) | const { opacity } = from; |
| [2165](#L2165) | if (opacity % 1) { |
| [2166](#L2166) | props.opacity = 1; |
| [2167](#L2167) | } else { |
| [2168](#L2168) | delete from.opacity; |
| [2169](#L2169) | } |
| [2170](#L2170) | } |
| [2171](#L2171) | return from; |
| [2172](#L2172) | }); |
| [2173](#L2173) | return [propsTo, propsFrom]; |
| [2174](#L2174) | } |
| [2175](#L2175) | function resetProps(el, props) { |
| [2176](#L2176) | for (const prop in props) { |
| [2177](#L2177) | css(el, prop, ""); |
| [2178](#L2178) | } |
| [2179](#L2179) | } |
| [2180](#L2180) | function getPositionWithMargin(el) { |
| [2181](#L2181) | const { height, width } = dimensions$1(el); |
| [2182](#L2182) | return { |
| [2183](#L2183) | height, |
| [2184](#L2184) | width, |
| [2185](#L2185) | transform: "", |
| [2186](#L2186) | ...position(el), |
| [2187](#L2187) | ...css(el, ["marginTop", "marginLeft"]) |
| [2188](#L2188) | }; |
| [2189](#L2189) | } |
| [2190](#L2190) | function awaitFrame() { |
| [2191](#L2191) | return new Promise((resolve) => requestAnimationFrame(resolve)); |
| [2192](#L2192) | } |
| [2193](#L2193) |  |
| [2194](#L2194) | const clsLeave = "bdt-transition-leave"; |
| [2195](#L2195) | const clsEnter = "bdt-transition-enter"; |
| [2196](#L2196) | function fade(action, target, duration, stagger = 0) { |
| [2197](#L2197) | const index = transitionIndex(target, true); |
| [2198](#L2198) | const propsIn = { opacity: 1 }; |
| [2199](#L2199) | const propsOut = { opacity: 0 }; |
| [2200](#L2200) | const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject(); |
| [2201](#L2201) | const leaveFn = wrapIndexFn(async () => { |
| [2202](#L2202) | addClass(target, clsLeave); |
| [2203](#L2203) | await Promise.all( |
| [2204](#L2204) | getTransitionNodes(target).map( |
| [2205](#L2205) | (child, i) => new Promise( |
| [2206](#L2206) | (resolve) => setTimeout( |
| [2207](#L2207) | () => Transition.start(child, propsOut, duration / 2, "ease").then( |
| [2208](#L2208) | resolve |
| [2209](#L2209) | ), |
| [2210](#L2210) | i \* stagger |
| [2211](#L2211) | ) |
| [2212](#L2212) | ) |
| [2213](#L2213) | ) |
| [2214](#L2214) | ); |
| [2215](#L2215) | removeClass(target, clsLeave); |
| [2216](#L2216) | }); |
| [2217](#L2217) | const enterFn = wrapIndexFn(async () => { |
| [2218](#L2218) | const oldHeight = height(target); |
| [2219](#L2219) | addClass(target, clsEnter); |
| [2220](#L2220) | action(); |
| [2221](#L2221) | css(children(target), { opacity: 0 }); |
| [2222](#L2222) | await awaitFrame(); |
| [2223](#L2223) | const nodes = children(target); |
| [2224](#L2224) | const newHeight = height(target); |
| [2225](#L2225) | css(target, "alignContent", "flex-start"); |
| [2226](#L2226) | height(target, oldHeight); |
| [2227](#L2227) | const transitionNodes = getTransitionNodes(target); |
| [2228](#L2228) | css(nodes, propsOut); |
| [2229](#L2229) | const transitions = transitionNodes.map(async (child, i) => { |
| [2230](#L2230) | await awaitTimeout(i \* stagger); |
| [2231](#L2231) | await Transition.start(child, propsIn, duration / 2, "ease"); |
| [2232](#L2232) | }); |
| [2233](#L2233) | if (oldHeight !== newHeight) { |
| [2234](#L2234) | transitions.push( |
| [2235](#L2235) | Transition.start( |
| [2236](#L2236) | target, |
| [2237](#L2237) | { height: newHeight }, |
| [2238](#L2238) | duration / 2 + transitionNodes.length \* stagger, |
| [2239](#L2239) | "ease" |
| [2240](#L2240) | ) |
| [2241](#L2241) | ); |
| [2242](#L2242) | } |
| [2243](#L2243) | await Promise.all(transitions).then(() => { |
| [2244](#L2244) | removeClass(target, clsEnter); |
| [2245](#L2245) | if (index === transitionIndex(target)) { |
| [2246](#L2246) | css(target, { height: "", alignContent: "" }); |
| [2247](#L2247) | css(nodes, { opacity: "" }); |
| [2248](#L2248) | delete target.dataset.transition; |
| [2249](#L2249) | } |
| [2250](#L2250) | }); |
| [2251](#L2251) | }); |
| [2252](#L2252) | return hasClass(target, clsLeave) ? waitTransitionend(target).then(enterFn) : hasClass(target, clsEnter) ? waitTransitionend(target).then(leaveFn).then(enterFn) : leaveFn().then(enterFn); |
| [2253](#L2253) | } |
| [2254](#L2254) | function transitionIndex(target, next) { |
| [2255](#L2255) | if (next) { |
| [2256](#L2256) | target.dataset.transition = 1 + transitionIndex(target); |
| [2257](#L2257) | } |
| [2258](#L2258) | return toNumber(target.dataset.transition) || 0; |
| [2259](#L2259) | } |
| [2260](#L2260) | function waitTransitionend(target) { |
| [2261](#L2261) | return Promise.all( |
| [2262](#L2262) | children(target).filter(Transition.inProgress).map( |
| [2263](#L2263) | (el) => new Promise((resolve) => once(el, "transitionend transitioncanceled", resolve)) |
| [2264](#L2264) | ) |
| [2265](#L2265) | ); |
| [2266](#L2266) | } |
| [2267](#L2267) | function getTransitionNodes(target) { |
| [2268](#L2268) | return getRows(children(target)).flat().filter(isVisible); |
| [2269](#L2269) | } |
| [2270](#L2270) | function awaitTimeout(timeout) { |
| [2271](#L2271) | return new Promise((resolve) => setTimeout(resolve, timeout)); |
| [2272](#L2272) | } |
| [2273](#L2273) |  |
| [2274](#L2274) | var Animate = { |
| [2275](#L2275) | props: { |
| [2276](#L2276) | duration: Number, |
| [2277](#L2277) | animation: Boolean |
| [2278](#L2278) | }, |
| [2279](#L2279) | data: { |
| [2280](#L2280) | duration: 150, |
| [2281](#L2281) | animation: "slide" |
| [2282](#L2282) | }, |
| [2283](#L2283) | methods: { |
| [2284](#L2284) | animate(action, target = this.$el) { |
| [2285](#L2285) | const name = this.animation; |
| [2286](#L2286) | const animationFn = name === "fade" ? fade : name === "delayed-fade" ? (...args) => fade(...args, 40) : name ? slide : () => { |
| [2287](#L2287) | action(); |
| [2288](#L2288) | return Promise.resolve(); |
| [2289](#L2289) | }; |
| [2290](#L2290) | return animationFn(action, target, this.duration).catch(noop); |
| [2291](#L2291) | } |
| [2292](#L2292) | } |
| [2293](#L2293) | }; |
| [2294](#L2294) |  |
| [2295](#L2295) | const keyMap = { |
| [2296](#L2296) | TAB: 9, |
| [2297](#L2297) | ESC: 27, |
| [2298](#L2298) | SPACE: 32, |
| [2299](#L2299) | END: 35, |
| [2300](#L2300) | HOME: 36, |
| [2301](#L2301) | LEFT: 37, |
| [2302](#L2302) | UP: 38, |
| [2303](#L2303) | RIGHT: 39, |
| [2304](#L2304) | DOWN: 40 |
| [2305](#L2305) | }; |
| [2306](#L2306) |  |
| [2307](#L2307) | var filter = { |
| [2308](#L2308) | mixins: [Animate], |
| [2309](#L2309) | args: "target", |
| [2310](#L2310) | props: { |
| [2311](#L2311) | target: String, |
| [2312](#L2312) | selActive: Boolean |
| [2313](#L2313) | }, |
| [2314](#L2314) | data: { |
| [2315](#L2315) | target: "", |
| [2316](#L2316) | selActive: false, |
| [2317](#L2317) | attrItem: "bdt-filter-control", |
| [2318](#L2318) | cls: "bdt-active", |
| [2319](#L2319) | duration: 250 |
| [2320](#L2320) | }, |
| [2321](#L2321) | computed: { |
| [2322](#L2322) | children: ({ target }, $el) => $$(`${target} > \*`, $el), |
| [2323](#L2323) | toggles: ({ attrItem }, $el) => $$(`[${attrItem}],[data-${attrItem}]`, $el) |
| [2324](#L2324) | }, |
| [2325](#L2325) | watch: { |
| [2326](#L2326) | toggles(toggles) { |
| [2327](#L2327) | this.updateState(); |
| [2328](#L2328) | const actives = $$(this.selActive, this.$el); |
| [2329](#L2329) | for (const toggle of toggles) { |
| [2330](#L2330) | if (this.selActive !== false) { |
| [2331](#L2331) | toggleClass(toggle, this.cls, includes(actives, toggle)); |
| [2332](#L2332) | } |
| [2333](#L2333) | const button = findButton(toggle); |
| [2334](#L2334) | if (isTag(button, "a")) { |
| [2335](#L2335) | attr(button, "role", "button"); |
| [2336](#L2336) | } |
| [2337](#L2337) | } |
| [2338](#L2338) | }, |
| [2339](#L2339) | children(list, prev) { |
| [2340](#L2340) | if (prev) { |
| [2341](#L2341) | this.updateState(); |
| [2342](#L2342) | } |
| [2343](#L2343) | } |
| [2344](#L2344) | }, |
| [2345](#L2345) | events: { |
| [2346](#L2346) | name: "click keydown", |
| [2347](#L2347) | delegate: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`, |
| [2348](#L2348) | handler(e) { |
| [2349](#L2349) | if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) { |
| [2350](#L2350) | return; |
| [2351](#L2351) | } |
| [2352](#L2352) | if (e.target.closest("a,button")) { |
| [2353](#L2353) | e.preventDefault(); |
| [2354](#L2354) | this.apply(e.current); |
| [2355](#L2355) | } |
| [2356](#L2356) | } |
| [2357](#L2357) | }, |
| [2358](#L2358) | methods: { |
| [2359](#L2359) | apply(el) { |
| [2360](#L2360) | const prevState = this.getState(); |
| [2361](#L2361) | const newState = mergeState(el, this.attrItem, this.getState()); |
| [2362](#L2362) | if (!isEqualState(prevState, newState)) { |
| [2363](#L2363) | this.setState(newState); |
| [2364](#L2364) | } |
| [2365](#L2365) | }, |
| [2366](#L2366) | getState() { |
| [2367](#L2367) | return this.toggles.filter((item) => hasClass(item, this.cls)).reduce((state, el) => mergeState(el, this.attrItem, state), { |
| [2368](#L2368) | filter: { "": "" }, |
| [2369](#L2369) | sort: [] |
| [2370](#L2370) | }); |
| [2371](#L2371) | }, |
| [2372](#L2372) | async setState(state, animate = true) { |
| [2373](#L2373) | state = { filter: { "": "" }, sort: [], ...state }; |
| [2374](#L2374) | trigger(this.$el, "beforeFilter", [this, state]); |
| [2375](#L2375) | for (const toggle of this.toggles) { |
| [2376](#L2376) | toggleClass(toggle, this.cls, matchFilter(toggle, this.attrItem, state)); |
| [2377](#L2377) | } |
| [2378](#L2378) | await Promise.all( |
| [2379](#L2379) | $$(this.target, this.$el).map((target) => { |
| [2380](#L2380) | const filterFn = () => applyState(state, target, children(target)); |
| [2381](#L2381) | return animate ? this.animate(filterFn, target) : filterFn(); |
| [2382](#L2382) | }) |
| [2383](#L2383) | ); |
| [2384](#L2384) | trigger(this.$el, "afterFilter", [this]); |
| [2385](#L2385) | }, |
| [2386](#L2386) | updateState() { |
| [2387](#L2387) | fastdom.write(() => this.setState(this.getState(), false)); |
| [2388](#L2388) | } |
| [2389](#L2389) | } |
| [2390](#L2390) | }; |
| [2391](#L2391) | function getFilter(el, attr2) { |
| [2392](#L2392) | return parseOptions(data(el, attr2), ["filter"]); |
| [2393](#L2393) | } |
| [2394](#L2394) | function isEqualState(stateA, stateB) { |
| [2395](#L2395) | return ["filter", "sort"].every((prop) => isEqual(stateA[prop], stateB[prop])); |
| [2396](#L2396) | } |
| [2397](#L2397) | function applyState(state, target, children) { |
| [2398](#L2398) | const selector = Object.values(state.filter).join(""); |
| [2399](#L2399) | for (const el of children) { |
| [2400](#L2400) | css(el, "display", selector && !matches(el, selector) ? "none" : ""); |
| [2401](#L2401) | } |
| [2402](#L2402) | const [sort, order] = state.sort; |
| [2403](#L2403) | if (sort) { |
| [2404](#L2404) | const sorted = sortItems(children, sort, order); |
| [2405](#L2405) | if (!isEqual(sorted, children)) { |
| [2406](#L2406) | append(target, sorted); |
| [2407](#L2407) | } |
| [2408](#L2408) | } |
| [2409](#L2409) | } |
| [2410](#L2410) | function mergeState(el, attr2, state) { |
| [2411](#L2411) | const { filter, group, sort, order = "asc" } = getFilter(el, attr2); |
| [2412](#L2412) | if (filter || isUndefined(sort)) { |
| [2413](#L2413) | if (group) { |
| [2414](#L2414) | if (filter) { |
| [2415](#L2415) | delete state.filter[""]; |
| [2416](#L2416) | state.filter[group] = filter; |
| [2417](#L2417) | } else { |
| [2418](#L2418) | delete state.filter[group]; |
| [2419](#L2419) | if (isEmpty(state.filter) || "" in state.filter) { |
| [2420](#L2420) | state.filter = { "": filter || "" }; |
| [2421](#L2421) | } |
| [2422](#L2422) | } |
| [2423](#L2423) | } else { |
| [2424](#L2424) | state.filter = { "": filter || "" }; |
| [2425](#L2425) | } |
| [2426](#L2426) | } |
| [2427](#L2427) | if (!isUndefined(sort)) { |
| [2428](#L2428) | state.sort = [sort, order]; |
| [2429](#L2429) | } |
| [2430](#L2430) | return state; |
| [2431](#L2431) | } |
| [2432](#L2432) | function matchFilter(el, attr2, { filter: stateFilter = { "": "" }, sort: [stateSort, stateOrder] }) { |
| [2433](#L2433) | const { filter = "", group = "", sort, order = "asc" } = getFilter(el, attr2); |
| [2434](#L2434) | return isUndefined(sort) ? group in stateFilter && filter === stateFilter[group] || !filter && group && !(group in stateFilter) && !stateFilter[""] : stateSort === sort && stateOrder === order; |
| [2435](#L2435) | } |
| [2436](#L2436) | function sortItems(nodes, sort, order) { |
| [2437](#L2437) | return [...nodes].sort( |
| [2438](#L2438) | (a, b) => data(a, sort).localeCompare(data(b, sort), void 0, { numeric: true }) \* (order === "asc" || -1) |
| [2439](#L2439) | ); |
| [2440](#L2440) | } |
| [2441](#L2441) | function findButton(el) { |
| [2442](#L2442) | return $("a,button", el) || el; |
| [2443](#L2443) | } |
| [2444](#L2444) |  |
| [2445](#L2445) | let prevented; |
| [2446](#L2446) | function preventBackgroundScroll(el) { |
| [2447](#L2447) | const off = on( |
| [2448](#L2448) | el, |
| [2449](#L2449) | "touchstart", |
| [2450](#L2450) | (e) => { |
| [2451](#L2451) | if (e.targetTouches.length !== 1 || matches(e.target, 'input[type="range"')) { |
| [2452](#L2452) | return; |
| [2453](#L2453) | } |
| [2454](#L2454) | let prev = getEventPos(e).y; |
| [2455](#L2455) | const offMove = on( |
| [2456](#L2456) | el, |
| [2457](#L2457) | "touchmove", |
| [2458](#L2458) | (e2) => { |
| [2459](#L2459) | const pos = getEventPos(e2).y; |
| [2460](#L2460) | if (pos === prev) { |
| [2461](#L2461) | return; |
| [2462](#L2462) | } |
| [2463](#L2463) | prev = pos; |
| [2464](#L2464) | if (!scrollParents(e2.target).some((scrollParent) => { |
| [2465](#L2465) | if (!el.contains(scrollParent)) { |
| [2466](#L2466) | return false; |
| [2467](#L2467) | } |
| [2468](#L2468) | let { scrollHeight, clientHeight } = scrollParent; |
| [2469](#L2469) | return clientHeight < scrollHeight; |
| [2470](#L2470) | })) { |
| [2471](#L2471) | e2.preventDefault(); |
| [2472](#L2472) | } |
| [2473](#L2473) | }, |
| [2474](#L2474) | { passive: false } |
| [2475](#L2475) | ); |
| [2476](#L2476) | once(el, "scroll touchend touchcanel", offMove, { capture: true }); |
| [2477](#L2477) | }, |
| [2478](#L2478) | { passive: true } |
| [2479](#L2479) | ); |
| [2480](#L2480) | if (prevented) { |
| [2481](#L2481) | return off; |
| [2482](#L2482) | } |
| [2483](#L2483) | prevented = true; |
| [2484](#L2484) | const { scrollingElement } = document; |
| [2485](#L2485) | css(scrollingElement, { |
| [2486](#L2486) | overflowY: CSS.supports("overflow", "clip") ? "clip" : "hidden", |
| [2487](#L2487) | touchAction: "none", |
| [2488](#L2488) | paddingRight: width(window) - scrollingElement.clientWidth || "" |
| [2489](#L2489) | }); |
| [2490](#L2490) | return () => { |
| [2491](#L2491) | prevented = false; |
| [2492](#L2492) | off(); |
| [2493](#L2493) | css(scrollingElement, { overflowY: "", touchAction: "", paddingRight: "" }); |
| [2494](#L2494) | }; |
| [2495](#L2495) | } |
| [2496](#L2496) |  |
| [2497](#L2497) | var Container = { |
| [2498](#L2498) | props: { |
| [2499](#L2499) | container: Boolean |
| [2500](#L2500) | }, |
| [2501](#L2501) | data: { |
| [2502](#L2502) | container: true |
| [2503](#L2503) | }, |
| [2504](#L2504) | computed: { |
| [2505](#L2505) | container({ container }) { |
| [2506](#L2506) | return container === true && this.$container || container && $(container); |
| [2507](#L2507) | } |
| [2508](#L2508) | } |
| [2509](#L2509) | }; |
| [2510](#L2510) |  |
| [2511](#L2511) | var Togglable = { |
| [2512](#L2512) | props: { |
| [2513](#L2513) | cls: Boolean, |
| [2514](#L2514) | animation: "list", |
| [2515](#L2515) | duration: Number, |
| [2516](#L2516) | velocity: Number, |
| [2517](#L2517) | origin: String, |
| [2518](#L2518) | transition: String |
| [2519](#L2519) | }, |
| [2520](#L2520) | data: { |
| [2521](#L2521) | cls: false, |
| [2522](#L2522) | animation: [false], |
| [2523](#L2523) | duration: 200, |
| [2524](#L2524) | velocity: 0.2, |
| [2525](#L2525) | origin: false, |
| [2526](#L2526) | transition: "ease", |
| [2527](#L2527) | clsEnter: "bdt-togglable-enter", |
| [2528](#L2528) | clsLeave: "bdt-togglable-leave" |
| [2529](#L2529) | }, |
| [2530](#L2530) | computed: { |
| [2531](#L2531) | hasAnimation: ({ animation }) => !!animation[0], |
| [2532](#L2532) | hasTransition: ({ animation }) => ["slide", "reveal"].some((transition) => startsWith(animation[0], transition)) |
| [2533](#L2533) | }, |
| [2534](#L2534) | methods: { |
| [2535](#L2535) | async toggleElement(targets, toggle, animate) { |
| [2536](#L2536) | try { |
| [2537](#L2537) | await Promise.all( |
| [2538](#L2538) | toNodes(targets).map((el) => { |
| [2539](#L2539) | const show = isBoolean(toggle) ? toggle : !this.isToggled(el); |
| [2540](#L2540) | if (!trigger(el, `before${show ? "show" : "hide"}`, [this])) { |
| [2541](#L2541) | return Promise.reject(); |
| [2542](#L2542) | } |
| [2543](#L2543) | const promise = (isFunction(animate) ? animate : animate === false || !this.hasAnimation ? toggleInstant : this.hasTransition ? toggleTransition : toggleAnimation)(el, show, this); |
| [2544](#L2544) | const cls = show ? this.clsEnter : this.clsLeave; |
| [2545](#L2545) | addClass(el, cls); |
| [2546](#L2546) | trigger(el, show ? "show" : "hide", [this]); |
| [2547](#L2547) | const done = () => { |
| [2548](#L2548) | removeClass(el, cls); |
| [2549](#L2549) | trigger(el, show ? "shown" : "hidden", [this]); |
| [2550](#L2550) | }; |
| [2551](#L2551) | return promise ? promise.then(done, () => { |
| [2552](#L2552) | removeClass(el, cls); |
| [2553](#L2553) | return Promise.reject(); |
| [2554](#L2554) | }) : done(); |
| [2555](#L2555) | }) |
| [2556](#L2556) | ); |
| [2557](#L2557) | return true; |
| [2558](#L2558) | } catch (e) { |
| [2559](#L2559) | return false; |
| [2560](#L2560) | } |
| [2561](#L2561) | }, |
| [2562](#L2562) | isToggled(el = this.$el) { |
| [2563](#L2563) | el = toNode(el); |
| [2564](#L2564) | return hasClass(el, this.clsEnter) ? true : hasClass(el, this.clsLeave) ? false : this.cls ? hasClass(el, this.cls.split(" ")[0]) : isVisible(el); |
| [2565](#L2565) | }, |
| [2566](#L2566) | \_toggle(el, toggled) { |
| [2567](#L2567) | if (!el) { |
| [2568](#L2568) | return; |
| [2569](#L2569) | } |
| [2570](#L2570) | toggled = Boolean(toggled); |
| [2571](#L2571) | let changed; |
| [2572](#L2572) | if (this.cls) { |
| [2573](#L2573) | changed = includes(this.cls, " ") || toggled !== hasClass(el, this.cls); |
| [2574](#L2574) | changed && toggleClass(el, this.cls, includes(this.cls, " ") ? void 0 : toggled); |
| [2575](#L2575) | } else { |
| [2576](#L2576) | changed = toggled === el.hidden; |
| [2577](#L2577) | changed && (el.hidden = !toggled); |
| [2578](#L2578) | } |
| [2579](#L2579) | $$("[autofocus]", el).some((el2) => isVisible(el2) ? el2.focus() || true : el2.blur()); |
| [2580](#L2580) | if (changed) { |
| [2581](#L2581) | trigger(el, "toggled", [toggled, this]); |
| [2582](#L2582) | } |
| [2583](#L2583) | } |
| [2584](#L2584) | } |
| [2585](#L2585) | }; |
| [2586](#L2586) | function toggleInstant(el, show, { \_toggle }) { |
| [2587](#L2587) | Animation.cancel(el); |
| [2588](#L2588) | Transition.cancel(el); |
| [2589](#L2589) | return \_toggle(el, show); |
| [2590](#L2590) | } |
| [2591](#L2591) | async function toggleTransition(el, show, { animation, duration, velocity, transition, \_toggle }) { |
| [2592](#L2592) | var \_a; |
| [2593](#L2593) | const [mode = "reveal", startProp = "top"] = ((\_a = animation[0]) == null ? void 0 : \_a.split("-")) || []; |
| [2594](#L2594) | const dirs = [ |
| [2595](#L2595) | ["left", "right"], |
| [2596](#L2596) | ["top", "bottom"] |
| [2597](#L2597) | ]; |
| [2598](#L2598) | const dir = dirs[includes(dirs[0], startProp) ? 0 : 1]; |
| [2599](#L2599) | const end = dir[1] === startProp; |
| [2600](#L2600) | const props = ["width", "height"]; |
| [2601](#L2601) | const dimProp = props[dirs.indexOf(dir)]; |
| [2602](#L2602) | const marginProp = `margin-${dir[0]}`; |
| [2603](#L2603) | const marginStartProp = `margin-${startProp}`; |
| [2604](#L2604) | let currentDim = dimensions$1(el)[dimProp]; |
| [2605](#L2605) | const inProgress = Transition.inProgress(el); |
| [2606](#L2606) | await Transition.cancel(el); |
| [2607](#L2607) | if (show) { |
| [2608](#L2608) | \_toggle(el, true); |
| [2609](#L2609) | } |
| [2610](#L2610) | const prevProps = Object.fromEntries( |
| [2611](#L2611) | [ |
| [2612](#L2612) | "padding", |
| [2613](#L2613) | "border", |
| [2614](#L2614) | "width", |
| [2615](#L2615) | "height", |
| [2616](#L2616) | "minWidth", |
| [2617](#L2617) | "minHeight", |
| [2618](#L2618) | "overflowY", |
| [2619](#L2619) | "overflowX", |
| [2620](#L2620) | marginProp, |
| [2621](#L2621) | marginStartProp |
| [2622](#L2622) | ].map((key) => [key, el.style[key]]) |
| [2623](#L2623) | ); |
| [2624](#L2624) | const dim = dimensions$1(el); |
| [2625](#L2625) | const currentMargin = toFloat(css(el, marginProp)); |
| [2626](#L2626) | const marginStart = toFloat(css(el, marginStartProp)); |
| [2627](#L2627) | const endDim = dim[dimProp] + marginStart; |
| [2628](#L2628) | if (!inProgress && !show) { |
| [2629](#L2629) | currentDim += marginStart; |
| [2630](#L2630) | } |
| [2631](#L2631) | const [wrapper] = wrapInner(el, "<div>"); |
| [2632](#L2632) | css(wrapper, { |
| [2633](#L2633) | boxSizing: "border-box", |
| [2634](#L2634) | height: dim.height, |
| [2635](#L2635) | width: dim.width, |
| [2636](#L2636) | ...css(el, [ |
| [2637](#L2637) | "overflow", |
| [2638](#L2638) | "padding", |
| [2639](#L2639) | "borderTop", |
| [2640](#L2640) | "borderRight", |
| [2641](#L2641) | "borderBottom", |
| [2642](#L2642) | "borderLeft", |
| [2643](#L2643) | "borderImage", |
| [2644](#L2644) | marginStartProp |
| [2645](#L2645) | ]) |
| [2646](#L2646) | }); |
| [2647](#L2647) | css(el, { |
| [2648](#L2648) | padding: 0, |
| [2649](#L2649) | border: 0, |
| [2650](#L2650) | minWidth: 0, |
| [2651](#L2651) | minHeight: 0, |
| [2652](#L2652) | [marginStartProp]: 0, |
| [2653](#L2653) | width: dim.width, |
| [2654](#L2654) | height: dim.height, |
| [2655](#L2655) | overflow: "hidden", |
| [2656](#L2656) | [dimProp]: currentDim |
| [2657](#L2657) | }); |
| [2658](#L2658) | const percent = currentDim / endDim; |
| [2659](#L2659) | duration = (velocity \* endDim + duration) \* (show ? 1 - percent : percent); |
| [2660](#L2660) | const endProps = { [dimProp]: show ? endDim : 0 }; |
| [2661](#L2661) | if (end) { |
| [2662](#L2662) | css(el, marginProp, endDim - currentDim + currentMargin); |
| [2663](#L2663) | endProps[marginProp] = show ? currentMargin : endDim + currentMargin; |
| [2664](#L2664) | } |
| [2665](#L2665) | if (!end ^ mode === "reveal") { |
| [2666](#L2666) | css(wrapper, marginProp, -endDim + currentDim); |
| [2667](#L2667) | Transition.start(wrapper, { [marginProp]: show ? 0 : -endDim }, duration, transition); |
| [2668](#L2668) | } |
| [2669](#L2669) | try { |
| [2670](#L2670) | await Transition.start(el, endProps, duration, transition); |
| [2671](#L2671) | } finally { |
| [2672](#L2672) | css(el, prevProps); |
| [2673](#L2673) | unwrap(wrapper.firstChild); |
| [2674](#L2674) | if (!show) { |
| [2675](#L2675) | \_toggle(el, false); |
| [2676](#L2676) | } |
| [2677](#L2677) | } |
| [2678](#L2678) | } |
| [2679](#L2679) | function toggleAnimation(el, show, cmp) { |
| [2680](#L2680) | const { animation, duration, \_toggle } = cmp; |
| [2681](#L2681) | if (show) { |
| [2682](#L2682) | \_toggle(el, true); |
| [2683](#L2683) | return Animation.in(el, animation[0], duration, cmp.origin); |
| [2684](#L2684) | } |
| [2685](#L2685) | return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then( |
| [2686](#L2686) | () => \_toggle(el, false) |
| [2687](#L2687) | ); |
| [2688](#L2688) | } |
| [2689](#L2689) |  |
| [2690](#L2690) | const active$1 = []; |
| [2691](#L2691) | var Modal = { |
| [2692](#L2692) | mixins: [Class, Container, Togglable], |
| [2693](#L2693) | props: { |
| [2694](#L2694) | selPanel: String, |
| [2695](#L2695) | selClose: String, |
| [2696](#L2696) | escClose: Boolean, |
| [2697](#L2697) | bgClose: Boolean, |
| [2698](#L2698) | stack: Boolean, |
| [2699](#L2699) | role: String |
| [2700](#L2700) | }, |
| [2701](#L2701) | data: { |
| [2702](#L2702) | cls: "bdt-open", |
| [2703](#L2703) | escClose: true, |
| [2704](#L2704) | bgClose: true, |
| [2705](#L2705) | overlay: true, |
| [2706](#L2706) | stack: false, |
| [2707](#L2707) | role: "dialog" |
| [2708](#L2708) | }, |
| [2709](#L2709) | computed: { |
| [2710](#L2710) | panel: ({ selPanel }, $el) => $(selPanel, $el), |
| [2711](#L2711) | transitionElement() { |
| [2712](#L2712) | return this.panel; |
| [2713](#L2713) | }, |
| [2714](#L2714) | bgClose({ bgClose }) { |
| [2715](#L2715) | return bgClose && this.panel; |
| [2716](#L2716) | } |
| [2717](#L2717) | }, |
| [2718](#L2718) | connected() { |
| [2719](#L2719) | attr(this.panel || this.$el, "role", this.role); |
| [2720](#L2720) | if (this.overlay) { |
| [2721](#L2721) | attr(this.panel || this.$el, "aria-modal", true); |
| [2722](#L2722) | } |
| [2723](#L2723) | }, |
| [2724](#L2724) | beforeDisconnect() { |
| [2725](#L2725) | if (includes(active$1, this)) { |
| [2726](#L2726) | this.toggleElement(this.$el, false, false); |
| [2727](#L2727) | } |
| [2728](#L2728) | }, |
| [2729](#L2729) | events: [ |
| [2730](#L2730) | { |
| [2731](#L2731) | name: "click", |
| [2732](#L2732) | delegate: ({ selClose }) => `${selClose},a[href\*="#"]`, |
| [2733](#L2733) | handler(e) { |
| [2734](#L2734) | const { current, defaultPrevented } = e; |
| [2735](#L2735) | const { hash } = current; |
| [2736](#L2736) | if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) { |
| [2737](#L2737) | this.hide(); |
| [2738](#L2738) | } else if (matches(current, this.selClose)) { |
| [2739](#L2739) | e.preventDefault(); |
| [2740](#L2740) | this.hide(); |
| [2741](#L2741) | } |
| [2742](#L2742) | } |
| [2743](#L2743) | }, |
| [2744](#L2744) | { |
| [2745](#L2745) | name: "toggle", |
| [2746](#L2746) | self: true, |
| [2747](#L2747) | handler(e) { |
| [2748](#L2748) | if (e.defaultPrevented) { |
| [2749](#L2749) | return; |
| [2750](#L2750) | } |
| [2751](#L2751) | e.preventDefault(); |
| [2752](#L2752) | if (this.isToggled() === includes(active$1, this)) { |
| [2753](#L2753) | this.toggle(); |
| [2754](#L2754) | } |
| [2755](#L2755) | } |
| [2756](#L2756) | }, |
| [2757](#L2757) | { |
| [2758](#L2758) | name: "beforeshow", |
| [2759](#L2759) | self: true, |
| [2760](#L2760) | handler(e) { |
| [2761](#L2761) | if (includes(active$1, this)) { |
| [2762](#L2762) | return false; |
| [2763](#L2763) | } |
| [2764](#L2764) | if (!this.stack && active$1.length) { |
| [2765](#L2765) | Promise.all(active$1.map((modal) => modal.hide())).then(this.show); |
| [2766](#L2766) | e.preventDefault(); |
| [2767](#L2767) | } else { |
| [2768](#L2768) | active$1.push(this); |
| [2769](#L2769) | } |
| [2770](#L2770) | } |
| [2771](#L2771) | }, |
| [2772](#L2772) | { |
| [2773](#L2773) | name: "show", |
| [2774](#L2774) | self: true, |
| [2775](#L2775) | handler() { |
| [2776](#L2776) | if (this.stack) { |
| [2777](#L2777) | css(this.$el, "zIndex", toFloat(css(this.$el, "zIndex")) + active$1.length); |
| [2778](#L2778) | } |
| [2779](#L2779) | const handlers = [ |
| [2780](#L2780) | this.overlay && preventBackgroundFocus(this), |
| [2781](#L2781) | this.overlay && preventBackgroundScroll(this.$el), |
| [2782](#L2782) | this.bgClose && listenForBackgroundClose$1(this), |
| [2783](#L2783) | this.escClose && listenForEscClose$1(this) |
| [2784](#L2784) | ]; |
| [2785](#L2785) | once( |
| [2786](#L2786) | this.$el, |
| [2787](#L2787) | "hidden", |
| [2788](#L2788) | () => handlers.forEach((handler) => handler && handler()), |
| [2789](#L2789) | { self: true } |
| [2790](#L2790) | ); |
| [2791](#L2791) | addClass(document.documentElement, this.clsPage); |
| [2792](#L2792) | } |
| [2793](#L2793) | }, |
| [2794](#L2794) | { |
| [2795](#L2795) | name: "shown", |
| [2796](#L2796) | self: true, |
| [2797](#L2797) | handler() { |
| [2798](#L2798) | if (!isFocusable(this.$el)) { |
| [2799](#L2799) | attr(this.$el, "tabindex", "-1"); |
| [2800](#L2800) | } |
| [2801](#L2801) | if (!matches(this.$el, ":focus-within")) { |
| [2802](#L2802) | this.$el.focus(); |
| [2803](#L2803) | } |
| [2804](#L2804) | } |
| [2805](#L2805) | }, |
| [2806](#L2806) | { |
| [2807](#L2807) | name: "hidden", |
| [2808](#L2808) | self: true, |
| [2809](#L2809) | handler() { |
| [2810](#L2810) | if (includes(active$1, this)) { |
| [2811](#L2811) | active$1.splice(active$1.indexOf(this), 1); |
| [2812](#L2812) | } |
| [2813](#L2813) | css(this.$el, "zIndex", ""); |
| [2814](#L2814) | if (!active$1.some((modal) => modal.clsPage === this.clsPage)) { |
| [2815](#L2815) | removeClass(document.documentElement, this.clsPage); |
| [2816](#L2816) | } |
| [2817](#L2817) | } |
| [2818](#L2818) | } |
| [2819](#L2819) | ], |
| [2820](#L2820) | methods: { |
| [2821](#L2821) | toggle() { |
| [2822](#L2822) | return this.isToggled() ? this.hide() : this.show(); |
| [2823](#L2823) | }, |
| [2824](#L2824) | show() { |
| [2825](#L2825) | if (this.container && parent(this.$el) !== this.container) { |
| [2826](#L2826) | append(this.container, this.$el); |
| [2827](#L2827) | return new Promise( |
| [2828](#L2828) | (resolve) => requestAnimationFrame(() => this.show().then(resolve)) |
| [2829](#L2829) | ); |
| [2830](#L2830) | } |
| [2831](#L2831) | return this.toggleElement(this.$el, true, animate$1); |
| [2832](#L2832) | }, |
| [2833](#L2833) | hide() { |
| [2834](#L2834) | return this.toggleElement(this.$el, false, animate$1); |
| [2835](#L2835) | } |
| [2836](#L2836) | } |
| [2837](#L2837) | }; |
| [2838](#L2838) | function animate$1(el, show, { transitionElement, \_toggle }) { |
| [2839](#L2839) | return new Promise( |
| [2840](#L2840) | (resolve, reject) => once(el, "show hide", () => { |
| [2841](#L2841) | var \_a; |
| [2842](#L2842) | (\_a = el.\_reject) == null ? void 0 : \_a.call(el); |
| [2843](#L2843) | el.\_reject = reject; |
| [2844](#L2844) | \_toggle(el, show); |
| [2845](#L2845) | const off = once( |
| [2846](#L2846) | transitionElement, |
| [2847](#L2847) | "transitionstart", |
| [2848](#L2848) | () => { |
| [2849](#L2849) | once(transitionElement, "transitionend transitioncancel", resolve, { |
| [2850](#L2850) | self: true |
| [2851](#L2851) | }); |
| [2852](#L2852) | clearTimeout(timer); |
| [2853](#L2853) | }, |
| [2854](#L2854) | { self: true } |
| [2855](#L2855) | ); |
| [2856](#L2856) | const timer = setTimeout( |
| [2857](#L2857) | () => { |
| [2858](#L2858) | off(); |
| [2859](#L2859) | resolve(); |
| [2860](#L2860) | }, |
| [2861](#L2861) | toMs(css(transitionElement, "transitionDuration")) |
| [2862](#L2862) | ); |
| [2863](#L2863) | }) |
| [2864](#L2864) | ).then(() => delete el.\_reject); |
| [2865](#L2865) | } |
| [2866](#L2866) | function toMs(time) { |
| [2867](#L2867) | return time ? endsWith(time, "ms") ? toFloat(time) : toFloat(time) \* 1e3 : 0; |
| [2868](#L2868) | } |
| [2869](#L2869) | function preventBackgroundFocus(modal) { |
| [2870](#L2870) | return on(document, "focusin", (e) => { |
| [2871](#L2871) | if (last(active$1) === modal && !modal.$el.contains(e.target)) { |
| [2872](#L2872) | modal.$el.focus(); |
| [2873](#L2873) | } |
| [2874](#L2874) | }); |
| [2875](#L2875) | } |
| [2876](#L2876) | function listenForBackgroundClose$1(modal) { |
| [2877](#L2877) | return on(document, pointerDown$1, ({ target }) => { |
| [2878](#L2878) | if (last(active$1) !== modal || modal.overlay && !modal.$el.contains(target) || modal.panel.contains(target)) { |
| [2879](#L2879) | return; |
| [2880](#L2880) | } |
| [2881](#L2881) | once( |
| [2882](#L2882) | document, |
| [2883](#L2883) | `${pointerUp$1} ${pointerCancel} scroll`, |
| [2884](#L2884) | ({ defaultPrevented, type, target: newTarget }) => { |
| [2885](#L2885) | if (!defaultPrevented && type === pointerUp$1 && target === newTarget) { |
| [2886](#L2886) | modal.hide(); |
| [2887](#L2887) | } |
| [2888](#L2888) | }, |
| [2889](#L2889) | true |
| [2890](#L2890) | ); |
| [2891](#L2891) | }); |
| [2892](#L2892) | } |
| [2893](#L2893) | function listenForEscClose$1(modal) { |
| [2894](#L2894) | return on(document, "keydown", (e) => { |
| [2895](#L2895) | if (e.keyCode === 27 && last(active$1) === modal) { |
| [2896](#L2896) | modal.hide(); |
| [2897](#L2897) | } |
| [2898](#L2898) | }); |
| [2899](#L2899) | } |
| [2900](#L2900) |  |
| [2901](#L2901) | var Animations$2 = { |
| [2902](#L2902) | slide: { |
| [2903](#L2903) | show(dir) { |
| [2904](#L2904) | return [{ transform: translate(dir \* -100) }, { transform: translate() }]; |
| [2905](#L2905) | }, |
| [2906](#L2906) | percent(current) { |
| [2907](#L2907) | return translated(current); |
| [2908](#L2908) | }, |
| [2909](#L2909) | translate(percent, dir) { |
| [2910](#L2910) | return [ |
| [2911](#L2911) | { transform: translate(dir \* -100 \* percent) }, |
| [2912](#L2912) | { transform: translate(dir \* 100 \* (1 - percent)) } |
| [2913](#L2913) | ]; |
| [2914](#L2914) | } |
| [2915](#L2915) | } |
| [2916](#L2916) | }; |
| [2917](#L2917) | function translated(el) { |
| [2918](#L2918) | return Math.abs(new DOMMatrix(css(el, "transform")).m41 / el.offsetWidth); |
| [2919](#L2919) | } |
| [2920](#L2920) | function translate(value = 0, unit = "%") { |
| [2921](#L2921) | value += value ? unit : ""; |
| [2922](#L2922) | return `translate3d(${value}, 0, 0)`; |
| [2923](#L2923) | } |
| [2924](#L2924) | function scale3d(value) { |
| [2925](#L2925) | return `scale3d(${value}, ${value}, 1)`; |
| [2926](#L2926) | } |
| [2927](#L2927) |  |
| [2928](#L2928) | function Transitioner$1(prev, next, dir, { animation, easing }) { |
| [2929](#L2929) | const { percent, translate, show = noop } = animation; |
| [2930](#L2930) | const props = show(dir); |
| [2931](#L2931) | const { promise, resolve } = withResolvers(); |
| [2932](#L2932) | return { |
| [2933](#L2933) | dir, |
| [2934](#L2934) | show(duration, percent2 = 0, linear) { |
| [2935](#L2935) | const timing = linear ? "linear" : easing; |
| [2936](#L2936) | duration -= Math.round(duration \* clamp(percent2, -1, 1)); |
| [2937](#L2937) | this.translate(percent2); |
| [2938](#L2938) | triggerUpdate(next, "itemin", { percent: percent2, duration, timing, dir }); |
| [2939](#L2939) | triggerUpdate(prev, "itemout", { percent: 1 - percent2, duration, timing, dir }); |
| [2940](#L2940) | Promise.all([ |
| [2941](#L2941) | Transition.start(next, props[1], duration, timing), |
| [2942](#L2942) | Transition.start(prev, props[0], duration, timing) |
| [2943](#L2943) | ]).then(() => { |
| [2944](#L2944) | this.reset(); |
| [2945](#L2945) | resolve(); |
| [2946](#L2946) | }, noop); |
| [2947](#L2947) | return promise; |
| [2948](#L2948) | }, |
| [2949](#L2949) | cancel() { |
| [2950](#L2950) | return Transition.cancel([next, prev]); |
| [2951](#L2951) | }, |
| [2952](#L2952) | reset() { |
| [2953](#L2953) | for (const prop in props[0]) { |
| [2954](#L2954) | css([next, prev], prop, ""); |
| [2955](#L2955) | } |
| [2956](#L2956) | }, |
| [2957](#L2957) | async forward(duration, percent2 = this.percent()) { |
| [2958](#L2958) | await this.cancel(); |
| [2959](#L2959) | return this.show(duration, percent2, true); |
| [2960](#L2960) | }, |
| [2961](#L2961) | translate(percent2) { |
| [2962](#L2962) | this.reset(); |
| [2963](#L2963) | const props2 = translate(percent2, dir); |
| [2964](#L2964) | css(next, props2[1]); |
| [2965](#L2965) | css(prev, props2[0]); |
| [2966](#L2966) | triggerUpdate(next, "itemtranslatein", { percent: percent2, dir }); |
| [2967](#L2967) | triggerUpdate(prev, "itemtranslateout", { percent: 1 - percent2, dir }); |
| [2968](#L2968) | }, |
| [2969](#L2969) | percent() { |
| [2970](#L2970) | return percent(prev || next, next, dir); |
| [2971](#L2971) | }, |
| [2972](#L2972) | getDistance() { |
| [2973](#L2973) | return prev == null ? void 0 : prev.offsetWidth; |
| [2974](#L2974) | } |
| [2975](#L2975) | }; |
| [2976](#L2976) | } |
| [2977](#L2977) | function triggerUpdate(el, type, data) { |
| [2978](#L2978) | trigger(el, createEvent(type, false, false, data)); |
| [2979](#L2979) | } |
| [2980](#L2980) | function withResolvers() { |
| [2981](#L2981) | let resolve; |
| [2982](#L2982) | return { promise: new Promise((res) => resolve = res), resolve }; |
| [2983](#L2983) | } |
| [2984](#L2984) |  |
| [2985](#L2985) | var I18n = { |
| [2986](#L2986) | props: { |
| [2987](#L2987) | i18n: Object |
| [2988](#L2988) | }, |
| [2989](#L2989) | data: { |
| [2990](#L2990) | i18n: null |
| [2991](#L2991) | }, |
| [2992](#L2992) | methods: { |
| [2993](#L2993) | t(key, ...params) { |
| [2994](#L2994) | var \_a, \_b, \_c; |
| [2995](#L2995) | let i = 0; |
| [2996](#L2996) | return ((\_c = ((\_a = this.i18n) == null ? void 0 : \_a[key]) || ((\_b = this.$options.i18n) == null ? void 0 : \_b[key])) == null ? void 0 : \_c.replace( |
| [2997](#L2997) | /%s/g, |
| [2998](#L2998) | () => params[i++] || "" |
| [2999](#L2999) | )) || ""; |
| [3000](#L3000) | } |
| [3001](#L3001) | } |
| [3002](#L3002) | }; |
| [3003](#L3003) |  |
| [3004](#L3004) | var SliderAutoplay = { |
| [3005](#L3005) | props: { |
| [3006](#L3006) | autoplay: Boolean, |
| [3007](#L3007) | autoplayInterval: Number, |
| [3008](#L3008) | pauseOnHover: Boolean |
| [3009](#L3009) | }, |
| [3010](#L3010) | data: { |
| [3011](#L3011) | autoplay: false, |
| [3012](#L3012) | autoplayInterval: 7e3, |
| [3013](#L3013) | pauseOnHover: true |
| [3014](#L3014) | }, |
| [3015](#L3015) | connected() { |
| [3016](#L3016) | attr(this.list, "aria-live", this.autoplay ? "off" : "polite"); |
| [3017](#L3017) | this.autoplay && this.startAutoplay(); |
| [3018](#L3018) | }, |
| [3019](#L3019) | disconnected() { |
| [3020](#L3020) | this.stopAutoplay(); |
| [3021](#L3021) | }, |
| [3022](#L3022) | update() { |
| [3023](#L3023) | attr(this.slides, "tabindex", "-1"); |
| [3024](#L3024) | }, |
| [3025](#L3025) | events: [ |
| [3026](#L3026) | { |
| [3027](#L3027) | name: "visibilitychange", |
| [3028](#L3028) | el: () => document, |
| [3029](#L3029) | filter: ({ autoplay }) => autoplay, |
| [3030](#L3030) | handler() { |
| [3031](#L3031) | if (document.hidden) { |
| [3032](#L3032) | this.stopAutoplay(); |
| [3033](#L3033) | } else { |
| [3034](#L3034) | this.startAutoplay(); |
| [3035](#L3035) | } |
| [3036](#L3036) | } |
| [3037](#L3037) | } |
| [3038](#L3038) | ], |
| [3039](#L3039) | methods: { |
| [3040](#L3040) | startAutoplay() { |
| [3041](#L3041) | this.stopAutoplay(); |
| [3042](#L3042) | this.interval = setInterval(() => { |
| [3043](#L3043) | if (!(this.stack.length || this.draggable && matches(this.$el, ":focus-within") && !matches(this.$el, ":focus") || this.pauseOnHover && matches(this.$el, ":hover"))) { |
| [3044](#L3044) | this.show("next"); |
| [3045](#L3045) | } |
| [3046](#L3046) | }, this.autoplayInterval); |
| [3047](#L3047) | }, |
| [3048](#L3048) | stopAutoplay() { |
| [3049](#L3049) | clearInterval(this.interval); |
| [3050](#L3050) | } |
| [3051](#L3051) | } |
| [3052](#L3052) | }; |
| [3053](#L3053) |  |
| [3054](#L3054) | const pointerOptions = { passive: false, capture: true }; |
| [3055](#L3055) | const pointerUpOptions = { passive: true, capture: true }; |
| [3056](#L3056) | const pointerDown = "touchstart mousedown"; |
| [3057](#L3057) | const pointerMove = "touchmove mousemove"; |
| [3058](#L3058) | const pointerUp = "touchend touchcancel mouseup click input scroll"; |
| [3059](#L3059) | const preventClick = (e) => e.preventDefault(); |
| [3060](#L3060) | var SliderDrag = { |
| [3061](#L3061) | props: { |
| [3062](#L3062) | draggable: Boolean |
| [3063](#L3063) | }, |
| [3064](#L3064) | data: { |
| [3065](#L3065) | draggable: true, |
| [3066](#L3066) | threshold: 10 |
| [3067](#L3067) | }, |
| [3068](#L3068) | created() { |
| [3069](#L3069) | for (const key of ["start", "move", "end"]) { |
| [3070](#L3070) | const fn = this[key]; |
| [3071](#L3071) | this[key] = (e) => { |
| [3072](#L3072) | const pos = getEventPos(e).x \* (isRtl ? -1 : 1); |
| [3073](#L3073) | this.prevPos = pos === this.pos ? this.prevPos : this.pos; |
| [3074](#L3074) | this.pos = pos; |
| [3075](#L3075) | fn(e); |
| [3076](#L3076) | }; |
| [3077](#L3077) | } |
| [3078](#L3078) | }, |
| [3079](#L3079) | events: [ |
| [3080](#L3080) | { |
| [3081](#L3081) | name: pointerDown, |
| [3082](#L3082) | passive: true, |
| [3083](#L3083) | delegate: ({ selList }) => `${selList} > \*`, |
| [3084](#L3084) | handler(e) { |
| [3085](#L3085) | if (!this.draggable || this.parallax || !isTouch(e) && hasSelectableText(e.target) || e.target.closest(selInput) || e.button > 0 || this.length < 2) { |
| [3086](#L3086) | return; |
| [3087](#L3087) | } |
| [3088](#L3088) | this.start(e); |
| [3089](#L3089) | } |
| [3090](#L3090) | }, |
| [3091](#L3091) | { |
| [3092](#L3092) | name: "dragstart", |
| [3093](#L3093) | handler(e) { |
| [3094](#L3094) | e.preventDefault(); |
| [3095](#L3095) | } |
| [3096](#L3096) | }, |
| [3097](#L3097) | { |
| [3098](#L3098) | // iOS workaround for slider stopping if swiping fast |
| [3099](#L3099) | name: pointerMove, |
| [3100](#L3100) | el: ({ list }) => list, |
| [3101](#L3101) | handler: noop, |
| [3102](#L3102) | ...pointerOptions |
| [3103](#L3103) | } |
| [3104](#L3104) | ], |
| [3105](#L3105) | methods: { |
| [3106](#L3106) | start() { |
| [3107](#L3107) | this.drag = this.pos; |
| [3108](#L3108) | if (this.\_transitioner) { |
| [3109](#L3109) | this.percent = this.\_transitioner.percent(); |
| [3110](#L3110) | this.drag += this.\_transitioner.getDistance() \* this.percent \* this.dir; |
| [3111](#L3111) | this.\_transitioner.cancel(); |
| [3112](#L3112) | this.\_transitioner.translate(this.percent); |
| [3113](#L3113) | this.dragging = true; |
| [3114](#L3114) | this.stack = []; |
| [3115](#L3115) | } else { |
| [3116](#L3116) | this.prevIndex = this.index; |
| [3117](#L3117) | } |
| [3118](#L3118) | on(document, pointerMove, this.move, pointerOptions); |
| [3119](#L3119) | on(document, pointerUp, this.end, pointerUpOptions); |
| [3120](#L3120) | css(this.list, "userSelect", "none"); |
| [3121](#L3121) | }, |
| [3122](#L3122) | move(e) { |
| [3123](#L3123) | const distance = this.pos - this.drag; |
| [3124](#L3124) | if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) { |
| [3125](#L3125) | return; |
| [3126](#L3126) | } |
| [3127](#L3127) | if (!this.dragging) { |
| [3128](#L3128) | on(this.list, "click", preventClick, pointerOptions); |
| [3129](#L3129) | } |
| [3130](#L3130) | e.cancelable && e.preventDefault(); |
| [3131](#L3131) | this.dragging = true; |
| [3132](#L3132) | this.dir = distance < 0 ? 1 : -1; |
| [3133](#L3133) | let { slides, prevIndex } = this; |
| [3134](#L3134) | let dis = Math.abs(distance); |
| [3135](#L3135) | let nextIndex = this.getIndex(prevIndex + this.dir); |
| [3136](#L3136) | let width = getDistance.call(this, prevIndex, nextIndex); |
| [3137](#L3137) | while (nextIndex !== prevIndex && dis > width) { |
| [3138](#L3138) | this.drag -= width \* this.dir; |
| [3139](#L3139) | prevIndex = nextIndex; |
| [3140](#L3140) | dis -= width; |
| [3141](#L3141) | nextIndex = this.getIndex(prevIndex + this.dir); |
| [3142](#L3142) | width = getDistance.call(this, prevIndex, nextIndex); |
| [3143](#L3143) | } |
| [3144](#L3144) | this.percent = dis / width; |
| [3145](#L3145) | const prev = slides[prevIndex]; |
| [3146](#L3146) | const next = slides[nextIndex]; |
| [3147](#L3147) | const changed = this.index !== nextIndex; |
| [3148](#L3148) | const edge = prevIndex === nextIndex; |
| [3149](#L3149) | let itemShown; |
| [3150](#L3150) | for (const i of [this.index, this.prevIndex]) { |
| [3151](#L3151) | if (!includes([nextIndex, prevIndex], i)) { |
| [3152](#L3152) | trigger(slides[i], "itemhidden", [this]); |
| [3153](#L3153) | if (edge) { |
| [3154](#L3154) | itemShown = true; |
| [3155](#L3155) | this.prevIndex = prevIndex; |
| [3156](#L3156) | } |
| [3157](#L3157) | } |
| [3158](#L3158) | } |
| [3159](#L3159) | if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) { |
| [3160](#L3160) | trigger(slides[this.index], "itemshown", [this]); |
| [3161](#L3161) | } |
| [3162](#L3162) | if (changed) { |
| [3163](#L3163) | this.prevIndex = prevIndex; |
| [3164](#L3164) | this.index = nextIndex; |
| [3165](#L3165) | if (!edge) { |
| [3166](#L3166) | trigger(prev, "beforeitemhide", [this]); |
| [3167](#L3167) | trigger(prev, "itemhide", [this]); |
| [3168](#L3168) | } |
| [3169](#L3169) | trigger(next, "beforeitemshow", [this]); |
| [3170](#L3170) | trigger(next, "itemshow", [this]); |
| [3171](#L3171) | } |
| [3172](#L3172) | this.\_transitioner = this.\_translate(Math.abs(this.percent), prev, !edge && next); |
| [3173](#L3173) | }, |
| [3174](#L3174) | end() { |
| [3175](#L3175) | off(document, pointerMove, this.move, pointerOptions); |
| [3176](#L3176) | off(document, pointerUp, this.end, pointerUpOptions); |
| [3177](#L3177) | if (this.dragging) { |
| [3178](#L3178) | this.dragging = null; |
| [3179](#L3179) | if (this.index === this.prevIndex) { |
| [3180](#L3180) | this.percent = 1 - this.percent; |
| [3181](#L3181) | this.dir \*= -1; |
| [3182](#L3182) | this.\_show(false, this.index, true); |
| [3183](#L3183) | this.\_transitioner = null; |
| [3184](#L3184) | } else { |
| [3185](#L3185) | const dirChange = (isRtl ? this.dir \* (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos; |
| [3186](#L3186) | this.index = dirChange ? this.index : this.prevIndex; |
| [3187](#L3187) | if (dirChange) { |
| [3188](#L3188) | this.percent = 1 - this.percent; |
| [3189](#L3189) | } |
| [3190](#L3190) | this.show( |
| [3191](#L3191) | this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? "next" : "previous", |
| [3192](#L3192) | true |
| [3193](#L3193) | ); |
| [3194](#L3194) | } |
| [3195](#L3195) | } |
| [3196](#L3196) | setTimeout(() => off(this.list, "click", preventClick, pointerOptions)); |
| [3197](#L3197) | css(this.list, { userSelect: "" }); |
| [3198](#L3198) | this.drag = this.percent = null; |
| [3199](#L3199) | } |
| [3200](#L3200) | } |
| [3201](#L3201) | }; |
| [3202](#L3202) | function getDistance(prev, next) { |
| [3203](#L3203) | return this.\_getTransitioner(prev, prev !== next && next).getDistance() || this.slides[prev].offsetWidth; |
| [3204](#L3204) | } |
| [3205](#L3205) | function hasSelectableText(el) { |
| [3206](#L3206) | return css(el, "userSelect") !== "none" && toArray(el.childNodes).some((el2) => el2.nodeType === 3 && el2.textContent.trim()); |
| [3207](#L3207) | } |
| [3208](#L3208) |  |
| [3209](#L3209) | function initWatches(instance) { |
| [3210](#L3210) | instance.\_watches = []; |
| [3211](#L3211) | for (const watches of instance.$options.watch || []) { |
| [3212](#L3212) | for (const [name, watch] of Object.entries(watches)) { |
| [3213](#L3213) | registerWatch(instance, watch, name); |
| [3214](#L3214) | } |
| [3215](#L3215) | } |
| [3216](#L3216) | instance.\_initial = true; |
| [3217](#L3217) | } |
| [3218](#L3218) | function registerWatch(instance, watch, name) { |
| [3219](#L3219) | instance.\_watches.push({ |
| [3220](#L3220) | name, |
| [3221](#L3221) | ...isPlainObject(watch) ? watch : { handler: watch } |
| [3222](#L3222) | }); |
| [3223](#L3223) | } |
| [3224](#L3224) | function runWatches(instance, values) { |
| [3225](#L3225) | for (const { name, handler, immediate = true } of instance.\_watches) { |
| [3226](#L3226) | if (instance.\_initial && immediate || hasOwn(values, name) && !isEqual(values[name], instance[name])) { |
| [3227](#L3227) | handler.call(instance, instance[name], values[name]); |
| [3228](#L3228) | } |
| [3229](#L3229) | } |
| [3230](#L3230) | instance.\_initial = false; |
| [3231](#L3231) | } |
| [3232](#L3232) |  |
| [3233](#L3233) | function initComputed(instance) { |
| [3234](#L3234) | const { computed } = instance.$options; |
| [3235](#L3235) | instance.\_computed = {}; |
| [3236](#L3236) | if (computed) { |
| [3237](#L3237) | for (const key in computed) { |
| [3238](#L3238) | registerComputed(instance, key, computed[key]); |
| [3239](#L3239) | } |
| [3240](#L3240) | } |
| [3241](#L3241) | } |
| [3242](#L3242) | const mutationOptions = { subtree: true, childList: true }; |
| [3243](#L3243) | function registerComputed(instance, key, cb) { |
| [3244](#L3244) | instance.\_hasComputed = true; |
| [3245](#L3245) | Object.defineProperty(instance, key, { |
| [3246](#L3246) | enumerable: true, |
| [3247](#L3247) | get() { |
| [3248](#L3248) | const { \_computed, $props, $el } = instance; |
| [3249](#L3249) | if (!hasOwn(\_computed, key)) { |
| [3250](#L3250) | \_computed[key] = (cb.get || cb).call(instance, $props, $el); |
| [3251](#L3251) | if (cb.observe && instance.\_computedObserver) { |
| [3252](#L3252) | const selector = cb.observe.call(instance, $props); |
| [3253](#L3253) | instance.\_computedObserver.observe( |
| [3254](#L3254) | ["~", "+", "-"].includes(selector[0]) ? $el.parentElement : $el.getRootNode(), |
| [3255](#L3255) | mutationOptions |
| [3256](#L3256) | ); |
| [3257](#L3257) | } |
| [3258](#L3258) | } |
| [3259](#L3259) | return \_computed[key]; |
| [3260](#L3260) | }, |
| [3261](#L3261) | set(value) { |
| [3262](#L3262) | const { \_computed } = instance; |
| [3263](#L3263) | \_computed[key] = cb.set ? cb.set.call(instance, value) : value; |
| [3264](#L3264) | if (isUndefined(\_computed[key])) { |
| [3265](#L3265) | delete \_computed[key]; |
| [3266](#L3266) | } |
| [3267](#L3267) | } |
| [3268](#L3268) | }); |
| [3269](#L3269) | } |
| [3270](#L3270) | function initComputedUpdates(instance) { |
| [3271](#L3271) | if (!instance.\_hasComputed) { |
| [3272](#L3272) | return; |
| [3273](#L3273) | } |
| [3274](#L3274) | prependUpdate(instance, { |
| [3275](#L3275) | read: () => runWatches(instance, resetComputed(instance)), |
| [3276](#L3276) | events: ["resize", "computed"] |
| [3277](#L3277) | }); |
| [3278](#L3278) | instance.\_computedObserver = observeMutation( |
| [3279](#L3279) | instance.$el, |
| [3280](#L3280) | () => callUpdate(instance, "computed"), |
| [3281](#L3281) | mutationOptions |
| [3282](#L3282) | ); |
| [3283](#L3283) | } |
| [3284](#L3284) | function disconnectComputedUpdates(instance) { |
| [3285](#L3285) | var \_a; |
| [3286](#L3286) | (\_a = instance.\_computedObserver) == null ? void 0 : \_a.disconnect(); |
| [3287](#L3287) | delete instance.\_computedObserver; |
| [3288](#L3288) | resetComputed(instance); |
| [3289](#L3289) | } |
| [3290](#L3290) | function resetComputed(instance) { |
| [3291](#L3291) | const values = { ...instance.\_computed }; |
| [3292](#L3292) | instance.\_computed = {}; |
| [3293](#L3293) | return values; |
| [3294](#L3294) | } |
| [3295](#L3295) |  |
| [3296](#L3296) | function initEvents(instance) { |
| [3297](#L3297) | instance.\_events = []; |
| [3298](#L3298) | for (const event of instance.$options.events || []) { |
| [3299](#L3299) | if (hasOwn(event, "handler")) { |
| [3300](#L3300) | registerEvent(instance, event); |
| [3301](#L3301) | } else { |
| [3302](#L3302) | for (const key in event) { |
| [3303](#L3303) | registerEvent(instance, event[key], key); |
| [3304](#L3304) | } |
| [3305](#L3305) | } |
| [3306](#L3306) | } |
| [3307](#L3307) | } |
| [3308](#L3308) | function unbindEvents(instance) { |
| [3309](#L3309) | instance.\_events.forEach((unbind) => unbind()); |
| [3310](#L3310) | delete instance.\_events; |
| [3311](#L3311) | } |
| [3312](#L3312) | function registerEvent(instance, event, key) { |
| [3313](#L3313) | let { name, el, handler, capture, passive, delegate, filter, self } = isPlainObject(event) ? event : { name: key, handler: event }; |
| [3314](#L3314) | el = isFunction(el) ? el.call(instance, instance) : el || instance.$el; |
| [3315](#L3315) | if (!el || isArray(el) && !el.length || filter && !filter.call(instance, instance)) { |
| [3316](#L3316) | return; |
| [3317](#L3317) | } |
| [3318](#L3318) | instance.\_events.push( |
| [3319](#L3319) | on( |
| [3320](#L3320) | el, |
| [3321](#L3321) | name, |
| [3322](#L3322) | delegate ? isString(delegate) ? delegate : delegate.call(instance, instance) : null, |
| [3323](#L3323) | isString(handler) ? instance[handler] : handler.bind(instance), |
| [3324](#L3324) | { passive, capture, self } |
| [3325](#L3325) | ) |
| [3326](#L3326) | ); |
| [3327](#L3327) | } |
| [3328](#L3328) |  |
| [3329](#L3329) | function initObservers(instance) { |
| [3330](#L3330) | instance.\_observers = []; |
| [3331](#L3331) | for (const observer of instance.$options.observe || []) { |
| [3332](#L3332) | registerObservable(instance, observer); |
| [3333](#L3333) | } |
| [3334](#L3334) | } |
| [3335](#L3335) | function registerObserver(instance, ...observer) { |
| [3336](#L3336) | instance.\_observers.push(...observer); |
| [3337](#L3337) | } |
| [3338](#L3338) | function disconnectObservers(instance) { |
| [3339](#L3339) | for (const observer of instance.\_observers) { |
| [3340](#L3340) | observer.disconnect(); |
| [3341](#L3341) | } |
| [3342](#L3342) | } |
| [3343](#L3343) | function registerObservable(instance, observable) { |
| [3344](#L3344) | let { observe, target = instance.$el, handler, options, filter, args } = observable; |
| [3345](#L3345) | if (filter && !filter.call(instance, instance)) { |
| [3346](#L3346) | return; |
| [3347](#L3347) | } |
| [3348](#L3348) | const key = `\_observe${instance.\_observers.length}`; |
| [3349](#L3349) | if (isFunction(target) && !hasOwn(instance, key)) { |
| [3350](#L3350) | registerComputed(instance, key, () => { |
| [3351](#L3351) | const targets2 = target.call(instance, instance); |
| [3352](#L3352) | return isArray(targets2) ? toNodes(targets2) : targets2; |
| [3353](#L3353) | }); |
| [3354](#L3354) | } |
| [3355](#L3355) | handler = isString(handler) ? instance[handler] : handler.bind(instance); |
| [3356](#L3356) | if (isFunction(options)) { |
| [3357](#L3357) | options = options.call(instance, instance); |
| [3358](#L3358) | } |
| [3359](#L3359) | const targets = hasOwn(instance, key) ? instance[key] : target; |
| [3360](#L3360) | const observer = observe(targets, handler, options, args); |
| [3361](#L3361) | if (isFunction(target) && isArray(instance[key])) { |
| [3362](#L3362) | registerWatch( |
| [3363](#L3363) | instance, |
| [3364](#L3364) | { handler: updateTargets(observer, options), immediate: false }, |
| [3365](#L3365) | key |
| [3366](#L3366) | ); |
| [3367](#L3367) | } |
| [3368](#L3368) | registerObserver(instance, observer); |
| [3369](#L3369) | } |
| [3370](#L3370) | function updateTargets(observer, options) { |
| [3371](#L3371) | return (targets, prev) => { |
| [3372](#L3372) | for (const target of prev) { |
| [3373](#L3373) | if (!includes(targets, target)) { |
| [3374](#L3374) | if (observer.unobserve) { |
| [3375](#L3375) | observer.unobserve(target); |
| [3376](#L3376) | } else if (observer.observe) { |
| [3377](#L3377) | observer.disconnect(); |
| [3378](#L3378) | } |
| [3379](#L3379) | } |
| [3380](#L3380) | } |
| [3381](#L3381) | for (const target of targets) { |
| [3382](#L3382) | if (!includes(prev, target) || !observer.unobserve) { |
| [3383](#L3383) | observer.observe(target, options); |
| [3384](#L3384) | } |
| [3385](#L3385) | } |
| [3386](#L3386) | }; |
| [3387](#L3387) | } |
| [3388](#L3388) |  |
| [3389](#L3389) | function initProps(instance) { |
| [3390](#L3390) | const { $options, $props } = instance; |
| [3391](#L3391) | const props = getProps($options); |
| [3392](#L3392) | assign($props, props); |
| [3393](#L3393) | const { computed, methods } = $options; |
| [3394](#L3394) | for (let key in $props) { |
| [3395](#L3395) | if (key in props && (!computed || !hasOwn(computed, key)) && (!methods || !hasOwn(methods, key))) { |
| [3396](#L3396) | instance[key] = $props[key]; |
| [3397](#L3397) | } |
| [3398](#L3398) | } |
| [3399](#L3399) | } |
| [3400](#L3400) | function getProps(opts) { |
| [3401](#L3401) | const data$1 = {}; |
| [3402](#L3402) | const { args = [], props = {}, el, id } = opts; |
| [3403](#L3403) | if (!props) { |
| [3404](#L3404) | return data$1; |
| [3405](#L3405) | } |
| [3406](#L3406) | for (const key in props) { |
| [3407](#L3407) | const prop = hyphenate(key); |
| [3408](#L3408) | let value = data(el, prop); |
| [3409](#L3409) | if (isUndefined(value)) { |
| [3410](#L3410) | continue; |
| [3411](#L3411) | } |
| [3412](#L3412) | value = props[key] === Boolean && value === "" ? true : coerce$1(props[key], value); |
| [3413](#L3413) | if (prop === "target" && startsWith(value, "\_")) { |
| [3414](#L3414) | continue; |
| [3415](#L3415) | } |
| [3416](#L3416) | data$1[key] = value; |
| [3417](#L3417) | } |
| [3418](#L3418) | const options = parseOptions(data(el, id), args); |
| [3419](#L3419) | for (const key in options) { |
| [3420](#L3420) | const prop = camelize(key); |
| [3421](#L3421) | if (!isUndefined(props[prop])) { |
| [3422](#L3422) | data$1[prop] = coerce$1(props[prop], options[key]); |
| [3423](#L3423) | } |
| [3424](#L3424) | } |
| [3425](#L3425) | return data$1; |
| [3426](#L3426) | } |
| [3427](#L3427) | const getAttributes = memoize((id, props) => { |
| [3428](#L3428) | const attributes = Object.keys(props); |
| [3429](#L3429) | const filter = attributes.concat(id).map((key) => [hyphenate(key), `data-${hyphenate(key)}`]).flat(); |
| [3430](#L3430) | return { attributes, filter }; |
| [3431](#L3431) | }); |
| [3432](#L3432) | function initPropsObserver(instance) { |
| [3433](#L3433) | const { $options, $props } = instance; |
| [3434](#L3434) | const { id, props, el } = $options; |
| [3435](#L3435) | if (!props) { |
| [3436](#L3436) | return; |
| [3437](#L3437) | } |
| [3438](#L3438) | const { attributes, filter } = getAttributes(id, props); |
| [3439](#L3439) | const observer = new MutationObserver((records) => { |
| [3440](#L3440) | const data = getProps($options); |
| [3441](#L3441) | if (records.some(({ attributeName }) => { |
| [3442](#L3442) | const prop = attributeName.replace("data-", ""); |
| [3443](#L3443) | return (prop === id ? attributes : [camelize(prop), camelize(attributeName)]).some( |
| [3444](#L3444) | (prop2) => !isUndefined(data[prop2]) && data[prop2] !== $props[prop2] |
| [3445](#L3445) | ); |
| [3446](#L3446) | })) { |
| [3447](#L3447) | instance.$reset(); |
| [3448](#L3448) | } |
| [3449](#L3449) | }); |
| [3450](#L3450) | observer.observe(el, { |
| [3451](#L3451) | attributes: true, |
| [3452](#L3452) | attributeFilter: filter |
| [3453](#L3453) | }); |
| [3454](#L3454) | registerObserver(instance, observer); |
| [3455](#L3455) | } |
| [3456](#L3456) |  |
| [3457](#L3457) | function callHook(instance, hook) { |
| [3458](#L3458) | var \_a; |
| [3459](#L3459) | (\_a = instance.$options[hook]) == null ? void 0 : \_a.forEach((handler) => handler.call(instance)); |
| [3460](#L3460) | } |
| [3461](#L3461) | function callConnected(instance) { |
| [3462](#L3462) | if (instance.\_connected) { |
| [3463](#L3463) | return; |
| [3464](#L3464) | } |
| [3465](#L3465) | initProps(instance); |
| [3466](#L3466) | callHook(instance, "beforeConnect"); |
| [3467](#L3467) | instance.\_connected = true; |
| [3468](#L3468) | initEvents(instance); |
| [3469](#L3469) | initUpdates(instance); |
| [3470](#L3470) | initWatches(instance); |
| [3471](#L3471) | initObservers(instance); |
| [3472](#L3472) | initPropsObserver(instance); |
| [3473](#L3473) | initComputedUpdates(instance); |
| [3474](#L3474) | callHook(instance, "connected"); |
| [3475](#L3475) | callUpdate(instance); |
| [3476](#L3476) | } |
| [3477](#L3477) | function callDisconnected(instance) { |
| [3478](#L3478) | if (!instance.\_connected) { |
| [3479](#L3479) | return; |
| [3480](#L3480) | } |
| [3481](#L3481) | callHook(instance, "beforeDisconnect"); |
| [3482](#L3482) | unbindEvents(instance); |
| [3483](#L3483) | clearUpdateData(instance); |
| [3484](#L3484) | disconnectObservers(instance); |
| [3485](#L3485) | disconnectComputedUpdates(instance); |
| [3486](#L3486) | callHook(instance, "disconnected"); |
| [3487](#L3487) | instance.\_connected = false; |
| [3488](#L3488) | } |
| [3489](#L3489) |  |
| [3490](#L3490) | let uid = 0; |
| [3491](#L3491) | function init$1(instance, options = {}) { |
| [3492](#L3492) | options.data = normalizeData(options, instance.constructor.options); |
| [3493](#L3493) | instance.$options = mergeOptions(instance.constructor.options, options, instance); |
| [3494](#L3494) | instance.$props = {}; |
| [3495](#L3495) | instance.\_uid = uid++; |
| [3496](#L3496) | initData(instance); |
| [3497](#L3497) | initMethods(instance); |
| [3498](#L3498) | initComputed(instance); |
| [3499](#L3499) | callHook(instance, "created"); |
| [3500](#L3500) | if (options.el) { |
| [3501](#L3501) | instance.$mount(options.el); |
| [3502](#L3502) | } |
| [3503](#L3503) | } |
| [3504](#L3504) | function initData(instance) { |
| [3505](#L3505) | const { data = {} } = instance.$options; |
| [3506](#L3506) | for (const key in data) { |
| [3507](#L3507) | instance.$props[key] = instance[key] = data[key]; |
| [3508](#L3508) | } |
| [3509](#L3509) | } |
| [3510](#L3510) | function initMethods(instance) { |
| [3511](#L3511) | const { methods } = instance.$options; |
| [3512](#L3512) | if (methods) { |
| [3513](#L3513) | for (const key in methods) { |
| [3514](#L3514) | instance[key] = methods[key].bind(instance); |
| [3515](#L3515) | } |
| [3516](#L3516) | } |
| [3517](#L3517) | } |
| [3518](#L3518) | function normalizeData({ data = {} }, { args = [], props = {} }) { |
| [3519](#L3519) | if (isArray(data)) { |
| [3520](#L3520) | data = data.slice(0, args.length).reduce((data2, value, index) => { |
| [3521](#L3521) | if (isPlainObject(value)) { |
| [3522](#L3522) | assign(data2, value); |
| [3523](#L3523) | } else { |
| [3524](#L3524) | data2[args[index]] = value; |
| [3525](#L3525) | } |
| [3526](#L3526) | return data2; |
| [3527](#L3527) | }, {}); |
| [3528](#L3528) | } |
| [3529](#L3529) | for (const key in data) { |
| [3530](#L3530) | if (isUndefined(data[key])) { |
| [3531](#L3531) | delete data[key]; |
| [3532](#L3532) | } else if (props[key]) { |
| [3533](#L3533) | data[key] = coerce$1(props[key], data[key]); |
| [3534](#L3534) | } |
| [3535](#L3535) | } |
| [3536](#L3536) | return data; |
| [3537](#L3537) | } |
| [3538](#L3538) |  |
| [3539](#L3539) | const App = function(options) { |
| [3540](#L3540) | init$1(this, options); |
| [3541](#L3541) | }; |
| [3542](#L3542) | App.util = util; |
| [3543](#L3543) | App.options = {}; |
| [3544](#L3544) | App.version = "3.21.7"; |
| [3545](#L3545) |  |
| [3546](#L3546) | const PREFIX = "bdt-"; |
| [3547](#L3547) | const DATA = "\_\_uikit\_\_"; |
| [3548](#L3548) | const components$2 = {}; |
| [3549](#L3549) | function component(name, options) { |
| [3550](#L3550) | var \_a, \_b; |
| [3551](#L3551) | const id = PREFIX + hyphenate(name); |
| [3552](#L3552) | if (!options) { |
| [3553](#L3553) | if (!components$2[id].options) { |
| [3554](#L3554) | components$2[id] = App.extend(components$2[id]); |
| [3555](#L3555) | } |
| [3556](#L3556) | return components$2[id]; |
| [3557](#L3557) | } |
| [3558](#L3558) | name = camelize(name); |
| [3559](#L3559) | App[name] = (element, data) => createComponent(name, element, data); |
| [3560](#L3560) | const opt = (\_a = options.options) != null ? \_a : { ...options }; |
| [3561](#L3561) | opt.id = id; |
| [3562](#L3562) | opt.name = name; |
| [3563](#L3563) | (\_b = opt.install) == null ? void 0 : \_b.call(opt, App, opt, name); |
| [3564](#L3564) | if (App.\_initialized && !opt.functional) { |
| [3565](#L3565) | requestAnimationFrame(() => createComponent(name, `[${id}],[data-${id}]`)); |
| [3566](#L3566) | } |
| [3567](#L3567) | return components$2[id] = opt; |
| [3568](#L3568) | } |
| [3569](#L3569) | function createComponent(name, element, data, ...args) { |
| [3570](#L3570) | const Component = component(name); |
| [3571](#L3571) | return Component.options.functional ? new Component({ data: isPlainObject(element) ? element : [element, data, ...args] }) : element ? $$(element).map(init)[0] : init(); |
| [3572](#L3572) | function init(element2) { |
| [3573](#L3573) | const instance = getComponent(element2, name); |
| [3574](#L3574) | if (instance) { |
| [3575](#L3575) | if (data) { |
| [3576](#L3576) | instance.$destroy(); |
| [3577](#L3577) | } else { |
| [3578](#L3578) | return instance; |
| [3579](#L3579) | } |
| [3580](#L3580) | } |
| [3581](#L3581) | return new Component({ el: element2, data }); |
| [3582](#L3582) | } |
| [3583](#L3583) | } |
| [3584](#L3584) | function getComponents(element) { |
| [3585](#L3585) | return (element == null ? void 0 : element[DATA]) || {}; |
| [3586](#L3586) | } |
| [3587](#L3587) | function getComponent(element, name) { |
| [3588](#L3588) | return getComponents(element)[name]; |
| [3589](#L3589) | } |
| [3590](#L3590) | function attachToElement(element, instance) { |
| [3591](#L3591) | if (!element[DATA]) { |
| [3592](#L3592) | element[DATA] = {}; |
| [3593](#L3593) | } |
| [3594](#L3594) | element[DATA][instance.$options.name] = instance; |
| [3595](#L3595) | } |
| [3596](#L3596) | function detachFromElement(element, instance) { |
| [3597](#L3597) | var \_a; |
| [3598](#L3598) | (\_a = element[DATA]) == null ? true : delete \_a[instance.$options.name]; |
| [3599](#L3599) | if (isEmpty(element[DATA])) { |
| [3600](#L3600) | delete element[DATA]; |
| [3601](#L3601) | } |
| [3602](#L3602) | } |
| [3603](#L3603) |  |
| [3604](#L3604) | function globalApi(App) { |
| [3605](#L3605) | App.component = component; |
| [3606](#L3606) | App.getComponents = getComponents; |
| [3607](#L3607) | App.getComponent = getComponent; |
| [3608](#L3608) | App.update = update; |
| [3609](#L3609) | App.use = function(plugin) { |
| [3610](#L3610) | if (plugin.installed) { |
| [3611](#L3611) | return; |
| [3612](#L3612) | } |
| [3613](#L3613) | plugin.call(null, this); |
| [3614](#L3614) | plugin.installed = true; |
| [3615](#L3615) | return this; |
| [3616](#L3616) | }; |
| [3617](#L3617) | App.mixin = function(mixin, component2) { |
| [3618](#L3618) | component2 = (isString(component2) ? this.component(component2) : component2) || this; |
| [3619](#L3619) | component2.options = mergeOptions(component2.options, mixin); |
| [3620](#L3620) | }; |
| [3621](#L3621) | App.extend = function(options) { |
| [3622](#L3622) | options || (options = {}); |
| [3623](#L3623) | const Super = this; |
| [3624](#L3624) | const Sub = function bdtUIkitComponent(options2) { |
| [3625](#L3625) | init$1(this, options2); |
| [3626](#L3626) | }; |
| [3627](#L3627) | Sub.prototype = Object.create(Super.prototype); |
| [3628](#L3628) | Sub.prototype.constructor = Sub; |
| [3629](#L3629) | Sub.options = mergeOptions(Super.options, options); |
| [3630](#L3630) | Sub.super = Super; |
| [3631](#L3631) | Sub.extend = Super.extend; |
| [3632](#L3632) | return Sub; |
| [3633](#L3633) | }; |
| [3634](#L3634) | let container; |
| [3635](#L3635) | Object.defineProperty(App, "container", { |
| [3636](#L3636) | get() { |
| [3637](#L3637) | return container || document.body; |
| [3638](#L3638) | }, |
| [3639](#L3639) | set(element) { |
| [3640](#L3640) | container = $(element); |
| [3641](#L3641) | } |
| [3642](#L3642) | }); |
| [3643](#L3643) | } |
| [3644](#L3644) | function update(element, e) { |
| [3645](#L3645) | element = element ? toNode(element) : document.body; |
| [3646](#L3646) | for (const parentEl of parents(element).reverse()) { |
| [3647](#L3647) | updateElement(parentEl, e); |
| [3648](#L3648) | } |
| [3649](#L3649) | apply(element, (element2) => updateElement(element2, e)); |
| [3650](#L3650) | } |
| [3651](#L3651) | function updateElement(element, e) { |
| [3652](#L3652) | const components = getComponents(element); |
| [3653](#L3653) | for (const name in components) { |
| [3654](#L3654) | callUpdate(components[name], e); |
| [3655](#L3655) | } |
| [3656](#L3656) | } |
| [3657](#L3657) |  |
| [3658](#L3658) | function instanceApi(App) { |
| [3659](#L3659) | App.prototype.$mount = function(el) { |
| [3660](#L3660) | const instance = this; |
| [3661](#L3661) | attachToElement(el, instance); |
| [3662](#L3662) | instance.$options.el = el; |
| [3663](#L3663) | if (document.contains(el)) { |
| [3664](#L3664) | callConnected(instance); |
| [3665](#L3665) | } |
| [3666](#L3666) | }; |
| [3667](#L3667) | App.prototype.$destroy = function(removeEl = false) { |
| [3668](#L3668) | const instance = this; |
| [3669](#L3669) | const { el } = instance.$options; |
| [3670](#L3670) | if (el) { |
| [3671](#L3671) | callDisconnected(instance); |
| [3672](#L3672) | } |
| [3673](#L3673) | callHook(instance, "destroy"); |
| [3674](#L3674) | detachFromElement(el, instance); |
| [3675](#L3675) | if (removeEl) { |
| [3676](#L3676) | remove$1(instance.$el); |
| [3677](#L3677) | } |
| [3678](#L3678) | }; |
| [3679](#L3679) | App.prototype.$create = createComponent; |
| [3680](#L3680) | App.prototype.$emit = function(e) { |
| [3681](#L3681) | callUpdate(this, e); |
| [3682](#L3682) | }; |
| [3683](#L3683) | App.prototype.$update = function(element = this.$el, e) { |
| [3684](#L3684) | update(element, e); |
| [3685](#L3685) | }; |
| [3686](#L3686) | App.prototype.$reset = function() { |
| [3687](#L3687) | callDisconnected(this); |
| [3688](#L3688) | callConnected(this); |
| [3689](#L3689) | }; |
| [3690](#L3690) | App.prototype.$getComponent = getComponent; |
| [3691](#L3691) | Object.defineProperties(App.prototype, { |
| [3692](#L3692) | $el: { |
| [3693](#L3693) | get() { |
| [3694](#L3694) | return this.$options.el; |
| [3695](#L3695) | } |
| [3696](#L3696) | }, |
| [3697](#L3697) | $container: Object.getOwnPropertyDescriptor(App, "container") |
| [3698](#L3698) | }); |
| [3699](#L3699) | } |
| [3700](#L3700) | let id = 1; |
| [3701](#L3701) | function generateId(instance, el = null) { |
| [3702](#L3702) | return (el == null ? void 0 : el.id) || `${instance.$options.id}-${id++}`; |
| [3703](#L3703) | } |
| [3704](#L3704) |  |
| [3705](#L3705) | var SliderNav = { |
| [3706](#L3706) | i18n: { |
| [3707](#L3707) | next: "Next slide", |
| [3708](#L3708) | previous: "Previous slide", |
| [3709](#L3709) | slideX: "Slide %s", |
| [3710](#L3710) | slideLabel: "%s of %s", |
| [3711](#L3711) | role: "String" |
| [3712](#L3712) | }, |
| [3713](#L3713) | data: { |
| [3714](#L3714) | selNav: false, |
| [3715](#L3715) | role: "region" |
| [3716](#L3716) | }, |
| [3717](#L3717) | computed: { |
| [3718](#L3718) | nav: ({ selNav }, $el) => $(selNav, $el), |
| [3719](#L3719) | navChildren() { |
| [3720](#L3720) | return children(this.nav); |
| [3721](#L3721) | }, |
| [3722](#L3722) | selNavItem: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`, |
| [3723](#L3723) | navItems(\_, $el) { |
| [3724](#L3724) | return $$(this.selNavItem, $el); |
| [3725](#L3725) | } |
| [3726](#L3726) | }, |
| [3727](#L3727) | watch: { |
| [3728](#L3728) | nav(nav, prev) { |
| [3729](#L3729) | attr(nav, "role", "tablist"); |
| [3730](#L3730) | this.padNavitems(); |
| [3731](#L3731) | if (prev) { |
| [3732](#L3732) | this.$emit(); |
| [3733](#L3733) | } |
| [3734](#L3734) | }, |
| [3735](#L3735) | list(list) { |
| [3736](#L3736) | if (isTag(list, "ul")) { |
| [3737](#L3737) | attr(list, "role", "presentation"); |
| [3738](#L3738) | } |
| [3739](#L3739) | }, |
| [3740](#L3740) | navChildren(children2) { |
| [3741](#L3741) | attr(children2, "role", "presentation"); |
| [3742](#L3742) | this.padNavitems(); |
| [3743](#L3743) | this.updateNav(); |
| [3744](#L3744) | }, |
| [3745](#L3745) | navItems(items) { |
| [3746](#L3746) | for (const el of items) { |
| [3747](#L3747) | const cmd = data(el, this.attrItem); |
| [3748](#L3748) | const button = $("a,button", el) || el; |
| [3749](#L3749) | let ariaLabel; |
| [3750](#L3750) | let ariaControls = null; |
| [3751](#L3751) | if (isNumeric(cmd)) { |
| [3752](#L3752) | const item = toNumber(cmd); |
| [3753](#L3753) | const slide = this.slides[item]; |
| [3754](#L3754) | if (slide) { |
| [3755](#L3755) | if (!slide.id) { |
| [3756](#L3756) | slide.id = generateId(this, slide); |
| [3757](#L3757) | } |
| [3758](#L3758) | ariaControls = slide.id; |
| [3759](#L3759) | } |
| [3760](#L3760) | ariaLabel = this.t("slideX", toFloat(cmd) + 1); |
| [3761](#L3761) | attr(button, "role", "tab"); |
| [3762](#L3762) | } else { |
| [3763](#L3763) | if (this.list) { |
| [3764](#L3764) | if (!this.list.id) { |
| [3765](#L3765) | this.list.id = generateId(this, this.list); |
| [3766](#L3766) | } |
| [3767](#L3767) | ariaControls = this.list.id; |
| [3768](#L3768) | } |
| [3769](#L3769) | ariaLabel = this.t(cmd); |
| [3770](#L3770) | } |
| [3771](#L3771) | attr(button, { |
| [3772](#L3772) | "aria-controls": ariaControls, |
| [3773](#L3773) | "aria-label": attr(button, "aria-label") || ariaLabel |
| [3774](#L3774) | }); |
| [3775](#L3775) | } |
| [3776](#L3776) | }, |
| [3777](#L3777) | slides(slides) { |
| [3778](#L3778) | slides.forEach( |
| [3779](#L3779) | (slide, i) => attr(slide, { |
| [3780](#L3780) | role: this.nav ? "tabpanel" : "group", |
| [3781](#L3781) | "aria-label": this.t("slideLabel", i + 1, this.length), |
| [3782](#L3782) | "aria-roledescription": this.nav ? null : "slide" |
| [3783](#L3783) | }) |
| [3784](#L3784) | ); |
| [3785](#L3785) | this.padNavitems(); |
| [3786](#L3786) | } |
| [3787](#L3787) | }, |
| [3788](#L3788) | connected() { |
| [3789](#L3789) | attr(this.$el, { |
| [3790](#L3790) | role: this.role, |
| [3791](#L3791) | "aria-roledescription": "carousel" |
| [3792](#L3792) | }); |
| [3793](#L3793) | }, |
| [3794](#L3794) | update: [ |
| [3795](#L3795) | { |
| [3796](#L3796) | write() { |
| [3797](#L3797) | this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex)); |
| [3798](#L3798) | this.updateNav(); |
| [3799](#L3799) | }, |
| [3800](#L3800) | events: ["resize"] |
| [3801](#L3801) | } |
| [3802](#L3802) | ], |
| [3803](#L3803) | events: [ |
| [3804](#L3804) | { |
| [3805](#L3805) | name: "click keydown", |
| [3806](#L3806) | delegate: ({ selNavItem }) => selNavItem, |
| [3807](#L3807) | filter: ({ parallax }) => !parallax, |
| [3808](#L3808) | handler(e) { |
| [3809](#L3809) | if (e.target.closest("a,button") && (e.type === "click" || e.keyCode === keyMap.SPACE)) { |
| [3810](#L3810) | e.preventDefault(); |
| [3811](#L3811) | this.show(data(e.current, this.attrItem)); |
| [3812](#L3812) | } |
| [3813](#L3813) | } |
| [3814](#L3814) | }, |
| [3815](#L3815) | { |
| [3816](#L3816) | name: "itemshow", |
| [3817](#L3817) | handler: "updateNav" |
| [3818](#L3818) | }, |
| [3819](#L3819) | { |
| [3820](#L3820) | name: "keydown", |
| [3821](#L3821) | delegate: ({ selNavItem }) => selNavItem, |
| [3822](#L3822) | filter: ({ parallax }) => !parallax, |
| [3823](#L3823) | handler(e) { |
| [3824](#L3824) | const { current, keyCode } = e; |
| [3825](#L3825) | const cmd = data(current, this.attrItem); |
| [3826](#L3826) | if (!isNumeric(cmd)) { |
| [3827](#L3827) | return; |
| [3828](#L3828) | } |
| [3829](#L3829) | let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT ? "previous" : keyCode === keyMap.RIGHT ? "next" : -1; |
| [3830](#L3830) | if (~i) { |
| [3831](#L3831) | e.preventDefault(); |
| [3832](#L3832) | this.show(i); |
| [3833](#L3833) | } |
| [3834](#L3834) | } |
| [3835](#L3835) | } |
| [3836](#L3836) | ], |
| [3837](#L3837) | methods: { |
| [3838](#L3838) | updateNav() { |
| [3839](#L3839) | const index = this.getValidIndex(); |
| [3840](#L3840) | for (const el of this.navItems) { |
| [3841](#L3841) | const cmd = data(el, this.attrItem); |
| [3842](#L3842) | const button = $("a,button", el) || el; |
| [3843](#L3843) | if (isNumeric(cmd)) { |
| [3844](#L3844) | const item = toNumber(cmd); |
| [3845](#L3845) | const active = item === index; |
| [3846](#L3846) | toggleClass(el, this.clsActive, active); |
| [3847](#L3847) | toggleClass(button, "bdt-disabled", this.parallax); |
| [3848](#L3848) | attr(button, { |
| [3849](#L3849) | "aria-selected": active, |
| [3850](#L3850) | tabindex: active && !this.parallax ? null : -1 |
| [3851](#L3851) | }); |
| [3852](#L3852) | if (active && button && matches(parent(el), ":focus-within")) { |
| [3853](#L3853) | button.focus(); |
| [3854](#L3854) | } |
| [3855](#L3855) | } else { |
| [3856](#L3856) | toggleClass( |
| [3857](#L3857) | el, |
| [3858](#L3858) | "bdt-invisible", |
| [3859](#L3859) | this.finite && (cmd === "previous" && index === 0 || cmd === "next" && index >= this.maxIndex) |
| [3860](#L3860) | ); |
| [3861](#L3861) | } |
| [3862](#L3862) | } |
| [3863](#L3863) | }, |
| [3864](#L3864) | padNavitems() { |
| [3865](#L3865) | if (!this.nav) { |
| [3866](#L3866) | return; |
| [3867](#L3867) | } |
| [3868](#L3868) | const children2 = []; |
| [3869](#L3869) | for (let i = 0; i < this.length; i++) { |
| [3870](#L3870) | const attr2 = `${this.attrItem}="${i}"`; |
| [3871](#L3871) | children2[i] = this.navChildren.findLast((el) => el.matches(`[${attr2}]`)) || $(`<li ${attr2}><a href></a></li>`); |
| [3872](#L3872) | } |
| [3873](#L3873) | if (!isEqual(children2, this.navChildren)) { |
| [3874](#L3874) | html(this.nav, children2); |
| [3875](#L3875) | } |
| [3876](#L3876) | } |
| [3877](#L3877) | } |
| [3878](#L3878) | }; |
| [3879](#L3879) |  |
| [3880](#L3880) | const easeOutQuad = "cubic-bezier(0.25, 0.46, 0.45, 0.94)"; |
| [3881](#L3881) | const easeOutQuart = "cubic-bezier(0.165, 0.84, 0.44, 1)"; |
| [3882](#L3882) | var Slider = { |
| [3883](#L3883) | mixins: [SliderAutoplay, SliderDrag, SliderNav, I18n], |
| [3884](#L3884) | props: { |
| [3885](#L3885) | clsActivated: String, |
| [3886](#L3886) | easing: String, |
| [3887](#L3887) | index: Number, |
| [3888](#L3888) | finite: Boolean, |
| [3889](#L3889) | velocity: Number |
| [3890](#L3890) | }, |
| [3891](#L3891) | data: () => ({ |
| [3892](#L3892) | easing: "ease", |
| [3893](#L3893) | finite: false, |
| [3894](#L3894) | velocity: 1, |
| [3895](#L3895) | index: 0, |
| [3896](#L3896) | prevIndex: -1, |
| [3897](#L3897) | stack: [], |
| [3898](#L3898) | percent: 0, |
| [3899](#L3899) | clsActive: "bdt-active", |
| [3900](#L3900) | clsActivated: "", |
| [3901](#L3901) | clsEnter: "bdt-slide-enter", |
| [3902](#L3902) | clsLeave: "bdt-slide-leave", |
| [3903](#L3903) | clsSlideActive: "bdt-slide-active", |
| [3904](#L3904) | Transitioner: false, |
| [3905](#L3905) | transitionOptions: {} |
| [3906](#L3906) | }), |
| [3907](#L3907) | connected() { |
| [3908](#L3908) | this.prevIndex = -1; |
| [3909](#L3909) | this.index = this.getValidIndex(this.$props.index); |
| [3910](#L3910) | this.stack = []; |
| [3911](#L3911) | }, |
| [3912](#L3912) | disconnected() { |
| [3913](#L3913) | removeClass(this.slides, this.clsActive); |
| [3914](#L3914) | }, |
| [3915](#L3915) | computed: { |
| [3916](#L3916) | duration: ({ velocity }, $el) => speedUp($el.offsetWidth / velocity), |
| [3917](#L3917) | list: ({ selList }, $el) => $(selList, $el), |
| [3918](#L3918) | maxIndex() { |
| [3919](#L3919) | return this.length - 1; |
| [3920](#L3920) | }, |
| [3921](#L3921) | slides() { |
| [3922](#L3922) | return children(this.list); |
| [3923](#L3923) | }, |
| [3924](#L3924) | length() { |
| [3925](#L3925) | return this.slides.length; |
| [3926](#L3926) | } |
| [3927](#L3927) | }, |
| [3928](#L3928) | watch: { |
| [3929](#L3929) | slides(slides, prev) { |
| [3930](#L3930) | if (prev) { |
| [3931](#L3931) | this.$emit(); |
| [3932](#L3932) | } |
| [3933](#L3933) | } |
| [3934](#L3934) | }, |
| [3935](#L3935) | events: { |
| [3936](#L3936) | itemshow({ target }) { |
| [3937](#L3937) | addClass(target, this.clsEnter, this.clsSlideActive); |
| [3938](#L3938) | }, |
| [3939](#L3939) | itemshown({ target }) { |
| [3940](#L3940) | removeClass(target, this.clsEnter); |
| [3941](#L3941) | }, |
| [3942](#L3942) | itemhide({ target }) { |
| [3943](#L3943) | addClass(target, this.clsLeave); |
| [3944](#L3944) | }, |
| [3945](#L3945) | itemhidden({ target }) { |
| [3946](#L3946) | removeClass(target, this.clsLeave, this.clsSlideActive); |
| [3947](#L3947) | } |
| [3948](#L3948) | }, |
| [3949](#L3949) | methods: { |
| [3950](#L3950) | show(index, force = false) { |
| [3951](#L3951) | var \_a; |
| [3952](#L3952) | if (this.dragging || !this.length || this.parallax) { |
| [3953](#L3953) | return; |
| [3954](#L3954) | } |
| [3955](#L3955) | const { stack } = this; |
| [3956](#L3956) | const queueIndex = force ? 0 : stack.length; |
| [3957](#L3957) | const reset = () => { |
| [3958](#L3958) | stack.splice(queueIndex, 1); |
| [3959](#L3959) | if (stack.length) { |
| [3960](#L3960) | this.show(stack.shift(), true); |
| [3961](#L3961) | } |
| [3962](#L3962) | }; |
| [3963](#L3963) | stack[force ? "unshift" : "push"](index); |
| [3964](#L3964) | if (!force && stack.length > 1) { |
| [3965](#L3965) | if (stack.length === 2) { |
| [3966](#L3966) | (\_a = this.\_transitioner) == null ? void 0 : \_a.forward(Math.min(this.duration, 200)); |
| [3967](#L3967) | } |
| [3968](#L3968) | return; |
| [3969](#L3969) | } |
| [3970](#L3970) | const prevIndex = this.getIndex(this.index); |
| [3971](#L3971) | const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex]; |
| [3972](#L3972) | const nextIndex = this.getIndex(index, this.index); |
| [3973](#L3973) | const next = this.slides[nextIndex]; |
| [3974](#L3974) | if (prev === next) { |
| [3975](#L3975) | reset(); |
| [3976](#L3976) | return; |
| [3977](#L3977) | } |
| [3978](#L3978) | this.dir = getDirection(index, prevIndex); |
| [3979](#L3979) | this.prevIndex = prevIndex; |
| [3980](#L3980) | this.index = nextIndex; |
| [3981](#L3981) | if (prev && !trigger(prev, "beforeitemhide", [this]) || !trigger(next, "beforeitemshow", [this, prev])) { |
| [3982](#L3982) | this.index = this.prevIndex; |
| [3983](#L3983) | reset(); |
| [3984](#L3984) | return; |
| [3985](#L3985) | } |
| [3986](#L3986) | const promise = this.\_show(prev, next, force).then(() => { |
| [3987](#L3987) | prev && trigger(prev, "itemhidden", [this]); |
| [3988](#L3988) | trigger(next, "itemshown", [this]); |
| [3989](#L3989) | stack.shift(); |
| [3990](#L3990) | this.\_transitioner = null; |
| [3991](#L3991) | if (stack.length) { |
| [3992](#L3992) | requestAnimationFrame(() => stack.length && this.show(stack.shift(), true)); |
| [3993](#L3993) | } |
| [3994](#L3994) | }); |
| [3995](#L3995) | prev && trigger(prev, "itemhide", [this]); |
| [3996](#L3996) | trigger(next, "itemshow", [this]); |
| [3997](#L3997) | return promise; |
| [3998](#L3998) | }, |
| [3999](#L3999) | getIndex(index = this.index, prev = this.index) { |
| [4000](#L4000) | return clamp( |
| [4001](#L4001) | getIndex(index, this.slides, prev, this.finite), |
| [4002](#L4002) | 0, |
| [4003](#L4003) | Math.max(0, this.maxIndex) |
| [4004](#L4004) | ); |
| [4005](#L4005) | }, |
| [4006](#L4006) | getValidIndex(index = this.index, prevIndex = this.prevIndex) { |
| [4007](#L4007) | return this.getIndex(index, prevIndex); |
| [4008](#L4008) | }, |
| [4009](#L4009) | async \_show(prev, next, force) { |
| [4010](#L4010) | this.\_transitioner = this.\_getTransitioner(prev, next, this.dir, { |
| [4011](#L4011) | easing: force ? next.offsetWidth < 600 ? easeOutQuad : easeOutQuart : this.easing, |
| [4012](#L4012) | ...this.transitionOptions |
| [4013](#L4013) | }); |
| [4014](#L4014) | if (!force && !prev) { |
| [4015](#L4015) | this.\_translate(1); |
| [4016](#L4016) | return; |
| [4017](#L4017) | } |
| [4018](#L4018) | const { length } = this.stack; |
| [4019](#L4019) | return this.\_transitioner[length > 1 ? "forward" : "show"]( |
| [4020](#L4020) | length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, |
| [4021](#L4021) | this.percent |
| [4022](#L4022) | ); |
| [4023](#L4023) | }, |
| [4024](#L4024) | \_translate(percent, prev = this.prevIndex, next = this.index) { |
| [4025](#L4025) | const transitioner = this.\_getTransitioner(prev === next ? false : prev, next); |
| [4026](#L4026) | transitioner.translate(percent); |
| [4027](#L4027) | return transitioner; |
| [4028](#L4028) | }, |
| [4029](#L4029) | \_getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) { |
| [4030](#L4030) | return new this.Transitioner( |
| [4031](#L4031) | isNumber(prev) ? this.slides[prev] : prev, |
| [4032](#L4032) | isNumber(next) ? this.slides[next] : next, |
| [4033](#L4033) | dir \* (isRtl ? -1 : 1), |
| [4034](#L4034) | options |
| [4035](#L4035) | ); |
| [4036](#L4036) | } |
| [4037](#L4037) | } |
| [4038](#L4038) | }; |
| [4039](#L4039) | function getDirection(index, prevIndex) { |
| [4040](#L4040) | return index === "next" ? 1 : index === "previous" ? -1 : index < prevIndex ? -1 : 1; |
| [4041](#L4041) | } |
| [4042](#L4042) | function speedUp(x) { |
| [4043](#L4043) | return 0.5 \* x + 300; |
| [4044](#L4044) | } |
| [4045](#L4045) |  |
| [4046](#L4046) | var Slideshow = { |
| [4047](#L4047) | mixins: [Slider], |
| [4048](#L4048) | props: { |
| [4049](#L4049) | animation: String |
| [4050](#L4050) | }, |
| [4051](#L4051) | data: { |
| [4052](#L4052) | animation: "slide", |
| [4053](#L4053) | clsActivated: "bdt-transition-active", |
| [4054](#L4054) | Animations: Animations$2, |
| [4055](#L4055) | Transitioner: Transitioner$1 |
| [4056](#L4056) | }, |
| [4057](#L4057) | computed: { |
| [4058](#L4058) | animation({ animation, Animations: Animations2 }) { |
| [4059](#L4059) | return { ...Animations2[animation] || Animations2.slide, name: animation }; |
| [4060](#L4060) | }, |
| [4061](#L4061) | transitionOptions() { |
| [4062](#L4062) | return { animation: this.animation }; |
| [4063](#L4063) | } |
| [4064](#L4064) | }, |
| [4065](#L4065) | observe: resize(), |
| [4066](#L4066) | events: { |
| [4067](#L4067) | beforeitemshow({ target }) { |
| [4068](#L4068) | addClass(target, this.clsActive); |
| [4069](#L4069) | }, |
| [4070](#L4070) | itemshown({ target }) { |
| [4071](#L4071) | addClass(target, this.clsActivated); |
| [4072](#L4072) | }, |
| [4073](#L4073) | itemhidden({ target }) { |
| [4074](#L4074) | removeClass(target, this.clsActive, this.clsActivated); |
| [4075](#L4075) | } |
| [4076](#L4076) | } |
| [4077](#L4077) | }; |
| [4078](#L4078) |  |
| [4079](#L4079) | var Animations$1 = { |
| [4080](#L4080) | ...Animations$2, |
| [4081](#L4081) | fade: { |
| [4082](#L4082) | show() { |
| [4083](#L4083) | return [{ opacity: 0 }, { opacity: 1 }]; |
| [4084](#L4084) | }, |
| [4085](#L4085) | percent(current) { |
| [4086](#L4086) | return 1 - css(current, "opacity"); |
| [4087](#L4087) | }, |
| [4088](#L4088) | translate(percent) { |
| [4089](#L4089) | return [{ opacity: 1 - percent }, { opacity: percent }]; |
| [4090](#L4090) | } |
| [4091](#L4091) | }, |
| [4092](#L4092) | scale: { |
| [4093](#L4093) | show() { |
| [4094](#L4094) | return [ |
| [4095](#L4095) | { opacity: 0, transform: scale3d(1 - 0.2) }, |
| [4096](#L4096) | { opacity: 1, transform: scale3d(1) } |
| [4097](#L4097) | ]; |
| [4098](#L4098) | }, |
| [4099](#L4099) | percent(current) { |
| [4100](#L4100) | return 1 - css(current, "opacity"); |
| [4101](#L4101) | }, |
| [4102](#L4102) | translate(percent) { |
| [4103](#L4103) | return [ |
| [4104](#L4104) | { opacity: 1 - percent, transform: scale3d(1 - 0.2 \* percent) }, |
| [4105](#L4105) | { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 \* percent) } |
| [4106](#L4106) | ]; |
| [4107](#L4107) | } |
| [4108](#L4108) | } |
| [4109](#L4109) | }; |
| [4110](#L4110) |  |
| [4111](#L4111) | var LightboxPanel = { |
| [4112](#L4112) | mixins: [Modal, Slideshow], |
| [4113](#L4113) | functional: true, |
| [4114](#L4114) | props: { |
| [4115](#L4115) | delayControls: Number, |
| [4116](#L4116) | preload: Number, |
| [4117](#L4117) | videoAutoplay: Boolean, |
| [4118](#L4118) | template: String |
| [4119](#L4119) | }, |
| [4120](#L4120) | data: () => ({ |
| [4121](#L4121) | preload: 1, |
| [4122](#L4122) | videoAutoplay: false, |
| [4123](#L4123) | delayControls: 3e3, |
| [4124](#L4124) | items: [], |
| [4125](#L4125) | cls: "bdt-open", |
| [4126](#L4126) | clsPage: "bdt-lightbox-page", |
| [4127](#L4127) | selList: ".bdt-lightbox-items", |
| [4128](#L4128) | attrItem: "bdt-lightbox-item", |
| [4129](#L4129) | selClose: ".bdt-close-large", |
| [4130](#L4130) | selCaption: ".bdt-lightbox-caption", |
| [4131](#L4131) | pauseOnHover: false, |
| [4132](#L4132) | velocity: 2, |
| [4133](#L4133) | Animations: Animations$1, |
| [4134](#L4134) | template: `<div class="bdt-lightbox bdt-overflow-hidden"> <div class="bdt-lightbox-items"></div> <div class="bdt-lightbox-toolbar bdt-position-top bdt-text-right bdt-transition-slide-top bdt-transition-opaque"> <button class="bdt-lightbox-toolbar-icon bdt-close-large" type="button" bdt-close></button> </div> <a class="bdt-lightbox-button bdt-position-center-left bdt-position-medium bdt-transition-fade" href bdt-slidenav-previous bdt-lightbox-item="previous"></a> <a class="bdt-lightbox-button bdt-position-center-right bdt-position-medium bdt-transition-fade" href bdt-slidenav-next bdt-lightbox-item="next"></a> <div class="bdt-lightbox-toolbar bdt-lightbox-caption bdt-position-bottom bdt-text-center bdt-transition-slide-bottom bdt-transition-opaque"></div> </div>` |
| [4135](#L4135) | }), |
| [4136](#L4136) | created() { |
| [4137](#L4137) | const $el = $(this.template); |
| [4138](#L4138) | const list = $(this.selList, $el); |
| [4139](#L4139) | this.items.forEach(() => append(list, "<div>")); |
| [4140](#L4140) | const close = $("[bdt-close]", $el); |
| [4141](#L4141) | const closeLabel = this.t("close"); |
| [4142](#L4142) | if (close && closeLabel) { |
| [4143](#L4143) | close.dataset.i18n = JSON.stringify({ label: closeLabel }); |
| [4144](#L4144) | } |
| [4145](#L4145) | this.$mount(append(this.container, $el)); |
| [4146](#L4146) | }, |
| [4147](#L4147) | events: [ |
| [4148](#L4148) | { |
| [4149](#L4149) | name: `${pointerMove$1} ${pointerDown$1} keydown`, |
| [4150](#L4150) | handler: "showControls" |
| [4151](#L4151) | }, |
| [4152](#L4152) | { |
| [4153](#L4153) | name: "click", |
| [4154](#L4154) | self: true, |
| [4155](#L4155) | delegate: ({ selList }) => `${selList} > \*`, |
| [4156](#L4156) | handler(e) { |
| [4157](#L4157) | if (!e.defaultPrevented) { |
| [4158](#L4158) | this.hide(); |
| [4159](#L4159) | } |
| [4160](#L4160) | } |
| [4161](#L4161) | }, |
| [4162](#L4162) | { |
| [4163](#L4163) | name: "shown", |
| [4164](#L4164) | self: true, |
| [4165](#L4165) | handler: "showControls" |
| [4166](#L4166) | }, |
| [4167](#L4167) | { |
| [4168](#L4168) | name: "hide", |
| [4169](#L4169) | self: true, |
| [4170](#L4170) | handler() { |
| [4171](#L4171) | this.hideControls(); |
| [4172](#L4172) | removeClass(this.slides, this.clsActive); |
| [4173](#L4173) | Transition.stop(this.slides); |
| [4174](#L4174) | } |
| [4175](#L4175) | }, |
| [4176](#L4176) | { |
| [4177](#L4177) | name: "hidden", |
| [4178](#L4178) | self: true, |
| [4179](#L4179) | handler() { |
| [4180](#L4180) | this.$destroy(true); |
| [4181](#L4181) | } |
| [4182](#L4182) | }, |
| [4183](#L4183) | { |
| [4184](#L4184) | name: "keyup", |
| [4185](#L4185) | el: () => document, |
| [4186](#L4186) | handler({ keyCode }) { |
| [4187](#L4187) | if (!this.isToggled(this.$el) || !this.draggable) { |
| [4188](#L4188) | return; |
| [4189](#L4189) | } |
| [4190](#L4190) | let i = -1; |
| [4191](#L4191) | if (keyCode === keyMap.LEFT) { |
| [4192](#L4192) | i = "previous"; |
| [4193](#L4193) | } else if (keyCode === keyMap.RIGHT) { |
| [4194](#L4194) | i = "next"; |
| [4195](#L4195) | } else if (keyCode === keyMap.HOME) { |
| [4196](#L4196) | i = 0; |
| [4197](#L4197) | } else if (keyCode === keyMap.END) { |
| [4198](#L4198) | i = "last"; |
| [4199](#L4199) | } |
| [4200](#L4200) | if (~i) { |
| [4201](#L4201) | this.show(i); |
| [4202](#L4202) | } |
| [4203](#L4203) | } |
| [4204](#L4204) | }, |
| [4205](#L4205) | { |
| [4206](#L4206) | name: "beforeitemshow", |
| [4207](#L4207) | handler(e) { |
| [4208](#L4208) | if (this.isToggled()) { |
| [4209](#L4209) | return; |
| [4210](#L4210) | } |
| [4211](#L4211) | this.draggable = false; |
| [4212](#L4212) | e.preventDefault(); |
| [4213](#L4213) | this.toggleElement(this.$el, true, false); |
| [4214](#L4214) | this.animation = Animations$1["scale"]; |
| [4215](#L4215) | removeClass(e.target, this.clsActive); |
| [4216](#L4216) | this.stack.splice(1, 0, this.index); |
| [4217](#L4217) | } |
| [4218](#L4218) | }, |
| [4219](#L4219) | { |
| [4220](#L4220) | name: "itemshow", |
| [4221](#L4221) | handler() { |
| [4222](#L4222) | html($(this.selCaption, this.$el), this.getItem().caption || ""); |
| [4223](#L4223) | for (let j = -this.preload; j <= this.preload; j++) { |
| [4224](#L4224) | this.loadItem(this.index + j); |
| [4225](#L4225) | } |
| [4226](#L4226) | } |
| [4227](#L4227) | }, |
| [4228](#L4228) | { |
| [4229](#L4229) | name: "itemshown", |
| [4230](#L4230) | handler() { |
| [4231](#L4231) | this.draggable = this.$props.draggable; |
| [4232](#L4232) | } |
| [4233](#L4233) | }, |
| [4234](#L4234) | { |
| [4235](#L4235) | name: "itemload", |
| [4236](#L4236) | async handler(\_, item) { |
| [4237](#L4237) | const { source: src, type, alt = "", poster, attrs = {} } = item; |
| [4238](#L4238) | this.setItem(item, "<span bdt-spinner></span>"); |
| [4239](#L4239) | if (!src) { |
| [4240](#L4240) | return; |
| [4241](#L4241) | } |
| [4242](#L4242) | let matches; |
| [4243](#L4243) | const iframeAttrs = { |
| [4244](#L4244) | allowfullscreen: "", |
| [4245](#L4245) | style: "max-width: 100%; box-sizing: border-box;", |
| [4246](#L4246) | "bdt-responsive": "", |
| [4247](#L4247) | "bdt-video": `${this.videoAutoplay}` |
| [4248](#L4248) | }; |
| [4249](#L4249) | if (type === "image" || src.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i)) { |
| [4250](#L4250) | const img = createEl("img", { src, alt, ...attrs }); |
| [4251](#L4251) | on(img, "load", () => this.setItem(item, img)); |
| [4252](#L4252) | on(img, "error", () => this.setError(item)); |
| [4253](#L4253) | } else if (type === "video" || src.match(/\.(mp4|webm|ogv)($|\?)/i)) { |
| [4254](#L4254) | const video = createEl("video", { |
| [4255](#L4255) | src, |
| [4256](#L4256) | poster, |
| [4257](#L4257) | controls: "", |
| [4258](#L4258) | playsinline: "", |
| [4259](#L4259) | "bdt-video": `${this.videoAutoplay}`, |
| [4260](#L4260) | ...attrs |
| [4261](#L4261) | }); |
| [4262](#L4262) | on(video, "loadedmetadata", () => this.setItem(item, video)); |
| [4263](#L4263) | on(video, "error", () => this.setError(item)); |
| [4264](#L4264) | } else if (type === "iframe" || src.match(/\.(html|php)($|\?)/i)) { |
| [4265](#L4265) | this.setItem( |
| [4266](#L4266) | item, |
| [4267](#L4267) | createEl("iframe", { |
| [4268](#L4268) | src, |
| [4269](#L4269) | allowfullscreen: "", |
| [4270](#L4270) | class: "bdt-lightbox-iframe", |
| [4271](#L4271) | ...attrs |
| [4272](#L4272) | }) |
| [4273](#L4273) | ); |
| [4274](#L4274) | } else if (matches = src.match( |
| [4275](#L4275) | /\/\/(?:.\*?youtube(-nocookie)?\..\*?(?:[?&]v=|\/shorts\/)|youtu\.be\/)([\w-]{11})[&?]?(.\*)?/ |
| [4276](#L4276) | )) { |
| [4277](#L4277) | this.setItem( |
| [4278](#L4278) | item, |
| [4279](#L4279) | createEl("iframe", { |
| [4280](#L4280) | src: `https://www.youtube${matches[1] || ""}.com/embed/${matches[2]}${matches[3] ? `?${matches[3]}` : ""}`, |
| [4281](#L4281) | width: 1920, |
| [4282](#L4282) | height: 1080, |
| [4283](#L4283) | ...iframeAttrs, |
| [4284](#L4284) | ...attrs |
| [4285](#L4285) | }) |
| [4286](#L4286) | ); |
| [4287](#L4287) | } else if (matches = src.match(/\/\/.\*?vimeo\.[a-z]+\/(\d+)[&?]?(.\*)?/)) { |
| [4288](#L4288) | try { |
| [4289](#L4289) | const { height, width } = await (await fetch( |
| [4290](#L4290) | `https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI( |
| [4291](#L4291) | src |
| [4292](#L4292) | )}`, |
| [4293](#L4293) | { credentials: "omit" } |
| [4294](#L4294) | )).json(); |
| [4295](#L4295) | this.setItem( |
| [4296](#L4296) | item, |
| [4297](#L4297) | createEl("iframe", { |
| [4298](#L4298) | src: `https://player.vimeo.com/video/${matches[1]}${matches[2] ? `?${matches[2]}` : ""}`, |
| [4299](#L4299) | width, |
| [4300](#L4300) | height, |
| [4301](#L4301) | ...iframeAttrs, |
| [4302](#L4302) | ...attrs |
| [4303](#L4303) | }) |
| [4304](#L4304) | ); |
| [4305](#L4305) | } catch (e) { |
| [4306](#L4306) | this.setError(item); |
| [4307](#L4307) | } |
| [4308](#L4308) | } |
| [4309](#L4309) | } |
| [4310](#L4310) | } |
| [4311](#L4311) | ], |
| [4312](#L4312) | methods: { |
| [4313](#L4313) | loadItem(index = this.index) { |
| [4314](#L4314) | const item = this.getItem(index); |
| [4315](#L4315) | if (!this.getSlide(item).childElementCount) { |
| [4316](#L4316) | trigger(this.$el, "itemload", [item]); |
| [4317](#L4317) | } |
| [4318](#L4318) | }, |
| [4319](#L4319) | getItem(index = this.index) { |
| [4320](#L4320) | return this.items[getIndex(index, this.slides)]; |
| [4321](#L4321) | }, |
| [4322](#L4322) | setItem(item, content) { |
| [4323](#L4323) | trigger(this.$el, "itemloaded", [this, html(this.getSlide(item), content)]); |
| [4324](#L4324) | }, |
| [4325](#L4325) | getSlide(item) { |
| [4326](#L4326) | return this.slides[this.items.indexOf(item)]; |
| [4327](#L4327) | }, |
| [4328](#L4328) | setError(item) { |
| [4329](#L4329) | this.setItem(item, '<span bdt-icon="icon: bolt; ratio: 2"></span>'); |
| [4330](#L4330) | }, |
| [4331](#L4331) | showControls() { |
| [4332](#L4332) | clearTimeout(this.controlsTimer); |
| [4333](#L4333) | this.controlsTimer = setTimeout(this.hideControls, this.delayControls); |
| [4334](#L4334) | addClass(this.$el, "bdt-active", "bdt-transition-active"); |
| [4335](#L4335) | }, |
| [4336](#L4336) | hideControls() { |
| [4337](#L4337) | removeClass(this.$el, "bdt-active", "bdt-transition-active"); |
| [4338](#L4338) | } |
| [4339](#L4339) | } |
| [4340](#L4340) | }; |
| [4341](#L4341) | function createEl(tag, attrs) { |
| [4342](#L4342) | const el = fragment(`<${tag}>`); |
| [4343](#L4343) | attr(el, attrs); |
| [4344](#L4344) | return el; |
| [4345](#L4345) | } |
| [4346](#L4346) |  |
| [4347](#L4347) | var lightbox = { |
| [4348](#L4348) | install: install$3, |
| [4349](#L4349) | props: { toggle: String }, |
| [4350](#L4350) | data: { toggle: "a" }, |
| [4351](#L4351) | computed: { |
| [4352](#L4352) | toggles: ({ toggle }, $el) => $$(toggle, $el) |
| [4353](#L4353) | }, |
| [4354](#L4354) | watch: { |
| [4355](#L4355) | toggles(toggles) { |
| [4356](#L4356) | this.hide(); |
| [4357](#L4357) | for (const toggle of toggles) { |
| [4358](#L4358) | if (isTag(toggle, "a")) { |
| [4359](#L4359) | attr(toggle, "role", "button"); |
| [4360](#L4360) | } |
| [4361](#L4361) | } |
| [4362](#L4362) | } |
| [4363](#L4363) | }, |
| [4364](#L4364) | disconnected() { |
| [4365](#L4365) | this.hide(); |
| [4366](#L4366) | }, |
| [4367](#L4367) | events: { |
| [4368](#L4368) | name: "click", |
| [4369](#L4369) | delegate: ({ toggle }) => `${toggle}:not(.bdt-disabled)`, |
| [4370](#L4370) | handler(e) { |
| [4371](#L4371) | if (!e.defaultPrevented) { |
| [4372](#L4372) | e.preventDefault(); |
| [4373](#L4373) | this.show(e.current); |
| [4374](#L4374) | } |
| [4375](#L4375) | } |
| [4376](#L4376) | }, |
| [4377](#L4377) | methods: { |
| [4378](#L4378) | show(index) { |
| [4379](#L4379) | const items = uniqueBy(this.toggles.map(toItem), "source"); |
| [4380](#L4380) | if (isElement(index)) { |
| [4381](#L4381) | const { source } = toItem(index); |
| [4382](#L4382) | index = findIndex(items, ({ source: src }) => source === src); |
| [4383](#L4383) | } |
| [4384](#L4384) | this.panel = this.panel || this.$create("lightboxPanel", { ...this.$props, items }); |
| [4385](#L4385) | on(this.panel.$el, "hidden", () => this.panel = null); |
| [4386](#L4386) | return this.panel.show(index); |
| [4387](#L4387) | }, |
| [4388](#L4388) | hide() { |
| [4389](#L4389) | var \_a; |
| [4390](#L4390) | return (\_a = this.panel) == null ? void 0 : \_a.hide(); |
| [4391](#L4391) | } |
| [4392](#L4392) | } |
| [4393](#L4393) | }; |
| [4394](#L4394) | function install$3(bdtUIkit, Lightbox) { |
| [4395](#L4395) | if (!bdtUIkit.lightboxPanel) { |
| [4396](#L4396) | bdtUIkit.component("lightboxPanel", LightboxPanel); |
| [4397](#L4397) | } |
| [4398](#L4398) | assign(Lightbox.props, bdtUIkit.component("lightboxPanel").options.props); |
| [4399](#L4399) | } |
| [4400](#L4400) | function toItem(el) { |
| [4401](#L4401) | const item = {}; |
| [4402](#L4402) | for (const attr2 of ["href", "caption", "type", "poster", "alt", "attrs"]) { |
| [4403](#L4403) | item[attr2 === "href" ? "source" : attr2] = data(el, attr2); |
| [4404](#L4404) | } |
| [4405](#L4405) | item.attrs = parseOptions(item.attrs); |
| [4406](#L4406) | return item; |
| [4407](#L4407) | } |
| [4408](#L4408) |  |
| [4409](#L4409) | var notification = { |
| [4410](#L4410) | mixins: [Container], |
| [4411](#L4411) | functional: true, |
| [4412](#L4412) | args: ["message", "status"], |
| [4413](#L4413) | data: { |
| [4414](#L4414) | message: "", |
| [4415](#L4415) | status: "", |
| [4416](#L4416) | timeout: 5e3, |
| [4417](#L4417) | group: "", |
| [4418](#L4418) | pos: "top-center", |
| [4419](#L4419) | clsContainer: "bdt-notification", |
| [4420](#L4420) | clsClose: "bdt-notification-close", |
| [4421](#L4421) | clsMsg: "bdt-notification-message" |
| [4422](#L4422) | }, |
| [4423](#L4423) | install: install$2, |
| [4424](#L4424) | computed: { |
| [4425](#L4425) | marginProp: ({ pos }) => `margin-${pos.match(/[a-z]+(?=-)/)[0]}`, |
| [4426](#L4426) | startProps() { |
| [4427](#L4427) | return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight }; |
| [4428](#L4428) | } |
| [4429](#L4429) | }, |
| [4430](#L4430) | created() { |
| [4431](#L4431) | const posClass = `${this.clsContainer}-${this.pos}`; |
| [4432](#L4432) | const containerAttr = `data-${this.clsContainer}-container`; |
| [4433](#L4433) | const container = $(`.${posClass}[${containerAttr}]`, this.container) || append( |
| [4434](#L4434) | this.container, |
| [4435](#L4435) | `<div class="${this.clsContainer} ${posClass}" ${containerAttr}></div>` |
| [4436](#L4436) | ); |
| [4437](#L4437) | this.$mount( |
| [4438](#L4438) | append( |
| [4439](#L4439) | container, |
| [4440](#L4440) | `<div class="${this.clsMsg}${this.status ? ` ${this.clsMsg}-${this.status}` : ""}" role="alert"> <a href class="${this.clsClose}" data-bdt-close></a> <div>${this.message}</div> </div>` |
| [4441](#L4441) | ) |
| [4442](#L4442) | ); |
| [4443](#L4443) | }, |
| [4444](#L4444) | async connected() { |
| [4445](#L4445) | const margin = toFloat(css(this.$el, this.marginProp)); |
| [4446](#L4446) | await Transition.start(css(this.$el, this.startProps), { |
| [4447](#L4447) | opacity: 1, |
| [4448](#L4448) | [this.marginProp]: margin |
| [4449](#L4449) | }); |
| [4450](#L4450) | if (this.timeout) { |
| [4451](#L4451) | this.timer = setTimeout(this.close, this.timeout); |
| [4452](#L4452) | } |
| [4453](#L4453) | }, |
| [4454](#L4454) | events: { |
| [4455](#L4455) | click(e) { |
| [4456](#L4456) | if (e.target.closest('a[href="#"],a[href=""]')) { |
| [4457](#L4457) | e.preventDefault(); |
| [4458](#L4458) | } |
| [4459](#L4459) | this.close(); |
| [4460](#L4460) | }, |
| [4461](#L4461) | [pointerEnter]() { |
| [4462](#L4462) | if (this.timer) { |
| [4463](#L4463) | clearTimeout(this.timer); |
| [4464](#L4464) | } |
| [4465](#L4465) | }, |
| [4466](#L4466) | [pointerLeave]() { |
| [4467](#L4467) | if (this.timeout) { |
| [4468](#L4468) | this.timer = setTimeout(this.close, this.timeout); |
| [4469](#L4469) | } |
| [4470](#L4470) | } |
| [4471](#L4471) | }, |
| [4472](#L4472) | methods: { |
| [4473](#L4473) | async close(immediate) { |
| [4474](#L4474) | const removeFn = (el) => { |
| [4475](#L4475) | const container = parent(el); |
| [4476](#L4476) | trigger(el, "close", [this]); |
| [4477](#L4477) | remove$1(el); |
| [4478](#L4478) | if (!(container == null ? void 0 : container.hasChildNodes())) { |
| [4479](#L4479) | remove$1(container); |
| [4480](#L4480) | } |
| [4481](#L4481) | }; |
| [4482](#L4482) | if (this.timer) { |
| [4483](#L4483) | clearTimeout(this.timer); |
| [4484](#L4484) | } |
| [4485](#L4485) | if (!immediate) { |
| [4486](#L4486) | await Transition.start(this.$el, this.startProps); |
| [4487](#L4487) | } |
| [4488](#L4488) | removeFn(this.$el); |
| [4489](#L4489) | } |
| [4490](#L4490) | } |
| [4491](#L4491) | }; |
| [4492](#L4492) | function install$2(bdtUIkit) { |
| [4493](#L4493) | bdtUIkit.notification.closeAll = function(group, immediate) { |
| [4494](#L4494) | apply(document.body, (el) => { |
| [4495](#L4495) | const notification = bdtUIkit.getComponent(el, "notification"); |
| [4496](#L4496) | if (notification && (!group || group === notification.group)) { |
| [4497](#L4497) | notification.close(immediate); |
| [4498](#L4498) | } |
| [4499](#L4499) | }); |
| [4500](#L4500) | }; |
| [4501](#L4501) | } |
| [4502](#L4502) |  |
| [4503](#L4503) | var Media = { |
| [4504](#L4504) | props: { |
| [4505](#L4505) | media: Boolean |
| [4506](#L4506) | }, |
| [4507](#L4507) | data: { |
| [4508](#L4508) | media: false |
| [4509](#L4509) | }, |
| [4510](#L4510) | connected() { |
| [4511](#L4511) | const media = toMedia(this.media, this.$el); |
| [4512](#L4512) | this.matchMedia = true; |
| [4513](#L4513) | if (media) { |
| [4514](#L4514) | this.mediaObj = window.matchMedia(media); |
| [4515](#L4515) | const handler = () => { |
| [4516](#L4516) | this.matchMedia = this.mediaObj.matches; |
| [4517](#L4517) | trigger(this.$el, createEvent("mediachange", false, true, [this.mediaObj])); |
| [4518](#L4518) | }; |
| [4519](#L4519) | this.offMediaObj = on(this.mediaObj, "change", () => { |
| [4520](#L4520) | handler(); |
| [4521](#L4521) | this.$emit("resize"); |
| [4522](#L4522) | }); |
| [4523](#L4523) | handler(); |
| [4524](#L4524) | } |
| [4525](#L4525) | }, |
| [4526](#L4526) | disconnected() { |
| [4527](#L4527) | var \_a; |
| [4528](#L4528) | (\_a = this.offMediaObj) == null ? void 0 : \_a.call(this); |
| [4529](#L4529) | } |
| [4530](#L4530) | }; |
| [4531](#L4531) | function toMedia(value, element) { |
| [4532](#L4532) | if (isString(value)) { |
| [4533](#L4533) | if (startsWith(value, "@")) { |
| [4534](#L4534) | value = toFloat(css(element, `--bdt-breakpoint-${value.slice(1)}`)); |
| [4535](#L4535) | } else if (isNaN(value)) { |
| [4536](#L4536) | return value; |
| [4537](#L4537) | } |
| [4538](#L4538) | } |
| [4539](#L4539) | return value && isNumeric(value) ? `(min-width: ${value}px)` : ""; |
| [4540](#L4540) | } |
| [4541](#L4541) |  |
| [4542](#L4542) | function getMaxPathLength(el) { |
| [4543](#L4543) | return isVisible(el) ? Math.ceil( |
| [4544](#L4544) | Math.max(0, ...$$("[stroke]", el).map((stroke) => { |
| [4545](#L4545) | var \_a; |
| [4546](#L4546) | return ((\_a = stroke.getTotalLength) == null ? void 0 : \_a.call(stroke)) || 0; |
| [4547](#L4547) | })) |
| [4548](#L4548) | ) : 0; |
| [4549](#L4549) | } |
| [4550](#L4550) |  |
| [4551](#L4551) | const props = { |
| [4552](#L4552) | x: transformFn, |
| [4553](#L4553) | y: transformFn, |
| [4554](#L4554) | rotate: transformFn, |
| [4555](#L4555) | scale: transformFn, |
| [4556](#L4556) | color: colorFn, |
| [4557](#L4557) | backgroundColor: colorFn, |
| [4558](#L4558) | borderColor: colorFn, |
| [4559](#L4559) | blur: filterFn, |
| [4560](#L4560) | hue: filterFn, |
| [4561](#L4561) | fopacity: filterFn, |
| [4562](#L4562) | grayscale: filterFn, |
| [4563](#L4563) | invert: filterFn, |
| [4564](#L4564) | saturate: filterFn, |
| [4565](#L4565) | sepia: filterFn, |
| [4566](#L4566) | opacity: cssPropFn, |
| [4567](#L4567) | stroke: strokeFn, |
| [4568](#L4568) | bgx: backgroundFn, |
| [4569](#L4569) | bgy: backgroundFn |
| [4570](#L4570) | }; |
| [4571](#L4571) | const { keys } = Object; |
| [4572](#L4572) | var Parallax = { |
| [4573](#L4573) | mixins: [Media], |
| [4574](#L4574) | props: fillObject(keys(props), "list"), |
| [4575](#L4575) | data: fillObject(keys(props), void 0), |
| [4576](#L4576) | computed: { |
| [4577](#L4577) | props(properties, $el) { |
| [4578](#L4578) | const stops = {}; |
| [4579](#L4579) | for (const prop in properties) { |
| [4580](#L4580) | if (prop in props && !isUndefined(properties[prop])) { |
| [4581](#L4581) | stops[prop] = properties[prop].slice(); |
| [4582](#L4582) | } |
| [4583](#L4583) | } |
| [4584](#L4584) | const result = {}; |
| [4585](#L4585) | for (const prop in stops) { |
| [4586](#L4586) | result[prop] = props[prop](prop, $el, stops[prop], stops); |
| [4587](#L4587) | } |
| [4588](#L4588) | return result; |
| [4589](#L4589) | } |
| [4590](#L4590) | }, |
| [4591](#L4591) | events: { |
| [4592](#L4592) | load() { |
| [4593](#L4593) | this.$emit(); |
| [4594](#L4594) | } |
| [4595](#L4595) | }, |
| [4596](#L4596) | methods: { |
| [4597](#L4597) | reset() { |
| [4598](#L4598) | for (const prop in this.getCss(0)) { |
| [4599](#L4599) | css(this.$el, prop, ""); |
| [4600](#L4600) | } |
| [4601](#L4601) | }, |
| [4602](#L4602) | getCss(percent) { |
| [4603](#L4603) | const css2 = {}; |
| [4604](#L4604) | for (const prop in this.props) { |
| [4605](#L4605) | this.props[prop](css2, clamp(percent)); |
| [4606](#L4606) | } |
| [4607](#L4607) | css2.willChange = Object.keys(css2).map(propName).join(","); |
| [4608](#L4608) | return css2; |
| [4609](#L4609) | } |
| [4610](#L4610) | } |
| [4611](#L4611) | }; |
| [4612](#L4612) | function transformFn(prop, el, stops) { |
| [4613](#L4613) | let unit = getUnit(stops) || { x: "px", y: "px", rotate: "deg" }[prop] || ""; |
| [4614](#L4614) | let transformFn2; |
| [4615](#L4615) | if (prop === "x" || prop === "y") { |
| [4616](#L4616) | prop = `translate${ucfirst(prop)}`; |
| [4617](#L4617) | transformFn2 = (stop) => toFloat(toFloat(stop).toFixed(unit === "px" ? 0 : 6)); |
| [4618](#L4618) | } else if (prop === "scale") { |
| [4619](#L4619) | unit = ""; |
| [4620](#L4620) | transformFn2 = (stop) => { |
| [4621](#L4621) | var \_a; |
| [4622](#L4622) | return getUnit([stop]) ? toPx(stop, "width", el, true) / el[`offset${((\_a = stop.endsWith) == null ? void 0 : \_a.call(stop, "vh")) ? "Height" : "Width"}`] : toFloat(stop); |
| [4623](#L4623) | }; |
| [4624](#L4624) | } |
| [4625](#L4625) | if (stops.length === 1) { |
| [4626](#L4626) | stops.unshift(prop === "scale" ? 1 : 0); |
| [4627](#L4627) | } |
| [4628](#L4628) | stops = parseStops(stops, transformFn2); |
| [4629](#L4629) | return (css2, percent) => { |
| [4630](#L4630) | css2.transform = `${css2.transform || ""} ${prop}(${getValue(stops, percent)}${unit})`; |
| [4631](#L4631) | }; |
| [4632](#L4632) | } |
| [4633](#L4633) | function colorFn(prop, el, stops) { |
| [4634](#L4634) | if (stops.length === 1) { |
| [4635](#L4635) | stops.unshift(getCssValue(el, prop, "")); |
| [4636](#L4636) | } |
| [4637](#L4637) | stops = parseStops(stops, (stop) => parseColor(el, stop)); |
| [4638](#L4638) | return (css2, percent) => { |
| [4639](#L4639) | const [start, end, p] = getStop(stops, percent); |
| [4640](#L4640) | const value = start.map((value2, i) => { |
| [4641](#L4641) | value2 += p \* (end[i] - value2); |
| [4642](#L4642) | return i === 3 ? toFloat(value2) : parseInt(value2, 10); |
| [4643](#L4643) | }).join(","); |
| [4644](#L4644) | css2[prop] = `rgba(${value})`; |
| [4645](#L4645) | }; |
| [4646](#L4646) | } |
| [4647](#L4647) | function parseColor(el, color) { |
| [4648](#L4648) | return getCssValue(el, "color", color).split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(toFloat); |
| [4649](#L4649) | } |
| [4650](#L4650) | function filterFn(prop, el, stops) { |
| [4651](#L4651) | if (stops.length === 1) { |
| [4652](#L4652) | stops.unshift(0); |
| [4653](#L4653) | } |
| [4654](#L4654) | const unit = getUnit(stops) || { blur: "px", hue: "deg" }[prop] || "%"; |
| [4655](#L4655) | prop = { fopacity: "opacity", hue: "hue-rotate" }[prop] || prop; |
| [4656](#L4656) | stops = parseStops(stops); |
| [4657](#L4657) | return (css2, percent) => { |
| [4658](#L4658) | const value = getValue(stops, percent); |
| [4659](#L4659) | css2.filter = `${css2.filter || ""} ${prop}(${value + unit})`; |
| [4660](#L4660) | }; |
| [4661](#L4661) | } |
| [4662](#L4662) | function cssPropFn(prop, el, stops) { |
| [4663](#L4663) | if (stops.length === 1) { |
| [4664](#L4664) | stops.unshift(getCssValue(el, prop, "")); |
| [4665](#L4665) | } |
| [4666](#L4666) | stops = parseStops(stops); |
| [4667](#L4667) | return (css2, percent) => { |
| [4668](#L4668) | css2[prop] = getValue(stops, percent); |
| [4669](#L4669) | }; |
| [4670](#L4670) | } |
| [4671](#L4671) | function strokeFn(prop, el, stops) { |
| [4672](#L4672) | if (stops.length === 1) { |
| [4673](#L4673) | stops.unshift(0); |
| [4674](#L4674) | } |
| [4675](#L4675) | const unit = getUnit(stops); |
| [4676](#L4676) | const length = getMaxPathLength(el); |
| [4677](#L4677) | stops = parseStops(stops.reverse(), (stop) => { |
| [4678](#L4678) | stop = toFloat(stop); |
| [4679](#L4679) | return unit === "%" ? stop \* length / 100 : stop; |
| [4680](#L4680) | }); |
| [4681](#L4681) | if (!stops.some(([value]) => value)) { |
| [4682](#L4682) | return noop; |
| [4683](#L4683) | } |
| [4684](#L4684) | css(el, "strokeDasharray", length); |
| [4685](#L4685) | return (css2, percent) => { |
| [4686](#L4686) | css2.strokeDashoffset = getValue(stops, percent); |
| [4687](#L4687) | }; |
| [4688](#L4688) | } |
| [4689](#L4689) | function backgroundFn(prop, el, stops, props2) { |
| [4690](#L4690) | if (stops.length === 1) { |
| [4691](#L4691) | stops.unshift(0); |
| [4692](#L4692) | } |
| [4693](#L4693) | const attr = prop === "bgy" ? "height" : "width"; |
| [4694](#L4694) | props2[prop] = parseStops(stops, (stop) => toPx(stop, attr, el)); |
| [4695](#L4695) | const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2); |
| [4696](#L4696) | if (bgProps.length === 2 && prop === "bgx") { |
| [4697](#L4697) | return noop; |
| [4698](#L4698) | } |
| [4699](#L4699) | if (getCssValue(el, "backgroundSize", "") === "cover") { |
| [4700](#L4700) | return backgroundCoverFn(prop, el, stops, props2); |
| [4701](#L4701) | } |
| [4702](#L4702) | const positions = {}; |
| [4703](#L4703) | for (const prop2 of bgProps) { |
| [4704](#L4704) | positions[prop2] = getBackgroundPos(el, prop2); |
| [4705](#L4705) | } |
| [4706](#L4706) | return setBackgroundPosFn(bgProps, positions, props2); |
| [4707](#L4707) | } |
| [4708](#L4708) | function backgroundCoverFn(prop, el, stops, props2) { |
| [4709](#L4709) | const dimImage = getBackgroundImageDimensions(el); |
| [4710](#L4710) | if (!dimImage.width) { |
| [4711](#L4711) | return noop; |
| [4712](#L4712) | } |
| [4713](#L4713) | const dimEl = { |
| [4714](#L4714) | width: el.offsetWidth, |
| [4715](#L4715) | height: el.offsetHeight |
| [4716](#L4716) | }; |
| [4717](#L4717) | const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2); |
| [4718](#L4718) | const positions = {}; |
| [4719](#L4719) | for (const prop2 of bgProps) { |
| [4720](#L4720) | const values = props2[prop2].map(([value]) => value); |
| [4721](#L4721) | const min = Math.min(...values); |
| [4722](#L4722) | const max = Math.max(...values); |
| [4723](#L4723) | const down = values.indexOf(min) < values.indexOf(max); |
| [4724](#L4724) | const diff = max - min; |
| [4725](#L4725) | positions[prop2] = `${(down ? -diff : 0) - (down ? min : max)}px`; |
| [4726](#L4726) | dimEl[prop2 === "bgy" ? "height" : "width"] += diff; |
| [4727](#L4727) | } |
| [4728](#L4728) | const dim = Dimensions.cover(dimImage, dimEl); |
| [4729](#L4729) | for (const prop2 of bgProps) { |
| [4730](#L4730) | const attr = prop2 === "bgy" ? "height" : "width"; |
| [4731](#L4731) | const overflow = dim[attr] - dimEl[attr]; |
| [4732](#L4732) | positions[prop2] = `max(${getBackgroundPos(el, prop2)},-${overflow}px) + ${positions[prop2]}`; |
| [4733](#L4733) | } |
| [4734](#L4734) | const fn = setBackgroundPosFn(bgProps, positions, props2); |
| [4735](#L4735) | return (css2, percent) => { |
| [4736](#L4736) | fn(css2, percent); |
| [4737](#L4737) | css2.backgroundSize = `${dim.width}px ${dim.height}px`; |
| [4738](#L4738) | css2.backgroundRepeat = "no-repeat"; |
| [4739](#L4739) | }; |
| [4740](#L4740) | } |
| [4741](#L4741) | function getBackgroundPos(el, prop) { |
| [4742](#L4742) | return getCssValue(el, `background-position-${prop.slice(-1)}`, ""); |
| [4743](#L4743) | } |
| [4744](#L4744) | function setBackgroundPosFn(bgProps, positions, props2) { |
| [4745](#L4745) | return function(css2, percent) { |
| [4746](#L4746) | for (const prop of bgProps) { |
| [4747](#L4747) | const value = getValue(props2[prop], percent); |
| [4748](#L4748) | css2[`background-position-${prop.slice(-1)}`] = `calc(${positions[prop]} + ${value}px)`; |
| [4749](#L4749) | } |
| [4750](#L4750) | }; |
| [4751](#L4751) | } |
| [4752](#L4752) | const loading = {}; |
| [4753](#L4753) | const dimensions = {}; |
| [4754](#L4754) | function getBackgroundImageDimensions(el) { |
| [4755](#L4755) | const src = css(el, "backgroundImage").replace(/^none|url\(["']?(.+?)["']?\)$/, "$1"); |
| [4756](#L4756) | if (dimensions[src]) { |
| [4757](#L4757) | return dimensions[src]; |
| [4758](#L4758) | } |
| [4759](#L4759) | const image = new Image(); |
| [4760](#L4760) | if (src) { |
| [4761](#L4761) | image.src = src; |
| [4762](#L4762) | if (!image.naturalWidth && !loading[src]) { |
| [4763](#L4763) | once(image, "error load", () => { |
| [4764](#L4764) | dimensions[src] = toDimensions(image); |
| [4765](#L4765) | trigger(el, createEvent("load", false)); |
| [4766](#L4766) | }); |
| [4767](#L4767) | loading[src] = true; |
| [4768](#L4768) | return toDimensions(image); |
| [4769](#L4769) | } |
| [4770](#L4770) | } |
| [4771](#L4771) | return dimensions[src] = toDimensions(image); |
| [4772](#L4772) | } |
| [4773](#L4773) | function toDimensions(image) { |
| [4774](#L4774) | return { |
| [4775](#L4775) | width: image.naturalWidth, |
| [4776](#L4776) | height: image.naturalHeight |
| [4777](#L4777) | }; |
| [4778](#L4778) | } |
| [4779](#L4779) | function parseStops(stops, fn = toFloat) { |
| [4780](#L4780) | const result = []; |
| [4781](#L4781) | const { length } = stops; |
| [4782](#L4782) | let nullIndex = 0; |
| [4783](#L4783) | for (let i = 0; i < length; i++) { |
| [4784](#L4784) | let [value, percent] = isString(stops[i]) ? stops[i].trim().split(/ (?![^(]\*\))/) : [stops[i]]; |
| [4785](#L4785) | value = fn(value); |
| [4786](#L4786) | percent = percent ? toFloat(percent) / 100 : null; |
| [4787](#L4787) | if (i === 0) { |
| [4788](#L4788) | if (percent === null) { |
| [4789](#L4789) | percent = 0; |
| [4790](#L4790) | } else if (percent) { |
| [4791](#L4791) | result.push([value, 0]); |
| [4792](#L4792) | } |
| [4793](#L4793) | } else if (i === length - 1) { |
| [4794](#L4794) | if (percent === null) { |
| [4795](#L4795) | percent = 1; |
| [4796](#L4796) | } else if (percent !== 1) { |
| [4797](#L4797) | result.push([value, percent]); |
| [4798](#L4798) | percent = 1; |
| [4799](#L4799) | } |
| [4800](#L4800) | } |
| [4801](#L4801) | result.push([value, percent]); |
| [4802](#L4802) | if (percent === null) { |
| [4803](#L4803) | nullIndex++; |
| [4804](#L4804) | } else if (nullIndex) { |
| [4805](#L4805) | const leftPercent = result[i - nullIndex - 1][1]; |
| [4806](#L4806) | const p = (percent - leftPercent) / (nullIndex + 1); |
| [4807](#L4807) | for (let j = nullIndex; j > 0; j--) { |
| [4808](#L4808) | result[i - j][1] = leftPercent + p \* (nullIndex - j + 1); |
| [4809](#L4809) | } |
| [4810](#L4810) | nullIndex = 0; |
| [4811](#L4811) | } |
| [4812](#L4812) | } |
| [4813](#L4813) | return result; |
| [4814](#L4814) | } |
| [4815](#L4815) | function getStop(stops, percent) { |
| [4816](#L4816) | const index = findIndex(stops.slice(1), ([, targetPercent]) => percent <= targetPercent) + 1; |
| [4817](#L4817) | return [ |
| [4818](#L4818) | stops[index - 1][0], |
| [4819](#L4819) | stops[index][0], |
| [4820](#L4820) | (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1]) |
| [4821](#L4821) | ]; |
| [4822](#L4822) | } |
| [4823](#L4823) | function getValue(stops, percent) { |
| [4824](#L4824) | const [start, end, p] = getStop(stops, percent); |
| [4825](#L4825) | return start + Math.abs(start - end) \* p \* (start < end ? 1 : -1); |
| [4826](#L4826) | } |
| [4827](#L4827) | const unitRe = /^-?\d+(?:\.\d+)?(\S+)?/; |
| [4828](#L4828) | function getUnit(stops, defaultUnit) { |
| [4829](#L4829) | var \_a; |
| [4830](#L4830) | for (const stop of stops) { |
| [4831](#L4831) | const match = (\_a = stop.match) == null ? void 0 : \_a.call(stop, unitRe); |
| [4832](#L4832) | if (match) { |
| [4833](#L4833) | return match[1]; |
| [4834](#L4834) | } |
| [4835](#L4835) | } |
| [4836](#L4836) | return defaultUnit; |
| [4837](#L4837) | } |
| [4838](#L4838) | function getCssValue(el, prop, value) { |
| [4839](#L4839) | const prev = el.style[prop]; |
| [4840](#L4840) | const val = css(css(el, prop, value), prop); |
| [4841](#L4841) | el.style[prop] = prev; |
| [4842](#L4842) | return val; |
| [4843](#L4843) | } |
| [4844](#L4844) | function fillObject(keys2, value) { |
| [4845](#L4845) | return keys2.reduce((data, prop) => { |
| [4846](#L4846) | data[prop] = value; |
| [4847](#L4847) | return data; |
| [4848](#L4848) | }, {}); |
| [4849](#L4849) | } |
| [4850](#L4850) | function ease(percent, easing) { |
| [4851](#L4851) | return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, 1 - easing); |
| [4852](#L4852) | } |
| [4853](#L4853) |  |
| [4854](#L4854) | var parallax = { |
| [4855](#L4855) | mixins: [Parallax], |
| [4856](#L4856) | props: { |
| [4857](#L4857) | target: String, |
| [4858](#L4858) | viewport: Number, |
| [4859](#L4859) | // Deprecated |
| [4860](#L4860) | easing: Number, |
| [4861](#L4861) | start: String, |
| [4862](#L4862) | end: String |
| [4863](#L4863) | }, |
| [4864](#L4864) | data: { |
| [4865](#L4865) | target: false, |
| [4866](#L4866) | viewport: 1, |
| [4867](#L4867) | easing: 1, |
| [4868](#L4868) | start: 0, |
| [4869](#L4869) | end: 0 |
| [4870](#L4870) | }, |
| [4871](#L4871) | computed: { |
| [4872](#L4872) | target: ({ target }, $el) => getOffsetElement(target && query(target, $el) || $el), |
| [4873](#L4873) | start({ start }) { |
| [4874](#L4874) | return toPx(start, "height", this.target, true); |
| [4875](#L4875) | }, |
| [4876](#L4876) | end({ end, viewport: viewport2 }) { |
| [4877](#L4877) | return toPx( |
| [4878](#L4878) | end || (viewport2 = (1 - viewport2) \* 100) && `${viewport2}vh+${viewport2}%`, |
| [4879](#L4879) | "height", |
| [4880](#L4880) | this.target, |
| [4881](#L4881) | true |
| [4882](#L4882) | ); |
| [4883](#L4883) | } |
| [4884](#L4884) | }, |
| [4885](#L4885) | observe: [ |
| [4886](#L4886) | viewport(), |
| [4887](#L4887) | scroll$1({ target: ({ target }) => target }), |
| [4888](#L4888) | resize({ target: ({ $el, target }) => [$el, target, scrollParent(target, true)] }) |
| [4889](#L4889) | ], |
| [4890](#L4890) | update: { |
| [4891](#L4891) | read({ percent }, types) { |
| [4892](#L4892) | if (!types.has("scroll")) { |
| [4893](#L4893) | percent = false; |
| [4894](#L4894) | } |
| [4895](#L4895) | if (!isVisible(this.$el)) { |
| [4896](#L4896) | return false; |
| [4897](#L4897) | } |
| [4898](#L4898) | if (!this.matchMedia) { |
| [4899](#L4899) | return; |
| [4900](#L4900) | } |
| [4901](#L4901) | const prev = percent; |
| [4902](#L4902) | percent = ease(scrolledOver(this.target, this.start, this.end), this.easing); |
| [4903](#L4903) | return { |
| [4904](#L4904) | percent, |
| [4905](#L4905) | style: prev === percent ? false : this.getCss(percent) |
| [4906](#L4906) | }; |
| [4907](#L4907) | }, |
| [4908](#L4908) | write({ style }) { |
| [4909](#L4909) | if (!this.matchMedia) { |
| [4910](#L4910) | this.reset(); |
| [4911](#L4911) | return; |
| [4912](#L4912) | } |
| [4913](#L4913) | style && css(this.$el, style); |
| [4914](#L4914) | }, |
| [4915](#L4915) | events: ["scroll", "resize"] |
| [4916](#L4916) | } |
| [4917](#L4917) | }; |
| [4918](#L4918) | function getOffsetElement(el) { |
| [4919](#L4919) | return el ? "offsetTop" in el ? el : getOffsetElement(parent(el)) : document.documentElement; |
| [4920](#L4920) | } |
| [4921](#L4921) |  |
| [4922](#L4922) | var SliderParallax = { |
| [4923](#L4923) | props: { |
| [4924](#L4924) | parallax: Boolean, |
| [4925](#L4925) | parallaxTarget: Boolean, |
| [4926](#L4926) | parallaxStart: String, |
| [4927](#L4927) | parallaxEnd: String, |
| [4928](#L4928) | parallaxEasing: Number |
| [4929](#L4929) | }, |
| [4930](#L4930) | data: { |
| [4931](#L4931) | parallax: false, |
| [4932](#L4932) | parallaxTarget: false, |
| [4933](#L4933) | parallaxStart: 0, |
| [4934](#L4934) | parallaxEnd: 0, |
| [4935](#L4935) | parallaxEasing: 0 |
| [4936](#L4936) | }, |
| [4937](#L4937) | observe: [ |
| [4938](#L4938) | resize({ |
| [4939](#L4939) | target: ({ $el, parallaxTarget }) => [$el, parallaxTarget], |
| [4940](#L4940) | filter: ({ parallax }) => parallax |
| [4941](#L4941) | }), |
| [4942](#L4942) | scroll$1({ filter: ({ parallax }) => parallax }) |
| [4943](#L4943) | ], |
| [4944](#L4944) | computed: { |
| [4945](#L4945) | parallaxTarget({ parallaxTarget }, $el) { |
| [4946](#L4946) | return parallaxTarget && query(parallaxTarget, $el) || this.list; |
| [4947](#L4947) | } |
| [4948](#L4948) | }, |
| [4949](#L4949) | update: { |
| [4950](#L4950) | read() { |
| [4951](#L4951) | if (!this.parallax) { |
| [4952](#L4952) | return false; |
| [4953](#L4953) | } |
| [4954](#L4954) | const target = this.parallaxTarget; |
| [4955](#L4955) | if (!target) { |
| [4956](#L4956) | return false; |
| [4957](#L4957) | } |
| [4958](#L4958) | const start = toPx(this.parallaxStart, "height", target, true); |
| [4959](#L4959) | const end = toPx(this.parallaxEnd, "height", target, true); |
| [4960](#L4960) | const percent = ease(scrolledOver(target, start, end), this.parallaxEasing); |
| [4961](#L4961) | return { parallax: this.getIndexAt(percent) }; |
| [4962](#L4962) | }, |
| [4963](#L4963) | write({ parallax }) { |
| [4964](#L4964) | const [prevIndex, slidePercent] = parallax; |
| [4965](#L4965) | const nextIndex = this.getValidIndex(prevIndex + Math.ceil(slidePercent)); |
| [4966](#L4966) | const prev = this.slides[prevIndex]; |
| [4967](#L4967) | const next = this.slides[nextIndex]; |
| [4968](#L4968) | const { triggerShow, triggerShown, triggerHide, triggerHidden } = useTriggers(this); |
| [4969](#L4969) | if (~this.prevIndex) { |
| [4970](#L4970) | for (const i of /\* @\_\_PURE\_\_ \*/ new Set([this.index, this.prevIndex])) { |
| [4971](#L4971) | if (!includes([nextIndex, prevIndex], i)) { |
| [4972](#L4972) | triggerHide(this.slides[i]); |
| [4973](#L4973) | triggerHidden(this.slides[i]); |
| [4974](#L4974) | } |
| [4975](#L4975) | } |
| [4976](#L4976) | } |
| [4977](#L4977) | const changed = this.prevIndex !== prevIndex || this.index !== nextIndex; |
| [4978](#L4978) | this.dir = 1; |
| [4979](#L4979) | this.prevIndex = prevIndex; |
| [4980](#L4980) | this.index = nextIndex; |
| [4981](#L4981) | if (prev !== next) { |
| [4982](#L4982) | triggerHide(prev); |
| [4983](#L4983) | } |
| [4984](#L4984) | triggerShow(next); |
| [4985](#L4985) | if (changed) { |
| [4986](#L4986) | triggerShown(prev); |
| [4987](#L4987) | } |
| [4988](#L4988) | this.\_translate(prev === next ? 1 : slidePercent, prev, next); |
| [4989](#L4989) | }, |
| [4990](#L4990) | events: ["scroll", "resize"] |
| [4991](#L4991) | }, |
| [4992](#L4992) | methods: { |
| [4993](#L4993) | getIndexAt(percent) { |
| [4994](#L4994) | const index = percent \* (this.length - 1); |
| [4995](#L4995) | return [Math.floor(index), index % 1]; |
| [4996](#L4996) | } |
| [4997](#L4997) | } |
| [4998](#L4998) | }; |
| [4999](#L4999) | function useTriggers(cmp) { |
| [5000](#L5000) | const { clsSlideActive, clsEnter, clsLeave } = cmp; |
| [5001](#L5001) | return { triggerShow, triggerShown, triggerHide, triggerHidden }; |
| [5002](#L5002) | function triggerShow(el) { |
| [5003](#L5003) | if (hasClass(el, clsLeave)) { |
| [5004](#L5004) | triggerHide(el); |
| [5005](#L5005) | triggerHidden(el); |
| [5006](#L5006) | } |
| [5007](#L5007) | if (!hasClass(el, clsSlideActive)) { |
| [5008](#L5008) | trigger(el, "beforeitemshow", [cmp]); |
| [5009](#L5009) | trigger(el, "itemshow", [cmp]); |
| [5010](#L5010) | } |
| [5011](#L5011) | } |
| [5012](#L5012) | function triggerShown(el) { |
| [5013](#L5013) | if (hasClass(el, clsEnter)) { |
| [5014](#L5014) | trigger(el, "itemshown", [cmp]); |
| [5015](#L5015) | } |
| [5016](#L5016) | } |
| [5017](#L5017) | function triggerHide(el) { |
| [5018](#L5018) | if (!hasClass(el, clsSlideActive)) { |
| [5019](#L5019) | triggerShow(el); |
| [5020](#L5020) | } |
| [5021](#L5021) | if (hasClass(el, clsEnter)) { |
| [5022](#L5022) | triggerShown(el); |
| [5023](#L5023) | } |
| [5024](#L5024) | if (!hasClass(el, clsLeave)) { |
| [5025](#L5025) | trigger(el, "beforeitemhide", [cmp]); |
| [5026](#L5026) | trigger(el, "itemhide", [cmp]); |
| [5027](#L5027) | } |
| [5028](#L5028) | } |
| [5029](#L5029) | function triggerHidden(el) { |
| [5030](#L5030) | if (hasClass(el, clsLeave)) { |
| [5031](#L5031) | trigger(el, "itemhidden", [cmp]); |
| [5032](#L5032) | } |
| [5033](#L5033) | } |
| [5034](#L5034) | } |
| [5035](#L5035) |  |
| [5036](#L5036) | var SliderReactive = { |
| [5037](#L5037) | update: { |
| [5038](#L5038) | write() { |
| [5039](#L5039) | if (this.stack.length || this.dragging || this.parallax) { |
| [5040](#L5040) | return; |
| [5041](#L5041) | } |
| [5042](#L5042) | const index = this.getValidIndex(); |
| [5043](#L5043) | if (!~this.prevIndex || this.index !== index) { |
| [5044](#L5044) | this.show(index); |
| [5045](#L5045) | } else { |
| [5046](#L5046) | this.\_translate(1); |
| [5047](#L5047) | } |
| [5048](#L5048) | }, |
| [5049](#L5049) | events: ["resize"] |
| [5050](#L5050) | } |
| [5051](#L5051) | }; |
| [5052](#L5052) |  |
| [5053](#L5053) | var SliderPreload = { |
| [5054](#L5054) | observe: lazyload({ |
| [5055](#L5055) | target: ({ slides }) => slides, |
| [5056](#L5056) | targets: (instance) => instance.getAdjacentSlides() |
| [5057](#L5057) | }), |
| [5058](#L5058) | methods: { |
| [5059](#L5059) | getAdjacentSlides() { |
| [5060](#L5060) | return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]); |
| [5061](#L5061) | } |
| [5062](#L5062) | } |
| [5063](#L5063) | }; |
| [5064](#L5064) |  |
| [5065](#L5065) | function Transitioner(prev, next, dir, { center, easing, list }) { |
| [5066](#L5066) | const from = prev ? getLeft(prev, list, center) : getLeft(next, list, center) + dimensions$1(next).width \* dir; |
| [5067](#L5067) | const to = next ? getLeft(next, list, center) : from + dimensions$1(prev).width \* dir \* (isRtl ? -1 : 1); |
| [5068](#L5068) | const { promise, resolve } = withResolvers(); |
| [5069](#L5069) | return { |
| [5070](#L5070) | dir, |
| [5071](#L5071) | show(duration, percent = 0, linear) { |
| [5072](#L5072) | const timing = linear ? "linear" : easing; |
| [5073](#L5073) | duration -= Math.round(duration \* clamp(percent, -1, 1)); |
| [5074](#L5074) | css(list, "transitionProperty", "none"); |
| [5075](#L5075) | this.translate(percent); |
| [5076](#L5076) | css(list, "transitionProperty", ""); |
| [5077](#L5077) | percent = prev ? percent : clamp(percent, 0, 1); |
| [5078](#L5078) | triggerUpdate(this.getItemIn(), "itemin", { percent, duration, timing, dir }); |
| [5079](#L5079) | prev && triggerUpdate(this.getItemIn(true), "itemout", { |
| [5080](#L5080) | percent: 1 - percent, |
| [5081](#L5081) | duration, |
| [5082](#L5082) | timing, |
| [5083](#L5083) | dir |
| [5084](#L5084) | }); |
| [5085](#L5085) | Transition.start( |
| [5086](#L5086) | list, |
| [5087](#L5087) | { transform: translate(-to \* (isRtl ? -1 : 1), "px") }, |
| [5088](#L5088) | duration, |
| [5089](#L5089) | timing |
| [5090](#L5090) | ).then(resolve, noop); |
| [5091](#L5091) | return promise; |
| [5092](#L5092) | }, |
| [5093](#L5093) | cancel() { |
| [5094](#L5094) | return Transition.cancel(list); |
| [5095](#L5095) | }, |
| [5096](#L5096) | reset() { |
| [5097](#L5097) | css(list, "transform", ""); |
| [5098](#L5098) | }, |
| [5099](#L5099) | async forward(duration, percent = this.percent()) { |
| [5100](#L5100) | await this.cancel(); |
| [5101](#L5101) | return this.show(duration, percent, true); |
| [5102](#L5102) | }, |
| [5103](#L5103) | translate(percent) { |
| [5104](#L5104) | if (percent === this.percent()) { |
| [5105](#L5105) | return; |
| [5106](#L5106) | } |
| [5107](#L5107) | const distance = this.getDistance() \* dir \* (isRtl ? -1 : 1); |
| [5108](#L5108) | css( |
| [5109](#L5109) | list, |
| [5110](#L5110) | "transform", |
| [5111](#L5111) | translate( |
| [5112](#L5112) | clamp( |
| [5113](#L5113) | -to + (distance - distance \* percent), |
| [5114](#L5114) | -getWidth(list), |
| [5115](#L5115) | dimensions$1(list).width |
| [5116](#L5116) | ) \* (isRtl ? -1 : 1), |
| [5117](#L5117) | "px" |
| [5118](#L5118) | ) |
| [5119](#L5119) | ); |
| [5120](#L5120) | const actives = this.getActives(); |
| [5121](#L5121) | const itemIn = this.getItemIn(); |
| [5122](#L5122) | const itemOut = this.getItemIn(true); |
| [5123](#L5123) | percent = prev ? clamp(percent, -1, 1) : 0; |
| [5124](#L5124) | for (const slide of children(list)) { |
| [5125](#L5125) | const isActive = includes(actives, slide); |
| [5126](#L5126) | const isIn = slide === itemIn; |
| [5127](#L5127) | const isOut = slide === itemOut; |
| [5128](#L5128) | const translateIn = isIn || !isOut && (isActive || dir \* (isRtl ? -1 : 1) === -1 ^ getElLeft(slide, list) > getElLeft(prev || next)); |
| [5129](#L5129) | triggerUpdate(slide, `itemtranslate${translateIn ? "in" : "out"}`, { |
| [5130](#L5130) | dir, |
| [5131](#L5131) | percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0 |
| [5132](#L5132) | }); |
| [5133](#L5133) | } |
| [5134](#L5134) | }, |
| [5135](#L5135) | percent() { |
| [5136](#L5136) | return Math.abs( |
| [5137](#L5137) | (new DOMMatrix(css(list, "transform")).m41 \* (isRtl ? -1 : 1) + from) / (to - from) |
| [5138](#L5138) | ); |
| [5139](#L5139) | }, |
| [5140](#L5140) | getDistance() { |
| [5141](#L5141) | return Math.abs(to - from); |
| [5142](#L5142) | }, |
| [5143](#L5143) | getItemIn(out = false) { |
| [5144](#L5144) | let actives = this.getActives(); |
| [5145](#L5145) | let nextActives = inView(list, getLeft(next || prev, list, center)); |
| [5146](#L5146) | if (out) { |
| [5147](#L5147) | const temp = actives; |
| [5148](#L5148) | actives = nextActives; |
| [5149](#L5149) | nextActives = temp; |
| [5150](#L5150) | } |
| [5151](#L5151) | return nextActives[findIndex(nextActives, (el) => !includes(actives, el))]; |
| [5152](#L5152) | }, |
| [5153](#L5153) | getActives() { |
| [5154](#L5154) | return inView(list, getLeft(prev || next, list, center)); |
| [5155](#L5155) | } |
| [5156](#L5156) | }; |
| [5157](#L5157) | } |
| [5158](#L5158) | function getLeft(el, list, center) { |
| [5159](#L5159) | const left = getElLeft(el, list); |
| [5160](#L5160) | return center ? left - centerEl(el, list) : Math.min(left, getMax(list)); |
| [5161](#L5161) | } |
| [5162](#L5162) | function getMax(list) { |
| [5163](#L5163) | return Math.max(0, getWidth(list) - dimensions$1(list).width); |
| [5164](#L5164) | } |
| [5165](#L5165) | function getWidth(list, index) { |
| [5166](#L5166) | return sumBy(children(list).slice(0, index), (el) => dimensions$1(el).width); |
| [5167](#L5167) | } |
| [5168](#L5168) | function centerEl(el, list) { |
| [5169](#L5169) | return dimensions$1(list).width / 2 - dimensions$1(el).width / 2; |
| [5170](#L5170) | } |
| [5171](#L5171) | function getElLeft(el, list) { |
| [5172](#L5172) | return el && (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) \* (isRtl ? -1 : 1) || 0; |
| [5173](#L5173) | } |
| [5174](#L5174) | function inView(list, listLeft) { |
| [5175](#L5175) | listLeft -= 1; |
| [5176](#L5176) | const listWidth = dimensions$1(list).width; |
| [5177](#L5177) | const listRight = listLeft + listWidth + 2; |
| [5178](#L5178) | return children(list).filter((slide) => { |
| [5179](#L5179) | const slideLeft = getElLeft(slide, list); |
| [5180](#L5180) | const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth); |
| [5181](#L5181) | return slideLeft >= listLeft && slideRight <= listRight; |
| [5182](#L5182) | }); |
| [5183](#L5183) | } |
| [5184](#L5184) |  |
| [5185](#L5185) | var slider = { |
| [5186](#L5186) | mixins: [Class, Slider, SliderReactive, SliderParallax, SliderPreload], |
| [5187](#L5187) | props: { |
| [5188](#L5188) | center: Boolean, |
| [5189](#L5189) | sets: Boolean, |
| [5190](#L5190) | active: String |
| [5191](#L5191) | }, |
| [5192](#L5192) | data: { |
| [5193](#L5193) | center: false, |
| [5194](#L5194) | sets: false, |
| [5195](#L5195) | attrItem: "bdt-slider-item", |
| [5196](#L5196) | selList: ".bdt-slider-items", |
| [5197](#L5197) | selNav: ".bdt-slider-nav", |
| [5198](#L5198) | clsContainer: "bdt-slider-container", |
| [5199](#L5199) | active: "all", |
| [5200](#L5200) | Transitioner |
| [5201](#L5201) | }, |
| [5202](#L5202) | computed: { |
| [5203](#L5203) | finite({ finite }) { |
| [5204](#L5204) | return finite || isFinite(this.list, this.center); |
| [5205](#L5205) | }, |
| [5206](#L5206) | maxIndex() { |
| [5207](#L5207) | if (!this.finite || this.center && !this.sets) { |
| [5208](#L5208) | return this.length - 1; |
| [5209](#L5209) | } |
| [5210](#L5210) | if (this.center) { |
| [5211](#L5211) | return last(this.sets); |
| [5212](#L5212) | } |
| [5213](#L5213) | let lft = 0; |
| [5214](#L5214) | const max = getMax(this.list); |
| [5215](#L5215) | const index = findIndex(this.slides, (el) => { |
| [5216](#L5216) | if (lft >= max) { |
| [5217](#L5217) | return true; |
| [5218](#L5218) | } |
| [5219](#L5219) | lft += dimensions$1(el).width; |
| [5220](#L5220) | }); |
| [5221](#L5221) | return ~index ? index : this.length - 1; |
| [5222](#L5222) | }, |
| [5223](#L5223) | sets({ sets: enabled }) { |
| [5224](#L5224) | if (!enabled || this.parallax) { |
| [5225](#L5225) | return; |
| [5226](#L5226) | } |
| [5227](#L5227) | let left = 0; |
| [5228](#L5228) | const sets = []; |
| [5229](#L5229) | const width = dimensions$1(this.list).width; |
| [5230](#L5230) | for (let i = 0; i < this.length; i++) { |
| [5231](#L5231) | const slideWidth = dimensions$1(this.slides[i]).width; |
| [5232](#L5232) | if (left + slideWidth > width) { |
| [5233](#L5233) | left = 0; |
| [5234](#L5234) | } |
| [5235](#L5235) | if (this.center) { |
| [5236](#L5236) | if (left < width / 2 && left + slideWidth + dimensions$1(this.slides[getIndex(i + 1, this.slides)]).width / 2 > width / 2) { |
| [5237](#L5237) | sets.push(i); |
| [5238](#L5238) | left = width / 2 - slideWidth / 2; |
| [5239](#L5239) | } |
| [5240](#L5240) | } else if (left === 0) { |
| [5241](#L5241) | sets.push(Math.min(i, this.maxIndex)); |
| [5242](#L5242) | } |
| [5243](#L5243) | left += slideWidth; |
| [5244](#L5244) | } |
| [5245](#L5245) | if (sets.length) { |
| [5246](#L5246) | return sets; |
| [5247](#L5247) | } |
| [5248](#L5248) | }, |
| [5249](#L5249) | transitionOptions() { |
| [5250](#L5250) | return { |
| [5251](#L5251) | center: this.center, |
| [5252](#L5252) | list: this.list |
| [5253](#L5253) | }; |
| [5254](#L5254) | }, |
| [5255](#L5255) | slides() { |
| [5256](#L5256) | return children(this.list).filter(isVisible); |
| [5257](#L5257) | } |
| [5258](#L5258) | }, |
| [5259](#L5259) | connected() { |
| [5260](#L5260) | toggleClass(this.$el, this.clsContainer, !$(`.${this.clsContainer}`, this.$el)); |
| [5261](#L5261) | }, |
| [5262](#L5262) | observe: resize({ |
| [5263](#L5263) | target: ({ slides, $el }) => [$el, ...slides] |
| [5264](#L5264) | }), |
| [5265](#L5265) | update: { |
| [5266](#L5266) | write() { |
| [5267](#L5267) | for (const el of this.navItems) { |
| [5268](#L5268) | const index = toNumber(data(el, this.attrItem)); |
| [5269](#L5269) | if (index !== false) { |
| [5270](#L5270) | el.hidden = !this.maxIndex || index > this.maxIndex || this.sets && !includes(this.sets, index); |
| [5271](#L5271) | } |
| [5272](#L5272) | } |
| [5273](#L5273) | this.reorder(); |
| [5274](#L5274) | if (!this.parallax) { |
| [5275](#L5275) | this.\_translate(1); |
| [5276](#L5276) | } |
| [5277](#L5277) | this.updateActiveClasses(); |
| [5278](#L5278) | }, |
| [5279](#L5279) | events: ["resize"] |
| [5280](#L5280) | }, |
| [5281](#L5281) | events: { |
| [5282](#L5282) | beforeitemshow(e) { |
| [5283](#L5283) | if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) { |
| [5284](#L5284) | this.index = this.getValidIndex(); |
| [5285](#L5285) | } |
| [5286](#L5286) | const diff = Math.abs( |
| [5287](#L5287) | this.index - this.prevIndex + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) \* this.dir : 0) |
| [5288](#L5288) | ); |
| [5289](#L5289) | if (!this.dragging && diff > 1) { |
| [5290](#L5290) | for (let i = 0; i < diff; i++) { |
| [5291](#L5291) | this.stack.splice(1, 0, this.dir > 0 ? "next" : "previous"); |
| [5292](#L5292) | } |
| [5293](#L5293) | e.preventDefault(); |
| [5294](#L5294) | return; |
| [5295](#L5295) | } |
| [5296](#L5296) | const index = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex; |
| [5297](#L5297) | const avgWidth = getWidth(this.list) / this.length; |
| [5298](#L5298) | this.duration = speedUp(avgWidth / this.velocity) \* (dimensions$1(this.slides[index]).width / avgWidth); |
| [5299](#L5299) | this.reorder(); |
| [5300](#L5300) | }, |
| [5301](#L5301) | itemshow() { |
| [5302](#L5302) | if (~this.prevIndex) { |
| [5303](#L5303) | addClass(this.\_getTransitioner().getItemIn(), this.clsActive); |
| [5304](#L5304) | } |
| [5305](#L5305) | this.updateActiveClasses(this.prevIndex); |
| [5306](#L5306) | }, |
| [5307](#L5307) | itemshown() { |
| [5308](#L5308) | this.updateActiveClasses(); |
| [5309](#L5309) | } |
| [5310](#L5310) | }, |
| [5311](#L5311) | methods: { |
| [5312](#L5312) | reorder() { |
| [5313](#L5313) | if (this.finite) { |
| [5314](#L5314) | css(this.slides, "order", ""); |
| [5315](#L5315) | return; |
| [5316](#L5316) | } |
| [5317](#L5317) | const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index; |
| [5318](#L5318) | this.slides.forEach( |
| [5319](#L5319) | (slide, i) => css( |
| [5320](#L5320) | slide, |
| [5321](#L5321) | "order", |
| [5322](#L5322) | this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : "" |
| [5323](#L5323) | ) |
| [5324](#L5324) | ); |
| [5325](#L5325) | if (!this.center || !this.length) { |
| [5326](#L5326) | return; |
| [5327](#L5327) | } |
| [5328](#L5328) | const next = this.slides[index]; |
| [5329](#L5329) | let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2; |
| [5330](#L5330) | let j = 0; |
| [5331](#L5331) | while (width > 0) { |
| [5332](#L5332) | const slideIndex = this.getIndex(--j + index, index); |
| [5333](#L5333) | const slide = this.slides[slideIndex]; |
| [5334](#L5334) | css(slide, "order", slideIndex > index ? -2 : -1); |
| [5335](#L5335) | width -= dimensions$1(slide).width; |
| [5336](#L5336) | } |
| [5337](#L5337) | }, |
| [5338](#L5338) | updateActiveClasses(currentIndex = this.index) { |
| [5339](#L5339) | let actives = this.\_getTransitioner(currentIndex).getActives(); |
| [5340](#L5340) | if (this.active !== "all") { |
| [5341](#L5341) | actives = [this.slides[this.getValidIndex(currentIndex)]]; |
| [5342](#L5342) | } |
| [5343](#L5343) | const activeClasses = [ |
| [5344](#L5344) | this.clsActive, |
| [5345](#L5345) | !this.sets || includes(this.sets, toFloat(this.index)) ? this.clsActivated : "" |
| [5346](#L5346) | ]; |
| [5347](#L5347) | for (const slide of this.slides) { |
| [5348](#L5348) | const active = includes(actives, slide); |
| [5349](#L5349) | toggleClass(slide, activeClasses, active); |
| [5350](#L5350) | attr(slide, "aria-hidden", !active); |
| [5351](#L5351) | for (const focusable of $$(selFocusable, slide)) { |
| [5352](#L5352) | if (!hasOwn(focusable, "\_tabindex")) { |
| [5353](#L5353) | focusable.\_tabindex = attr(focusable, "tabindex"); |
| [5354](#L5354) | } |
| [5355](#L5355) | attr(focusable, "tabindex", active ? focusable.\_tabindex : -1); |
| [5356](#L5356) | } |
| [5357](#L5357) | } |
| [5358](#L5358) | }, |
| [5359](#L5359) | getValidIndex(index = this.index, prevIndex = this.prevIndex) { |
| [5360](#L5360) | index = this.getIndex(index, prevIndex); |
| [5361](#L5361) | if (!this.sets) { |
| [5362](#L5362) | return index; |
| [5363](#L5363) | } |
| [5364](#L5364) | let prev; |
| [5365](#L5365) | do { |
| [5366](#L5366) | if (includes(this.sets, index)) { |
| [5367](#L5367) | return index; |
| [5368](#L5368) | } |
| [5369](#L5369) | prev = index; |
| [5370](#L5370) | index = this.getIndex(index + this.dir, prevIndex); |
| [5371](#L5371) | } while (index !== prev); |
| [5372](#L5372) | return index; |
| [5373](#L5373) | }, |
| [5374](#L5374) | getAdjacentSlides() { |
| [5375](#L5375) | const { width } = dimensions$1(this.list); |
| [5376](#L5376) | const left = -width; |
| [5377](#L5377) | const right = width \* 2; |
| [5378](#L5378) | const slideWidth = dimensions$1(this.slides[this.index]).width; |
| [5379](#L5379) | const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0; |
| [5380](#L5380) | const slides = /\* @\_\_PURE\_\_ \*/ new Set(); |
| [5381](#L5381) | for (const i of [-1, 1]) { |
| [5382](#L5382) | let currentLeft = slideLeft + (i > 0 ? slideWidth : 0); |
| [5383](#L5383) | let j = 0; |
| [5384](#L5384) | do { |
| [5385](#L5385) | const slide = this.slides[this.getIndex(this.index + i + j++ \* i)]; |
| [5386](#L5386) | currentLeft += dimensions$1(slide).width \* i; |
| [5387](#L5387) | slides.add(slide); |
| [5388](#L5388) | } while (this.length > j && currentLeft > left && currentLeft < right); |
| [5389](#L5389) | } |
| [5390](#L5390) | return Array.from(slides); |
| [5391](#L5391) | }, |
| [5392](#L5392) | getIndexAt(percent) { |
| [5393](#L5393) | let index = -1; |
| [5394](#L5394) | const scrollDist = this.center ? getWidth(this.list) - (dimensions$1(this.slides[0]).width / 2 + dimensions$1(last(this.slides)).width / 2) : getWidth(this.list, this.maxIndex); |
| [5395](#L5395) | let dist = percent \* scrollDist; |
| [5396](#L5396) | let slidePercent = 0; |
| [5397](#L5397) | do { |
| [5398](#L5398) | const slideWidth = dimensions$1(this.slides[++index]).width; |
| [5399](#L5399) | const slideDist = this.center ? slideWidth / 2 + dimensions$1(this.slides[index + 1]).width / 2 : slideWidth; |
| [5400](#L5400) | slidePercent = dist / slideDist % 1; |
| [5401](#L5401) | dist -= slideDist; |
| [5402](#L5402) | } while (dist >= 0 && index < this.maxIndex); |
| [5403](#L5403) | return [index, slidePercent]; |
| [5404](#L5404) | } |
| [5405](#L5405) | } |
| [5406](#L5406) | }; |
| [5407](#L5407) | function isFinite(list, center) { |
| [5408](#L5408) | if (!list || list.length < 2) { |
| [5409](#L5409) | return true; |
| [5410](#L5410) | } |
| [5411](#L5411) | const { width: listWidth } = dimensions$1(list); |
| [5412](#L5412) | if (!center) { |
| [5413](#L5413) | return Math.ceil(getWidth(list)) < Math.trunc(listWidth + getMaxElWidth(list)); |
| [5414](#L5414) | } |
| [5415](#L5415) | const slides = children(list); |
| [5416](#L5416) | const listHalf = Math.trunc(listWidth / 2); |
| [5417](#L5417) | for (const index in slides) { |
| [5418](#L5418) | const slide = slides[index]; |
| [5419](#L5419) | const slideWidth = dimensions$1(slide).width; |
| [5420](#L5420) | const slidesInView = /\* @\_\_PURE\_\_ \*/ new Set([slide]); |
| [5421](#L5421) | let diff = 0; |
| [5422](#L5422) | for (const i of [-1, 1]) { |
| [5423](#L5423) | let left = slideWidth / 2; |
| [5424](#L5424) | let j = 0; |
| [5425](#L5425) | while (left < listHalf) { |
| [5426](#L5426) | const nextSlide = slides[getIndex(+index + i + j++ \* i, slides)]; |
| [5427](#L5427) | if (slidesInView.has(nextSlide)) { |
| [5428](#L5428) | return true; |
| [5429](#L5429) | } |
| [5430](#L5430) | left += dimensions$1(nextSlide).width; |
| [5431](#L5431) | slidesInView.add(nextSlide); |
| [5432](#L5432) | } |
| [5433](#L5433) | diff = Math.max( |
| [5434](#L5434) | diff, |
| [5435](#L5435) | slideWidth / 2 + dimensions$1(slides[getIndex(+index + i, slides)]).width / 2 - (left - listHalf) |
| [5436](#L5436) | ); |
| [5437](#L5437) | } |
| [5438](#L5438) | if (Math.trunc(diff) > sumBy( |
| [5439](#L5439) | slides.filter((slide2) => !slidesInView.has(slide2)), |
| [5440](#L5440) | (slide2) => dimensions$1(slide2).width |
| [5441](#L5441) | )) { |
| [5442](#L5442) | return true; |
| [5443](#L5443) | } |
| [5444](#L5444) | } |
| [5445](#L5445) | return false; |
| [5446](#L5446) | } |
| [5447](#L5447) | function getMaxElWidth(list) { |
| [5448](#L5448) | return Math.max(0, ...children(list).map((el) => dimensions$1(el).width)); |
| [5449](#L5449) | } |
| [5450](#L5450) |  |
| [5451](#L5451) | var sliderParallax = { |
| [5452](#L5452) | mixins: [Parallax], |
| [5453](#L5453) | beforeConnect() { |
| [5454](#L5454) | this.item = this.$el.closest(`.${this.$options.id.replace("parallax", "items")} > \*`); |
| [5455](#L5455) | }, |
| [5456](#L5456) | disconnected() { |
| [5457](#L5457) | this.item = null; |
| [5458](#L5458) | }, |
| [5459](#L5459) | events: [ |
| [5460](#L5460) | { |
| [5461](#L5461) | name: "itemin itemout", |
| [5462](#L5462) | self: true, |
| [5463](#L5463) | el: ({ item }) => item, |
| [5464](#L5464) | handler({ type, detail: { percent, duration, timing, dir } }) { |
| [5465](#L5465) | fastdom.read(() => { |
| [5466](#L5466) | if (!this.matchMedia) { |
| [5467](#L5467) | return; |
| [5468](#L5468) | } |
| [5469](#L5469) | const propsFrom = this.getCss(getCurrentPercent(type, dir, percent)); |
| [5470](#L5470) | const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0); |
| [5471](#L5471) | fastdom.write(() => { |
| [5472](#L5472) | css(this.$el, propsFrom); |
| [5473](#L5473) | Transition.start(this.$el, propsTo, duration, timing).catch(noop); |
| [5474](#L5474) | }); |
| [5475](#L5475) | }); |
| [5476](#L5476) | } |
| [5477](#L5477) | }, |
| [5478](#L5478) | { |
| [5479](#L5479) | name: "transitioncanceled transitionend", |
| [5480](#L5480) | self: true, |
| [5481](#L5481) | el: ({ item }) => item, |
| [5482](#L5482) | handler() { |
| [5483](#L5483) | Transition.cancel(this.$el); |
| [5484](#L5484) | } |
| [5485](#L5485) | }, |
| [5486](#L5486) | { |
| [5487](#L5487) | name: "itemtranslatein itemtranslateout", |
| [5488](#L5488) | self: true, |
| [5489](#L5489) | el: ({ item }) => item, |
| [5490](#L5490) | handler({ type, detail: { percent, dir } }) { |
| [5491](#L5491) | fastdom.read(() => { |
| [5492](#L5492) | if (!this.matchMedia) { |
| [5493](#L5493) | this.reset(); |
| [5494](#L5494) | return; |
| [5495](#L5495) | } |
| [5496](#L5496) | const props = this.getCss(getCurrentPercent(type, dir, percent)); |
| [5497](#L5497) | fastdom.write(() => css(this.$el, props)); |
| [5498](#L5498) | }); |
| [5499](#L5499) | } |
| [5500](#L5500) | } |
| [5501](#L5501) | ] |
| [5502](#L5502) | }; |
| [5503](#L5503) | function isIn(type) { |
| [5504](#L5504) | return endsWith(type, "in"); |
| [5505](#L5505) | } |
| [5506](#L5506) | function getCurrentPercent(type, dir, percent) { |
| [5507](#L5507) | percent /= 2; |
| [5508](#L5508) | return isIn(type) ^ dir < 0 ? percent : 1 - percent; |
| [5509](#L5509) | } |
| [5510](#L5510) |  |
| [5511](#L5511) | var Animations = { |
| [5512](#L5512) | ...Animations$2, |
| [5513](#L5513) | fade: { |
| [5514](#L5514) | show() { |
| [5515](#L5515) | return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }]; |
| [5516](#L5516) | }, |
| [5517](#L5517) | percent(current) { |
| [5518](#L5518) | return 1 - css(current, "opacity"); |
| [5519](#L5519) | }, |
| [5520](#L5520) | translate(percent) { |
| [5521](#L5521) | return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }]; |
| [5522](#L5522) | } |
| [5523](#L5523) | }, |
| [5524](#L5524) | scale: { |
| [5525](#L5525) | show() { |
| [5526](#L5526) | return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }]; |
| [5527](#L5527) | }, |
| [5528](#L5528) | percent(current) { |
| [5529](#L5529) | return 1 - css(current, "opacity"); |
| [5530](#L5530) | }, |
| [5531](#L5531) | translate(percent) { |
| [5532](#L5532) | return [ |
| [5533](#L5533) | { opacity: 1 - percent, transform: scale3d(1 + 0.5 \* percent), zIndex: 0 }, |
| [5534](#L5534) | { zIndex: -1 } |
| [5535](#L5535) | ]; |
| [5536](#L5536) | } |
| [5537](#L5537) | }, |
| [5538](#L5538) | pull: { |
| [5539](#L5539) | show(dir) { |
| [5540](#L5540) | return dir < 0 ? [ |
| [5541](#L5541) | { transform: translate(30), zIndex: -1 }, |
| [5542](#L5542) | { transform: translate(), zIndex: 0 } |
| [5543](#L5543) | ] : [ |
| [5544](#L5544) | { transform: translate(-100), zIndex: 0 }, |
| [5545](#L5545) | { transform: translate(), zIndex: -1 } |
| [5546](#L5546) | ]; |
| [5547](#L5547) | }, |
| [5548](#L5548) | percent(current, next, dir) { |
| [5549](#L5549) | return dir < 0 ? 1 - translated(next) : translated(current); |
| [5550](#L5550) | }, |
| [5551](#L5551) | translate(percent, dir) { |
| [5552](#L5552) | return dir < 0 ? [ |
| [5553](#L5553) | { transform: translate(30 \* percent), zIndex: -1 }, |
| [5554](#L5554) | { transform: translate(-100 \* (1 - percent)), zIndex: 0 } |
| [5555](#L5555) | ] : [ |
| [5556](#L5556) | { transform: translate(-percent \* 100), zIndex: 0 }, |
| [5557](#L5557) | { transform: translate(30 \* (1 - percent)), zIndex: -1 } |
| [5558](#L5558) | ]; |
| [5559](#L5559) | } |
| [5560](#L5560) | }, |
| [5561](#L5561) | push: { |
| [5562](#L5562) | show(dir) { |
| [5563](#L5563) | return dir < 0 ? [ |
| [5564](#L5564) | { transform: translate(100), zIndex: 0 }, |
| [5565](#L5565) | { transform: translate(), zIndex: -1 } |
| [5566](#L5566) | ] : [ |
| [5567](#L5567) | { transform: translate(-30), zIndex: -1 }, |
| [5568](#L5568) | { transform: translate(), zIndex: 0 } |
| [5569](#L5569) | ]; |
| [5570](#L5570) | }, |
| [5571](#L5571) | percent(current, next, dir) { |
| [5572](#L5572) | return dir > 0 ? 1 - translated(next) : translated(current); |
| [5573](#L5573) | }, |
| [5574](#L5574) | translate(percent, dir) { |
| [5575](#L5575) | return dir < 0 ? [ |
| [5576](#L5576) | { transform: translate(percent \* 100), zIndex: 0 }, |
| [5577](#L5577) | { transform: translate(-30 \* (1 - percent)), zIndex: -1 } |
| [5578](#L5578) | ] : [ |
| [5579](#L5579) | { transform: translate(-30 \* percent), zIndex: -1 }, |
| [5580](#L5580) | { transform: translate(100 \* (1 - percent)), zIndex: 0 } |
| [5581](#L5581) | ]; |
| [5582](#L5582) | } |
| [5583](#L5583) | } |
| [5584](#L5584) | }; |
| [5585](#L5585) |  |
| [5586](#L5586) | var slideshow = { |
| [5587](#L5587) | mixins: [Class, Slideshow, SliderReactive, SliderParallax, SliderPreload], |
| [5588](#L5588) | props: { |
| [5589](#L5589) | ratio: String, |
| [5590](#L5590) | minHeight: String, |
| [5591](#L5591) | maxHeight: String |
| [5592](#L5592) | }, |
| [5593](#L5593) | data: { |
| [5594](#L5594) | ratio: "16:9", |
| [5595](#L5595) | minHeight: void 0, |
| [5596](#L5596) | maxHeight: void 0, |
| [5597](#L5597) | selList: ".bdt-slideshow-items", |
| [5598](#L5598) | attrItem: "bdt-slideshow-item", |
| [5599](#L5599) | selNav: ".bdt-slideshow-nav", |
| [5600](#L5600) | Animations |
| [5601](#L5601) | }, |
| [5602](#L5602) | watch: { |
| [5603](#L5603) | list(list) { |
| [5604](#L5604) | css(list, { |
| [5605](#L5605) | aspectRatio: this.ratio ? this.ratio.replace(":", "/") : void 0, |
| [5606](#L5606) | minHeight: this.minHeight, |
| [5607](#L5607) | maxHeight: this.maxHeight, |
| [5608](#L5608) | minWidth: "100%", |
| [5609](#L5609) | maxWidth: "100%" |
| [5610](#L5610) | }); |
| [5611](#L5611) | } |
| [5612](#L5612) | }, |
| [5613](#L5613) | methods: { |
| [5614](#L5614) | getAdjacentSlides() { |
| [5615](#L5615) | return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]); |
| [5616](#L5616) | } |
| [5617](#L5617) | } |
| [5618](#L5618) | }; |
| [5619](#L5619) |  |
| [5620](#L5620) | var sortable = { |
| [5621](#L5621) | mixins: [Class, Animate], |
| [5622](#L5622) | props: { |
| [5623](#L5623) | group: String, |
| [5624](#L5624) | threshold: Number, |
| [5625](#L5625) | clsItem: String, |
| [5626](#L5626) | clsPlaceholder: String, |
| [5627](#L5627) | clsDrag: String, |
| [5628](#L5628) | clsDragState: String, |
| [5629](#L5629) | clsBase: String, |
| [5630](#L5630) | clsNoDrag: String, |
| [5631](#L5631) | clsEmpty: String, |
| [5632](#L5632) | clsCustom: String, |
| [5633](#L5633) | handle: String |
| [5634](#L5634) | }, |
| [5635](#L5635) | data: { |
| [5636](#L5636) | group: false, |
| [5637](#L5637) | threshold: 5, |
| [5638](#L5638) | clsItem: "bdt-sortable-item", |
| [5639](#L5639) | clsPlaceholder: "bdt-sortable-placeholder", |
| [5640](#L5640) | clsDrag: "bdt-sortable-drag", |
| [5641](#L5641) | clsDragState: "bdt-drag", |
| [5642](#L5642) | clsBase: "bdt-sortable", |
| [5643](#L5643) | clsNoDrag: "bdt-sortable-nodrag", |
| [5644](#L5644) | clsEmpty: "bdt-sortable-empty", |
| [5645](#L5645) | clsCustom: "", |
| [5646](#L5646) | handle: false, |
| [5647](#L5647) | pos: {} |
| [5648](#L5648) | }, |
| [5649](#L5649) | events: { |
| [5650](#L5650) | name: pointerDown$1, |
| [5651](#L5651) | passive: false, |
| [5652](#L5652) | handler: "init" |
| [5653](#L5653) | }, |
| [5654](#L5654) | computed: { |
| [5655](#L5655) | target: (\_, $el) => ($el.tBodies || [$el])[0], |
| [5656](#L5656) | items() { |
| [5657](#L5657) | return children(this.target); |
| [5658](#L5658) | }, |
| [5659](#L5659) | isEmpty() { |
| [5660](#L5660) | return !this.items.length; |
| [5661](#L5661) | }, |
| [5662](#L5662) | handles({ handle }, $el) { |
| [5663](#L5663) | return handle ? $$(handle, $el) : this.items; |
| [5664](#L5664) | } |
| [5665](#L5665) | }, |
| [5666](#L5666) | watch: { |
| [5667](#L5667) | isEmpty(empty) { |
| [5668](#L5668) | toggleClass(this.target, this.clsEmpty, empty); |
| [5669](#L5669) | }, |
| [5670](#L5670) | handles(handles, prev) { |
| [5671](#L5671) | css(prev, { touchAction: "", userSelect: "" }); |
| [5672](#L5672) | css(handles, { touchAction: "none", userSelect: "none" }); |
| [5673](#L5673) | } |
| [5674](#L5674) | }, |
| [5675](#L5675) | update: { |
| [5676](#L5676) | write(data) { |
| [5677](#L5677) | if (!this.drag || !parent(this.placeholder)) { |
| [5678](#L5678) | return; |
| [5679](#L5679) | } |
| [5680](#L5680) | const { |
| [5681](#L5681) | pos: { x, y }, |
| [5682](#L5682) | origin: { offsetTop, offsetLeft }, |
| [5683](#L5683) | placeholder |
| [5684](#L5684) | } = this; |
| [5685](#L5685) | css(this.drag, { |
| [5686](#L5686) | top: y - offsetTop, |
| [5687](#L5687) | left: x - offsetLeft |
| [5688](#L5688) | }); |
| [5689](#L5689) | const sortable = this.getSortable(document.elementFromPoint(x, y)); |
| [5690](#L5690) | if (!sortable) { |
| [5691](#L5691) | return; |
| [5692](#L5692) | } |
| [5693](#L5693) | const { items } = sortable; |
| [5694](#L5694) | if (items.some(Transition.inProgress)) { |
| [5695](#L5695) | return; |
| [5696](#L5696) | } |
| [5697](#L5697) | const target = findTarget(items, { x, y }); |
| [5698](#L5698) | if (items.length && (!target || target === placeholder)) { |
| [5699](#L5699) | return; |
| [5700](#L5700) | } |
| [5701](#L5701) | const previous = this.getSortable(placeholder); |
| [5702](#L5702) | const insertTarget = findInsertTarget( |
| [5703](#L5703) | sortable.target, |
| [5704](#L5704) | target, |
| [5705](#L5705) | placeholder, |
| [5706](#L5706) | x, |
| [5707](#L5707) | y, |
| [5708](#L5708) | sortable === previous && data.moved !== target |
| [5709](#L5709) | ); |
| [5710](#L5710) | if (insertTarget === false) { |
| [5711](#L5711) | return; |
| [5712](#L5712) | } |
| [5713](#L5713) | if (insertTarget && placeholder === insertTarget) { |
| [5714](#L5714) | return; |
| [5715](#L5715) | } |
| [5716](#L5716) | if (sortable !== previous) { |
| [5717](#L5717) | previous.remove(placeholder); |
| [5718](#L5718) | data.moved = target; |
| [5719](#L5719) | } else { |
| [5720](#L5720) | delete data.moved; |
| [5721](#L5721) | } |
| [5722](#L5722) | sortable.insert(placeholder, insertTarget); |
| [5723](#L5723) | this.touched.add(sortable); |
| [5724](#L5724) | }, |
| [5725](#L5725) | events: ["move"] |
| [5726](#L5726) | }, |
| [5727](#L5727) | methods: { |
| [5728](#L5728) | init(e) { |
| [5729](#L5729) | const { target, button, defaultPrevented } = e; |
| [5730](#L5730) | const [placeholder] = this.items.filter((el) => el.contains(target)); |
| [5731](#L5731) | if (!placeholder || defaultPrevented || button > 0 || isInput(target) || target.closest(`.${this.clsNoDrag}`) || this.handle && !target.closest(this.handle)) { |
| [5732](#L5732) | return; |
| [5733](#L5733) | } |
| [5734](#L5734) | e.preventDefault(); |
| [5735](#L5735) | this.pos = getEventPos(e); |
| [5736](#L5736) | this.touched = /\* @\_\_PURE\_\_ \*/ new Set([this]); |
| [5737](#L5737) | this.placeholder = placeholder; |
| [5738](#L5738) | this.origin = { target, index: index(placeholder), ...this.pos }; |
| [5739](#L5739) | on(document, pointerMove$1, this.move); |
| [5740](#L5740) | on(document, pointerUp$1, this.end); |
| [5741](#L5741) | if (!this.threshold) { |
| [5742](#L5742) | this.start(e); |
| [5743](#L5743) | } |
| [5744](#L5744) | }, |
| [5745](#L5745) | start(e) { |
| [5746](#L5746) | this.drag = appendDrag(this.$container, this.placeholder); |
| [5747](#L5747) | const { left, top } = dimensions$1(this.placeholder); |
| [5748](#L5748) | assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top }); |
| [5749](#L5749) | addClass(this.drag, this.clsDrag, this.clsCustom); |
| [5750](#L5750) | addClass(this.placeholder, this.clsPlaceholder); |
| [5751](#L5751) | addClass(this.items, this.clsItem); |
| [5752](#L5752) | addClass(document.documentElement, this.clsDragState); |
| [5753](#L5753) | trigger(this.$el, "start", [this, this.placeholder]); |
| [5754](#L5754) | trackScroll(this.pos); |
| [5755](#L5755) | this.move(e); |
| [5756](#L5756) | }, |
| [5757](#L5757) | move: throttle(function(e) { |
| [5758](#L5758) | assign(this.pos, getEventPos(e)); |
| [5759](#L5759) | if (!this.drag && (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold)) { |
| [5760](#L5760) | this.start(e); |
| [5761](#L5761) | } |
| [5762](#L5762) | this.$emit("move"); |
| [5763](#L5763) | }), |
| [5764](#L5764) | end() { |
| [5765](#L5765) | off(document, pointerMove$1, this.move); |
| [5766](#L5766) | off(document, pointerUp$1, this.end); |
| [5767](#L5767) | if (!this.drag) { |
| [5768](#L5768) | return; |
| [5769](#L5769) | } |
| [5770](#L5770) | untrackScroll(); |
| [5771](#L5771) | const sortable = this.getSortable(this.placeholder); |
| [5772](#L5772) | if (this === sortable) { |
| [5773](#L5773) | if (this.origin.index !== index(this.placeholder)) { |
| [5774](#L5774) | trigger(this.$el, "moved", [this, this.placeholder]); |
| [5775](#L5775) | } |
| [5776](#L5776) | } else { |
| [5777](#L5777) | trigger(sortable.$el, "added", [sortable, this.placeholder]); |
| [5778](#L5778) | trigger(this.$el, "removed", [this, this.placeholder]); |
| [5779](#L5779) | } |
| [5780](#L5780) | trigger(this.$el, "stop", [this, this.placeholder]); |
| [5781](#L5781) | remove$1(this.drag); |
| [5782](#L5782) | this.drag = null; |
| [5783](#L5783) | for (const { clsPlaceholder, clsItem } of this.touched) { |
| [5784](#L5784) | for (const sortable2 of this.touched) { |
| [5785](#L5785) | removeClass(sortable2.items, clsPlaceholder, clsItem); |
| [5786](#L5786) | } |
| [5787](#L5787) | } |
| [5788](#L5788) | this.touched = null; |
| [5789](#L5789) | removeClass(document.documentElement, this.clsDragState); |
| [5790](#L5790) | }, |
| [5791](#L5791) | insert(element, target) { |
| [5792](#L5792) | addClass(this.items, this.clsItem); |
| [5793](#L5793) | if (target && target.previousElementSibling !== element) { |
| [5794](#L5794) | this.animate(() => before(target, element)); |
| [5795](#L5795) | } else if (!target && this.target.lastElementChild !== element) { |
| [5796](#L5796) | this.animate(() => append(this.target, element)); |
| [5797](#L5797) | } |
| [5798](#L5798) | }, |
| [5799](#L5799) | remove(element) { |
| [5800](#L5800) | if (this.target.contains(element)) { |
| [5801](#L5801) | this.animate(() => remove$1(element)); |
| [5802](#L5802) | } |
| [5803](#L5803) | }, |
| [5804](#L5804) | getSortable(element) { |
| [5805](#L5805) | do { |
| [5806](#L5806) | const sortable = this.$getComponent(element, "sortable"); |
| [5807](#L5807) | if (sortable && (sortable === this || this.group !== false && sortable.group === this.group)) { |
| [5808](#L5808) | return sortable; |
| [5809](#L5809) | } |
| [5810](#L5810) | } while (element = parent(element)); |
| [5811](#L5811) | } |
| [5812](#L5812) | } |
| [5813](#L5813) | }; |
| [5814](#L5814) | let trackTimer; |
| [5815](#L5815) | function trackScroll(pos) { |
| [5816](#L5816) | let last = Date.now(); |
| [5817](#L5817) | trackTimer = setInterval(() => { |
| [5818](#L5818) | let { x, y } = pos; |
| [5819](#L5819) | y += document.scrollingElement.scrollTop; |
| [5820](#L5820) | const dist = (Date.now() - last) \* 0.3; |
| [5821](#L5821) | last = Date.now(); |
| [5822](#L5822) | scrollParents(document.elementFromPoint(x, pos.y)).reverse().some((scrollEl) => { |
| [5823](#L5823) | let { scrollTop: scroll, scrollHeight } = scrollEl; |
| [5824](#L5824) | const { top, bottom, height: height2 } = offsetViewport(scrollEl); |
| [5825](#L5825) | if (top < y && top + 35 > y) { |
| [5826](#L5826) | scroll -= dist; |
| [5827](#L5827) | } else if (bottom > y && bottom - 35 < y) { |
| [5828](#L5828) | scroll += dist; |
| [5829](#L5829) | } else { |
| [5830](#L5830) | return; |
| [5831](#L5831) | } |
| [5832](#L5832) | if (scroll > 0 && scroll < scrollHeight - height2) { |
| [5833](#L5833) | scrollEl.scrollTop = scroll; |
| [5834](#L5834) | return true; |
| [5835](#L5835) | } |
| [5836](#L5836) | }); |
| [5837](#L5837) | }, 15); |
| [5838](#L5838) | } |
| [5839](#L5839) | function untrackScroll() { |
| [5840](#L5840) | clearInterval(trackTimer); |
| [5841](#L5841) | } |
| [5842](#L5842) | function appendDrag(container, element) { |
| [5843](#L5843) | let clone; |
| [5844](#L5844) | if (isTag(element, "li", "tr")) { |
| [5845](#L5845) | clone = $("<div>"); |
| [5846](#L5846) | append(clone, element.cloneNode(true).children); |
| [5847](#L5847) | for (const attribute of element.getAttributeNames()) { |
| [5848](#L5848) | attr(clone, attribute, element.getAttribute(attribute)); |
| [5849](#L5849) | } |
| [5850](#L5850) | } else { |
| [5851](#L5851) | clone = element.cloneNode(true); |
| [5852](#L5852) | } |
| [5853](#L5853) | append(container, clone); |
| [5854](#L5854) | css(clone, "margin", "0", "important"); |
| [5855](#L5855) | css(clone, { |
| [5856](#L5856) | boxSizing: "border-box", |
| [5857](#L5857) | width: element.offsetWidth, |
| [5858](#L5858) | height: element.offsetHeight, |
| [5859](#L5859) | padding: css(element, "padding") |
| [5860](#L5860) | }); |
| [5861](#L5861) | height(clone.firstElementChild, height(element.firstElementChild)); |
| [5862](#L5862) | return clone; |
| [5863](#L5863) | } |
| [5864](#L5864) | function findTarget(items, point) { |
| [5865](#L5865) | return items[findIndex(items, (item) => pointInRect(point, dimensions$1(item)))]; |
| [5866](#L5866) | } |
| [5867](#L5867) | function findInsertTarget(list, target, placeholder, x, y, sameList) { |
| [5868](#L5868) | if (!children(list).length) { |
| [5869](#L5869) | return; |
| [5870](#L5870) | } |
| [5871](#L5871) | const rect = dimensions$1(target); |
| [5872](#L5872) | if (!sameList) { |
| [5873](#L5873) | if (!isHorizontal(list, placeholder)) { |
| [5874](#L5874) | return y < rect.top + rect.height / 2 ? target : target.nextElementSibling; |
| [5875](#L5875) | } |
| [5876](#L5876) | return target; |
| [5877](#L5877) | } |
| [5878](#L5878) | const placeholderRect = dimensions$1(placeholder); |
| [5879](#L5879) | const sameRow = linesIntersect( |
| [5880](#L5880) | [rect.top, rect.bottom], |
| [5881](#L5881) | [placeholderRect.top, placeholderRect.bottom] |
| [5882](#L5882) | ); |
| [5883](#L5883) | const [pointerPos, lengthProp, startProp, endProp] = sameRow ? [x, "width", "left", "right"] : [y, "height", "top", "bottom"]; |
| [5884](#L5884) | const diff = placeholderRect[lengthProp] < rect[lengthProp] ? rect[lengthProp] - placeholderRect[lengthProp] : 0; |
| [5885](#L5885) | if (placeholderRect[startProp] < rect[startProp]) { |
| [5886](#L5886) | if (diff && pointerPos < rect[startProp] + diff) { |
| [5887](#L5887) | return false; |
| [5888](#L5888) | } |
| [5889](#L5889) | return target.nextElementSibling; |
| [5890](#L5890) | } |
| [5891](#L5891) | if (diff && pointerPos > rect[endProp] - diff) { |
| [5892](#L5892) | return false; |
| [5893](#L5893) | } |
| [5894](#L5894) | return target; |
| [5895](#L5895) | } |
| [5896](#L5896) | function isHorizontal(list, placeholder) { |
| [5897](#L5897) | const single = children(list).length === 1; |
| [5898](#L5898) | if (single) { |
| [5899](#L5899) | append(list, placeholder); |
| [5900](#L5900) | } |
| [5901](#L5901) | const items = children(list); |
| [5902](#L5902) | const isHorizontal2 = items.some((el, i) => { |
| [5903](#L5903) | const rectA = dimensions$1(el); |
| [5904](#L5904) | return items.slice(i + 1).some((el2) => { |
| [5905](#L5905) | const rectB = dimensions$1(el2); |
| [5906](#L5906) | return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]); |
| [5907](#L5907) | }); |
| [5908](#L5908) | }); |
| [5909](#L5909) | if (single) { |
| [5910](#L5910) | remove$1(placeholder); |
| [5911](#L5911) | } |
| [5912](#L5912) | return isHorizontal2; |
| [5913](#L5913) | } |
| [5914](#L5914) | function linesIntersect(lineA, lineB) { |
| [5915](#L5915) | return lineA[1] > lineB[0] && lineB[1] > lineA[0]; |
| [5916](#L5916) | } |
| [5917](#L5917) | function throttle(fn) { |
| [5918](#L5918) | let throttled; |
| [5919](#L5919) | return function(...args) { |
| [5920](#L5920) | if (!throttled) { |
| [5921](#L5921) | throttled = true; |
| [5922](#L5922) | fn.call(this, ...args); |
| [5923](#L5923) | requestAnimationFrame(() => throttled = false); |
| [5924](#L5924) | } |
| [5925](#L5925) | }; |
| [5926](#L5926) | } |
| [5927](#L5927) |  |
| [5928](#L5928) | var Position = { |
| [5929](#L5929) | props: { |
| [5930](#L5930) | pos: String, |
| [5931](#L5931) | offset: Boolean, |
| [5932](#L5932) | flip: Boolean, |
| [5933](#L5933) | shift: Boolean, |
| [5934](#L5934) | inset: Boolean |
| [5935](#L5935) | }, |
| [5936](#L5936) | data: { |
| [5937](#L5937) | pos: `bottom-${isRtl ? "right" : "left"}`, |
| [5938](#L5938) | offset: false, |
| [5939](#L5939) | flip: true, |
| [5940](#L5940) | shift: true, |
| [5941](#L5941) | inset: false |
| [5942](#L5942) | }, |
| [5943](#L5943) | connected() { |
| [5944](#L5944) | this.pos = this.$props.pos.split("-").concat("center").slice(0, 2); |
| [5945](#L5945) | [this.dir, this.align] = this.pos; |
| [5946](#L5946) | this.axis = includes(["top", "bottom"], this.dir) ? "y" : "x"; |
| [5947](#L5947) | }, |
| [5948](#L5948) | methods: { |
| [5949](#L5949) | positionAt(element, target, boundary) { |
| [5950](#L5950) | let offset = [this.getPositionOffset(element), this.getShiftOffset(element)]; |
| [5951](#L5951) | const placement = [this.flip && "flip", this.shift && "shift"]; |
| [5952](#L5952) | const attach = { |
| [5953](#L5953) | element: [this.inset ? this.dir : flipPosition(this.dir), this.align], |
| [5954](#L5954) | target: [this.dir, this.align] |
| [5955](#L5955) | }; |
| [5956](#L5956) | if (this.axis === "y") { |
| [5957](#L5957) | for (const prop in attach) { |
| [5958](#L5958) | attach[prop].reverse(); |
| [5959](#L5959) | } |
| [5960](#L5960) | offset.reverse(); |
| [5961](#L5961) | placement.reverse(); |
| [5962](#L5962) | } |
| [5963](#L5963) | const restoreScrollPosition = storeScrollPosition(element); |
| [5964](#L5964) | const elDim = dimensions$1(element); |
| [5965](#L5965) | css(element, { top: -elDim.height, left: -elDim.width }); |
| [5966](#L5966) | positionAt(element, target, { |
| [5967](#L5967) | attach, |
| [5968](#L5968) | offset, |
| [5969](#L5969) | boundary, |
| [5970](#L5970) | placement, |
| [5971](#L5971) | viewportOffset: this.getViewportOffset(element) |
| [5972](#L5972) | }); |
| [5973](#L5973) | restoreScrollPosition(); |
| [5974](#L5974) | }, |
| [5975](#L5975) | getPositionOffset(element = this.$el) { |
| [5976](#L5976) | return toPx( |
| [5977](#L5977) | this.offset === false ? css(element, "--bdt-position-offset") : this.offset, |
| [5978](#L5978) | this.axis === "x" ? "width" : "height", |
| [5979](#L5979) | element |
| [5980](#L5980) | ) \* (includes(["left", "top"], this.dir) ? -1 : 1) \* (this.inset ? -1 : 1); |
| [5981](#L5981) | }, |
| [5982](#L5982) | getShiftOffset(element = this.$el) { |
| [5983](#L5983) | return this.align === "center" ? 0 : toPx( |
| [5984](#L5984) | css(element, "--bdt-position-shift-offset"), |
| [5985](#L5985) | this.axis === "y" ? "width" : "height", |
| [5986](#L5986) | element |
| [5987](#L5987) | ) \* (includes(["left", "top"], this.align) ? 1 : -1); |
| [5988](#L5988) | }, |
| [5989](#L5989) | getViewportOffset(element) { |
| [5990](#L5990) | return toPx(css(element, "--bdt-position-viewport-offset")); |
| [5991](#L5991) | } |
| [5992](#L5992) | } |
| [5993](#L5993) | }; |
| [5994](#L5994) | function storeScrollPosition(element) { |
| [5995](#L5995) | const scrollElement = scrollParent(element); |
| [5996](#L5996) | const { scrollTop } = scrollElement; |
| [5997](#L5997) | return () => { |
| [5998](#L5998) | if (scrollTop !== scrollElement.scrollTop) { |
| [5999](#L5999) | scrollElement.scrollTop = scrollTop; |
| [6000](#L6000) | } |
| [6001](#L6001) | }; |
| [6002](#L6002) | } |
| [6003](#L6003) |  |
| [6004](#L6004) | var tooltip = { |
| [6005](#L6005) | mixins: [Container, Togglable, Position], |
| [6006](#L6006) | data: { |
| [6007](#L6007) | pos: "top", |
| [6008](#L6008) | animation: ["bdt-animation-scale-up"], |
| [6009](#L6009) | duration: 100, |
| [6010](#L6010) | cls: "bdt-active" |
| [6011](#L6011) | }, |
| [6012](#L6012) | connected() { |
| [6013](#L6013) | makeFocusable(this.$el); |
| [6014](#L6014) | }, |
| [6015](#L6015) | disconnected() { |
| [6016](#L6016) | this.hide(); |
| [6017](#L6017) | }, |
| [6018](#L6018) | methods: { |
| [6019](#L6019) | show() { |
| [6020](#L6020) | if (this.isToggled(this.tooltip || null)) { |
| [6021](#L6021) | return; |
| [6022](#L6022) | } |
| [6023](#L6023) | const { delay = 0, title } = parseProps(this.$options); |
| [6024](#L6024) | if (!title) { |
| [6025](#L6025) | return; |
| [6026](#L6026) | } |
| [6027](#L6027) | const titleAttr = attr(this.$el, "title"); |
| [6028](#L6028) | const off = on(this.$el, ["blur", pointerLeave], (e) => !isTouch(e) && this.hide()); |
| [6029](#L6029) | this.reset = () => { |
| [6030](#L6030) | attr(this.$el, { title: titleAttr, "aria-describedby": null }); |
| [6031](#L6031) | off(); |
| [6032](#L6032) | }; |
| [6033](#L6033) | const id = generateId(this); |
| [6034](#L6034) | attr(this.$el, { title: null, "aria-describedby": id }); |
| [6035](#L6035) | clearTimeout(this.showTimer); |
| [6036](#L6036) | this.showTimer = setTimeout(() => this.\_show(title, id), delay); |
| [6037](#L6037) | }, |
| [6038](#L6038) | async hide() { |
| [6039](#L6039) | var \_a; |
| [6040](#L6040) | if (matches(this.$el, "input:focus")) { |
| [6041](#L6041) | return; |
| [6042](#L6042) | } |
| [6043](#L6043) | clearTimeout(this.showTimer); |
| [6044](#L6044) | if (this.isToggled(this.tooltip || null)) { |
| [6045](#L6045) | await this.toggleElement(this.tooltip, false, false); |
| [6046](#L6046) | } |
| [6047](#L6047) | (\_a = this.reset) == null ? void 0 : \_a.call(this); |
| [6048](#L6048) | remove$1(this.tooltip); |
| [6049](#L6049) | this.tooltip = null; |
| [6050](#L6050) | }, |
| [6051](#L6051) | async \_show(title, id) { |
| [6052](#L6052) | this.tooltip = append( |
| [6053](#L6053) | this.container, |
| [6054](#L6054) | `<div id="${id}" class="bdt-${this.$options.name}" role="tooltip"> <div class="bdt-${this.$options.name}-inner">${title}</div> </div>` |
| [6055](#L6055) | ); |
| [6056](#L6056) | on(this.tooltip, "toggled", (e, toggled) => { |
| [6057](#L6057) | if (!toggled) { |
| [6058](#L6058) | return; |
| [6059](#L6059) | } |
| [6060](#L6060) | const update = () => this.positionAt(this.tooltip, this.$el); |
| [6061](#L6061) | update(); |
| [6062](#L6062) | const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos); |
| [6063](#L6063) | this.origin = this.axis === "y" ? `${flipPosition(dir)}-${align}` : `${align}-${flipPosition(dir)}`; |
| [6064](#L6064) | const handlers = [ |
| [6065](#L6065) | once( |
| [6066](#L6066) | document, |
| [6067](#L6067) | `keydown ${pointerDown$1}`, |
| [6068](#L6068) | this.hide, |
| [6069](#L6069) | false, |
| [6070](#L6070) | (e2) => e2.type === pointerDown$1 && !this.$el.contains(e2.target) || e2.type === "keydown" && e2.keyCode === keyMap.ESC |
| [6071](#L6071) | ), |
| [6072](#L6072) | on([document, ...overflowParents(this.$el)], "scroll", update, { |
| [6073](#L6073) | passive: true |
| [6074](#L6074) | }) |
| [6075](#L6075) | ]; |
| [6076](#L6076) | once(this.tooltip, "hide", () => handlers.forEach((handler) => handler()), { |
| [6077](#L6077) | self: true |
| [6078](#L6078) | }); |
| [6079](#L6079) | }); |
| [6080](#L6080) | if (!await this.toggleElement(this.tooltip, true)) { |
| [6081](#L6081) | this.hide(); |
| [6082](#L6082) | } |
| [6083](#L6083) | } |
| [6084](#L6084) | }, |
| [6085](#L6085) | events: { |
| [6086](#L6086) | // Clicking a button does not give it focus on all browsers and platforms |
| [6087](#L6087) | // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking\_and\_focus |
| [6088](#L6088) | [`focus ${pointerEnter} ${pointerDown$1}`](e) { |
| [6089](#L6089) | if (!isTouch(e) || e.type === pointerDown$1) { |
| [6090](#L6090) | this.show(); |
| [6091](#L6091) | } |
| [6092](#L6092) | } |
| [6093](#L6093) | } |
| [6094](#L6094) | }; |
| [6095](#L6095) | function makeFocusable(el) { |
| [6096](#L6096) | if (!isFocusable(el)) { |
| [6097](#L6097) | attr(el, "tabindex", "0"); |
| [6098](#L6098) | } |
| [6099](#L6099) | } |
| [6100](#L6100) | function getAlignment(el, target, [dir, align]) { |
| [6101](#L6101) | const elOffset = offset(el); |
| [6102](#L6102) | const targetOffset = offset(target); |
| [6103](#L6103) | const properties = [ |
| [6104](#L6104) | ["left", "right"], |
| [6105](#L6105) | ["top", "bottom"] |
| [6106](#L6106) | ]; |
| [6107](#L6107) | for (const props2 of properties) { |
| [6108](#L6108) | if (elOffset[props2[0]] >= targetOffset[props2[1]]) { |
| [6109](#L6109) | dir = props2[1]; |
| [6110](#L6110) | break; |
| [6111](#L6111) | } |
| [6112](#L6112) | if (elOffset[props2[1]] <= targetOffset[props2[0]]) { |
| [6113](#L6113) | dir = props2[0]; |
| [6114](#L6114) | break; |
| [6115](#L6115) | } |
| [6116](#L6116) | } |
| [6117](#L6117) | const props = includes(properties[0], dir) ? properties[1] : properties[0]; |
| [6118](#L6118) | align = props.find((prop) => elOffset[prop] === targetOffset[prop]) || "center"; |
| [6119](#L6119) | return [dir, align]; |
| [6120](#L6120) | } |
| [6121](#L6121) | function parseProps(options) { |
| [6122](#L6122) | const { el, id, data: data$1 } = options; |
| [6123](#L6123) | return ["delay", "title"].reduce((obj, key) => ({ [key]: data(el, key), ...obj }), { |
| [6124](#L6124) | ...parseOptions(data(el, id), ["title"]), |
| [6125](#L6125) | ...data$1 |
| [6126](#L6126) | }); |
| [6127](#L6127) | } |
| [6128](#L6128) |  |
| [6129](#L6129) | var upload = { |
| [6130](#L6130) | mixins: [I18n], |
| [6131](#L6131) | i18n: { |
| [6132](#L6132) | invalidMime: "Invalid File Type: %s", |
| [6133](#L6133) | invalidName: "Invalid File Name: %s", |
| [6134](#L6134) | invalidSize: "Invalid File Size: %s Kilobytes Max" |
| [6135](#L6135) | }, |
| [6136](#L6136) | props: { |
| [6137](#L6137) | allow: String, |
| [6138](#L6138) | clsDragover: String, |
| [6139](#L6139) | concurrent: Number, |
| [6140](#L6140) | maxSize: Number, |
| [6141](#L6141) | method: String, |
| [6142](#L6142) | mime: String, |
| [6143](#L6143) | multiple: Boolean, |
| [6144](#L6144) | name: String, |
| [6145](#L6145) | params: Object, |
| [6146](#L6146) | type: String, |
| [6147](#L6147) | url: String |
| [6148](#L6148) | }, |
| [6149](#L6149) | data: { |
| [6150](#L6150) | allow: false, |
| [6151](#L6151) | clsDragover: "bdt-dragover", |
| [6152](#L6152) | concurrent: 1, |
| [6153](#L6153) | maxSize: 0, |
| [6154](#L6154) | method: "POST", |
| [6155](#L6155) | mime: false, |
| [6156](#L6156) | multiple: false, |
| [6157](#L6157) | name: "files[]", |
| [6158](#L6158) | params: {}, |
| [6159](#L6159) | type: "", |
| [6160](#L6160) | url: "", |
| [6161](#L6161) | abort: noop, |
| [6162](#L6162) | beforeAll: noop, |
| [6163](#L6163) | beforeSend: noop, |
| [6164](#L6164) | complete: noop, |
| [6165](#L6165) | completeAll: noop, |
| [6166](#L6166) | error: noop, |
| [6167](#L6167) | fail: noop, |
| [6168](#L6168) | load: noop, |
| [6169](#L6169) | loadEnd: noop, |
| [6170](#L6170) | loadStart: noop, |
| [6171](#L6171) | progress: noop |
| [6172](#L6172) | }, |
| [6173](#L6173) | events: { |
| [6174](#L6174) | change(e) { |
| [6175](#L6175) | if (!matches(e.target, 'input[type="file"]')) { |
| [6176](#L6176) | return; |
| [6177](#L6177) | } |
| [6178](#L6178) | e.preventDefault(); |
| [6179](#L6179) | if (e.target.files) { |
| [6180](#L6180) | this.upload(e.target.files); |
| [6181](#L6181) | } |
| [6182](#L6182) | e.target.value = ""; |
| [6183](#L6183) | }, |
| [6184](#L6184) | drop(e) { |
| [6185](#L6185) | stop(e); |
| [6186](#L6186) | const transfer = e.dataTransfer; |
| [6187](#L6187) | if (!(transfer == null ? void 0 : transfer.files)) { |
| [6188](#L6188) | return; |
| [6189](#L6189) | } |
| [6190](#L6190) | removeClass(this.$el, this.clsDragover); |
| [6191](#L6191) | this.upload(transfer.files); |
| [6192](#L6192) | }, |
| [6193](#L6193) | dragenter(e) { |
| [6194](#L6194) | stop(e); |
| [6195](#L6195) | }, |
| [6196](#L6196) | dragover(e) { |
| [6197](#L6197) | stop(e); |
| [6198](#L6198) | addClass(this.$el, this.clsDragover); |
| [6199](#L6199) | }, |
| [6200](#L6200) | dragleave(e) { |
| [6201](#L6201) | stop(e); |
| [6202](#L6202) | removeClass(this.$el, this.clsDragover); |
| [6203](#L6203) | } |
| [6204](#L6204) | }, |
| [6205](#L6205) | methods: { |
| [6206](#L6206) | async upload(files) { |
| [6207](#L6207) | files = toArray(files); |
| [6208](#L6208) | if (!files.length) { |
| [6209](#L6209) | return; |
| [6210](#L6210) | } |
| [6211](#L6211) | trigger(this.$el, "upload", [files]); |
| [6212](#L6212) | for (const file of files) { |
| [6213](#L6213) | if (this.maxSize && this.maxSize \* 1e3 < file.size) { |
| [6214](#L6214) | this.fail(this.t("invalidSize", this.maxSize)); |
| [6215](#L6215) | return; |
| [6216](#L6216) | } |
| [6217](#L6217) | if (this.allow && !match$1(this.allow, file.name)) { |
| [6218](#L6218) | this.fail(this.t("invalidName", this.allow)); |
| [6219](#L6219) | return; |
| [6220](#L6220) | } |
| [6221](#L6221) | if (this.mime && !match$1(this.mime, file.type)) { |
| [6222](#L6222) | this.fail(this.t("invalidMime", this.mime)); |
| [6223](#L6223) | return; |
| [6224](#L6224) | } |
| [6225](#L6225) | } |
| [6226](#L6226) | if (!this.multiple) { |
| [6227](#L6227) | files = files.slice(0, 1); |
| [6228](#L6228) | } |
| [6229](#L6229) | this.beforeAll(this, files); |
| [6230](#L6230) | const chunks = chunk(files, this.concurrent); |
| [6231](#L6231) | const upload = async (files2) => { |
| [6232](#L6232) | const data = new FormData(); |
| [6233](#L6233) | files2.forEach((file) => data.append(this.name, file)); |
| [6234](#L6234) | for (const key in this.params) { |
| [6235](#L6235) | data.append(key, this.params[key]); |
| [6236](#L6236) | } |
| [6237](#L6237) | try { |
| [6238](#L6238) | const xhr = await ajax(this.url, { |
| [6239](#L6239) | data, |
| [6240](#L6240) | method: this.method, |
| [6241](#L6241) | responseType: this.type, |
| [6242](#L6242) | beforeSend: (env) => { |
| [6243](#L6243) | const { xhr: xhr2 } = env; |
| [6244](#L6244) | on(xhr2.upload, "progress", this.progress); |
| [6245](#L6245) | for (const type of ["loadStart", "load", "loadEnd", "abort"]) { |
| [6246](#L6246) | on(xhr2, type.toLowerCase(), this[type]); |
| [6247](#L6247) | } |
| [6248](#L6248) | return this.beforeSend(env); |
| [6249](#L6249) | } |
| [6250](#L6250) | }); |
| [6251](#L6251) | this.complete(xhr); |
| [6252](#L6252) | if (chunks.length) { |
| [6253](#L6253) | await upload(chunks.shift()); |
| [6254](#L6254) | } else { |
| [6255](#L6255) | this.completeAll(xhr); |
| [6256](#L6256) | } |
| [6257](#L6257) | } catch (e) { |
| [6258](#L6258) | this.error(e); |
| [6259](#L6259) | } |
| [6260](#L6260) | }; |
| [6261](#L6261) | await upload(chunks.shift()); |
| [6262](#L6262) | } |
| [6263](#L6263) | } |
| [6264](#L6264) | }; |
| [6265](#L6265) | function match$1(pattern, path) { |
| [6266](#L6266) | return path.match( |
| [6267](#L6267) | new RegExp( |
| [6268](#L6268) | `^${pattern.replace(/\//g, "\\/").replace(/\\*\\*/g, "(\\/[^\\/]+)\*").replace(/\\*/g, "[^\\/]+").replace(/((?!\\))\?/g, "$1.")}$`, |
| [6269](#L6269) | "i" |
| [6270](#L6270) | ) |
| [6271](#L6271) | ); |
| [6272](#L6272) | } |
| [6273](#L6273) | function chunk(files, size) { |
| [6274](#L6274) | const chunks = []; |
| [6275](#L6275) | for (let i = 0; i < files.length; i += size) { |
| [6276](#L6276) | chunks.push(files.slice(i, i + size)); |
| [6277](#L6277) | } |
| [6278](#L6278) | return chunks; |
| [6279](#L6279) | } |
| [6280](#L6280) | function stop(e) { |
| [6281](#L6281) | e.preventDefault(); |
| [6282](#L6282) | e.stopPropagation(); |
| [6283](#L6283) | } |
| [6284](#L6284) | async function ajax(url, options) { |
| [6285](#L6285) | const env = { |
| [6286](#L6286) | data: null, |
| [6287](#L6287) | method: "GET", |
| [6288](#L6288) | headers: {}, |
| [6289](#L6289) | xhr: new XMLHttpRequest(), |
| [6290](#L6290) | beforeSend: noop, |
| [6291](#L6291) | responseType: "", |
| [6292](#L6292) | ...options |
| [6293](#L6293) | }; |
| [6294](#L6294) | await env.beforeSend(env); |
| [6295](#L6295) | return send(url, env); |
| [6296](#L6296) | } |
| [6297](#L6297) | function send(url, env) { |
| [6298](#L6298) | return new Promise((resolve, reject) => { |
| [6299](#L6299) | const { xhr } = env; |
| [6300](#L6300) | for (const prop in env) { |
| [6301](#L6301) | if (prop in xhr) { |
| [6302](#L6302) | try { |
| [6303](#L6303) | xhr[prop] = env[prop]; |
| [6304](#L6304) | } catch (e) { |
| [6305](#L6305) | } |
| [6306](#L6306) | } |
| [6307](#L6307) | } |
| [6308](#L6308) | xhr.open(env.method.toUpperCase(), url); |
| [6309](#L6309) | for (const header in env.headers) { |
| [6310](#L6310) | xhr.setRequestHeader(header, env.headers[header]); |
| [6311](#L6311) | } |
| [6312](#L6312) | on(xhr, "load", () => { |
| [6313](#L6313) | if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) { |
| [6314](#L6314) | resolve(xhr); |
| [6315](#L6315) | } else { |
| [6316](#L6316) | reject( |
| [6317](#L6317) | assign(Error(xhr.statusText), { |
| [6318](#L6318) | xhr, |
| [6319](#L6319) | status: xhr.status |
| [6320](#L6320) | }) |
| [6321](#L6321) | ); |
| [6322](#L6322) | } |
| [6323](#L6323) | }); |
| [6324](#L6324) | on(xhr, "error", () => reject(assign(Error("Network Error"), { xhr }))); |
| [6325](#L6325) | on(xhr, "timeout", () => reject(assign(Error("Network Timeout"), { xhr }))); |
| [6326](#L6326) | xhr.send(env.data); |
| [6327](#L6327) | }); |
| [6328](#L6328) | } |
| [6329](#L6329) |  |
| [6330](#L6330) | var components$1 = /\*#\_\_PURE\_\_\*/Object.freeze({ |
| [6331](#L6331) | \_\_proto\_\_: null, |
| [6332](#L6332) | Countdown: countdown, |
| [6333](#L6333) | Filter: filter, |
| [6334](#L6334) | Lightbox: lightbox, |
| [6335](#L6335) | LightboxPanel: LightboxPanel, |
| [6336](#L6336) | Notification: notification, |
| [6337](#L6337) | Parallax: parallax, |
| [6338](#L6338) | Slider: slider, |
| [6339](#L6339) | SliderParallax: sliderParallax, |
| [6340](#L6340) | Slideshow: slideshow, |
| [6341](#L6341) | SlideshowParallax: sliderParallax, |
| [6342](#L6342) | Sortable: sortable, |
| [6343](#L6343) | Tooltip: tooltip, |
| [6344](#L6344) | Upload: upload |
| [6345](#L6345) | }); |
| [6346](#L6346) |  |
| [6347](#L6347) | function boot(App) { |
| [6348](#L6348) | if (inBrowser && window.MutationObserver) { |
| [6349](#L6349) | if (document.body) { |
| [6350](#L6350) | requestAnimationFrame(() => init(App)); |
| [6351](#L6351) | } else { |
| [6352](#L6352) | new MutationObserver((records, observer) => { |
| [6353](#L6353) | if (document.body) { |
| [6354](#L6354) | init(App); |
| [6355](#L6355) | observer.disconnect(); |
| [6356](#L6356) | } |
| [6357](#L6357) | }).observe(document.documentElement, { childList: true }); |
| [6358](#L6358) | } |
| [6359](#L6359) | } |
| [6360](#L6360) | } |
| [6361](#L6361) | function init(App) { |
| [6362](#L6362) | trigger(document, "uikit:init", App); |
| [6363](#L6363) | if (document.body) { |
| [6364](#L6364) | apply(document.body, connect); |
| [6365](#L6365) | } |
| [6366](#L6366) | new MutationObserver((records) => records.forEach(applyChildListMutation)).observe(document, { |
| [6367](#L6367) | subtree: true, |
| [6368](#L6368) | childList: true |
| [6369](#L6369) | }); |
| [6370](#L6370) | new MutationObserver((records) => records.forEach(applyAttributeMutation)).observe(document, { |
| [6371](#L6371) | subtree: true, |
| [6372](#L6372) | attributes: true |
| [6373](#L6373) | }); |
| [6374](#L6374) | App.\_initialized = true; |
| [6375](#L6375) | } |
| [6376](#L6376) | function applyChildListMutation({ addedNodes, removedNodes }) { |
| [6377](#L6377) | for (const node of addedNodes) { |
| [6378](#L6378) | apply(node, connect); |
| [6379](#L6379) | } |
| [6380](#L6380) | for (const node of removedNodes) { |
| [6381](#L6381) | apply(node, disconnect); |
| [6382](#L6382) | } |
| [6383](#L6383) | } |
| [6384](#L6384) | function applyAttributeMutation({ target, attributeName }) { |
| [6385](#L6385) | var \_a; |
| [6386](#L6386) | const name = getComponentName(attributeName); |
| [6387](#L6387) | if (name) { |
| [6388](#L6388) | if (hasAttr(target, attributeName)) { |
| [6389](#L6389) | createComponent(name, target); |
| [6390](#L6390) | } else { |
| [6391](#L6391) | (\_a = getComponent(target, name)) == null ? void 0 : \_a.$destroy(); |
| [6392](#L6392) | } |
| [6393](#L6393) | } |
| [6394](#L6394) | } |
| [6395](#L6395) | function connect(node) { |
| [6396](#L6396) | const components2 = getComponents(node); |
| [6397](#L6397) | for (const name in components2) { |
| [6398](#L6398) | callConnected(components2[name]); |
| [6399](#L6399) | } |
| [6400](#L6400) | for (const attributeName of node.getAttributeNames()) { |
| [6401](#L6401) | const name = getComponentName(attributeName); |
| [6402](#L6402) | name && createComponent(name, node); |
| [6403](#L6403) | } |
| [6404](#L6404) | } |
| [6405](#L6405) | function disconnect(node) { |
| [6406](#L6406) | const components2 = getComponents(node); |
| [6407](#L6407) | for (const name in components2) { |
| [6408](#L6408) | callDisconnected(components2[name]); |
| [6409](#L6409) | } |
| [6410](#L6410) | } |
| [6411](#L6411) | function getComponentName(attribute) { |
| [6412](#L6412) | if (startsWith(attribute, "data-")) { |
| [6413](#L6413) | attribute = attribute.slice(5); |
| [6414](#L6414) | } |
| [6415](#L6415) | const cmp = components$2[attribute]; |
| [6416](#L6416) | return cmp && (cmp.options || cmp).name; |
| [6417](#L6417) | } |
| [6418](#L6418) |  |
| [6419](#L6419) | globalApi(App); |
| [6420](#L6420) | instanceApi(App); |
| [6421](#L6421) |  |
| [6422](#L6422) | var Accordion = { |
| [6423](#L6423) | mixins: [Class, Togglable], |
| [6424](#L6424) | props: { |
| [6425](#L6425) | animation: Boolean, |
| [6426](#L6426) | targets: String, |
| [6427](#L6427) | active: null, |
| [6428](#L6428) | collapsible: Boolean, |
| [6429](#L6429) | multiple: Boolean, |
| [6430](#L6430) | toggle: String, |
| [6431](#L6431) | content: String, |
| [6432](#L6432) | offset: Number |
| [6433](#L6433) | }, |
| [6434](#L6434) | data: { |
| [6435](#L6435) | targets: "> \*", |
| [6436](#L6436) | active: false, |
| [6437](#L6437) | animation: true, |
| [6438](#L6438) | collapsible: true, |
| [6439](#L6439) | multiple: false, |
| [6440](#L6440) | clsOpen: "bdt-open", |
| [6441](#L6441) | toggle: "> .bdt-accordion-title", |
| [6442](#L6442) | content: "> .bdt-accordion-content", |
| [6443](#L6443) | offset: 0 |
| [6444](#L6444) | }, |
| [6445](#L6445) | computed: { |
| [6446](#L6446) | items: ({ targets }, $el) => $$(targets, $el), |
| [6447](#L6447) | toggles({ toggle }) { |
| [6448](#L6448) | return this.items.map((item) => $(toggle, item)); |
| [6449](#L6449) | }, |
| [6450](#L6450) | contents({ content }) { |
| [6451](#L6451) | return this.items.map((item) => { |
| [6452](#L6452) | var \_a; |
| [6453](#L6453) | return ((\_a = item.\_wrapper) == null ? void 0 : \_a.firstElementChild) || $(content, item); |
| [6454](#L6454) | }); |
| [6455](#L6455) | } |
| [6456](#L6456) | }, |
| [6457](#L6457) | watch: { |
| [6458](#L6458) | items(items, prev) { |
| [6459](#L6459) | if (prev || hasClass(items, this.clsOpen)) { |
| [6460](#L6460) | return; |
| [6461](#L6461) | } |
| [6462](#L6462) | const active = this.active !== false && items[Number(this.active)] || !this.collapsible && items[0]; |
| [6463](#L6463) | if (active) { |
| [6464](#L6464) | this.toggle(active, false); |
| [6465](#L6465) | } |
| [6466](#L6466) | }, |
| [6467](#L6467) | toggles() { |
| [6468](#L6468) | this.$emit(); |
| [6469](#L6469) | }, |
| [6470](#L6470) | contents(items) { |
| [6471](#L6471) | for (const el of items) { |
| [6472](#L6472) | const isOpen = hasClass( |
| [6473](#L6473) | this.items.find((item) => item.contains(el)), |
| [6474](#L6474) | this.clsOpen |
| [6475](#L6475) | ); |
| [6476](#L6476) | hide(el, !isOpen); |
| [6477](#L6477) | } |
| [6478](#L6478) | this.$emit(); |
| [6479](#L6479) | } |
| [6480](#L6480) | }, |
| [6481](#L6481) | observe: lazyload(), |
| [6482](#L6482) | events: [ |
| [6483](#L6483) | { |
| [6484](#L6484) | name: "click keydown", |
| [6485](#L6485) | delegate: ({ targets, $props }) => `${targets} ${$props.toggle}`, |
| [6486](#L6486) | async handler(e) { |
| [6487](#L6487) | var \_a; |
| [6488](#L6488) | if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) { |
| [6489](#L6489) | return; |
| [6490](#L6490) | } |
| [6491](#L6491) | e.preventDefault(); |
| [6492](#L6492) | (\_a = this.\_off) == null ? void 0 : \_a.call(this); |
| [6493](#L6493) | this.\_off = keepScrollPosition(e.target); |
| [6494](#L6494) | await this.toggle(index(this.toggles, e.current)); |
| [6495](#L6495) | this.\_off(); |
| [6496](#L6496) | } |
| [6497](#L6497) | }, |
| [6498](#L6498) | { |
| [6499](#L6499) | name: "shown hidden", |
| [6500](#L6500) | self: true, |
| [6501](#L6501) | delegate: ({ targets }) => targets, |
| [6502](#L6502) | handler() { |
| [6503](#L6503) | this.$emit(); |
| [6504](#L6504) | } |
| [6505](#L6505) | } |
| [6506](#L6506) | ], |
| [6507](#L6507) | update() { |
| [6508](#L6508) | const activeItems = filter$1(this.items, `.${this.clsOpen}`); |
| [6509](#L6509) | for (const index2 in this.items) { |
| [6510](#L6510) | const toggle = this.toggles[index2]; |
| [6511](#L6511) | const content = this.contents[index2]; |
| [6512](#L6512) | if (!toggle || !content) { |
| [6513](#L6513) | continue; |
| [6514](#L6514) | } |
| [6515](#L6515) | toggle.id = generateId(this, toggle); |
| [6516](#L6516) | content.id = generateId(this, content); |
| [6517](#L6517) | const active = includes(activeItems, this.items[index2]); |
| [6518](#L6518) | attr(toggle, { |
| [6519](#L6519) | role: isTag(toggle, "a") ? "button" : null, |
| [6520](#L6520) | "aria-controls": content.id, |
| [6521](#L6521) | "aria-expanded": active, |
| [6522](#L6522) | "aria-disabled": !this.collapsible && activeItems.length < 2 && active |
| [6523](#L6523) | }); |
| [6524](#L6524) | attr(content, { role: "region", "aria-labelledby": toggle.id }); |
| [6525](#L6525) | if (isTag(content, "ul")) { |
| [6526](#L6526) | attr(children(content), "role", "presentation"); |
| [6527](#L6527) | } |
| [6528](#L6528) | } |
| [6529](#L6529) | }, |
| [6530](#L6530) | methods: { |
| [6531](#L6531) | toggle(item, animate) { |
| [6532](#L6532) | item = this.items[getIndex(item, this.items)]; |
| [6533](#L6533) | let items = [item]; |
| [6534](#L6534) | const activeItems = filter$1(this.items, `.${this.clsOpen}`); |
| [6535](#L6535) | if (!this.multiple && !includes(activeItems, items[0])) { |
| [6536](#L6536) | items = items.concat(activeItems); |
| [6537](#L6537) | } |
| [6538](#L6538) | if (!this.collapsible && activeItems.length < 2 && includes(activeItems, item)) { |
| [6539](#L6539) | return; |
| [6540](#L6540) | } |
| [6541](#L6541) | return Promise.all( |
| [6542](#L6542) | items.map( |
| [6543](#L6543) | (el) => this.toggleElement(el, !includes(activeItems, el), (el2, show) => { |
| [6544](#L6544) | toggleClass(el2, this.clsOpen, show); |
| [6545](#L6545) | if (animate === false || !this.animation) { |
| [6546](#L6546) | hide($(this.content, el2), !show); |
| [6547](#L6547) | return; |
| [6548](#L6548) | } |
| [6549](#L6549) | return transition(el2, show, this); |
| [6550](#L6550) | }) |
| [6551](#L6551) | ) |
| [6552](#L6552) | ); |
| [6553](#L6553) | } |
| [6554](#L6554) | } |
| [6555](#L6555) | }; |
| [6556](#L6556) | function hide(el, hide2) { |
| [6557](#L6557) | el && (el.hidden = hide2); |
| [6558](#L6558) | } |
| [6559](#L6559) | async function transition(el, show, { content, duration, velocity, transition: transition2 }) { |
| [6560](#L6560) | var \_a; |
| [6561](#L6561) | content = ((\_a = el.\_wrapper) == null ? void 0 : \_a.firstElementChild) || $(content, el); |
| [6562](#L6562) | if (!el.\_wrapper) { |
| [6563](#L6563) | el.\_wrapper = wrapAll(content, "<div>"); |
| [6564](#L6564) | } |
| [6565](#L6565) | const wrapper = el.\_wrapper; |
| [6566](#L6566) | css(wrapper, "overflow", "hidden"); |
| [6567](#L6567) | const currentHeight = toFloat(css(wrapper, "height")); |
| [6568](#L6568) | await Transition.cancel(wrapper); |
| [6569](#L6569) | hide(content, false); |
| [6570](#L6570) | const endHeight = sumBy(["marginTop", "marginBottom"], (prop) => css(content, prop)) + dimensions$1(content).height; |
| [6571](#L6571) | const percent = currentHeight / endHeight; |
| [6572](#L6572) | duration = (velocity \* endHeight + duration) \* (show ? 1 - percent : percent); |
| [6573](#L6573) | css(wrapper, "height", currentHeight); |
| [6574](#L6574) | await Transition.start(wrapper, { height: show ? endHeight : 0 }, duration, transition2); |
| [6575](#L6575) | unwrap(content); |
| [6576](#L6576) | delete el.\_wrapper; |
| [6577](#L6577) | if (!show) { |
| [6578](#L6578) | hide(content, true); |
| [6579](#L6579) | } |
| [6580](#L6580) | } |
| [6581](#L6581) | function keepScrollPosition(el) { |
| [6582](#L6582) | const scrollElement = scrollParent(el, true); |
| [6583](#L6583) | let frame; |
| [6584](#L6584) | (function scroll() { |
| [6585](#L6585) | frame = requestAnimationFrame(() => { |
| [6586](#L6586) | const { top } = dimensions$1(el); |
| [6587](#L6587) | if (top < 0) { |
| [6588](#L6588) | scrollElement.scrollTop += top; |
| [6589](#L6589) | } |
| [6590](#L6590) | scroll(); |
| [6591](#L6591) | }); |
| [6592](#L6592) | })(); |
| [6593](#L6593) | return () => requestAnimationFrame(() => cancelAnimationFrame(frame)); |
| [6594](#L6594) | } |
| [6595](#L6595) |  |
| [6596](#L6596) | var alert = { |
| [6597](#L6597) | mixins: [Class, Togglable], |
| [6598](#L6598) | args: "animation", |
| [6599](#L6599) | props: { |
| [6600](#L6600) | animation: Boolean, |
| [6601](#L6601) | close: String |
| [6602](#L6602) | }, |
| [6603](#L6603) | data: { |
| [6604](#L6604) | animation: true, |
| [6605](#L6605) | selClose: ".bdt-alert-close", |
| [6606](#L6606) | duration: 150 |
| [6607](#L6607) | }, |
| [6608](#L6608) | events: { |
| [6609](#L6609) | name: "click", |
| [6610](#L6610) | delegate: ({ selClose }) => selClose, |
| [6611](#L6611) | handler(e) { |
| [6612](#L6612) | e.preventDefault(); |
| [6613](#L6613) | this.close(); |
| [6614](#L6614) | } |
| [6615](#L6615) | }, |
| [6616](#L6616) | methods: { |
| [6617](#L6617) | async close() { |
| [6618](#L6618) | await this.toggleElement(this.$el, false, animate); |
| [6619](#L6619) | this.$destroy(true); |
| [6620](#L6620) | } |
| [6621](#L6621) | } |
| [6622](#L6622) | }; |
| [6623](#L6623) | function animate(el, show, { duration, transition, velocity }) { |
| [6624](#L6624) | const height = toFloat(css(el, "height")); |
| [6625](#L6625) | css(el, "height", height); |
| [6626](#L6626) | return Transition.start( |
| [6627](#L6627) | el, |
| [6628](#L6628) | { |
| [6629](#L6629) | height: 0, |
| [6630](#L6630) | marginTop: 0, |
| [6631](#L6631) | marginBottom: 0, |
| [6632](#L6632) | paddingTop: 0, |
| [6633](#L6633) | paddingBottom: 0, |
| [6634](#L6634) | borderTop: 0, |
| [6635](#L6635) | borderBottom: 0, |
| [6636](#L6636) | opacity: 0 |
| [6637](#L6637) | }, |
| [6638](#L6638) | velocity \* height + duration, |
| [6639](#L6639) | transition |
| [6640](#L6640) | ); |
| [6641](#L6641) | } |
| [6642](#L6642) |  |
| [6643](#L6643) | var Video = { |
| [6644](#L6644) | args: "autoplay", |
| [6645](#L6645) | props: { |
| [6646](#L6646) | automute: Boolean, |
| [6647](#L6647) | autoplay: Boolean |
| [6648](#L6648) | }, |
| [6649](#L6649) | data: { |
| [6650](#L6650) | automute: false, |
| [6651](#L6651) | autoplay: true |
| [6652](#L6652) | }, |
| [6653](#L6653) | beforeConnect() { |
| [6654](#L6654) | if (this.autoplay === "inview" && !hasAttr(this.$el, "preload")) { |
| [6655](#L6655) | this.$el.preload = "none"; |
| [6656](#L6656) | } |
| [6657](#L6657) | if (isTag(this.$el, "iframe") && !hasAttr(this.$el, "allow")) { |
| [6658](#L6658) | this.$el.allow = "autoplay"; |
| [6659](#L6659) | } |
| [6660](#L6660) | if (this.autoplay === "hover") { |
| [6661](#L6661) | if (isTag(this.$el, "video")) { |
| [6662](#L6662) | this.$el.tabindex = 0; |
| [6663](#L6663) | } else { |
| [6664](#L6664) | this.autoplay = true; |
| [6665](#L6665) | } |
| [6666](#L6666) | } |
| [6667](#L6667) | if (this.automute) { |
| [6668](#L6668) | mute(this.$el); |
| [6669](#L6669) | } |
| [6670](#L6670) | }, |
| [6671](#L6671) | events: [ |
| [6672](#L6672) | { |
| [6673](#L6673) | name: `${pointerEnter} focusin`, |
| [6674](#L6674) | filter: ({ autoplay }) => includes(autoplay, "hover"), |
| [6675](#L6675) | handler(e) { |
| [6676](#L6676) | if (!isTouch(e) || !isPlaying(this.$el)) { |
| [6677](#L6677) | play(this.$el); |
| [6678](#L6678) | } else { |
| [6679](#L6679) | pause(this.$el); |
| [6680](#L6680) | } |
| [6681](#L6681) | } |
| [6682](#L6682) | }, |
| [6683](#L6683) | { |
| [6684](#L6684) | name: `${pointerLeave} focusout`, |
| [6685](#L6685) | filter: ({ autoplay }) => includes(autoplay, "hover"), |
| [6686](#L6686) | handler(e) { |
| [6687](#L6687) | if (!isTouch(e)) { |
| [6688](#L6688) | pause(this.$el); |
| [6689](#L6689) | } |
| [6690](#L6690) | } |
| [6691](#L6691) | } |
| [6692](#L6692) | ], |
| [6693](#L6693) | observe: [ |
| [6694](#L6694) | intersection({ |
| [6695](#L6695) | filter: ({ $el, autoplay }) => autoplay && autoplay !== "hover" && isVideo($el), |
| [6696](#L6696) | handler([{ isIntersecting }]) { |
| [6697](#L6697) | if (!document.fullscreenElement) { |
| [6698](#L6698) | if (isIntersecting) { |
| [6699](#L6699) | play(this.$el); |
| [6700](#L6700) | } else { |
| [6701](#L6701) | pause(this.$el); |
| [6702](#L6702) | } |
| [6703](#L6703) | } |
| [6704](#L6704) | }, |
| [6705](#L6705) | args: { intersecting: false }, |
| [6706](#L6706) | options: ({ $el, autoplay }) => ({ root: autoplay === "inview" ? null : parent($el) }) |
| [6707](#L6707) | }) |
| [6708](#L6708) | ] |
| [6709](#L6709) | }; |
| [6710](#L6710) | function isPlaying(videoEl) { |
| [6711](#L6711) | return !videoEl.paused && !videoEl.ended; |
| [6712](#L6712) | } |
| [6713](#L6713) |  |
| [6714](#L6714) | var cover = { |
| [6715](#L6715) | mixins: [Video], |
| [6716](#L6716) | props: { |
| [6717](#L6717) | width: Number, |
| [6718](#L6718) | height: Number |
| [6719](#L6719) | }, |
| [6720](#L6720) | data: { |
| [6721](#L6721) | automute: true |
| [6722](#L6722) | }, |
| [6723](#L6723) | created() { |
| [6724](#L6724) | this.useObjectFit = isTag(this.$el, "img", "video"); |
| [6725](#L6725) | }, |
| [6726](#L6726) | observe: resize({ |
| [6727](#L6727) | target: ({ $el }) => getPositionedParent($el) || parent($el), |
| [6728](#L6728) | filter: ({ useObjectFit }) => !useObjectFit |
| [6729](#L6729) | }), |
| [6730](#L6730) | update: { |
| [6731](#L6731) | read() { |
| [6732](#L6732) | if (this.useObjectFit) { |
| [6733](#L6733) | return false; |
| [6734](#L6734) | } |
| [6735](#L6735) | const { ratio, cover } = Dimensions; |
| [6736](#L6736) | const { $el, width, height } = this; |
| [6737](#L6737) | let dim = { width, height }; |
| [6738](#L6738) | if (!width || !height) { |
| [6739](#L6739) | const intrinsic = { |
| [6740](#L6740) | width: $el.naturalWidth || $el.videoWidth || $el.clientWidth, |
| [6741](#L6741) | height: $el.naturalHeight || $el.videoHeight || $el.clientHeight |
| [6742](#L6742) | }; |
| [6743](#L6743) | if (width) { |
| [6744](#L6744) | dim = ratio(intrinsic, "width", width); |
| [6745](#L6745) | } else if (height) { |
| [6746](#L6746) | dim = ratio(intrinsic, "height", height); |
| [6747](#L6747) | } else { |
| [6748](#L6748) | dim = intrinsic; |
| [6749](#L6749) | } |
| [6750](#L6750) | } |
| [6751](#L6751) | const { offsetHeight: coverHeight, offsetWidth: coverWidth } = getPositionedParent($el) || parent($el); |
| [6752](#L6752) | const coverDim = cover(dim, { width: coverWidth, height: coverHeight }); |
| [6753](#L6753) | if (!coverDim.width || !coverDim.height) { |
| [6754](#L6754) | return false; |
| [6755](#L6755) | } |
| [6756](#L6756) | return coverDim; |
| [6757](#L6757) | }, |
| [6758](#L6758) | write({ height, width }) { |
| [6759](#L6759) | css(this.$el, { height, width }); |
| [6760](#L6760) | }, |
| [6761](#L6761) | events: ["resize"] |
| [6762](#L6762) | } |
| [6763](#L6763) | }; |
| [6764](#L6764) | function getPositionedParent(el) { |
| [6765](#L6765) | while (el = parent(el)) { |
| [6766](#L6766) | if (css(el, "position") !== "static") { |
| [6767](#L6767) | return el; |
| [6768](#L6768) | } |
| [6769](#L6769) | } |
| [6770](#L6770) | } |
| [6771](#L6771) |  |
| [6772](#L6772) | let active; |
| [6773](#L6773) | var drop = { |
| [6774](#L6774) | mixins: [Container, Position, Togglable], |
| [6775](#L6775) | args: "pos", |
| [6776](#L6776) | props: { |
| [6777](#L6777) | mode: "list", |
| [6778](#L6778) | toggle: Boolean, |
| [6779](#L6779) | boundary: Boolean, |
| [6780](#L6780) | boundaryX: Boolean, |
| [6781](#L6781) | boundaryY: Boolean, |
| [6782](#L6782) | target: Boolean, |
| [6783](#L6783) | targetX: Boolean, |
| [6784](#L6784) | targetY: Boolean, |
| [6785](#L6785) | stretch: Boolean, |
| [6786](#L6786) | delayShow: Number, |
| [6787](#L6787) | delayHide: Number, |
| [6788](#L6788) | autoUpdate: Boolean, |
| [6789](#L6789) | clsDrop: String, |
| [6790](#L6790) | animateOut: Boolean, |
| [6791](#L6791) | bgScroll: Boolean, |
| [6792](#L6792) | closeOnScroll: Boolean |
| [6793](#L6793) | }, |
| [6794](#L6794) | data: { |
| [6795](#L6795) | mode: ["click", "hover"], |
| [6796](#L6796) | toggle: "- \*", |
| [6797](#L6797) | boundary: false, |
| [6798](#L6798) | boundaryX: false, |
| [6799](#L6799) | boundaryY: false, |
| [6800](#L6800) | target: false, |
| [6801](#L6801) | targetX: false, |
| [6802](#L6802) | targetY: false, |
| [6803](#L6803) | stretch: false, |
| [6804](#L6804) | delayShow: 0, |
| [6805](#L6805) | delayHide: 800, |
| [6806](#L6806) | autoUpdate: true, |
| [6807](#L6807) | clsDrop: false, |
| [6808](#L6808) | animateOut: false, |
| [6809](#L6809) | bgScroll: true, |
| [6810](#L6810) | animation: ["bdt-animation-fade"], |
| [6811](#L6811) | cls: "bdt-open", |
| [6812](#L6812) | container: false, |
| [6813](#L6813) | closeOnScroll: false |
| [6814](#L6814) | }, |
| [6815](#L6815) | computed: { |
| [6816](#L6816) | boundary({ boundary, boundaryX, boundaryY }, $el) { |
| [6817](#L6817) | return [ |
| [6818](#L6818) | query(boundaryX || boundary, $el) || window, |
| [6819](#L6819) | query(boundaryY || boundary, $el) || window |
| [6820](#L6820) | ]; |
| [6821](#L6821) | }, |
| [6822](#L6822) | target({ target, targetX, targetY }, $el) { |
| [6823](#L6823) | targetX || (targetX = target || this.targetEl); |
| [6824](#L6824) | targetY || (targetY = target || this.targetEl); |
| [6825](#L6825) | return [ |
| [6826](#L6826) | targetX === true ? window : query(targetX, $el), |
| [6827](#L6827) | targetY === true ? window : query(targetY, $el) |
| [6828](#L6828) | ]; |
| [6829](#L6829) | } |
| [6830](#L6830) | }, |
| [6831](#L6831) | created() { |
| [6832](#L6832) | this.tracker = new MouseTracker(); |
| [6833](#L6833) | }, |
| [6834](#L6834) | beforeConnect() { |
| [6835](#L6835) | this.clsDrop = this.$props.clsDrop || this.$options.id; |
| [6836](#L6836) | }, |
| [6837](#L6837) | connected() { |
| [6838](#L6838) | addClass(this.$el, "bdt-drop", this.clsDrop); |
| [6839](#L6839) | if (this.toggle && !this.targetEl) { |
| [6840](#L6840) | this.targetEl = createToggleComponent(this); |
| [6841](#L6841) | } |
| [6842](#L6842) | this.\_style = pick(this.$el.style, ["width", "height"]); |
| [6843](#L6843) | }, |
| [6844](#L6844) | disconnected() { |
| [6845](#L6845) | if (this.isActive()) { |
| [6846](#L6846) | this.hide(false); |
| [6847](#L6847) | active = null; |
| [6848](#L6848) | } |
| [6849](#L6849) | css(this.$el, this.\_style); |
| [6850](#L6850) | }, |
| [6851](#L6851) | events: [ |
| [6852](#L6852) | { |
| [6853](#L6853) | name: "click", |
| [6854](#L6854) | delegate: () => ".bdt-drop-close", |
| [6855](#L6855) | handler(e) { |
| [6856](#L6856) | e.preventDefault(); |
| [6857](#L6857) | this.hide(false); |
| [6858](#L6858) | } |
| [6859](#L6859) | }, |
| [6860](#L6860) | { |
| [6861](#L6861) | name: "click", |
| [6862](#L6862) | delegate: () => 'a[href\*="#"]', |
| [6863](#L6863) | handler({ defaultPrevented, current }) { |
| [6864](#L6864) | const { hash } = current; |
| [6865](#L6865) | if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) { |
| [6866](#L6866) | this.hide(false); |
| [6867](#L6867) | } |
| [6868](#L6868) | } |
| [6869](#L6869) | }, |
| [6870](#L6870) | { |
| [6871](#L6871) | name: "beforescroll", |
| [6872](#L6872) | handler() { |
| [6873](#L6873) | this.hide(false); |
| [6874](#L6874) | } |
| [6875](#L6875) | }, |
| [6876](#L6876) | { |
| [6877](#L6877) | name: "toggle", |
| [6878](#L6878) | self: true, |
| [6879](#L6879) | handler(e, toggle) { |
| [6880](#L6880) | e.preventDefault(); |
| [6881](#L6881) | if (this.isToggled()) { |
| [6882](#L6882) | this.hide(false); |
| [6883](#L6883) | } else { |
| [6884](#L6884) | this.show(toggle == null ? void 0 : toggle.$el, false); |
| [6885](#L6885) | } |
| [6886](#L6886) | } |
| [6887](#L6887) | }, |
| [6888](#L6888) | { |
| [6889](#L6889) | name: "toggleshow", |
| [6890](#L6890) | self: true, |
| [6891](#L6891) | handler(e, toggle) { |
| [6892](#L6892) | e.preventDefault(); |
| [6893](#L6893) | this.show(toggle == null ? void 0 : toggle.$el); |
| [6894](#L6894) | } |
| [6895](#L6895) | }, |
| [6896](#L6896) | { |
| [6897](#L6897) | name: "togglehide", |
| [6898](#L6898) | self: true, |
| [6899](#L6899) | handler(e) { |
| [6900](#L6900) | e.preventDefault(); |
| [6901](#L6901) | if (!matches(this.$el, ":focus,:hover")) { |
| [6902](#L6902) | this.hide(); |
| [6903](#L6903) | } |
| [6904](#L6904) | } |
| [6905](#L6905) | }, |
| [6906](#L6906) | { |
| [6907](#L6907) | name: `${pointerEnter} focusin`, |
| [6908](#L6908) | filter: ({ mode }) => includes(mode, "hover"), |
| [6909](#L6909) | handler(e) { |
| [6910](#L6910) | if (!isTouch(e)) { |
| [6911](#L6911) | this.clearTimers(); |
| [6912](#L6912) | } |
| [6913](#L6913) | } |
| [6914](#L6914) | }, |
| [6915](#L6915) | { |
| [6916](#L6916) | name: `${pointerLeave} focusout`, |
| [6917](#L6917) | filter: ({ mode }) => includes(mode, "hover"), |
| [6918](#L6918) | handler(e) { |
| [6919](#L6919) | if (!isTouch(e) && e.relatedTarget) { |
| [6920](#L6920) | this.hide(); |
| [6921](#L6921) | } |
| [6922](#L6922) | } |
| [6923](#L6923) | }, |
| [6924](#L6924) | { |
| [6925](#L6925) | name: "toggled", |
| [6926](#L6926) | self: true, |
| [6927](#L6927) | handler(e, toggled) { |
| [6928](#L6928) | if (toggled) { |
| [6929](#L6929) | this.clearTimers(); |
| [6930](#L6930) | this.position(); |
| [6931](#L6931) | } |
| [6932](#L6932) | } |
| [6933](#L6933) | }, |
| [6934](#L6934) | { |
| [6935](#L6935) | name: "show", |
| [6936](#L6936) | self: true, |
| [6937](#L6937) | handler() { |
| [6938](#L6938) | active = this; |
| [6939](#L6939) | this.tracker.init(); |
| [6940](#L6940) | attr(this.targetEl, "aria-expanded", true); |
| [6941](#L6941) | const handlers = [ |
| [6942](#L6942) | listenForResize(this), |
| [6943](#L6943) | listenForEscClose(this), |
| [6944](#L6944) | listenForBackgroundClose(this), |
| [6945](#L6945) | this.autoUpdate && listenForScroll(this), |
| [6946](#L6946) | this.closeOnScroll && listenForScrollClose(this) |
| [6947](#L6947) | ]; |
| [6948](#L6948) | once(this.$el, "hide", () => handlers.forEach((handler) => handler && handler()), { |
| [6949](#L6949) | self: true |
| [6950](#L6950) | }); |
| [6951](#L6951) | if (!this.bgScroll) { |
| [6952](#L6952) | once(this.$el, "hidden", preventBackgroundScroll(this.$el), { self: true }); |
| [6953](#L6953) | } |
| [6954](#L6954) | } |
| [6955](#L6955) | }, |
| [6956](#L6956) | { |
| [6957](#L6957) | name: "beforehide", |
| [6958](#L6958) | self: true, |
| [6959](#L6959) | handler: "clearTimers" |
| [6960](#L6960) | }, |
| [6961](#L6961) | { |
| [6962](#L6962) | name: "hide", |
| [6963](#L6963) | handler({ target }) { |
| [6964](#L6964) | if (this.$el !== target) { |
| [6965](#L6965) | active = active === null && this.$el.contains(target) && this.isToggled() ? this : active; |
| [6966](#L6966) | return; |
| [6967](#L6967) | } |
| [6968](#L6968) | active = this.isActive() ? null : active; |
| [6969](#L6969) | this.tracker.cancel(); |
| [6970](#L6970) | attr(this.targetEl, "aria-expanded", null); |
| [6971](#L6971) | } |
| [6972](#L6972) | } |
| [6973](#L6973) | ], |
| [6974](#L6974) | update: { |
| [6975](#L6975) | write() { |
| [6976](#L6976) | if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) { |
| [6977](#L6977) | this.position(); |
| [6978](#L6978) | } |
| [6979](#L6979) | } |
| [6980](#L6980) | }, |
| [6981](#L6981) | methods: { |
| [6982](#L6982) | show(target = this.targetEl, delay = true) { |
| [6983](#L6983) | if (this.isToggled() && target && this.targetEl && target !== this.targetEl) { |
| [6984](#L6984) | this.hide(false, false); |
| [6985](#L6985) | } |
| [6986](#L6986) | this.targetEl = target; |
| [6987](#L6987) | this.clearTimers(); |
| [6988](#L6988) | if (this.isActive()) { |
| [6989](#L6989) | return; |
| [6990](#L6990) | } |
| [6991](#L6991) | if (active) { |
| [6992](#L6992) | if (delay && active.isDelaying()) { |
| [6993](#L6993) | this.showTimer = setTimeout(() => matches(target, ":hover") && this.show(), 10); |
| [6994](#L6994) | return; |
| [6995](#L6995) | } |
| [6996](#L6996) | let prev; |
| [6997](#L6997) | while (active && prev !== active && !active.$el.contains(this.$el)) { |
| [6998](#L6998) | prev = active; |
| [6999](#L6999) | active.hide(false, false); |
| [7000](#L7000) | } |
| [7001](#L7001) | } |
| [7002](#L7002) | if (this.container && parent(this.$el) !== this.container) { |
| [7003](#L7003) | append(this.container, this.$el); |
| [7004](#L7004) | } |
| [7005](#L7005) | this.showTimer = setTimeout( |
| [7006](#L7006) | () => this.toggleElement(this.$el, true), |
| [7007](#L7007) | delay && this.delayShow || 0 |
| [7008](#L7008) | ); |
| [7009](#L7009) | }, |
| [7010](#L7010) | hide(delay = true, animate = true) { |
| [7011](#L7011) | const hide = () => this.toggleElement(this.$el, false, this.animateOut && animate); |
| [7012](#L7012) | this.clearTimers(); |
| [7013](#L7013) | this.isDelayedHide = delay; |
| [7014](#L7014) | if (delay && this.isDelaying()) { |
| [7015](#L7015) | this.hideTimer = setTimeout(this.hide, 50); |
| [7016](#L7016) | } else if (delay && this.delayHide) { |
| [7017](#L7017) | this.hideTimer = setTimeout(hide, this.delayHide); |
| [7018](#L7018) | } else { |
| [7019](#L7019) | hide(); |
| [7020](#L7020) | } |
| [7021](#L7021) | }, |
| [7022](#L7022) | clearTimers() { |
| [7023](#L7023) | clearTimeout(this.showTimer); |
| [7024](#L7024) | clearTimeout(this.hideTimer); |
| [7025](#L7025) | this.showTimer = null; |
| [7026](#L7026) | this.hideTimer = null; |
| [7027](#L7027) | }, |
| [7028](#L7028) | isActive() { |
| [7029](#L7029) | return active === this; |
| [7030](#L7030) | }, |
| [7031](#L7031) | isDelaying() { |
| [7032](#L7032) | return [this.$el, ...$$(".bdt-drop", this.$el)].some((el) => this.tracker.movesTo(el)); |
| [7033](#L7033) | }, |
| [7034](#L7034) | position() { |
| [7035](#L7035) | const restoreScrollPosition = storeScrollPosition(this.$el); |
| [7036](#L7036) | removeClass(this.$el, "bdt-drop-stack"); |
| [7037](#L7037) | css(this.$el, this.\_style); |
| [7038](#L7038) | this.$el.hidden = true; |
| [7039](#L7039) | const viewports = this.target.map((target) => getViewport$1(this.$el, target)); |
| [7040](#L7040) | const viewportOffset = this.getViewportOffset(this.$el); |
| [7041](#L7041) | const dirs = [ |
| [7042](#L7042) | [0, ["x", "width", "left", "right"]], |
| [7043](#L7043) | [1, ["y", "height", "top", "bottom"]] |
| [7044](#L7044) | ]; |
| [7045](#L7045) | for (const [i, [axis, prop]] of dirs) { |
| [7046](#L7046) | if (this.axis !== axis && includes([axis, true], this.stretch)) { |
| [7047](#L7047) | css(this.$el, { |
| [7048](#L7048) | [prop]: Math.min( |
| [7049](#L7049) | offset(this.boundary[i])[prop], |
| [7050](#L7050) | viewports[i][prop] - 2 \* viewportOffset |
| [7051](#L7051) | ), |
| [7052](#L7052) | [`overflow-${axis}`]: "auto" |
| [7053](#L7053) | }); |
| [7054](#L7054) | } |
| [7055](#L7055) | } |
| [7056](#L7056) | const maxWidth = viewports[0].width - 2 \* viewportOffset; |
| [7057](#L7057) | this.$el.hidden = false; |
| [7058](#L7058) | css(this.$el, "maxWidth", ""); |
| [7059](#L7059) | if (this.$el.offsetWidth > maxWidth) { |
| [7060](#L7060) | addClass(this.$el, "bdt-drop-stack"); |
| [7061](#L7061) | } |
| [7062](#L7062) | css(this.$el, "maxWidth", maxWidth); |
| [7063](#L7063) | this.positionAt(this.$el, this.target, this.boundary); |
| [7064](#L7064) | for (const [i, [axis, prop, start, end]] of dirs) { |
| [7065](#L7065) | if (this.axis === axis && includes([axis, true], this.stretch)) { |
| [7066](#L7066) | const positionOffset = Math.abs(this.getPositionOffset()); |
| [7067](#L7067) | const targetOffset = offset(this.target[i]); |
| [7068](#L7068) | const elOffset = offset(this.$el); |
| [7069](#L7069) | css(this.$el, { |
| [7070](#L7070) | [prop]: (targetOffset[start] > elOffset[start] ? targetOffset[this.inset ? end : start] - Math.max( |
| [7071](#L7071) | offset(this.boundary[i])[start], |
| [7072](#L7072) | viewports[i][start] + viewportOffset |
| [7073](#L7073) | ) : Math.min( |
| [7074](#L7074) | offset(this.boundary[i])[end], |
| [7075](#L7075) | viewports[i][end] - viewportOffset |
| [7076](#L7076) | ) - targetOffset[this.inset ? start : end]) - positionOffset, |
| [7077](#L7077) | [`overflow-${axis}`]: "auto" |
| [7078](#L7078) | }); |
| [7079](#L7079) | this.positionAt(this.$el, this.target, this.boundary); |
| [7080](#L7080) | } |
| [7081](#L7081) | } |
| [7082](#L7082) | restoreScrollPosition(); |
| [7083](#L7083) | } |
| [7084](#L7084) | } |
| [7085](#L7085) | }; |
| [7086](#L7086) | function getViewport$1(el, target) { |
| [7087](#L7087) | return offsetViewport(overflowParents(target).find((parent2) => parent2.contains(el))); |
| [7088](#L7088) | } |
| [7089](#L7089) | function createToggleComponent(drop) { |
| [7090](#L7090) | const { $el } = drop.$create("toggle", query(drop.toggle, drop.$el), { |
| [7091](#L7091) | target: drop.$el, |
| [7092](#L7092) | mode: drop.mode |
| [7093](#L7093) | }); |
| [7094](#L7094) | attr($el, "aria-haspopup", true); |
| [7095](#L7095) | return $el; |
| [7096](#L7096) | } |
| [7097](#L7097) | function listenForResize(drop) { |
| [7098](#L7098) | const update = () => drop.$emit(); |
| [7099](#L7099) | const off = [ |
| [7100](#L7100) | observeViewportResize(update), |
| [7101](#L7101) | observeResize(overflowParents(drop.$el).concat(drop.target), update) |
| [7102](#L7102) | ]; |
| [7103](#L7103) | return () => off.map((observer) => observer.disconnect()); |
| [7104](#L7104) | } |
| [7105](#L7105) | function listenForScroll(drop, fn = () => drop.$emit()) { |
| [7106](#L7106) | return on([document, ...overflowParents(drop.$el)], "scroll", fn, { |
| [7107](#L7107) | passive: true |
| [7108](#L7108) | }); |
| [7109](#L7109) | } |
| [7110](#L7110) | function listenForEscClose(drop) { |
| [7111](#L7111) | return on(document, "keydown", (e) => { |
| [7112](#L7112) | if (e.keyCode === keyMap.ESC) { |
| [7113](#L7113) | drop.hide(false); |
| [7114](#L7114) | } |
| [7115](#L7115) | }); |
| [7116](#L7116) | } |
| [7117](#L7117) | function listenForScrollClose(drop) { |
| [7118](#L7118) | return listenForScroll(drop, () => drop.hide(false)); |
| [7119](#L7119) | } |
| [7120](#L7120) | function listenForBackgroundClose(drop) { |
| [7121](#L7121) | return on(document, pointerDown$1, ({ target }) => { |
| [7122](#L7122) | if (drop.$el.contains(target)) { |
| [7123](#L7123) | return; |
| [7124](#L7124) | } |
| [7125](#L7125) | once( |
| [7126](#L7126) | document, |
| [7127](#L7127) | `${pointerUp$1} ${pointerCancel} scroll`, |
| [7128](#L7128) | ({ defaultPrevented, type, target: newTarget }) => { |
| [7129](#L7129) | var \_a; |
| [7130](#L7130) | if (!defaultPrevented && type === pointerUp$1 && target === newTarget && !((\_a = drop.targetEl) == null ? void 0 : \_a.contains(target))) { |
| [7131](#L7131) | drop.hide(false); |
| [7132](#L7132) | } |
| [7133](#L7133) | }, |
| [7134](#L7134) | true |
| [7135](#L7135) | ); |
| [7136](#L7136) | }); |
| [7137](#L7137) | } |
| [7138](#L7138) |  |
| [7139](#L7139) | var Dropnav = { |
| [7140](#L7140) | mixins: [Class, Container], |
| [7141](#L7141) | props: { |
| [7142](#L7142) | align: String, |
| [7143](#L7143) | clsDrop: String, |
| [7144](#L7144) | boundary: Boolean, |
| [7145](#L7145) | dropbar: Boolean, |
| [7146](#L7146) | dropbarAnchor: Boolean, |
| [7147](#L7147) | duration: Number, |
| [7148](#L7148) | mode: Boolean, |
| [7149](#L7149) | offset: Boolean, |
| [7150](#L7150) | stretch: Boolean, |
| [7151](#L7151) | delayShow: Boolean, |
| [7152](#L7152) | delayHide: Boolean, |
| [7153](#L7153) | target: Boolean, |
| [7154](#L7154) | targetX: Boolean, |
| [7155](#L7155) | targetY: Boolean, |
| [7156](#L7156) | animation: Boolean, |
| [7157](#L7157) | animateOut: Boolean, |
| [7158](#L7158) | closeOnScroll: Boolean |
| [7159](#L7159) | }, |
| [7160](#L7160) | data: { |
| [7161](#L7161) | align: isRtl ? "right" : "left", |
| [7162](#L7162) | clsDrop: "bdt-dropdown", |
| [7163](#L7163) | clsDropbar: "bdt-dropnav-dropbar", |
| [7164](#L7164) | boundary: true, |
| [7165](#L7165) | dropbar: false, |
| [7166](#L7166) | dropbarAnchor: false, |
| [7167](#L7167) | duration: 200, |
| [7168](#L7168) | container: false, |
| [7169](#L7169) | selNavItem: "> li > a, > ul > li > a" |
| [7170](#L7170) | }, |
| [7171](#L7171) | computed: { |
| [7172](#L7172) | dropbarAnchor: ({ dropbarAnchor }, $el) => query(dropbarAnchor, $el) || $el, |
| [7173](#L7173) | dropbar({ dropbar }) { |
| [7174](#L7174) | if (!dropbar) { |
| [7175](#L7175) | return null; |
| [7176](#L7176) | } |
| [7177](#L7177) | dropbar = this.\_dropbar || query(dropbar, this.$el) || $(`+ .${this.clsDropbar}`, this.$el); |
| [7178](#L7178) | return dropbar ? dropbar : this.\_dropbar = $("<div></div>"); |
| [7179](#L7179) | }, |
| [7180](#L7180) | dropContainer(\_, $el) { |
| [7181](#L7181) | return this.container || $el; |
| [7182](#L7182) | }, |
| [7183](#L7183) | dropdowns({ clsDrop }, $el) { |
| [7184](#L7184) | var \_a; |
| [7185](#L7185) | const dropdowns = $$(`.${clsDrop}`, $el); |
| [7186](#L7186) | if (this.dropContainer !== $el) { |
| [7187](#L7187) | for (const el of $$(`.${clsDrop}`, this.dropContainer)) { |
| [7188](#L7188) | const target = (\_a = this.getDropdown(el)) == null ? void 0 : \_a.targetEl; |
| [7189](#L7189) | if (!includes(dropdowns, el) && target && this.$el.contains(target)) { |
| [7190](#L7190) | dropdowns.push(el); |
| [7191](#L7191) | } |
| [7192](#L7192) | } |
| [7193](#L7193) | } |
| [7194](#L7194) | return dropdowns; |
| [7195](#L7195) | }, |
| [7196](#L7196) | items({ selNavItem }, $el) { |
| [7197](#L7197) | return $$(selNavItem, $el); |
| [7198](#L7198) | } |
| [7199](#L7199) | }, |
| [7200](#L7200) | watch: { |
| [7201](#L7201) | dropbar(dropbar) { |
| [7202](#L7202) | addClass( |
| [7203](#L7203) | dropbar, |
| [7204](#L7204) | "bdt-dropbar", |
| [7205](#L7205) | "bdt-dropbar-top", |
| [7206](#L7206) | this.clsDropbar, |
| [7207](#L7207) | `bdt-${this.$options.name}-dropbar` |
| [7208](#L7208) | ); |
| [7209](#L7209) | }, |
| [7210](#L7210) | dropdowns() { |
| [7211](#L7211) | this.initializeDropdowns(); |
| [7212](#L7212) | } |
| [7213](#L7213) | }, |
| [7214](#L7214) | connected() { |
| [7215](#L7215) | this.initializeDropdowns(); |
| [7216](#L7216) | }, |
| [7217](#L7217) | disconnected() { |
| [7218](#L7218) | remove$1(this.\_dropbar); |
| [7219](#L7219) | delete this.\_dropbar; |
| [7220](#L7220) | }, |
| [7221](#L7221) | events: [ |
| [7222](#L7222) | { |
| [7223](#L7223) | name: "mouseover focusin", |
| [7224](#L7224) | delegate: ({ selNavItem }) => selNavItem, |
| [7225](#L7225) | handler({ current }) { |
| [7226](#L7226) | const active2 = this.getActive(); |
| [7227](#L7227) | if (active2 && includes(active2.mode, "hover") && active2.targetEl && !current.contains(active2.targetEl) && !active2.isDelaying()) { |
| [7228](#L7228) | active2.hide(false); |
| [7229](#L7229) | } |
| [7230](#L7230) | } |
| [7231](#L7231) | }, |
| [7232](#L7232) | { |
| [7233](#L7233) | name: "keydown", |
| [7234](#L7234) | self: true, |
| [7235](#L7235) | delegate: ({ selNavItem }) => selNavItem, |
| [7236](#L7236) | handler(e) { |
| [7237](#L7237) | var \_a; |
| [7238](#L7238) | const { current, keyCode } = e; |
| [7239](#L7239) | const active2 = this.getActive(); |
| [7240](#L7240) | if (keyCode === keyMap.DOWN && (active2 == null ? void 0 : active2.targetEl) === current) { |
| [7241](#L7241) | e.preventDefault(); |
| [7242](#L7242) | (\_a = $(selFocusable, active2.$el)) == null ? void 0 : \_a.focus(); |
| [7243](#L7243) | } |
| [7244](#L7244) | handleNavItemNavigation(e, this.items, active2); |
| [7245](#L7245) | } |
| [7246](#L7246) | }, |
| [7247](#L7247) | { |
| [7248](#L7248) | name: "keydown", |
| [7249](#L7249) | el: ({ dropContainer }) => dropContainer, |
| [7250](#L7250) | delegate: ({ clsDrop }) => `.${clsDrop}`, |
| [7251](#L7251) | handler(e) { |
| [7252](#L7252) | var \_a; |
| [7253](#L7253) | const { current, keyCode, target } = e; |
| [7254](#L7254) | if (isInput(target) || !includes(this.dropdowns, current)) { |
| [7255](#L7255) | return; |
| [7256](#L7256) | } |
| [7257](#L7257) | const active2 = this.getActive(); |
| [7258](#L7258) | let next = -1; |
| [7259](#L7259) | if (keyCode === keyMap.HOME) { |
| [7260](#L7260) | next = 0; |
| [7261](#L7261) | } else if (keyCode === keyMap.END) { |
| [7262](#L7262) | next = "last"; |
| [7263](#L7263) | } else if (keyCode === keyMap.UP) { |
| [7264](#L7264) | next = "previous"; |
| [7265](#L7265) | } else if (keyCode === keyMap.DOWN) { |
| [7266](#L7266) | next = "next"; |
| [7267](#L7267) | } else if (keyCode === keyMap.ESC) { |
| [7268](#L7268) | (\_a = active2.targetEl) == null ? void 0 : \_a.focus(); |
| [7269](#L7269) | } |
| [7270](#L7270) | if (~next) { |
| [7271](#L7271) | e.preventDefault(); |
| [7272](#L7272) | const elements = $$(selFocusable, current); |
| [7273](#L7273) | elements[getIndex( |
| [7274](#L7274) | next, |
| [7275](#L7275) | elements, |
| [7276](#L7276) | findIndex(elements, (el) => matches(el, ":focus")) |
| [7277](#L7277) | )].focus(); |
| [7278](#L7278) | } |
| [7279](#L7279) | handleNavItemNavigation(e, this.items, active2); |
| [7280](#L7280) | } |
| [7281](#L7281) | }, |
| [7282](#L7282) | { |
| [7283](#L7283) | name: "mouseleave", |
| [7284](#L7284) | el: ({ dropbar }) => dropbar, |
| [7285](#L7285) | filter: ({ dropbar }) => dropbar, |
| [7286](#L7286) | handler() { |
| [7287](#L7287) | const active2 = this.getActive(); |
| [7288](#L7288) | if (active2 && includes(active2.mode, "hover") && !this.dropdowns.some((el) => matches(el, ":hover"))) { |
| [7289](#L7289) | active2.hide(); |
| [7290](#L7290) | } |
| [7291](#L7291) | } |
| [7292](#L7292) | }, |
| [7293](#L7293) | { |
| [7294](#L7294) | name: "beforeshow", |
| [7295](#L7295) | el: ({ dropContainer }) => dropContainer, |
| [7296](#L7296) | filter: ({ dropbar }) => dropbar, |
| [7297](#L7297) | handler({ target }) { |
| [7298](#L7298) | if (!this.isDropbarDrop(target)) { |
| [7299](#L7299) | return; |
| [7300](#L7300) | } |
| [7301](#L7301) | if (this.dropbar.previousElementSibling !== this.dropbarAnchor) { |
| [7302](#L7302) | after(this.dropbarAnchor, this.dropbar); |
| [7303](#L7303) | } |
| [7304](#L7304) | addClass(target, `${this.clsDrop}-dropbar`); |
| [7305](#L7305) | } |
| [7306](#L7306) | }, |
| [7307](#L7307) | { |
| [7308](#L7308) | name: "show", |
| [7309](#L7309) | el: ({ dropContainer }) => dropContainer, |
| [7310](#L7310) | filter: ({ dropbar }) => dropbar, |
| [7311](#L7311) | handler({ target }) { |
| [7312](#L7312) | if (!this.isDropbarDrop(target)) { |
| [7313](#L7313) | return; |
| [7314](#L7314) | } |
| [7315](#L7315) | const drop = this.getDropdown(target); |
| [7316](#L7316) | const adjustHeight = () => { |
| [7317](#L7317) | const maxBottom = Math.max( |
| [7318](#L7318) | ...parents(target, `.${this.clsDrop}`).concat(target).map((el) => offset(el).bottom) |
| [7319](#L7319) | ); |
| [7320](#L7320) | offset(this.dropbar, { |
| [7321](#L7321) | left: offset(this.dropbar).left, |
| [7322](#L7322) | top: this.getDropbarOffset(drop.getPositionOffset()) |
| [7323](#L7323) | }); |
| [7324](#L7324) | this.transitionTo( |
| [7325](#L7325) | maxBottom - offset(this.dropbar).top + toFloat(css(target, "marginBottom")), |
| [7326](#L7326) | target |
| [7327](#L7327) | ); |
| [7328](#L7328) | }; |
| [7329](#L7329) | this.\_observer = observeResize([drop.$el, ...drop.target], adjustHeight); |
| [7330](#L7330) | adjustHeight(); |
| [7331](#L7331) | } |
| [7332](#L7332) | }, |
| [7333](#L7333) | { |
| [7334](#L7334) | name: "beforehide", |
| [7335](#L7335) | el: ({ dropContainer }) => dropContainer, |
| [7336](#L7336) | filter: ({ dropbar }) => dropbar, |
| [7337](#L7337) | handler(e) { |
| [7338](#L7338) | const active2 = this.getActive(); |
| [7339](#L7339) | if (matches(this.dropbar, ":hover") && active2.$el === e.target && this.isDropbarDrop(active2.$el) && includes(active2.mode, "hover") && active2.isDelayedHide && !this.items.some((el) => active2.targetEl !== el && matches(el, ":focus"))) { |
| [7340](#L7340) | e.preventDefault(); |
| [7341](#L7341) | } |
| [7342](#L7342) | } |
| [7343](#L7343) | }, |
| [7344](#L7344) | { |
| [7345](#L7345) | name: "hide", |
| [7346](#L7346) | el: ({ dropContainer }) => dropContainer, |
| [7347](#L7347) | filter: ({ dropbar }) => dropbar, |
| [7348](#L7348) | handler({ target }) { |
| [7349](#L7349) | var \_a; |
| [7350](#L7350) | if (!this.isDropbarDrop(target)) { |
| [7351](#L7351) | return; |
| [7352](#L7352) | } |
| [7353](#L7353) | (\_a = this.\_observer) == null ? void 0 : \_a.disconnect(); |
| [7354](#L7354) | const active2 = this.getActive(); |
| [7355](#L7355) | if (!active2 || active2.$el === target) { |
| [7356](#L7356) | this.transitionTo(0); |
| [7357](#L7357) | } |
| [7358](#L7358) | } |
| [7359](#L7359) | } |
| [7360](#L7360) | ], |
| [7361](#L7361) | methods: { |
| [7362](#L7362) | getActive() { |
| [7363](#L7363) | var \_a; |
| [7364](#L7364) | return includes(this.dropdowns, (\_a = active) == null ? void 0 : \_a.$el) && active; |
| [7365](#L7365) | }, |
| [7366](#L7366) | async transitionTo(newHeight, el) { |
| [7367](#L7367) | const { dropbar } = this; |
| [7368](#L7368) | const oldHeight = height(dropbar); |
| [7369](#L7369) | el = oldHeight < newHeight && el; |
| [7370](#L7370) | await Transition.cancel([el, dropbar]); |
| [7371](#L7371) | if (el) { |
| [7372](#L7372) | const diff = offset(el).top - offset(dropbar).top - oldHeight; |
| [7373](#L7373) | if (diff > 0) { |
| [7374](#L7374) | css(el, "transitionDelay", `${diff / newHeight \* this.duration}ms`); |
| [7375](#L7375) | } |
| [7376](#L7376) | } |
| [7377](#L7377) | css(el, "clipPath", `polygon(0 0,100% 0,100% ${oldHeight}px,0 ${oldHeight}px)`); |
| [7378](#L7378) | height(dropbar, oldHeight); |
| [7379](#L7379) | await Promise.all([ |
| [7380](#L7380) | Transition.start(dropbar, { height: newHeight }, this.duration), |
| [7381](#L7381) | Transition.start( |
| [7382](#L7382) | el, |
| [7383](#L7383) | { clipPath: `polygon(0 0,100% 0,100% ${newHeight}px,0 ${newHeight}px)` }, |
| [7384](#L7384) | this.duration |
| [7385](#L7385) | ).finally(() => css(el, { clipPath: "", transitionDelay: "" })) |
| [7386](#L7386) | ]).catch(noop); |
| [7387](#L7387) | }, |
| [7388](#L7388) | getDropdown(el) { |
| [7389](#L7389) | return this.$getComponent(el, "drop") || this.$getComponent(el, "dropdown"); |
| [7390](#L7390) | }, |
| [7391](#L7391) | isDropbarDrop(el) { |
| [7392](#L7392) | return includes(this.dropdowns, el) && hasClass(el, this.clsDrop); |
| [7393](#L7393) | }, |
| [7394](#L7394) | getDropbarOffset(offsetTop) { |
| [7395](#L7395) | const { $el, target, targetY } = this; |
| [7396](#L7396) | const { top, height: height2 } = offset(query(targetY || target || $el, $el)); |
| [7397](#L7397) | return top + height2 + offsetTop; |
| [7398](#L7398) | }, |
| [7399](#L7399) | initializeDropdowns() { |
| [7400](#L7400) | this.$create( |
| [7401](#L7401) | "drop", |
| [7402](#L7402) | this.dropdowns.filter((el) => !this.getDropdown(el)), |
| [7403](#L7403) | { |
| [7404](#L7404) | ...this.$props, |
| [7405](#L7405) | flip: false, |
| [7406](#L7406) | shift: true, |
| [7407](#L7407) | pos: `bottom-${this.align}`, |
| [7408](#L7408) | boundary: this.boundary === true ? this.$el : this.boundary |
| [7409](#L7409) | } |
| [7410](#L7410) | ); |
| [7411](#L7411) | } |
| [7412](#L7412) | } |
| [7413](#L7413) | }; |
| [7414](#L7414) | function handleNavItemNavigation(e, toggles, active2) { |
| [7415](#L7415) | var \_a, \_b, \_c; |
| [7416](#L7416) | const { current, keyCode } = e; |
| [7417](#L7417) | let next = -1; |
| [7418](#L7418) | if (keyCode === keyMap.HOME) { |
| [7419](#L7419) | next = 0; |
| [7420](#L7420) | } else if (keyCode === keyMap.END) { |
| [7421](#L7421) | next = "last"; |
| [7422](#L7422) | } else if (keyCode === keyMap.LEFT) { |
| [7423](#L7423) | next = "previous"; |
| [7424](#L7424) | } else if (keyCode === keyMap.RIGHT) { |
| [7425](#L7425) | next = "next"; |
| [7426](#L7426) | } else if (keyCode === keyMap.TAB) { |
| [7427](#L7427) | (\_a = active2.targetEl) == null ? void 0 : \_a.focus(); |
| [7428](#L7428) | (\_b = active2.hide) == null ? void 0 : \_b.call(active2, false); |
| [7429](#L7429) | } |
| [7430](#L7430) | if (~next) { |
| [7431](#L7431) | e.preventDefault(); |
| [7432](#L7432) | (\_c = active2.hide) == null ? void 0 : \_c.call(active2, false); |
| [7433](#L7433) | toggles[getIndex(next, toggles, toggles.indexOf(active2.targetEl || current))].focus(); |
| [7434](#L7434) | } |
| [7435](#L7435) | } |
| [7436](#L7436) |  |
| [7437](#L7437) | var formCustom = { |
| [7438](#L7438) | mixins: [Class], |
| [7439](#L7439) | args: "target", |
| [7440](#L7440) | props: { |
| [7441](#L7441) | target: Boolean |
| [7442](#L7442) | }, |
| [7443](#L7443) | data: { |
| [7444](#L7444) | target: false |
| [7445](#L7445) | }, |
| [7446](#L7446) | computed: { |
| [7447](#L7447) | input: (\_, $el) => $(selInput, $el), |
| [7448](#L7448) | state() { |
| [7449](#L7449) | return this.input.nextElementSibling; |
| [7450](#L7450) | }, |
| [7451](#L7451) | target({ target }, $el) { |
| [7452](#L7452) | return target && (target === true && parent(this.input) === $el && this.input.nextElementSibling || $(target, $el)); |
| [7453](#L7453) | } |
| [7454](#L7454) | }, |
| [7455](#L7455) | update() { |
| [7456](#L7456) | var \_a; |
| [7457](#L7457) | const { target, input } = this; |
| [7458](#L7458) | if (!target) { |
| [7459](#L7459) | return; |
| [7460](#L7460) | } |
| [7461](#L7461) | let option; |
| [7462](#L7462) | const prop = isInput(target) ? "value" : "textContent"; |
| [7463](#L7463) | const prev = target[prop]; |
| [7464](#L7464) | const value = ((\_a = input.files) == null ? void 0 : \_a[0]) ? input.files[0].name : matches(input, "select") && (option = $$("option", input).filter((el) => el.selected)[0]) ? option.textContent : input.value; |
| [7465](#L7465) | if (prev !== value) { |
| [7466](#L7466) | target[prop] = value; |
| [7467](#L7467) | } |
| [7468](#L7468) | }, |
| [7469](#L7469) | events: [ |
| [7470](#L7470) | { |
| [7471](#L7471) | name: "change", |
| [7472](#L7472) | handler() { |
| [7473](#L7473) | this.$emit(); |
| [7474](#L7474) | } |
| [7475](#L7475) | }, |
| [7476](#L7476) | { |
| [7477](#L7477) | name: "reset", |
| [7478](#L7478) | el: ({ $el }) => $el.closest("form"), |
| [7479](#L7479) | handler() { |
| [7480](#L7480) | this.$emit(); |
| [7481](#L7481) | } |
| [7482](#L7482) | } |
| [7483](#L7483) | ] |
| [7484](#L7484) | }; |
| [7485](#L7485) |  |
| [7486](#L7486) | var grid = { |
| [7487](#L7487) | extends: Margin, |
| [7488](#L7488) | mixins: [Class], |
| [7489](#L7489) | name: "grid", |
| [7490](#L7490) | props: { |
| [7491](#L7491) | masonry: Boolean, |
| [7492](#L7492) | parallax: String, |
| [7493](#L7493) | parallaxStart: String, |
| [7494](#L7494) | parallaxEnd: String, |
| [7495](#L7495) | parallaxJustify: Boolean |
| [7496](#L7496) | }, |
| [7497](#L7497) | data: { |
| [7498](#L7498) | margin: "bdt-grid-margin", |
| [7499](#L7499) | clsStack: "bdt-grid-stack", |
| [7500](#L7500) | masonry: false, |
| [7501](#L7501) | parallax: 0, |
| [7502](#L7502) | parallaxStart: 0, |
| [7503](#L7503) | parallaxEnd: 0, |
| [7504](#L7504) | parallaxJustify: false |
| [7505](#L7505) | }, |
| [7506](#L7506) | connected() { |
| [7507](#L7507) | this.masonry && addClass(this.$el, "bdt-flex-top", "bdt-flex-wrap-top"); |
| [7508](#L7508) | }, |
| [7509](#L7509) | observe: scroll$1({ filter: ({ parallax, parallaxJustify }) => parallax || parallaxJustify }), |
| [7510](#L7510) | update: [ |
| [7511](#L7511) | { |
| [7512](#L7512) | write({ rows }) { |
| [7513](#L7513) | toggleClass(this.$el, this.clsStack, !rows.some((row) => row.length > 1)); |
| [7514](#L7514) | }, |
| [7515](#L7515) | events: ["resize"] |
| [7516](#L7516) | }, |
| [7517](#L7517) | { |
| [7518](#L7518) | read(data) { |
| [7519](#L7519) | const { rows } = data; |
| [7520](#L7520) | let { masonry, parallax, parallaxJustify, margin } = this; |
| [7521](#L7521) | parallax = Math.max(0, toPx(parallax)); |
| [7522](#L7522) | if (!(masonry || parallax || parallaxJustify) || positionedAbsolute(rows) || rows[0].some( |
| [7523](#L7523) | (el, i) => rows.some((row) => row[i] && row[i].offsetWidth !== el.offsetWidth) |
| [7524](#L7524) | )) { |
| [7525](#L7525) | return data.translates = data.scrollColumns = false; |
| [7526](#L7526) | } |
| [7527](#L7527) | let gutter = getGutter(rows, margin); |
| [7528](#L7528) | let columns; |
| [7529](#L7529) | let translates; |
| [7530](#L7530) | if (masonry) { |
| [7531](#L7531) | [columns, translates] = applyMasonry(rows, gutter, masonry === "next"); |
| [7532](#L7532) | } else { |
| [7533](#L7533) | columns = transpose(rows); |
| [7534](#L7534) | } |
| [7535](#L7535) | const columnHeights = columns.map( |
| [7536](#L7536) | (column) => sumBy(column, "offsetHeight") + gutter \* (column.length - 1) |
| [7537](#L7537) | ); |
| [7538](#L7538) | const height = Math.max(0, ...columnHeights); |
| [7539](#L7539) | let scrollColumns; |
| [7540](#L7540) | let parallaxStart; |
| [7541](#L7541) | let parallaxEnd; |
| [7542](#L7542) | if (parallax || parallaxJustify) { |
| [7543](#L7543) | scrollColumns = columnHeights.map( |
| [7544](#L7544) | (hgt, i) => parallaxJustify ? height - hgt + parallax : parallax / (i % 2 || 8) |
| [7545](#L7545) | ); |
| [7546](#L7546) | if (!parallaxJustify) { |
| [7547](#L7547) | parallax = Math.max( |
| [7548](#L7548) | ...columnHeights.map((hgt, i) => hgt + scrollColumns[i] - height) |
| [7549](#L7549) | ); |
| [7550](#L7550) | } |
| [7551](#L7551) | parallaxStart = toPx(this.parallaxStart, "height", this.$el, true); |
| [7552](#L7552) | parallaxEnd = toPx(this.parallaxEnd, "height", this.$el, true); |
| [7553](#L7553) | } |
| [7554](#L7554) | return { |
| [7555](#L7555) | columns, |
| [7556](#L7556) | translates, |
| [7557](#L7557) | scrollColumns, |
| [7558](#L7558) | parallaxStart, |
| [7559](#L7559) | parallaxEnd, |
| [7560](#L7560) | padding: parallax, |
| [7561](#L7561) | height: translates ? height : "" |
| [7562](#L7562) | }; |
| [7563](#L7563) | }, |
| [7564](#L7564) | write({ height, padding }) { |
| [7565](#L7565) | css(this.$el, "paddingBottom", padding || ""); |
| [7566](#L7566) | height !== false && css(this.$el, "height", height); |
| [7567](#L7567) | }, |
| [7568](#L7568) | events: ["resize"] |
| [7569](#L7569) | }, |
| [7570](#L7570) | { |
| [7571](#L7571) | read({ rows, scrollColumns, parallaxStart, parallaxEnd }) { |
| [7572](#L7572) | return { |
| [7573](#L7573) | scrolled: scrollColumns && !positionedAbsolute(rows) ? scrolledOver(this.$el, parallaxStart, parallaxEnd) : false |
| [7574](#L7574) | }; |
| [7575](#L7575) | }, |
| [7576](#L7576) | write({ columns, scrolled, scrollColumns, translates }) { |
| [7577](#L7577) | if (!scrolled && !translates) { |
| [7578](#L7578) | return; |
| [7579](#L7579) | } |
| [7580](#L7580) | columns.forEach( |
| [7581](#L7581) | (column, i) => column.forEach((el, j) => { |
| [7582](#L7582) | let [x, y] = translates && translates[i][j] || [0, 0]; |
| [7583](#L7583) | if (scrolled) { |
| [7584](#L7584) | y += scrolled \* scrollColumns[i]; |
| [7585](#L7585) | } |
| [7586](#L7586) | css(el, "transform", `translate(${x}px, ${y}px)`); |
| [7587](#L7587) | }) |
| [7588](#L7588) | ); |
| [7589](#L7589) | }, |
| [7590](#L7590) | events: ["scroll", "resize"] |
| [7591](#L7591) | } |
| [7592](#L7592) | ] |
| [7593](#L7593) | }; |
| [7594](#L7594) | function positionedAbsolute(rows) { |
| [7595](#L7595) | return rows.flat().some((el) => css(el, "position") === "absolute"); |
| [7596](#L7596) | } |
| [7597](#L7597) | function applyMasonry(rows, gutter, next) { |
| [7598](#L7598) | const columns = []; |
| [7599](#L7599) | const translates = []; |
| [7600](#L7600) | const columnHeights = Array(rows[0].length).fill(0); |
| [7601](#L7601) | let rowHeights = 0; |
| [7602](#L7602) | for (let row of rows) { |
| [7603](#L7603) | if (isRtl) { |
| [7604](#L7604) | row = row.reverse(); |
| [7605](#L7605) | } |
| [7606](#L7606) | let height = 0; |
| [7607](#L7607) | for (const j in row) { |
| [7608](#L7608) | const { offsetWidth, offsetHeight } = row[j]; |
| [7609](#L7609) | const index = next ? j : columnHeights.indexOf(Math.min(...columnHeights)); |
| [7610](#L7610) | push(columns, index, row[j]); |
| [7611](#L7611) | push(translates, index, [ |
| [7612](#L7612) | (index - j) \* offsetWidth \* (isRtl ? -1 : 1), |
| [7613](#L7613) | columnHeights[index] - rowHeights |
| [7614](#L7614) | ]); |
| [7615](#L7615) | columnHeights[index] += offsetHeight + gutter; |
| [7616](#L7616) | height = Math.max(height, offsetHeight); |
| [7617](#L7617) | } |
| [7618](#L7618) | rowHeights += height + gutter; |
| [7619](#L7619) | } |
| [7620](#L7620) | return [columns, translates]; |
| [7621](#L7621) | } |
| [7622](#L7622) | function getGutter(rows, cls) { |
| [7623](#L7623) | const node = rows.flat().find((el) => hasClass(el, cls)); |
| [7624](#L7624) | return toFloat(node ? css(node, "marginTop") : css(rows[0][0], "paddingLeft")); |
| [7625](#L7625) | } |
| [7626](#L7626) | function transpose(rows) { |
| [7627](#L7627) | const columns = []; |
| [7628](#L7628) | for (const row of rows) { |
| [7629](#L7629) | for (const i in row) { |
| [7630](#L7630) | push(columns, i, row[i]); |
| [7631](#L7631) | } |
| [7632](#L7632) | } |
| [7633](#L7633) | return columns; |
| [7634](#L7634) | } |
| [7635](#L7635) | function push(array, index, value) { |
| [7636](#L7636) | if (!array[index]) { |
| [7637](#L7637) | array[index] = []; |
| [7638](#L7638) | } |
| [7639](#L7639) | array[index].push(value); |
| [7640](#L7640) | } |
| [7641](#L7641) |  |
| [7642](#L7642) | var heightMatch = { |
| [7643](#L7643) | args: "target", |
| [7644](#L7644) | props: { |
| [7645](#L7645) | target: String, |
| [7646](#L7646) | row: Boolean |
| [7647](#L7647) | }, |
| [7648](#L7648) | data: { |
| [7649](#L7649) | target: "> \*", |
| [7650](#L7650) | row: true |
| [7651](#L7651) | }, |
| [7652](#L7652) | computed: { |
| [7653](#L7653) | elements: ({ target }, $el) => $$(target, $el) |
| [7654](#L7654) | }, |
| [7655](#L7655) | observe: resize({ |
| [7656](#L7656) | target: ({ $el, elements }) => elements.reduce((elements2, el) => elements2.concat(el, ...el.children), [$el]) |
| [7657](#L7657) | }), |
| [7658](#L7658) | events: { |
| [7659](#L7659) | // Hidden elements may change height when fonts load |
| [7660](#L7660) | name: "loadingdone", |
| [7661](#L7661) | el: () => document.fonts, |
| [7662](#L7662) | handler() { |
| [7663](#L7663) | this.$emit("resize"); |
| [7664](#L7664) | } |
| [7665](#L7665) | }, |
| [7666](#L7666) | update: { |
| [7667](#L7667) | read() { |
| [7668](#L7668) | return { |
| [7669](#L7669) | rows: (this.row ? getRows(this.elements) : [this.elements]).map(match) |
| [7670](#L7670) | }; |
| [7671](#L7671) | }, |
| [7672](#L7672) | write({ rows }) { |
| [7673](#L7673) | for (const { heights, elements } of rows) { |
| [7674](#L7674) | elements.forEach((el, i) => css(el, "minHeight", heights[i])); |
| [7675](#L7675) | } |
| [7676](#L7676) | }, |
| [7677](#L7677) | events: ["resize"] |
| [7678](#L7678) | } |
| [7679](#L7679) | }; |
| [7680](#L7680) | function match(elements) { |
| [7681](#L7681) | if (elements.length < 2) { |
| [7682](#L7682) | return { heights: [""], elements }; |
| [7683](#L7683) | } |
| [7684](#L7684) | let heights = elements.map(getHeight); |
| [7685](#L7685) | const max = Math.max(...heights); |
| [7686](#L7686) | return { |
| [7687](#L7687) | heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? "" : max), |
| [7688](#L7688) | elements |
| [7689](#L7689) | }; |
| [7690](#L7690) | } |
| [7691](#L7691) | function getHeight(element) { |
| [7692](#L7692) | const style = pick(element.style, ["display", "minHeight"]); |
| [7693](#L7693) | if (!isVisible(element)) { |
| [7694](#L7694) | css(element, "display", "block", "important"); |
| [7695](#L7695) | } |
| [7696](#L7696) | css(element, "minHeight", ""); |
| [7697](#L7697) | const height = dimensions$1(element).height - boxModelAdjust(element, "height", "content-box"); |
| [7698](#L7698) | css(element, style); |
| [7699](#L7699) | return height; |
| [7700](#L7700) | } |
| [7701](#L7701) |  |
| [7702](#L7702) | var heightPlaceholder = { |
| [7703](#L7703) | args: "target", |
| [7704](#L7704) | props: { |
| [7705](#L7705) | target: String |
| [7706](#L7706) | }, |
| [7707](#L7707) | data: { |
| [7708](#L7708) | target: "" |
| [7709](#L7709) | }, |
| [7710](#L7710) | computed: { |
| [7711](#L7711) | target: { |
| [7712](#L7712) | get: ({ target }, $el) => query(target, $el), |
| [7713](#L7713) | observe: ({ target }) => target |
| [7714](#L7714) | } |
| [7715](#L7715) | }, |
| [7716](#L7716) | observe: resize({ target: ({ target }) => target }), |
| [7717](#L7717) | update: { |
| [7718](#L7718) | read() { |
| [7719](#L7719) | return this.target ? { height: this.target.offsetHeight } : false; |
| [7720](#L7720) | }, |
| [7721](#L7721) | write({ height }) { |
| [7722](#L7722) | css(this.$el, { minHeight: height }); |
| [7723](#L7723) | }, |
| [7724](#L7724) | events: ["resize"] |
| [7725](#L7725) | } |
| [7726](#L7726) | }; |
| [7727](#L7727) |  |
| [7728](#L7728) | var heightViewport = { |
| [7729](#L7729) | props: { |
| [7730](#L7730) | expand: Boolean, |
| [7731](#L7731) | offsetTop: Boolean, |
| [7732](#L7732) | offsetBottom: Boolean, |
| [7733](#L7733) | minHeight: Number |
| [7734](#L7734) | }, |
| [7735](#L7735) | data: { |
| [7736](#L7736) | expand: false, |
| [7737](#L7737) | offsetTop: false, |
| [7738](#L7738) | offsetBottom: false, |
| [7739](#L7739) | minHeight: 0 |
| [7740](#L7740) | }, |
| [7741](#L7741) | // check for offsetTop change |
| [7742](#L7742) | observe: [ |
| [7743](#L7743) | viewport({ filter: ({ expand }) => expand }), |
| [7744](#L7744) | resize({ target: ({ $el }) => scrollParents($el) }) |
| [7745](#L7745) | ], |
| [7746](#L7746) | update: { |
| [7747](#L7747) | read() { |
| [7748](#L7748) | if (!isVisible(this.$el)) { |
| [7749](#L7749) | return false; |
| [7750](#L7750) | } |
| [7751](#L7751) | let minHeight = ""; |
| [7752](#L7752) | const box = boxModelAdjust(this.$el, "height", "content-box"); |
| [7753](#L7753) | const { body, scrollingElement } = document; |
| [7754](#L7754) | const scrollElement = scrollParent(this.$el); |
| [7755](#L7755) | const { height: viewportHeight } = offsetViewport( |
| [7756](#L7756) | scrollElement === body ? scrollingElement : scrollElement |
| [7757](#L7757) | ); |
| [7758](#L7758) | const isScrollingElement = scrollingElement === scrollElement || body === scrollElement; |
| [7759](#L7759) | minHeight = `calc(${isScrollingElement ? "100vh" : `${viewportHeight}px`}`; |
| [7760](#L7760) | if (this.expand) { |
| [7761](#L7761) | const diff = dimensions$1(scrollElement).height - dimensions$1(this.$el).height; |
| [7762](#L7762) | minHeight += ` - ${diff}px`; |
| [7763](#L7763) | } else { |
| [7764](#L7764) | if (this.offsetTop) { |
| [7765](#L7765) | if (isScrollingElement) { |
| [7766](#L7766) | const offsetTopEl = this.offsetTop === true ? this.$el : query(this.offsetTop, this.$el); |
| [7767](#L7767) | const { top } = offset(offsetTopEl); |
| [7768](#L7768) | minHeight += top > 0 && top < viewportHeight / 2 ? ` - ${top}px` : ""; |
| [7769](#L7769) | } else { |
| [7770](#L7770) | minHeight += ` - ${boxModelAdjust(scrollElement, "height", css(scrollElement, "boxSizing"))}px`; |
| [7771](#L7771) | } |
| [7772](#L7772) | } |
| [7773](#L7773) | if (this.offsetBottom === true) { |
| [7774](#L7774) | minHeight += ` - ${dimensions$1(this.$el.nextElementSibling).height}px`; |
| [7775](#L7775) | } else if (isNumeric(this.offsetBottom)) { |
| [7776](#L7776) | minHeight += ` - ${this.offsetBottom}vh`; |
| [7777](#L7777) | } else if (this.offsetBottom && endsWith(this.offsetBottom, "px")) { |
| [7778](#L7778) | minHeight += ` - ${toFloat(this.offsetBottom)}px`; |
| [7779](#L7779) | } else if (isString(this.offsetBottom)) { |
| [7780](#L7780) | minHeight += ` - ${dimensions$1(query(this.offsetBottom, this.$el)).height}px`; |
| [7781](#L7781) | } |
| [7782](#L7782) | } |
| [7783](#L7783) | minHeight += `${box ? ` - ${box}px` : ""})`; |
| [7784](#L7784) | return { minHeight }; |
| [7785](#L7785) | }, |
| [7786](#L7786) | write({ minHeight }) { |
| [7787](#L7787) | css(this.$el, "minHeight", `max(${this.minHeight || 0}px, ${minHeight})`); |
| [7788](#L7788) | }, |
| [7789](#L7789) | events: ["resize"] |
| [7790](#L7790) | } |
| [7791](#L7791) | }; |
| [7792](#L7792) |  |
| [7793](#L7793) | var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>"; |
| [7794](#L7794) |  |
| [7795](#L7795) | var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>"; |
| [7796](#L7796) |  |
| [7797](#L7797) | var dropParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>"; |
| [7798](#L7798) |  |
| [7799](#L7799) | var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><rect width=\"1\" height=\"11\" x=\"9\" y=\"4\"/><rect width=\"11\" height=\"1\" x=\"4\" y=\"9\"/></svg>"; |
| [7800](#L7800) |  |
| [7801](#L7801) | var navParentIconLarge = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 4 7 10 13 4\"/></svg>"; |
| [7802](#L7802) |  |
| [7803](#L7803) | var navParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>"; |
| [7804](#L7804) |  |
| [7805](#L7805) | var navbarParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>"; |
| [7806](#L7806) |  |
| [7807](#L7807) | var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><style>.bdt-navbar-toggle-icon svg&gt;[class\*=&quot;line-&quot;]{transition:0.2s ease-in-out;transition-property:transform, opacity;transform-origin:center;opacity:1}.bdt-navbar-toggle-icon svg&gt;.line-3{opacity:0}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{opacity:1}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-2{transform:rotate(45deg)}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{transform:rotate(-45deg)}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1,.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{opacity:0}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1{transform:translateY(6px) scaleX(0)}.bdt-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{transform:translateY(-6px) scaleX(0)}</style><rect width=\"20\" height=\"2\" y=\"3\" class=\"line-1\"/><rect width=\"20\" height=\"2\" y=\"9\" class=\"line-2\"/><rect width=\"20\" height=\"2\" y=\"9\" class=\"line-3\"/><rect width=\"20\" height=\"2\" y=\"15\" class=\"line-4\"/></svg>"; |
| [7808](#L7808) |  |
| [7809](#L7809) | var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><rect width=\"1\" height=\"40\" x=\"19\" y=\"0\"/><rect width=\"40\" height=\"1\" x=\"0\" y=\"19\"/></svg>"; |
| [7810](#L7810) |  |
| [7811](#L7811) | var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>"; |
| [7812](#L7812) |  |
| [7813](#L7813) | var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>"; |
| [7814](#L7814) |  |
| [7815](#L7815) | var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>"; |
| [7816](#L7816) |  |
| [7817](#L7817) | var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>"; |
| [7818](#L7818) |  |
| [7819](#L7819) | var searchMedium = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>"; |
| [7820](#L7820) |  |
| [7821](#L7821) | var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5\"/></svg>"; |
| [7822](#L7822) |  |
| [7823](#L7823) | var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1\"/></svg>"; |
| [7824](#L7824) |  |
| [7825](#L7825) | var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547\"/></svg>"; |
| [7826](#L7826) |  |
| [7827](#L7827) | var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23\"/></svg>"; |
| [7828](#L7828) |  |
| [7829](#L7829) | var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>"; |
| [7830](#L7830) |  |
| [7831](#L7831) | var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9\"/></svg>"; |
| [7832](#L7832) |  |
| [7833](#L7833) | var Svg = { |
| [7834](#L7834) | args: "src", |
| [7835](#L7835) | props: { |
| [7836](#L7836) | width: Number, |
| [7837](#L7837) | height: Number, |
| [7838](#L7838) | ratio: Number |
| [7839](#L7839) | }, |
| [7840](#L7840) | data: { |
| [7841](#L7841) | ratio: 1 |
| [7842](#L7842) | }, |
| [7843](#L7843) | connected() { |
| [7844](#L7844) | this.svg = this.getSvg().then((el) => { |
| [7845](#L7845) | if (!this.\_connected) { |
| [7846](#L7846) | return; |
| [7847](#L7847) | } |
| [7848](#L7848) | const svg = insertSVG(el, this.$el); |
| [7849](#L7849) | if (this.svgEl && svg !== this.svgEl) { |
| [7850](#L7850) | remove$1(this.svgEl); |
| [7851](#L7851) | } |
| [7852](#L7852) | applyWidthAndHeight.call(this, svg, el); |
| [7853](#L7853) | return this.svgEl = svg; |
| [7854](#L7854) | }, noop); |
| [7855](#L7855) | }, |
| [7856](#L7856) | disconnected() { |
| [7857](#L7857) | this.svg.then((svg) => { |
| [7858](#L7858) | if (this.\_connected) { |
| [7859](#L7859) | return; |
| [7860](#L7860) | } |
| [7861](#L7861) | if (isVoidElement(this.$el)) { |
| [7862](#L7862) | this.$el.hidden = false; |
| [7863](#L7863) | } |
| [7864](#L7864) | remove$1(svg); |
| [7865](#L7865) | this.svgEl = null; |
| [7866](#L7866) | }); |
| [7867](#L7867) | this.svg = null; |
| [7868](#L7868) | }, |
| [7869](#L7869) | methods: { |
| [7870](#L7870) | async getSvg() { |
| [7871](#L7871) | } |
| [7872](#L7872) | } |
| [7873](#L7873) | }; |
| [7874](#L7874) | function insertSVG(el, root) { |
| [7875](#L7875) | if (isVoidElement(root) || isTag(root, "canvas")) { |
| [7876](#L7876) | root.hidden = true; |
| [7877](#L7877) | const next = root.nextElementSibling; |
| [7878](#L7878) | return equals(el, next) ? next : after(root, el); |
| [7879](#L7879) | } |
| [7880](#L7880) | const last = root.lastElementChild; |
| [7881](#L7881) | return equals(el, last) ? last : append(root, el); |
| [7882](#L7882) | } |
| [7883](#L7883) | function equals(el, other) { |
| [7884](#L7884) | return isTag(el, "svg") && isTag(other, "svg") && el.innerHTML === other.innerHTML; |
| [7885](#L7885) | } |
| [7886](#L7886) | function applyWidthAndHeight(el, ref) { |
| [7887](#L7887) | const props = ["width", "height"]; |
| [7888](#L7888) | let dimensions = props.map((prop) => this[prop]); |
| [7889](#L7889) | if (!dimensions.some((val) => val)) { |
| [7890](#L7890) | dimensions = props.map((prop) => attr(ref, prop)); |
| [7891](#L7891) | } |
| [7892](#L7892) | const viewBox = attr(ref, "viewBox"); |
| [7893](#L7893) | if (viewBox && !dimensions.some((val) => val)) { |
| [7894](#L7894) | dimensions = viewBox.split(" ").slice(2); |
| [7895](#L7895) | } |
| [7896](#L7896) | dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) \* this.ratio || null)); |
| [7897](#L7897) | } |
| [7898](#L7898) |  |
| [7899](#L7899) | var svg = { |
| [7900](#L7900) | mixins: [Svg], |
| [7901](#L7901) | args: "src", |
| [7902](#L7902) | props: { |
| [7903](#L7903) | src: String, |
| [7904](#L7904) | icon: String, |
| [7905](#L7905) | attributes: "list", |
| [7906](#L7906) | strokeAnimation: Boolean |
| [7907](#L7907) | }, |
| [7908](#L7908) | data: { |
| [7909](#L7909) | strokeAnimation: false |
| [7910](#L7910) | }, |
| [7911](#L7911) | observe: [ |
| [7912](#L7912) | mutation({ |
| [7913](#L7913) | async handler() { |
| [7914](#L7914) | const svg = await this.svg; |
| [7915](#L7915) | if (svg) { |
| [7916](#L7916) | applyAttributes.call(this, svg); |
| [7917](#L7917) | } |
| [7918](#L7918) | }, |
| [7919](#L7919) | options: { |
| [7920](#L7920) | attributes: true, |
| [7921](#L7921) | attributeFilter: ["id", "class", "style"] |
| [7922](#L7922) | } |
| [7923](#L7923) | }) |
| [7924](#L7924) | ], |
| [7925](#L7925) | async connected() { |
| [7926](#L7926) | if (includes(this.src, "#")) { |
| [7927](#L7927) | [this.src, this.icon] = this.src.split("#"); |
| [7928](#L7928) | } |
| [7929](#L7929) | const svg = await this.svg; |
| [7930](#L7930) | if (svg) { |
| [7931](#L7931) | applyAttributes.call(this, svg); |
| [7932](#L7932) | if (this.strokeAnimation) { |
| [7933](#L7933) | applyAnimation(svg); |
| [7934](#L7934) | } |
| [7935](#L7935) | } |
| [7936](#L7936) | }, |
| [7937](#L7937) | methods: { |
| [7938](#L7938) | async getSvg() { |
| [7939](#L7939) | if (isTag(this.$el, "img") && !this.$el.complete && this.$el.loading === "lazy") { |
| [7940](#L7940) | await new Promise((resolve) => once(this.$el, "load", resolve)); |
| [7941](#L7941) | } |
| [7942](#L7942) | return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject("SVG not found."); |
| [7943](#L7943) | } |
| [7944](#L7944) | } |
| [7945](#L7945) | }; |
| [7946](#L7946) | function applyAttributes(el) { |
| [7947](#L7947) | const { $el } = this; |
| [7948](#L7948) | addClass(el, attr($el, "class"), "bdt-svg"); |
| [7949](#L7949) | for (let i = 0; i < $el.style.length; i++) { |
| [7950](#L7950) | const prop = $el.style[i]; |
| [7951](#L7951) | css(el, prop, css($el, prop)); |
| [7952](#L7952) | } |
| [7953](#L7953) | for (const attribute in this.attributes) { |
| [7954](#L7954) | const [prop, value] = this.attributes[attribute].split(":", 2); |
| [7955](#L7955) | attr(el, prop, value); |
| [7956](#L7956) | } |
| [7957](#L7957) | if (!this.$el.id) { |
| [7958](#L7958) | removeAttr(el, "id"); |
| [7959](#L7959) | } |
| [7960](#L7960) | } |
| [7961](#L7961) | const loadSVG = memoize(async (src) => { |
| [7962](#L7962) | if (src) { |
| [7963](#L7963) | if (startsWith(src, "data:")) { |
| [7964](#L7964) | return decodeURIComponent(src.split(",")[1]); |
| [7965](#L7965) | } else { |
| [7966](#L7966) | return (await fetch(src)).text(); |
| [7967](#L7967) | } |
| [7968](#L7968) | } else { |
| [7969](#L7969) | return Promise.reject(); |
| [7970](#L7970) | } |
| [7971](#L7971) | }); |
| [7972](#L7972) | function parseSVG(svg, icon) { |
| [7973](#L7973) | if (icon && includes(svg, "<symbol")) { |
| [7974](#L7974) | svg = parseSymbols(svg)[icon] || svg; |
| [7975](#L7975) | } |
| [7976](#L7976) | return stringToSvg(svg); |
| [7977](#L7977) | } |
| [7978](#L7978) | const symbolRe = /<symbol([^]\*?id=(['"])(.+?)\2[^]\*?<\/)symbol>/g; |
| [7979](#L7979) | const parseSymbols = memoize(function(svg) { |
| [7980](#L7980) | const symbols = {}; |
| [7981](#L7981) | symbolRe.lastIndex = 0; |
| [7982](#L7982) | let match; |
| [7983](#L7983) | while (match = symbolRe.exec(svg)) { |
| [7984](#L7984) | symbols[match[3]] = `<svg ${match[1]}svg>`; |
| [7985](#L7985) | } |
| [7986](#L7986) | return symbols; |
| [7987](#L7987) | }); |
| [7988](#L7988) | function applyAnimation(el) { |
| [7989](#L7989) | const length = getMaxPathLength(el); |
| [7990](#L7990) | if (length) { |
| [7991](#L7991) | css(el, "--bdt-animation-stroke", length); |
| [7992](#L7992) | } |
| [7993](#L7993) | } |
| [7994](#L7994) | function stringToSvg(string) { |
| [7995](#L7995) | const container = document.createElement("template"); |
| [7996](#L7996) | container.innerHTML = string; |
| [7997](#L7997) | return container.content.firstElementChild; |
| [7998](#L7998) | } |
| [7999](#L7999) |  |
| [8000](#L8000) | const icons = { |
| [8001](#L8001) | spinner, |
| [8002](#L8002) | totop, |
| [8003](#L8003) | marker, |
| [8004](#L8004) | "close-icon": closeIcon, |
| [8005](#L8005) | "close-large": closeLarge, |
| [8006](#L8006) | "drop-parent-icon": dropParentIcon, |
| [8007](#L8007) | "nav-parent-icon": navParentIcon, |
| [8008](#L8008) | "nav-parent-icon-large": navParentIconLarge, |
| [8009](#L8009) | "navbar-parent-icon": navbarParentIcon, |
| [8010](#L8010) | "navbar-toggle-icon": navbarToggleIcon, |
| [8011](#L8011) | "overlay-icon": overlayIcon, |
| [8012](#L8012) | "pagination-next": paginationNext, |
| [8013](#L8013) | "pagination-previous": paginationPrevious, |
| [8014](#L8014) | "search-icon": searchIcon, |
| [8015](#L8015) | "search-medium": searchMedium, |
| [8016](#L8016) | "search-large": searchLarge, |
| [8017](#L8017) | "search-toggle-icon": searchIcon, |
| [8018](#L8018) | "slidenav-next": slidenavNext, |
| [8019](#L8019) | "slidenav-next-large": slidenavNextLarge, |
| [8020](#L8020) | "slidenav-previous": slidenavPrevious, |
| [8021](#L8021) | "slidenav-previous-large": slidenavPreviousLarge |
| [8022](#L8022) | }; |
| [8023](#L8023) | const Icon = { |
| [8024](#L8024) | install: install$1, |
| [8025](#L8025) | mixins: [Svg], |
| [8026](#L8026) | args: "icon", |
| [8027](#L8027) | props: { icon: String }, |
| [8028](#L8028) | isIcon: true, |
| [8029](#L8029) | beforeConnect() { |
| [8030](#L8030) | addClass(this.$el, "bdt-icon"); |
| [8031](#L8031) | }, |
| [8032](#L8032) | methods: { |
| [8033](#L8033) | async getSvg() { |
| [8034](#L8034) | const icon = getIcon(this.icon); |
| [8035](#L8035) | if (!icon) { |
| [8036](#L8036) | throw "Icon not found."; |
| [8037](#L8037) | } |
| [8038](#L8038) | return icon; |
| [8039](#L8039) | } |
| [8040](#L8040) | } |
| [8041](#L8041) | }; |
| [8042](#L8042) | const IconComponent = { |
| [8043](#L8043) | args: false, |
| [8044](#L8044) | extends: Icon, |
| [8045](#L8045) | data: (vm) => ({ |
| [8046](#L8046) | icon: hyphenate(vm.constructor.options.name) |
| [8047](#L8047) | }), |
| [8048](#L8048) | beforeConnect() { |
| [8049](#L8049) | addClass(this.$el, this.$options.id); |
| [8050](#L8050) | } |
| [8051](#L8051) | }; |
| [8052](#L8052) | const NavParentIcon = { |
| [8053](#L8053) | extends: IconComponent, |
| [8054](#L8054) | beforeConnect() { |
| [8055](#L8055) | const icon = this.$props.icon; |
| [8056](#L8056) | this.icon = this.$el.closest(".bdt-nav-primary") ? `${icon}-large` : icon; |
| [8057](#L8057) | } |
| [8058](#L8058) | }; |
| [8059](#L8059) | const Search = { |
| [8060](#L8060) | extends: IconComponent, |
| [8061](#L8061) | mixins: [I18n], |
| [8062](#L8062) | i18n: { toggle: "Open Search", submit: "Submit Search" }, |
| [8063](#L8063) | beforeConnect() { |
| [8064](#L8064) | const isToggle = hasClass(this.$el, "bdt-search-toggle") || hasClass(this.$el, "bdt-navbar-toggle"); |
| [8065](#L8065) | this.icon = isToggle ? "search-toggle-icon" : hasClass(this.$el, "bdt-search-icon") && this.$el.closest(".bdt-search-large") ? "search-large" : this.$el.closest(".bdt-search-medium") ? "search-medium" : this.$props.icon; |
| [8066](#L8066) | if (hasAttr(this.$el, "aria-label")) { |
| [8067](#L8067) | return; |
| [8068](#L8068) | } |
| [8069](#L8069) | if (isToggle) { |
| [8070](#L8070) | const label = this.t("toggle"); |
| [8071](#L8071) | attr(this.$el, "aria-label", label); |
| [8072](#L8072) | } else { |
| [8073](#L8073) | const button = this.$el.closest("a,button"); |
| [8074](#L8074) | if (button) { |
| [8075](#L8075) | const label = this.t("submit"); |
| [8076](#L8076) | attr(button, "aria-label", label); |
| [8077](#L8077) | } |
| [8078](#L8078) | } |
| [8079](#L8079) | } |
| [8080](#L8080) | }; |
| [8081](#L8081) | const Spinner = { |
| [8082](#L8082) | extends: IconComponent, |
| [8083](#L8083) | beforeConnect() { |
| [8084](#L8084) | attr(this.$el, "role", "status"); |
| [8085](#L8085) | }, |
| [8086](#L8086) | methods: { |
| [8087](#L8087) | async getSvg() { |
| [8088](#L8088) | const icon = await Icon.methods.getSvg.call(this); |
| [8089](#L8089) | if (this.ratio !== 1) { |
| [8090](#L8090) | css($("circle", icon), "strokeWidth", 1 / this.ratio); |
| [8091](#L8091) | } |
| [8092](#L8092) | return icon; |
| [8093](#L8093) | } |
| [8094](#L8094) | } |
| [8095](#L8095) | }; |
| [8096](#L8096) | const ButtonComponent = { |
| [8097](#L8097) | extends: IconComponent, |
| [8098](#L8098) | mixins: [I18n], |
| [8099](#L8099) | beforeConnect() { |
| [8100](#L8100) | const button = this.$el.closest("a,button"); |
| [8101](#L8101) | attr(button, "role", this.role !== null && isTag(button, "a") ? "button" : this.role); |
| [8102](#L8102) | const label = this.t("label"); |
| [8103](#L8103) | if (label && !hasAttr(button, "aria-label")) { |
| [8104](#L8104) | attr(button, "aria-label", label); |
| [8105](#L8105) | } |
| [8106](#L8106) | } |
| [8107](#L8107) | }; |
| [8108](#L8108) | const Slidenav = { |
| [8109](#L8109) | extends: ButtonComponent, |
| [8110](#L8110) | beforeConnect() { |
| [8111](#L8111) | addClass(this.$el, "bdt-slidenav"); |
| [8112](#L8112) | const icon = this.$props.icon; |
| [8113](#L8113) | this.icon = hasClass(this.$el, "bdt-slidenav-large") ? `${icon}-large` : icon; |
| [8114](#L8114) | } |
| [8115](#L8115) | }; |
| [8116](#L8116) | const NavbarToggleIcon = { |
| [8117](#L8117) | extends: ButtonComponent, |
| [8118](#L8118) | i18n: { label: "Open menu" } |
| [8119](#L8119) | }; |
| [8120](#L8120) | const Close = { |
| [8121](#L8121) | extends: ButtonComponent, |
| [8122](#L8122) | i18n: { label: "Close" }, |
| [8123](#L8123) | beforeConnect() { |
| [8124](#L8124) | this.icon = `close-${hasClass(this.$el, "bdt-close-large") ? "large" : "icon"}`; |
| [8125](#L8125) | } |
| [8126](#L8126) | }; |
| [8127](#L8127) | const Marker = { |
| [8128](#L8128) | extends: ButtonComponent, |
| [8129](#L8129) | i18n: { label: "Open" } |
| [8130](#L8130) | }; |
| [8131](#L8131) | const Totop = { |
| [8132](#L8132) | extends: ButtonComponent, |
| [8133](#L8133) | i18n: { label: "Back to top" } |
| [8134](#L8134) | }; |
| [8135](#L8135) | const PaginationNext = { |
| [8136](#L8136) | extends: ButtonComponent, |
| [8137](#L8137) | i18n: { label: "Next page" }, |
| [8138](#L8138) | data: { role: null } |
| [8139](#L8139) | }; |
| [8140](#L8140) | const PaginationPrevious = { |
| [8141](#L8141) | extends: ButtonComponent, |
| [8142](#L8142) | i18n: { label: "Previous page" }, |
| [8143](#L8143) | data: { role: null } |
| [8144](#L8144) | }; |
| [8145](#L8145) | const parsed = {}; |
| [8146](#L8146) | function install$1(bdtUIkit) { |
| [8147](#L8147) | bdtUIkit.icon.add = (name, svg) => { |
| [8148](#L8148) | const added = isString(name) ? { [name]: svg } : name; |
| [8149](#L8149) | each(added, (svg2, name2) => { |
| [8150](#L8150) | icons[name2] = svg2; |
| [8151](#L8151) | delete parsed[name2]; |
| [8152](#L8152) | }); |
| [8153](#L8153) | if (bdtUIkit.\_initialized) { |
| [8154](#L8154) | apply( |
| [8155](#L8155) | document.body, |
| [8156](#L8156) | (el) => each(bdtUIkit.getComponents(el), (cmp) => { |
| [8157](#L8157) | cmp.$options.isIcon && cmp.icon in added && cmp.$reset(); |
| [8158](#L8158) | }) |
| [8159](#L8159) | ); |
| [8160](#L8160) | } |
| [8161](#L8161) | }; |
| [8162](#L8162) | } |
| [8163](#L8163) | const aliases = { twitter: "x" }; |
| [8164](#L8164) | function getIcon(icon) { |
| [8165](#L8165) | icon = aliases[icon] || icon; |
| [8166](#L8166) | if (!icons[icon]) { |
| [8167](#L8167) | return null; |
| [8168](#L8168) | } |
| [8169](#L8169) | if (!parsed[icon]) { |
| [8170](#L8170) | parsed[icon] = stringToSvg(icons[applyRtl(icon)] || icons[icon]); |
| [8171](#L8171) | } |
| [8172](#L8172) | return parsed[icon].cloneNode(true); |
| [8173](#L8173) | } |
| [8174](#L8174) | function applyRtl(icon) { |
| [8175](#L8175) | return isRtl ? swap(swap(icon, "left", "right"), "previous", "next") : icon; |
| [8176](#L8176) | } |
| [8177](#L8177) |  |
| [8178](#L8178) | var img = { |
| [8179](#L8179) | args: "dataSrc", |
| [8180](#L8180) | props: { |
| [8181](#L8181) | dataSrc: String, |
| [8182](#L8182) | sources: String, |
| [8183](#L8183) | margin: String, |
| [8184](#L8184) | target: String, |
| [8185](#L8185) | loading: String |
| [8186](#L8186) | }, |
| [8187](#L8187) | data: { |
| [8188](#L8188) | dataSrc: "", |
| [8189](#L8189) | sources: false, |
| [8190](#L8190) | margin: "50%", |
| [8191](#L8191) | target: false, |
| [8192](#L8192) | loading: "lazy" |
| [8193](#L8193) | }, |
| [8194](#L8194) | connected() { |
| [8195](#L8195) | if (this.loading !== "lazy") { |
| [8196](#L8196) | this.load(); |
| [8197](#L8197) | } else if (isImg(this.$el)) { |
| [8198](#L8198) | this.$el.loading = "lazy"; |
| [8199](#L8199) | setSrcAttrs(this.$el); |
| [8200](#L8200) | } |
| [8201](#L8201) | }, |
| [8202](#L8202) | disconnected() { |
| [8203](#L8203) | if (this.img) { |
| [8204](#L8204) | this.img.onload = ""; |
| [8205](#L8205) | } |
| [8206](#L8206) | delete this.img; |
| [8207](#L8207) | }, |
| [8208](#L8208) | observe: intersection({ |
| [8209](#L8209) | handler(entries, observer) { |
| [8210](#L8210) | this.load(); |
| [8211](#L8211) | observer.disconnect(); |
| [8212](#L8212) | }, |
| [8213](#L8213) | options: ({ margin }) => ({ rootMargin: margin }), |
| [8214](#L8214) | filter: ({ loading }) => loading === "lazy", |
| [8215](#L8215) | target: ({ $el, $props }) => $props.target ? [$el, ...queryAll($props.target, $el)] : $el |
| [8216](#L8216) | }), |
| [8217](#L8217) | methods: { |
| [8218](#L8218) | load() { |
| [8219](#L8219) | if (this.img) { |
| [8220](#L8220) | return this.img; |
| [8221](#L8221) | } |
| [8222](#L8222) | const image = isImg(this.$el) ? this.$el : getImageFromElement(this.$el, this.dataSrc, this.sources); |
| [8223](#L8223) | removeAttr(image, "loading"); |
| [8224](#L8224) | setSrcAttrs(this.$el, image.currentSrc); |
| [8225](#L8225) | return this.img = image; |
| [8226](#L8226) | } |
| [8227](#L8227) | } |
| [8228](#L8228) | }; |
| [8229](#L8229) | function setSrcAttrs(el, src) { |
| [8230](#L8230) | if (isImg(el)) { |
| [8231](#L8231) | const parentNode = parent(el); |
| [8232](#L8232) | const elements = isTag(parentNode, "picture") ? children(parentNode) : [el]; |
| [8233](#L8233) | elements.forEach((el2) => setSourceProps(el2, el2)); |
| [8234](#L8234) | } else if (src) { |
| [8235](#L8235) | const change = !includes(el.style.backgroundImage, src); |
| [8236](#L8236) | if (change) { |
| [8237](#L8237) | css(el, "backgroundImage", `url(${escape(src)})`); |
| [8238](#L8238) | trigger(el, createEvent("load", false)); |
| [8239](#L8239) | } |
| [8240](#L8240) | } |
| [8241](#L8241) | } |
| [8242](#L8242) | const srcProps = ["data-src", "data-srcset", "sizes"]; |
| [8243](#L8243) | function setSourceProps(sourceEl, targetEl) { |
| [8244](#L8244) | for (const prop of srcProps) { |
| [8245](#L8245) | const value = data(sourceEl, prop); |
| [8246](#L8246) | if (value) { |
| [8247](#L8247) | attr(targetEl, prop.replace(/^(data-)+/, ""), value); |
| [8248](#L8248) | } |
| [8249](#L8249) | } |
| [8250](#L8250) | } |
| [8251](#L8251) | function getImageFromElement(el, src, sources) { |
| [8252](#L8252) | const img = new Image(); |
| [8253](#L8253) | wrapInPicture(img, sources); |
| [8254](#L8254) | setSourceProps(el, img); |
| [8255](#L8255) | img.onload = () => { |
| [8256](#L8256) | setSrcAttrs(el, img.currentSrc); |
| [8257](#L8257) | }; |
| [8258](#L8258) | attr(img, "src", src); |
| [8259](#L8259) | return img; |
| [8260](#L8260) | } |
| [8261](#L8261) | function wrapInPicture(img, sources) { |
| [8262](#L8262) | sources = parseSources(sources); |
| [8263](#L8263) | if (sources.length) { |
| [8264](#L8264) | const picture = fragment("<picture>"); |
| [8265](#L8265) | for (const attrs of sources) { |
| [8266](#L8266) | const source = fragment("<source>"); |
| [8267](#L8267) | attr(source, attrs); |
| [8268](#L8268) | append(picture, source); |
| [8269](#L8269) | } |
| [8270](#L8270) | append(picture, img); |
| [8271](#L8271) | } |
| [8272](#L8272) | } |
| [8273](#L8273) | function parseSources(sources) { |
| [8274](#L8274) | if (!sources) { |
| [8275](#L8275) | return []; |
| [8276](#L8276) | } |
| [8277](#L8277) | if (startsWith(sources, "[")) { |
| [8278](#L8278) | try { |
| [8279](#L8279) | sources = JSON.parse(sources); |
| [8280](#L8280) | } catch (e) { |
| [8281](#L8281) | sources = []; |
| [8282](#L8282) | } |
| [8283](#L8283) | } else { |
| [8284](#L8284) | sources = parseOptions(sources); |
| [8285](#L8285) | } |
| [8286](#L8286) | if (!isArray(sources)) { |
| [8287](#L8287) | sources = [sources]; |
| [8288](#L8288) | } |
| [8289](#L8289) | return sources.filter((source) => !isEmpty(source)); |
| [8290](#L8290) | } |
| [8291](#L8291) | function isImg(el) { |
| [8292](#L8292) | return isTag(el, "img"); |
| [8293](#L8293) | } |
| [8294](#L8294) |  |
| [8295](#L8295) | var inverse = { |
| [8296](#L8296) | props: { |
| [8297](#L8297) | target: String, |
| [8298](#L8298) | selActive: String |
| [8299](#L8299) | }, |
| [8300](#L8300) | data: { |
| [8301](#L8301) | target: false, |
| [8302](#L8302) | selActive: false |
| [8303](#L8303) | }, |
| [8304](#L8304) | computed: { |
| [8305](#L8305) | target: ({ target }, $el) => target ? $$(target, $el) : $el |
| [8306](#L8306) | }, |
| [8307](#L8307) | observe: [ |
| [8308](#L8308) | intersection({ |
| [8309](#L8309) | handler(entries) { |
| [8310](#L8310) | this.isIntersecting = entries.some(({ isIntersecting }) => isIntersecting); |
| [8311](#L8311) | this.$emit(); |
| [8312](#L8312) | }, |
| [8313](#L8313) | target: ({ target }) => target, |
| [8314](#L8314) | args: { intersecting: false } |
| [8315](#L8315) | }), |
| [8316](#L8316) | mutation({ |
| [8317](#L8317) | target: ({ target }) => target, |
| [8318](#L8318) | options: { attributes: true, attributeFilter: ["class"], attributeOldValue: true } |
| [8319](#L8319) | }), |
| [8320](#L8320) | { |
| [8321](#L8321) | target: ({ target }) => target, |
| [8322](#L8322) | observe: (target, handler) => { |
| [8323](#L8323) | const observer = observeResize( |
| [8324](#L8324) | [...toNodes(target), document.documentElement], |
| [8325](#L8325) | handler |
| [8326](#L8326) | ); |
| [8327](#L8327) | const listener = [ |
| [8328](#L8328) | on(document, "scroll itemshown itemhidden", handler, { |
| [8329](#L8329) | passive: true, |
| [8330](#L8330) | capture: true |
| [8331](#L8331) | }), |
| [8332](#L8332) | on(document, "show hide transitionstart", (e) => { |
| [8333](#L8333) | handler(); |
| [8334](#L8334) | return observer.observe(e.target); |
| [8335](#L8335) | }), |
| [8336](#L8336) | on(document, "shown hidden transitionend transitioncancel", (e) => { |
| [8337](#L8337) | handler(); |
| [8338](#L8338) | return observer.unobserve(e.target); |
| [8339](#L8339) | }) |
| [8340](#L8340) | ]; |
| [8341](#L8341) | return { |
| [8342](#L8342) | observe: observer.observe.bind(observer), |
| [8343](#L8343) | unobserve: observer.unobserve.bind(observer), |
| [8344](#L8344) | disconnect() { |
| [8345](#L8345) | observer.disconnect(); |
| [8346](#L8346) | listener.map((off) => off()); |
| [8347](#L8347) | } |
| [8348](#L8348) | }; |
| [8349](#L8349) | }, |
| [8350](#L8350) | handler() { |
| [8351](#L8351) | this.$emit(); |
| [8352](#L8352) | } |
| [8353](#L8353) | } |
| [8354](#L8354) | ], |
| [8355](#L8355) | update: { |
| [8356](#L8356) | read() { |
| [8357](#L8357) | if (!this.isIntersecting) { |
| [8358](#L8358) | return false; |
| [8359](#L8359) | } |
| [8360](#L8360) | for (const target of toNodes(this.target)) { |
| [8361](#L8361) | let color = !this.selActive || matches(target, this.selActive) ? findTargetColor(target) : ""; |
| [8362](#L8362) | if (color !== false) { |
| [8363](#L8363) | replaceClass(target, "bdt-light bdt-dark", color); |
| [8364](#L8364) | } |
| [8365](#L8365) | } |
| [8366](#L8366) | } |
| [8367](#L8367) | } |
| [8368](#L8368) | }; |
| [8369](#L8369) | function findTargetColor(target) { |
| [8370](#L8370) | const dim = dimensions$1(target); |
| [8371](#L8371) | const viewport = dimensions$1(window); |
| [8372](#L8372) | if (!intersectRect(dim, viewport)) { |
| [8373](#L8373) | return false; |
| [8374](#L8374) | } |
| [8375](#L8375) | const { left, top, height, width } = dim; |
| [8376](#L8376) | let last; |
| [8377](#L8377) | for (const percent of [0.25, 0.5, 0.75]) { |
| [8378](#L8378) | const elements = target.ownerDocument.elementsFromPoint( |
| [8379](#L8379) | Math.max(0, Math.min(left + width \* percent, viewport.width - 1)), |
| [8380](#L8380) | Math.max(0, Math.min(top + height / 2, viewport.height - 1)) |
| [8381](#L8381) | ); |
| [8382](#L8382) | for (const element of elements) { |
| [8383](#L8383) | if (target.contains(element) || !checkVisibility(element) || element.closest('[class\*="-leave"]') && elements.some((el) => element !== el && matches(el, '[class\*="-enter"]'))) { |
| [8384](#L8384) | continue; |
| [8385](#L8385) | } |
| [8386](#L8386) | const color = css(element, "--bdt-inverse"); |
| [8387](#L8387) | if (color) { |
| [8388](#L8388) | if (color === last) { |
| [8389](#L8389) | return `bdt-${color}`; |
| [8390](#L8390) | } |
| [8391](#L8391) | last = color; |
| [8392](#L8392) | break; |
| [8393](#L8393) | } |
| [8394](#L8394) | } |
| [8395](#L8395) | } |
| [8396](#L8396) | return last ? `bdt-${last}` : ""; |
| [8397](#L8397) | } |
| [8398](#L8398) | function checkVisibility(element) { |
| [8399](#L8399) | if (css(element, "visibility") !== "visible") { |
| [8400](#L8400) | return false; |
| [8401](#L8401) | } |
| [8402](#L8402) | while (element) { |
| [8403](#L8403) | if (css(element, "opacity") === "0") { |
| [8404](#L8404) | return false; |
| [8405](#L8405) | } |
| [8406](#L8406) | element = parent(element); |
| [8407](#L8407) | } |
| [8408](#L8408) | return true; |
| [8409](#L8409) | } |
| [8410](#L8410) |  |
| [8411](#L8411) | var leader = { |
| [8412](#L8412) | mixins: [Class, Media], |
| [8413](#L8413) | props: { |
| [8414](#L8414) | fill: String |
| [8415](#L8415) | }, |
| [8416](#L8416) | data: { |
| [8417](#L8417) | fill: "", |
| [8418](#L8418) | clsWrapper: "bdt-leader-fill", |
| [8419](#L8419) | clsHide: "bdt-leader-hide", |
| [8420](#L8420) | attrFill: "data-fill" |
| [8421](#L8421) | }, |
| [8422](#L8422) | computed: { |
| [8423](#L8423) | fill: ({ fill }, $el) => fill || css($el, "--bdt-leader-fill-content") |
| [8424](#L8424) | }, |
| [8425](#L8425) | connected() { |
| [8426](#L8426) | [this.wrapper] = wrapInner(this.$el, `<span class="${this.clsWrapper}">`); |
| [8427](#L8427) | }, |
| [8428](#L8428) | disconnected() { |
| [8429](#L8429) | unwrap(this.wrapper.childNodes); |
| [8430](#L8430) | }, |
| [8431](#L8431) | observe: resize(), |
| [8432](#L8432) | update: { |
| [8433](#L8433) | read() { |
| [8434](#L8434) | const width = Math.trunc(this.$el.offsetWidth / 2); |
| [8435](#L8435) | return { |
| [8436](#L8436) | width, |
| [8437](#L8437) | fill: this.fill, |
| [8438](#L8438) | hide: !this.matchMedia |
| [8439](#L8439) | }; |
| [8440](#L8440) | }, |
| [8441](#L8441) | write({ width, fill, hide }) { |
| [8442](#L8442) | toggleClass(this.wrapper, this.clsHide, hide); |
| [8443](#L8443) | attr(this.wrapper, this.attrFill, new Array(width).join(fill)); |
| [8444](#L8444) | }, |
| [8445](#L8445) | events: ["resize"] |
| [8446](#L8446) | } |
| [8447](#L8447) | }; |
| [8448](#L8448) |  |
| [8449](#L8449) | var modal = { |
| [8450](#L8450) | install, |
| [8451](#L8451) | mixins: [Modal], |
| [8452](#L8452) | data: { |
| [8453](#L8453) | clsPage: "bdt-modal-page", |
| [8454](#L8454) | selPanel: ".bdt-modal-dialog", |
| [8455](#L8455) | selClose: '[class\*="bdt-modal-close"]' |
| [8456](#L8456) | }, |
| [8457](#L8457) | events: [ |
| [8458](#L8458) | { |
| [8459](#L8459) | name: "fullscreenchange webkitendfullscreen", |
| [8460](#L8460) | capture: true, |
| [8461](#L8461) | handler(e) { |
| [8462](#L8462) | if (isTag(e.target, "video") && this.isToggled() && !document.fullscreenElement) { |
| [8463](#L8463) | this.hide(); |
| [8464](#L8464) | } |
| [8465](#L8465) | } |
| [8466](#L8466) | }, |
| [8467](#L8467) | { |
| [8468](#L8468) | name: "show", |
| [8469](#L8469) | self: true, |
| [8470](#L8470) | handler() { |
| [8471](#L8471) | if (hasClass(this.panel, "bdt-margin-auto-vertical")) { |
| [8472](#L8472) | addClass(this.$el, "bdt-flex"); |
| [8473](#L8473) | } else { |
| [8474](#L8474) | css(this.$el, "display", "block"); |
| [8475](#L8475) | } |
| [8476](#L8476) | height(this.$el); |
| [8477](#L8477) | } |
| [8478](#L8478) | }, |
| [8479](#L8479) | { |
| [8480](#L8480) | name: "hidden", |
| [8481](#L8481) | self: true, |
| [8482](#L8482) | handler() { |
| [8483](#L8483) | css(this.$el, "display", ""); |
| [8484](#L8484) | removeClass(this.$el, "bdt-flex"); |
| [8485](#L8485) | } |
| [8486](#L8486) | } |
| [8487](#L8487) | ] |
| [8488](#L8488) | }; |
| [8489](#L8489) | function install({ modal }) { |
| [8490](#L8490) | modal.dialog = function(content, options) { |
| [8491](#L8491) | const dialog = modal($(`<div><div class="bdt-modal-dialog">${content}</div></div>`), { |
| [8492](#L8492) | stack: true, |
| [8493](#L8493) | role: "alertdialog", |
| [8494](#L8494) | ...options |
| [8495](#L8495) | }); |
| [8496](#L8496) | dialog.show(); |
| [8497](#L8497) | on( |
| [8498](#L8498) | dialog.$el, |
| [8499](#L8499) | "hidden", |
| [8500](#L8500) | async () => { |
| [8501](#L8501) | await Promise.resolve(); |
| [8502](#L8502) | dialog.$destroy(true); |
| [8503](#L8503) | }, |
| [8504](#L8504) | { self: true } |
| [8505](#L8505) | ); |
| [8506](#L8506) | return dialog; |
| [8507](#L8507) | }; |
| [8508](#L8508) | modal.alert = function(message, options) { |
| [8509](#L8509) | return openDialog( |
| [8510](#L8510) | ({ i18n }) => `<div class="bdt-modal-body">${isString(message) ? message : html(message)}</div> <div class="bdt-modal-footer bdt-text-right"> <button class="bdt-button bdt-button-primary bdt-modal-close" autofocus>${i18n.ok}</button> </div>`, |
| [8511](#L8511) | options |
| [8512](#L8512) | ); |
| [8513](#L8513) | }; |
| [8514](#L8514) | modal.confirm = function(message, options) { |
| [8515](#L8515) | return openDialog( |
| [8516](#L8516) | ({ i18n }) => `<form> <div class="bdt-modal-body">${isString(message) ? message : html(message)}</div> <div class="bdt-modal-footer bdt-text-right"> <button class="bdt-button bdt-button-default bdt-modal-close" type="button">${i18n.cancel}</button> <button class="bdt-button bdt-button-primary" autofocus>${i18n.ok}</button> </div> </form>`, |
| [8517](#L8517) | options, |
| [8518](#L8518) | () => Promise.reject() |
| [8519](#L8519) | ); |
| [8520](#L8520) | }; |
| [8521](#L8521) | modal.prompt = function(message, value, options) { |
| [8522](#L8522) | const promise = openDialog( |
| [8523](#L8523) | ({ i18n }) => `<form class="bdt-form-stacked"> <div class="bdt-modal-body"> <label>${isString(message) ? message : html(message)}</label> <input class="bdt-input" autofocus> </div> <div class="bdt-modal-footer bdt-text-right"> <button class="bdt-button bdt-button-default bdt-modal-close" type="button">${i18n.cancel}</button> <button class="bdt-button bdt-button-primary">${i18n.ok}</button> </div> </form>`, |
| [8524](#L8524) | options, |
| [8525](#L8525) | () => null, |
| [8526](#L8526) | () => input.value |
| [8527](#L8527) | ); |
| [8528](#L8528) | const { $el } = promise.dialog; |
| [8529](#L8529) | const input = $("input", $el); |
| [8530](#L8530) | input.value = value || ""; |
| [8531](#L8531) | on($el, "show", () => input.select()); |
| [8532](#L8532) | return promise; |
| [8533](#L8533) | }; |
| [8534](#L8534) | modal.i18n = { |
| [8535](#L8535) | ok: "Ok", |
| [8536](#L8536) | cancel: "Cancel" |
| [8537](#L8537) | }; |
| [8538](#L8538) | function openDialog(tmpl, options, hideFn = noop, submitFn = noop) { |
| [8539](#L8539) | options = { |
| [8540](#L8540) | bgClose: false, |
| [8541](#L8541) | escClose: true, |
| [8542](#L8542) | ...options, |
| [8543](#L8543) | i18n: { ...modal.i18n, ...options == null ? void 0 : options.i18n } |
| [8544](#L8544) | }; |
| [8545](#L8545) | const dialog = modal.dialog(tmpl(options), options); |
| [8546](#L8546) | return assign( |
| [8547](#L8547) | new Promise((resolve) => { |
| [8548](#L8548) | const off = on(dialog.$el, "hide", () => resolve(hideFn())); |
| [8549](#L8549) | on(dialog.$el, "submit", "form", (e) => { |
| [8550](#L8550) | e.preventDefault(); |
| [8551](#L8551) | resolve(submitFn(dialog)); |
| [8552](#L8552) | off(); |
| [8553](#L8553) | dialog.hide(); |
| [8554](#L8554) | }); |
| [8555](#L8555) | }), |
| [8556](#L8556) | { dialog } |
| [8557](#L8557) | ); |
| [8558](#L8558) | } |
| [8559](#L8559) | } |
| [8560](#L8560) |  |
| [8561](#L8561) | var nav = { |
| [8562](#L8562) | extends: Accordion, |
| [8563](#L8563) | data: { |
| [8564](#L8564) | targets: "> .bdt-parent", |
| [8565](#L8565) | toggle: "> a", |
| [8566](#L8566) | content: "> ul" |
| [8567](#L8567) | } |
| [8568](#L8568) | }; |
| [8569](#L8569) |  |
| [8570](#L8570) | const clsNavbarTransparent = "bdt-navbar-transparent"; |
| [8571](#L8571) | var navbar = { |
| [8572](#L8572) | extends: Dropnav, |
| [8573](#L8573) | props: { |
| [8574](#L8574) | dropbarTransparentMode: Boolean |
| [8575](#L8575) | }, |
| [8576](#L8576) | data: { |
| [8577](#L8577) | clsDrop: "bdt-navbar-dropdown", |
| [8578](#L8578) | selNavItem: ".bdt-navbar-nav > li > a,a.bdt-navbar-item,button.bdt-navbar-item,.bdt-navbar-item a,.bdt-navbar-item button,.bdt-navbar-toggle", |
| [8579](#L8579) | // Simplify with :where() selector once browser target is Safari 14+ |
| [8580](#L8580) | dropbarTransparentMode: false |
| [8581](#L8581) | }, |
| [8582](#L8582) | computed: { |
| [8583](#L8583) | navbarContainer: (\_, $el) => $el.closest(".bdt-navbar-container") |
| [8584](#L8584) | }, |
| [8585](#L8585) | watch: { |
| [8586](#L8586) | items() { |
| [8587](#L8587) | const justify = hasClass(this.$el, "bdt-navbar-justify"); |
| [8588](#L8588) | const containers = $$(".bdt-navbar-nav, .bdt-navbar-left, .bdt-navbar-right", this.$el); |
| [8589](#L8589) | for (const container of containers) { |
| [8590](#L8590) | const items = justify ? $$(".bdt-navbar-nav > li > a, .bdt-navbar-item, .bdt-navbar-toggle", container).length : ""; |
| [8591](#L8591) | css(container, "flexGrow", items); |
| [8592](#L8592) | } |
| [8593](#L8593) | } |
| [8594](#L8594) | }, |
| [8595](#L8595) | events: [ |
| [8596](#L8596) | { |
| [8597](#L8597) | name: "show", |
| [8598](#L8598) | el: ({ dropContainer }) => dropContainer, |
| [8599](#L8599) | handler({ target }) { |
| [8600](#L8600) | if (this.getTransparentMode(target) === "remove" && hasClass(this.navbarContainer, clsNavbarTransparent)) { |
| [8601](#L8601) | removeClass(this.navbarContainer, clsNavbarTransparent); |
| [8602](#L8602) | this.\_transparent = true; |
| [8603](#L8603) | } |
| [8604](#L8604) | } |
| [8605](#L8605) | }, |
| [8606](#L8606) | { |
| [8607](#L8607) | name: "hide", |
| [8608](#L8608) | el: ({ dropContainer }) => dropContainer, |
| [8609](#L8609) | async handler() { |
| [8610](#L8610) | await awaitMacroTask(); |
| [8611](#L8611) | if (!this.getActive() && this.\_transparent) { |
| [8612](#L8612) | addClass(this.navbarContainer, clsNavbarTransparent); |
| [8613](#L8613) | this.\_transparent = null; |
| [8614](#L8614) | } |
| [8615](#L8615) | } |
| [8616](#L8616) | } |
| [8617](#L8617) | ], |
| [8618](#L8618) | methods: { |
| [8619](#L8619) | getTransparentMode(el) { |
| [8620](#L8620) | if (!this.navbarContainer) { |
| [8621](#L8621) | return; |
| [8622](#L8622) | } |
| [8623](#L8623) | if (this.dropbar && this.isDropbarDrop(el)) { |
| [8624](#L8624) | return this.dropbarTransparentMode; |
| [8625](#L8625) | } |
| [8626](#L8626) | const drop = this.getDropdown(el); |
| [8627](#L8627) | if (drop && hasClass(el, "bdt-dropbar")) { |
| [8628](#L8628) | return drop.inset ? "behind" : "remove"; |
| [8629](#L8629) | } |
| [8630](#L8630) | }, |
| [8631](#L8631) | getDropbarOffset(offsetTop) { |
| [8632](#L8632) | const { top, height } = offset(this.navbarContainer); |
| [8633](#L8633) | return top + (this.dropbarTransparentMode === "behind" ? 0 : height + offsetTop); |
| [8634](#L8634) | } |
| [8635](#L8635) | } |
| [8636](#L8636) | }; |
| [8637](#L8637) | function awaitMacroTask() { |
| [8638](#L8638) | return new Promise((resolve) => setTimeout(resolve)); |
| [8639](#L8639) | } |
| [8640](#L8640) |  |
| [8641](#L8641) | var offcanvas = { |
| [8642](#L8642) | mixins: [Modal], |
| [8643](#L8643) | args: "mode", |
| [8644](#L8644) | props: { |
| [8645](#L8645) | mode: String, |
| [8646](#L8646) | flip: Boolean, |
| [8647](#L8647) | overlay: Boolean, |
| [8648](#L8648) | swiping: Boolean |
| [8649](#L8649) | }, |
| [8650](#L8650) | data: { |
| [8651](#L8651) | mode: "slide", |
| [8652](#L8652) | flip: false, |
| [8653](#L8653) | overlay: false, |
| [8654](#L8654) | clsPage: "bdt-offcanvas-page", |
| [8655](#L8655) | clsContainer: "bdt-offcanvas-container", |
| [8656](#L8656) | selPanel: ".bdt-offcanvas-bar", |
| [8657](#L8657) | clsFlip: "bdt-offcanvas-flip", |
| [8658](#L8658) | clsContainerAnimation: "bdt-offcanvas-container-animation", |
| [8659](#L8659) | clsSidebarAnimation: "bdt-offcanvas-bar-animation", |
| [8660](#L8660) | clsMode: "bdt-offcanvas", |
| [8661](#L8661) | clsOverlay: "bdt-offcanvas-overlay", |
| [8662](#L8662) | selClose: ".bdt-offcanvas-close", |
| [8663](#L8663) | container: false, |
| [8664](#L8664) | swiping: true |
| [8665](#L8665) | }, |
| [8666](#L8666) | computed: { |
| [8667](#L8667) | clsFlip: ({ flip, clsFlip }) => flip ? clsFlip : "", |
| [8668](#L8668) | clsOverlay: ({ overlay, clsOverlay }) => overlay ? clsOverlay : "", |
| [8669](#L8669) | clsMode: ({ mode, clsMode }) => `${clsMode}-${mode}`, |
| [8670](#L8670) | clsSidebarAnimation: ({ mode, clsSidebarAnimation }) => mode === "none" || mode === "reveal" ? "" : clsSidebarAnimation, |
| [8671](#L8671) | clsContainerAnimation: ({ mode, clsContainerAnimation }) => mode !== "push" && mode !== "reveal" ? "" : clsContainerAnimation, |
| [8672](#L8672) | transitionElement({ mode }) { |
| [8673](#L8673) | return mode === "reveal" ? parent(this.panel) : this.panel; |
| [8674](#L8674) | } |
| [8675](#L8675) | }, |
| [8676](#L8676) | observe: swipe({ filter: ({ swiping }) => swiping }), |
| [8677](#L8677) | update: { |
| [8678](#L8678) | read() { |
| [8679](#L8679) | if (this.isToggled() && !isVisible(this.$el)) { |
| [8680](#L8680) | this.hide(); |
| [8681](#L8681) | } |
| [8682](#L8682) | }, |
| [8683](#L8683) | events: ["resize"] |
| [8684](#L8684) | }, |
| [8685](#L8685) | events: [ |
| [8686](#L8686) | { |
| [8687](#L8687) | name: "touchmove", |
| [8688](#L8688) | self: true, |
| [8689](#L8689) | passive: false, |
| [8690](#L8690) | filter: ({ overlay }) => overlay, |
| [8691](#L8691) | handler(e) { |
| [8692](#L8692) | e.cancelable && e.preventDefault(); |
| [8693](#L8693) | } |
| [8694](#L8694) | }, |
| [8695](#L8695) | { |
| [8696](#L8696) | name: "show", |
| [8697](#L8697) | self: true, |
| [8698](#L8698) | handler() { |
| [8699](#L8699) | if (this.mode === "reveal" && !hasClass(parent(this.panel), this.clsMode)) { |
| [8700](#L8700) | wrapAll(this.panel, "<div>"); |
| [8701](#L8701) | addClass(parent(this.panel), this.clsMode); |
| [8702](#L8702) | } |
| [8703](#L8703) | const { body, scrollingElement } = document; |
| [8704](#L8704) | addClass(body, this.clsContainer, this.clsFlip); |
| [8705](#L8705) | css(body, "touch-action", "pan-y pinch-zoom"); |
| [8706](#L8706) | css(this.$el, "display", "block"); |
| [8707](#L8707) | css(this.panel, "maxWidth", scrollingElement.clientWidth); |
| [8708](#L8708) | addClass(this.$el, this.clsOverlay); |
| [8709](#L8709) | addClass( |
| [8710](#L8710) | this.panel, |
| [8711](#L8711) | this.clsSidebarAnimation, |
| [8712](#L8712) | this.mode === "reveal" ? "" : this.clsMode |
| [8713](#L8713) | ); |
| [8714](#L8714) | height(body); |
| [8715](#L8715) | addClass(body, this.clsContainerAnimation); |
| [8716](#L8716) | this.clsContainerAnimation && suppressUserScale(); |
| [8717](#L8717) | } |
| [8718](#L8718) | }, |
| [8719](#L8719) | { |
| [8720](#L8720) | name: "hide", |
| [8721](#L8721) | self: true, |
| [8722](#L8722) | handler() { |
| [8723](#L8723) | removeClass(document.body, this.clsContainerAnimation); |
| [8724](#L8724) | css(document.body, "touch-action", ""); |
| [8725](#L8725) | } |
| [8726](#L8726) | }, |
| [8727](#L8727) | { |
| [8728](#L8728) | name: "hidden", |
| [8729](#L8729) | self: true, |
| [8730](#L8730) | handler() { |
| [8731](#L8731) | this.clsContainerAnimation && resumeUserScale(); |
| [8732](#L8732) | if (this.mode === "reveal") { |
| [8733](#L8733) | unwrap(this.panel); |
| [8734](#L8734) | } |
| [8735](#L8735) | removeClass(this.panel, this.clsSidebarAnimation, this.clsMode); |
| [8736](#L8736) | removeClass(this.$el, this.clsOverlay); |
| [8737](#L8737) | css(this.$el, "display", ""); |
| [8738](#L8738) | css(this.panel, "maxWidth", ""); |
| [8739](#L8739) | removeClass(document.body, this.clsContainer, this.clsFlip); |
| [8740](#L8740) | } |
| [8741](#L8741) | }, |
| [8742](#L8742) | { |
| [8743](#L8743) | name: "swipeLeft swipeRight", |
| [8744](#L8744) | handler(e) { |
| [8745](#L8745) | if (this.isToggled() && endsWith(e.type, "Left") ^ this.flip) { |
| [8746](#L8746) | this.hide(); |
| [8747](#L8747) | } |
| [8748](#L8748) | } |
| [8749](#L8749) | } |
| [8750](#L8750) | ] |
| [8751](#L8751) | }; |
| [8752](#L8752) | function suppressUserScale() { |
| [8753](#L8753) | getViewport().content += ",user-scalable=0"; |
| [8754](#L8754) | } |
| [8755](#L8755) | function resumeUserScale() { |
| [8756](#L8756) | const viewport = getViewport(); |
| [8757](#L8757) | viewport.content = viewport.content.replace(/,user-scalable=0$/, ""); |
| [8758](#L8758) | } |
| [8759](#L8759) | function getViewport() { |
| [8760](#L8760) | return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">'); |
| [8761](#L8761) | } |
| [8762](#L8762) |  |
| [8763](#L8763) | var overflowAuto = { |
| [8764](#L8764) | mixins: [Class], |
| [8765](#L8765) | props: { |
| [8766](#L8766) | selContainer: String, |
| [8767](#L8767) | selContent: String, |
| [8768](#L8768) | minHeight: Number |
| [8769](#L8769) | }, |
| [8770](#L8770) | data: { |
| [8771](#L8771) | selContainer: ".bdt-modal", |
| [8772](#L8772) | selContent: ".bdt-modal-dialog", |
| [8773](#L8773) | minHeight: 150 |
| [8774](#L8774) | }, |
| [8775](#L8775) | computed: { |
| [8776](#L8776) | container: ({ selContainer }, $el) => $el.closest(selContainer), |
| [8777](#L8777) | content: ({ selContent }, $el) => $el.closest(selContent) |
| [8778](#L8778) | }, |
| [8779](#L8779) | observe: resize({ |
| [8780](#L8780) | target: ({ container, content }) => [container, content] |
| [8781](#L8781) | }), |
| [8782](#L8782) | update: { |
| [8783](#L8783) | read() { |
| [8784](#L8784) | if (!this.content || !this.container || !isVisible(this.$el)) { |
| [8785](#L8785) | return false; |
| [8786](#L8786) | } |
| [8787](#L8787) | return { |
| [8788](#L8788) | max: Math.max( |
| [8789](#L8789) | this.minHeight, |
| [8790](#L8790) | height(this.container) - (dimensions$1(this.content).height - height(this.$el)) |
| [8791](#L8791) | ) |
| [8792](#L8792) | }; |
| [8793](#L8793) | }, |
| [8794](#L8794) | write({ max }) { |
| [8795](#L8795) | css(this.$el, { minHeight: this.minHeight, maxHeight: max }); |
| [8796](#L8796) | }, |
| [8797](#L8797) | events: ["resize"] |
| [8798](#L8798) | } |
| [8799](#L8799) | }; |
| [8800](#L8800) |  |
| [8801](#L8801) | var responsive = { |
| [8802](#L8802) | props: ["width", "height"], |
| [8803](#L8803) | connected() { |
| [8804](#L8804) | addClass(this.$el, "bdt-responsive-width"); |
| [8805](#L8805) | css(this.$el, "aspectRatio", `${this.width}/${this.height}`); |
| [8806](#L8806) | } |
| [8807](#L8807) | }; |
| [8808](#L8808) |  |
| [8809](#L8809) | var scroll = { |
| [8810](#L8810) | props: { |
| [8811](#L8811) | offset: Number |
| [8812](#L8812) | }, |
| [8813](#L8813) | data: { |
| [8814](#L8814) | offset: 0 |
| [8815](#L8815) | }, |
| [8816](#L8816) | connected() { |
| [8817](#L8817) | registerClick(this); |
| [8818](#L8818) | }, |
| [8819](#L8819) | disconnected() { |
| [8820](#L8820) | unregisterClick(this); |
| [8821](#L8821) | }, |
| [8822](#L8822) | methods: { |
| [8823](#L8823) | async scrollTo(el) { |
| [8824](#L8824) | el = el && $(el) || document.body; |
| [8825](#L8825) | if (trigger(this.$el, "beforescroll", [this, el])) { |
| [8826](#L8826) | await scrollIntoView(el, { offset: this.offset }); |
| [8827](#L8827) | trigger(this.$el, "scrolled", [this, el]); |
| [8828](#L8828) | } |
| [8829](#L8829) | } |
| [8830](#L8830) | } |
| [8831](#L8831) | }; |
| [8832](#L8832) | const instances = /\* @\_\_PURE\_\_ \*/ new Set(); |
| [8833](#L8833) | function registerClick(cmp) { |
| [8834](#L8834) | if (!instances.size) { |
| [8835](#L8835) | on(document, "click", clickHandler); |
| [8836](#L8836) | } |
| [8837](#L8837) | instances.add(cmp); |
| [8838](#L8838) | } |
| [8839](#L8839) | function unregisterClick(cmp) { |
| [8840](#L8840) | instances.delete(cmp); |
| [8841](#L8841) | if (!instances.size) { |
| [8842](#L8842) | off(document, "click", clickHandler); |
| [8843](#L8843) | } |
| [8844](#L8844) | } |
| [8845](#L8845) | function clickHandler(e) { |
| [8846](#L8846) | if (e.defaultPrevented) { |
| [8847](#L8847) | return; |
| [8848](#L8848) | } |
| [8849](#L8849) | for (const instance of instances) { |
| [8850](#L8850) | if (instance.$el.contains(e.target) && isSameSiteAnchor(instance.$el)) { |
| [8851](#L8851) | e.preventDefault(); |
| [8852](#L8852) | if (window.location.href !== instance.$el.href) { |
| [8853](#L8853) | window.history.pushState({}, "", instance.$el.href); |
| [8854](#L8854) | } |
| [8855](#L8855) | instance.scrollTo(getTargetedElement(instance.$el)); |
| [8856](#L8856) | } |
| [8857](#L8857) | } |
| [8858](#L8858) | } |
| [8859](#L8859) |  |
| [8860](#L8860) | const clsInView = "bdt-scrollspy-inview"; |
| [8861](#L8861) | var scrollspy = { |
| [8862](#L8862) | args: "cls", |
| [8863](#L8863) | props: { |
| [8864](#L8864) | cls: String, |
| [8865](#L8865) | target: String, |
| [8866](#L8866) | hidden: Boolean, |
| [8867](#L8867) | margin: String, |
| [8868](#L8868) | repeat: Boolean, |
| [8869](#L8869) | delay: Number |
| [8870](#L8870) | }, |
| [8871](#L8871) | data: () => ({ |
| [8872](#L8872) | cls: "", |
| [8873](#L8873) | target: false, |
| [8874](#L8874) | hidden: true, |
| [8875](#L8875) | margin: "-1px", |
| [8876](#L8876) | repeat: false, |
| [8877](#L8877) | delay: 0 |
| [8878](#L8878) | }), |
| [8879](#L8879) | computed: { |
| [8880](#L8880) | elements: ({ target }, $el) => target ? $$(target, $el) : [$el] |
| [8881](#L8881) | }, |
| [8882](#L8882) | watch: { |
| [8883](#L8883) | elements(elements) { |
| [8884](#L8884) | if (this.hidden) { |
| [8885](#L8885) | css(filter$1(elements, `:not(.${clsInView})`), "opacity", 0); |
| [8886](#L8886) | } |
| [8887](#L8887) | } |
| [8888](#L8888) | }, |
| [8889](#L8889) | connected() { |
| [8890](#L8890) | this.elementData = /\* @\_\_PURE\_\_ \*/ new Map(); |
| [8891](#L8891) | }, |
| [8892](#L8892) | disconnected() { |
| [8893](#L8893) | for (const [el, state] of this.elementData.entries()) { |
| [8894](#L8894) | removeClass(el, clsInView, (state == null ? void 0 : state.cls) || ""); |
| [8895](#L8895) | } |
| [8896](#L8896) | delete this.elementData; |
| [8897](#L8897) | }, |
| [8898](#L8898) | observe: intersection({ |
| [8899](#L8899) | target: ({ elements }) => elements, |
| [8900](#L8900) | handler(records) { |
| [8901](#L8901) | const elements = this.elementData; |
| [8902](#L8902) | for (const { target: el, isIntersecting } of records) { |
| [8903](#L8903) | if (!elements.has(el)) { |
| [8904](#L8904) | elements.set(el, { |
| [8905](#L8905) | cls: data(el, "bdt-scrollspy-class") || this.cls |
| [8906](#L8906) | }); |
| [8907](#L8907) | } |
| [8908](#L8908) | const state = elements.get(el); |
| [8909](#L8909) | if (!this.repeat && state.show) { |
| [8910](#L8910) | continue; |
| [8911](#L8911) | } |
| [8912](#L8912) | state.show = isIntersecting; |
| [8913](#L8913) | } |
| [8914](#L8914) | this.$emit(); |
| [8915](#L8915) | }, |
| [8916](#L8916) | options: ({ margin }) => ({ rootMargin: margin }), |
| [8917](#L8917) | args: { intersecting: false } |
| [8918](#L8918) | }), |
| [8919](#L8919) | update: [ |
| [8920](#L8920) | { |
| [8921](#L8921) | write(data) { |
| [8922](#L8922) | for (const [el, state] of this.elementData.entries()) { |
| [8923](#L8923) | if (state.show && !state.inview && !state.queued) { |
| [8924](#L8924) | state.queued = true; |
| [8925](#L8925) | data.promise = (data.promise || Promise.resolve()).then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).then(() => { |
| [8926](#L8926) | this.toggle(el, true); |
| [8927](#L8927) | setTimeout(() => { |
| [8928](#L8928) | state.queued = false; |
| [8929](#L8929) | this.$emit(); |
| [8930](#L8930) | }, 300); |
| [8931](#L8931) | }); |
| [8932](#L8932) | } else if (!state.show && state.inview && !state.queued && this.repeat) { |
| [8933](#L8933) | this.toggle(el, false); |
| [8934](#L8934) | } |
| [8935](#L8935) | } |
| [8936](#L8936) | } |
| [8937](#L8937) | } |
| [8938](#L8938) | ], |
| [8939](#L8939) | methods: { |
| [8940](#L8940) | toggle(el, inview) { |
| [8941](#L8941) | var \_a, \_b; |
| [8942](#L8942) | const state = (\_a = this.elementData) == null ? void 0 : \_a.get(el); |
| [8943](#L8943) | if (!state) { |
| [8944](#L8944) | return; |
| [8945](#L8945) | } |
| [8946](#L8946) | (\_b = state.off) == null ? void 0 : \_b.call(state); |
| [8947](#L8947) | css(el, "opacity", !inview && this.hidden ? 0 : ""); |
| [8948](#L8948) | toggleClass(el, clsInView, inview); |
| [8949](#L8949) | toggleClass(el, state.cls); |
| [8950](#L8950) | let match; |
| [8951](#L8951) | if (match = state.cls.match(/\bbdt-animation-[\w-]+/g)) { |
| [8952](#L8952) | const removeAnimationClasses = () => removeClass(el, match); |
| [8953](#L8953) | if (inview) { |
| [8954](#L8954) | state.off = once(el, "animationcancel animationend", removeAnimationClasses, { |
| [8955](#L8955) | self: true |
| [8956](#L8956) | }); |
| [8957](#L8957) | } else { |
| [8958](#L8958) | removeAnimationClasses(); |
| [8959](#L8959) | } |
| [8960](#L8960) | } |
| [8961](#L8961) | trigger(el, inview ? "inview" : "outview"); |
| [8962](#L8962) | state.inview = inview; |
| [8963](#L8963) | } |
| [8964](#L8964) | } |
| [8965](#L8965) | }; |
| [8966](#L8966) |  |
| [8967](#L8967) | var scrollspyNav = { |
| [8968](#L8968) | props: { |
| [8969](#L8969) | cls: String, |
| [8970](#L8970) | closest: Boolean, |
| [8971](#L8971) | scroll: Boolean, |
| [8972](#L8972) | target: String, |
| [8973](#L8973) | offset: Number |
| [8974](#L8974) | }, |
| [8975](#L8975) | data: { |
| [8976](#L8976) | cls: "bdt-active", |
| [8977](#L8977) | closest: false, |
| [8978](#L8978) | scroll: false, |
| [8979](#L8979) | target: 'a[href]:not([role="button"])', |
| [8980](#L8980) | offset: 0 |
| [8981](#L8981) | }, |
| [8982](#L8982) | computed: { |
| [8983](#L8983) | links: ({ target }, $el) => $$(target, $el).filter((el) => isSameSiteAnchor(el)), |
| [8984](#L8984) | elements({ closest }) { |
| [8985](#L8985) | return this.links.map((el) => el.closest(closest || "\*")); |
| [8986](#L8986) | } |
| [8987](#L8987) | }, |
| [8988](#L8988) | watch: { |
| [8989](#L8989) | links(links) { |
| [8990](#L8990) | if (this.scroll) { |
| [8991](#L8991) | this.$create("scroll", links, { offset: this.offset }); |
| [8992](#L8992) | } |
| [8993](#L8993) | } |
| [8994](#L8994) | }, |
| [8995](#L8995) | observe: [intersection(), scroll$1()], |
| [8996](#L8996) | update: [ |
| [8997](#L8997) | { |
| [8998](#L8998) | read() { |
| [8999](#L8999) | const targets = this.links.map((el) => getTargetedElement(el) || el.ownerDocument); |
| [9000](#L9000) | const { length } = targets; |
| [9001](#L9001) | if (!length || !isVisible(this.$el)) { |
| [9002](#L9002) | return false; |
| [9003](#L9003) | } |
| [9004](#L9004) | const scrollElement = scrollParent(targets, true); |
| [9005](#L9005) | const { scrollTop, scrollHeight } = scrollElement; |
| [9006](#L9006) | const viewport = offsetViewport(scrollElement); |
| [9007](#L9007) | const max = scrollHeight - viewport.height; |
| [9008](#L9008) | let active = false; |
| [9009](#L9009) | if (scrollTop >= max) { |
| [9010](#L9010) | active = length - 1; |
| [9011](#L9011) | } else { |
| [9012](#L9012) | const offsetBy = this.offset + dimensions$1(getCoveringElement()).height + viewport.height \* 0.1; |
| [9013](#L9013) | for (let i = 0; i < targets.length; i++) { |
| [9014](#L9014) | if (offset(targets[i]).top - viewport.top - offsetBy > 0) { |
| [9015](#L9015) | break; |
| [9016](#L9016) | } |
| [9017](#L9017) | active = +i; |
| [9018](#L9018) | } |
| [9019](#L9019) | } |
| [9020](#L9020) | return { active }; |
| [9021](#L9021) | }, |
| [9022](#L9022) | write({ active }) { |
| [9023](#L9023) | const changed = active !== false && !hasClass(this.elements[active], this.cls); |
| [9024](#L9024) | this.links.forEach((el) => el.blur()); |
| [9025](#L9025) | for (let i = 0; i < this.elements.length; i++) { |
| [9026](#L9026) | toggleClass(this.elements[i], this.cls, +i === active); |
| [9027](#L9027) | } |
| [9028](#L9028) | if (changed) { |
| [9029](#L9029) | trigger(this.$el, "active", [active, this.elements[active]]); |
| [9030](#L9030) | } |
| [9031](#L9031) | }, |
| [9032](#L9032) | events: ["scroll", "resize"] |
| [9033](#L9033) | } |
| [9034](#L9034) | ] |
| [9035](#L9035) | }; |
| [9036](#L9036) |  |
| [9037](#L9037) | var sticky = { |
| [9038](#L9038) | mixins: [Class, Media], |
| [9039](#L9039) | props: { |
| [9040](#L9040) | position: String, |
| [9041](#L9041) | top: null, |
| [9042](#L9042) | bottom: null, |
| [9043](#L9043) | start: null, |
| [9044](#L9044) | end: null, |
| [9045](#L9045) | offset: String, |
| [9046](#L9046) | overflowFlip: Boolean, |
| [9047](#L9047) | animation: String, |
| [9048](#L9048) | clsActive: String, |
| [9049](#L9049) | clsInactive: String, |
| [9050](#L9050) | clsFixed: String, |
| [9051](#L9051) | clsBelow: String, |
| [9052](#L9052) | selTarget: String, |
| [9053](#L9053) | showOnUp: Boolean, |
| [9054](#L9054) | targetOffset: Number |
| [9055](#L9055) | }, |
| [9056](#L9056) | data: { |
| [9057](#L9057) | position: "top", |
| [9058](#L9058) | top: false, |
| [9059](#L9059) | bottom: false, |
| [9060](#L9060) | start: false, |
| [9061](#L9061) | end: false, |
| [9062](#L9062) | offset: 0, |
| [9063](#L9063) | overflowFlip: false, |
| [9064](#L9064) | animation: "", |
| [9065](#L9065) | clsActive: "bdt-active", |
| [9066](#L9066) | clsInactive: "", |
| [9067](#L9067) | clsFixed: "bdt-sticky-fixed", |
| [9068](#L9068) | clsBelow: "bdt-sticky-below", |
| [9069](#L9069) | selTarget: "", |
| [9070](#L9070) | showOnUp: false, |
| [9071](#L9071) | targetOffset: false |
| [9072](#L9072) | }, |
| [9073](#L9073) | computed: { |
| [9074](#L9074) | target: ({ selTarget }, $el) => selTarget && $(selTarget, $el) || $el |
| [9075](#L9075) | }, |
| [9076](#L9076) | connected() { |
| [9077](#L9077) | this.start = coerce(this.start || this.top); |
| [9078](#L9078) | this.end = coerce(this.end || this.bottom); |
| [9079](#L9079) | this.placeholder = $("+ .bdt-sticky-placeholder", this.$el) || $('<div class="bdt-sticky-placeholder"></div>'); |
| [9080](#L9080) | this.isFixed = false; |
| [9081](#L9081) | this.setActive(false); |
| [9082](#L9082) | }, |
| [9083](#L9083) | beforeDisconnect() { |
| [9084](#L9084) | if (this.isFixed) { |
| [9085](#L9085) | this.hide(); |
| [9086](#L9086) | removeClass(this.target, this.clsInactive); |
| [9087](#L9087) | } |
| [9088](#L9088) | reset(this.$el); |
| [9089](#L9089) | remove$1(this.placeholder); |
| [9090](#L9090) | this.placeholder = null; |
| [9091](#L9091) | }, |
| [9092](#L9092) | observe: [ |
| [9093](#L9093) | viewport(), |
| [9094](#L9094) | scroll$1({ target: () => document.scrollingElement }), |
| [9095](#L9095) | resize({ |
| [9096](#L9096) | target: ({ $el }) => [$el, getVisibleParent($el), document.scrollingElement], |
| [9097](#L9097) | handler(entries) { |
| [9098](#L9098) | this.$emit( |
| [9099](#L9099) | this.\_data.resized && entries.some(({ target }) => target === getVisibleParent(this.$el)) ? "update" : "resize" |
| [9100](#L9100) | ); |
| [9101](#L9101) | this.\_data.resized = true; |
| [9102](#L9102) | } |
| [9103](#L9103) | }) |
| [9104](#L9104) | ], |
| [9105](#L9105) | events: [ |
| [9106](#L9106) | { |
| [9107](#L9107) | name: "load hashchange popstate", |
| [9108](#L9108) | el: () => window, |
| [9109](#L9109) | filter: ({ targetOffset }) => targetOffset !== false, |
| [9110](#L9110) | handler() { |
| [9111](#L9111) | const { scrollingElement } = document; |
| [9112](#L9112) | if (!location.hash || scrollingElement.scrollTop === 0) { |
| [9113](#L9113) | return; |
| [9114](#L9114) | } |
| [9115](#L9115) | setTimeout(() => { |
| [9116](#L9116) | const targetOffset = offset($(location.hash)); |
| [9117](#L9117) | const elOffset = offset(this.$el); |
| [9118](#L9118) | if (this.isFixed && intersectRect(targetOffset, elOffset)) { |
| [9119](#L9119) | scrollingElement.scrollTop = Math.ceil( |
| [9120](#L9120) | targetOffset.top - elOffset.height - toPx(this.targetOffset, "height", this.placeholder) - toPx(this.offset, "height", this.placeholder) |
| [9121](#L9121) | ); |
| [9122](#L9122) | } |
| [9123](#L9123) | }); |
| [9124](#L9124) | } |
| [9125](#L9125) | } |
| [9126](#L9126) | ], |
| [9127](#L9127) | update: [ |
| [9128](#L9128) | { |
| [9129](#L9129) | read({ height: height$1, width, margin, sticky }, types) { |
| [9130](#L9130) | this.inactive = !this.matchMedia || !isVisible(this.$el) || !this.$el.offsetHeight; |
| [9131](#L9131) | if (this.inactive) { |
| [9132](#L9132) | return; |
| [9133](#L9133) | } |
| [9134](#L9134) | const hide = this.isFixed && types.has("update"); |
| [9135](#L9135) | if (hide) { |
| [9136](#L9136) | preventTransition(this.target); |
| [9137](#L9137) | this.hide(); |
| [9138](#L9138) | } |
| [9139](#L9139) | if (!this.active) { |
| [9140](#L9140) | ({ height: height$1, width } = dimensions$1(this.$el)); |
| [9141](#L9141) | margin = css(this.$el, "margin"); |
| [9142](#L9142) | } |
| [9143](#L9143) | if (hide) { |
| [9144](#L9144) | this.show(); |
| [9145](#L9145) | } |
| [9146](#L9146) | const viewport2 = toPx("100vh", "height"); |
| [9147](#L9147) | const dynamicViewport = height(window); |
| [9148](#L9148) | const maxScrollHeight = Math.max( |
| [9149](#L9149) | 0, |
| [9150](#L9150) | document.scrollingElement.scrollHeight - viewport2 |
| [9151](#L9151) | ); |
| [9152](#L9152) | let position = this.position; |
| [9153](#L9153) | if (this.overflowFlip && height$1 > viewport2) { |
| [9154](#L9154) | position = position === "top" ? "bottom" : "top"; |
| [9155](#L9155) | } |
| [9156](#L9156) | const referenceElement = this.isFixed ? this.placeholder : this.$el; |
| [9157](#L9157) | let offset$1 = toPx(this.offset, "height", sticky ? this.$el : referenceElement); |
| [9158](#L9158) | if (position === "bottom" && (height$1 < dynamicViewport || this.overflowFlip)) { |
| [9159](#L9159) | offset$1 += dynamicViewport - height$1; |
| [9160](#L9160) | } |
| [9161](#L9161) | const overflow = this.overflowFlip ? 0 : Math.max(0, height$1 + offset$1 - viewport2); |
| [9162](#L9162) | const topOffset = offset(referenceElement).top; |
| [9163](#L9163) | const elHeight = dimensions$1(this.$el).height; |
| [9164](#L9164) | const start = (this.start === false ? topOffset : parseProp(this.start, this.$el, topOffset)) - offset$1; |
| [9165](#L9165) | const end = this.end === false ? maxScrollHeight : Math.min( |
| [9166](#L9166) | maxScrollHeight, |
| [9167](#L9167) | parseProp(this.end, this.$el, topOffset + height$1, true) - elHeight - offset$1 + overflow |
| [9168](#L9168) | ); |
| [9169](#L9169) | sticky = maxScrollHeight && !this.showOnUp && start + offset$1 === topOffset && end === Math.min( |
| [9170](#L9170) | maxScrollHeight, |
| [9171](#L9171) | parseProp(true, this.$el, 0, true) - elHeight - offset$1 + overflow |
| [9172](#L9172) | ) && css(getVisibleParent(this.$el), "overflowY") === "visible"; |
| [9173](#L9173) | return { |
| [9174](#L9174) | start, |
| [9175](#L9175) | end, |
| [9176](#L9176) | offset: offset$1, |
| [9177](#L9177) | overflow, |
| [9178](#L9178) | height: height$1, |
| [9179](#L9179) | elHeight, |
| [9180](#L9180) | width, |
| [9181](#L9181) | margin, |
| [9182](#L9182) | top: offsetPosition(referenceElement)[0], |
| [9183](#L9183) | sticky, |
| [9184](#L9184) | viewport: viewport2, |
| [9185](#L9185) | maxScrollHeight |
| [9186](#L9186) | }; |
| [9187](#L9187) | }, |
| [9188](#L9188) | write({ height, width, margin, offset, sticky }) { |
| [9189](#L9189) | if (this.inactive || sticky || !this.isFixed) { |
| [9190](#L9190) | reset(this.$el); |
| [9191](#L9191) | } |
| [9192](#L9192) | if (this.inactive) { |
| [9193](#L9193) | return; |
| [9194](#L9194) | } |
| [9195](#L9195) | if (sticky) { |
| [9196](#L9196) | height = width = margin = 0; |
| [9197](#L9197) | css(this.$el, { position: "sticky", top: offset }); |
| [9198](#L9198) | } |
| [9199](#L9199) | const { placeholder } = this; |
| [9200](#L9200) | css(placeholder, { height, width, margin }); |
| [9201](#L9201) | if (parent(placeholder) !== parent(this.$el) || sticky ^ index(placeholder) < index(this.$el)) { |
| [9202](#L9202) | (sticky ? before : after)(this.$el, placeholder); |
| [9203](#L9203) | placeholder.hidden = true; |
| [9204](#L9204) | } |
| [9205](#L9205) | }, |
| [9206](#L9206) | events: ["resize"] |
| [9207](#L9207) | }, |
| [9208](#L9208) | { |
| [9209](#L9209) | read({ |
| [9210](#L9210) | scroll: prevScroll = 0, |
| [9211](#L9211) | dir: prevDir = "down", |
| [9212](#L9212) | overflow, |
| [9213](#L9213) | overflowScroll = 0, |
| [9214](#L9214) | start, |
| [9215](#L9215) | end, |
| [9216](#L9216) | elHeight, |
| [9217](#L9217) | height, |
| [9218](#L9218) | sticky, |
| [9219](#L9219) | maxScrollHeight |
| [9220](#L9220) | }) { |
| [9221](#L9221) | const scroll2 = Math.min(document.scrollingElement.scrollTop, maxScrollHeight); |
| [9222](#L9222) | const dir = prevScroll <= scroll2 ? "down" : "up"; |
| [9223](#L9223) | const referenceElement = this.isFixed ? this.placeholder : this.$el; |
| [9224](#L9224) | return { |
| [9225](#L9225) | dir, |
| [9226](#L9226) | prevDir, |
| [9227](#L9227) | scroll: scroll2, |
| [9228](#L9228) | prevScroll, |
| [9229](#L9229) | below: scroll2 > offset(referenceElement).top + (sticky ? Math.min(height, elHeight) : height), |
| [9230](#L9230) | offsetParentTop: offset(referenceElement.offsetParent).top, |
| [9231](#L9231) | overflowScroll: clamp( |
| [9232](#L9232) | overflowScroll + clamp(scroll2, start, end) - clamp(prevScroll, start, end), |
| [9233](#L9233) | 0, |
| [9234](#L9234) | overflow |
| [9235](#L9235) | ) |
| [9236](#L9236) | }; |
| [9237](#L9237) | }, |
| [9238](#L9238) | write(data, types) { |
| [9239](#L9239) | const isScrollUpdate = types.has("scroll"); |
| [9240](#L9240) | const { |
| [9241](#L9241) | initTimestamp = 0, |
| [9242](#L9242) | dir, |
| [9243](#L9243) | prevDir, |
| [9244](#L9244) | scroll: scroll2, |
| [9245](#L9245) | prevScroll = 0, |
| [9246](#L9246) | top, |
| [9247](#L9247) | start, |
| [9248](#L9248) | below |
| [9249](#L9249) | } = data; |
| [9250](#L9250) | if (scroll2 < 0 || scroll2 === prevScroll && isScrollUpdate || this.showOnUp && !isScrollUpdate && !this.isFixed) { |
| [9251](#L9251) | return; |
| [9252](#L9252) | } |
| [9253](#L9253) | const now = Date.now(); |
| [9254](#L9254) | if (now - initTimestamp > 300 || dir !== prevDir) { |
| [9255](#L9255) | data.initScroll = scroll2; |
| [9256](#L9256) | data.initTimestamp = now; |
| [9257](#L9257) | } |
| [9258](#L9258) | if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll2) <= 30 && Math.abs(prevScroll - scroll2) <= 10) { |
| [9259](#L9259) | return; |
| [9260](#L9260) | } |
| [9261](#L9261) | if (this.inactive || scroll2 < start || this.showOnUp && (scroll2 <= start || dir === "down" && isScrollUpdate || dir === "up" && !this.isFixed && !below)) { |
| [9262](#L9262) | if (!this.isFixed) { |
| [9263](#L9263) | if (Animation.inProgress(this.$el) && top > scroll2) { |
| [9264](#L9264) | Animation.cancel(this.$el); |
| [9265](#L9265) | this.hide(); |
| [9266](#L9266) | } |
| [9267](#L9267) | return; |
| [9268](#L9268) | } |
| [9269](#L9269) | if (this.animation && below) { |
| [9270](#L9270) | if (hasClass(this.$el, "bdt-animation-leave")) { |
| [9271](#L9271) | return; |
| [9272](#L9272) | } |
| [9273](#L9273) | Animation.out(this.$el, this.animation).then(() => this.hide(), noop); |
| [9274](#L9274) | } else { |
| [9275](#L9275) | this.hide(); |
| [9276](#L9276) | } |
| [9277](#L9277) | } else if (this.isFixed) { |
| [9278](#L9278) | this.update(); |
| [9279](#L9279) | } else if (this.animation && below) { |
| [9280](#L9280) | this.show(); |
| [9281](#L9281) | Animation.in(this.$el, this.animation).catch(noop); |
| [9282](#L9282) | } else { |
| [9283](#L9283) | preventTransition(this.target); |
| [9284](#L9284) | this.show(); |
| [9285](#L9285) | } |
| [9286](#L9286) | }, |
| [9287](#L9287) | events: ["resize", "resizeViewport", "scroll"] |
| [9288](#L9288) | } |
| [9289](#L9289) | ], |
| [9290](#L9290) | methods: { |
| [9291](#L9291) | show() { |
| [9292](#L9292) | this.isFixed = true; |
| [9293](#L9293) | this.update(); |
| [9294](#L9294) | this.placeholder.hidden = false; |
| [9295](#L9295) | }, |
| [9296](#L9296) | hide() { |
| [9297](#L9297) | const { offset, sticky } = this.\_data; |
| [9298](#L9298) | this.setActive(false); |
| [9299](#L9299) | removeClass(this.$el, this.clsFixed, this.clsBelow); |
| [9300](#L9300) | if (sticky) { |
| [9301](#L9301) | css(this.$el, "top", offset); |
| [9302](#L9302) | } else { |
| [9303](#L9303) | css(this.$el, { |
| [9304](#L9304) | position: "", |
| [9305](#L9305) | top: "", |
| [9306](#L9306) | width: "", |
| [9307](#L9307) | marginTop: "" |
| [9308](#L9308) | }); |
| [9309](#L9309) | } |
| [9310](#L9310) | this.placeholder.hidden = true; |
| [9311](#L9311) | this.isFixed = false; |
| [9312](#L9312) | }, |
| [9313](#L9313) | update() { |
| [9314](#L9314) | let { |
| [9315](#L9315) | width, |
| [9316](#L9316) | scroll: scroll2 = 0, |
| [9317](#L9317) | overflow, |
| [9318](#L9318) | overflowScroll = 0, |
| [9319](#L9319) | start, |
| [9320](#L9320) | end, |
| [9321](#L9321) | offset, |
| [9322](#L9322) | offsetParentTop, |
| [9323](#L9323) | sticky, |
| [9324](#L9324) | below |
| [9325](#L9325) | } = this.\_data; |
| [9326](#L9326) | const active = start !== 0 || scroll2 > start; |
| [9327](#L9327) | if (!sticky) { |
| [9328](#L9328) | let position = "fixed"; |
| [9329](#L9329) | if (scroll2 > end) { |
| [9330](#L9330) | offset += end - offsetParentTop + overflowScroll - overflow; |
| [9331](#L9331) | position = "absolute"; |
| [9332](#L9332) | } |
| [9333](#L9333) | css(this.$el, { position, width, marginTop: 0 }, "important"); |
| [9334](#L9334) | } |
| [9335](#L9335) | css(this.$el, "top", offset - overflowScroll); |
| [9336](#L9336) | this.setActive(active); |
| [9337](#L9337) | toggleClass(this.$el, this.clsBelow, below); |
| [9338](#L9338) | addClass(this.$el, this.clsFixed); |
| [9339](#L9339) | }, |
| [9340](#L9340) | setActive(active) { |
| [9341](#L9341) | const prev = this.active; |
| [9342](#L9342) | this.active = active; |
| [9343](#L9343) | if (active) { |
| [9344](#L9344) | replaceClass(this.target, this.clsInactive, this.clsActive); |
| [9345](#L9345) | prev !== active && trigger(this.$el, "active"); |
| [9346](#L9346) | } else { |
| [9347](#L9347) | replaceClass(this.target, this.clsActive, this.clsInactive); |
| [9348](#L9348) | if (prev !== active) { |
| [9349](#L9349) | preventTransition(this.target); |
| [9350](#L9350) | trigger(this.$el, "inactive"); |
| [9351](#L9351) | } |
| [9352](#L9352) | } |
| [9353](#L9353) | } |
| [9354](#L9354) | } |
| [9355](#L9355) | }; |
| [9356](#L9356) | function parseProp(value, el, propOffset, padding) { |
| [9357](#L9357) | if (!value) { |
| [9358](#L9358) | return 0; |
| [9359](#L9359) | } |
| [9360](#L9360) | if (isNumeric(value) || isString(value) && value.match(/^-?\d/)) { |
| [9361](#L9361) | return propOffset + toPx(value, "height", el, true); |
| [9362](#L9362) | } else { |
| [9363](#L9363) | const refElement = value === true ? getVisibleParent(el) : query(value, el); |
| [9364](#L9364) | return offset(refElement).bottom - (padding && (refElement == null ? void 0 : refElement.contains(el)) ? toFloat(css(refElement, "paddingBottom")) : 0); |
| [9365](#L9365) | } |
| [9366](#L9366) | } |
| [9367](#L9367) | function coerce(value) { |
| [9368](#L9368) | if (value === "true") { |
| [9369](#L9369) | return true; |
| [9370](#L9370) | } else if (value === "false") { |
| [9371](#L9371) | return false; |
| [9372](#L9372) | } |
| [9373](#L9373) | return value; |
| [9374](#L9374) | } |
| [9375](#L9375) | function reset(el) { |
| [9376](#L9376) | css(el, { position: "", top: "", marginTop: "", width: "" }); |
| [9377](#L9377) | } |
| [9378](#L9378) | const clsTransitionDisable = "bdt-transition-disable"; |
| [9379](#L9379) | function preventTransition(element) { |
| [9380](#L9380) | if (!hasClass(element, clsTransitionDisable)) { |
| [9381](#L9381) | addClass(element, clsTransitionDisable); |
| [9382](#L9382) | requestAnimationFrame(() => removeClass(element, clsTransitionDisable)); |
| [9383](#L9383) | } |
| [9384](#L9384) | } |
| [9385](#L9385) | function getVisibleParent(element) { |
| [9386](#L9386) | while (element = parent(element)) { |
| [9387](#L9387) | if (isVisible(element)) { |
| [9388](#L9388) | return element; |
| [9389](#L9389) | } |
| [9390](#L9390) | } |
| [9391](#L9391) | } |
| [9392](#L9392) |  |
| [9393](#L9393) | const selDisabled = ".bdt-disabled \*, .bdt-disabled, [disabled]"; |
| [9394](#L9394) | var Switcher = { |
| [9395](#L9395) | mixins: [Togglable], |
| [9396](#L9396) | args: "connect", |
| [9397](#L9397) | props: { |
| [9398](#L9398) | connect: String, |
| [9399](#L9399) | toggle: String, |
| [9400](#L9400) | itemNav: String, |
| [9401](#L9401) | active: Number, |
| [9402](#L9402) | followFocus: Boolean, |
| [9403](#L9403) | swiping: Boolean |
| [9404](#L9404) | }, |
| [9405](#L9405) | data: { |
| [9406](#L9406) | connect: "~.bdt-switcher", |
| [9407](#L9407) | toggle: "> \* > :first-child", |
| [9408](#L9408) | itemNav: false, |
| [9409](#L9409) | active: 0, |
| [9410](#L9410) | cls: "bdt-active", |
| [9411](#L9411) | attrItem: "bdt-switcher-item", |
| [9412](#L9412) | selVertical: ".bdt-nav", |
| [9413](#L9413) | followFocus: false, |
| [9414](#L9414) | swiping: true |
| [9415](#L9415) | }, |
| [9416](#L9416) | computed: { |
| [9417](#L9417) | connects: { |
| [9418](#L9418) | get: ({ connect }, $el) => queryAll(connect, $el), |
| [9419](#L9419) | observe: ({ connect }) => connect |
| [9420](#L9420) | }, |
| [9421](#L9421) | connectChildren() { |
| [9422](#L9422) | return this.connects.map((el) => children(el)).flat(); |
| [9423](#L9423) | }, |
| [9424](#L9424) | toggles: ({ toggle }, $el) => $$(toggle, $el), |
| [9425](#L9425) | children(\_, $el) { |
| [9426](#L9426) | return children($el).filter( |
| [9427](#L9427) | (child) => this.toggles.some((toggle) => child.contains(toggle)) |
| [9428](#L9428) | ); |
| [9429](#L9429) | } |
| [9430](#L9430) | }, |
| [9431](#L9431) | watch: { |
| [9432](#L9432) | connects(connects) { |
| [9433](#L9433) | if (this.swiping) { |
| [9434](#L9434) | css(connects, "touchAction", "pan-y pinch-zoom"); |
| [9435](#L9435) | } |
| [9436](#L9436) | this.$emit(); |
| [9437](#L9437) | }, |
| [9438](#L9438) | connectChildren() { |
| [9439](#L9439) | let index = Math.max(0, this.index()); |
| [9440](#L9440) | for (const el of this.connects) { |
| [9441](#L9441) | children(el).forEach((child, i) => toggleClass(child, this.cls, i === index)); |
| [9442](#L9442) | } |
| [9443](#L9443) | this.$emit(); |
| [9444](#L9444) | }, |
| [9445](#L9445) | toggles(toggles) { |
| [9446](#L9446) | this.$emit(); |
| [9447](#L9447) | const active = this.index(); |
| [9448](#L9448) | this.show(~active ? active : toggles[this.active] || toggles[0]); |
| [9449](#L9449) | } |
| [9450](#L9450) | }, |
| [9451](#L9451) | connected() { |
| [9452](#L9452) | attr(this.$el, "role", "tablist"); |
| [9453](#L9453) | }, |
| [9454](#L9454) | observe: [ |
| [9455](#L9455) | lazyload({ targets: ({ connectChildren }) => connectChildren }), |
| [9456](#L9456) | swipe({ target: ({ connects }) => connects, filter: ({ swiping }) => swiping }) |
| [9457](#L9457) | ], |
| [9458](#L9458) | events: [ |
| [9459](#L9459) | { |
| [9460](#L9460) | name: "click keydown", |
| [9461](#L9461) | delegate: ({ toggle }) => toggle, |
| [9462](#L9462) | handler(e) { |
| [9463](#L9463) | if (!matches(e.current, selDisabled) && (e.type === "click" || e.keyCode === keyMap.SPACE)) { |
| [9464](#L9464) | e.preventDefault(); |
| [9465](#L9465) | this.show(e.current); |
| [9466](#L9466) | } |
| [9467](#L9467) | } |
| [9468](#L9468) | }, |
| [9469](#L9469) | { |
| [9470](#L9470) | name: "keydown", |
| [9471](#L9471) | delegate: ({ toggle }) => toggle, |
| [9472](#L9472) | handler(e) { |
| [9473](#L9473) | const { current, keyCode } = e; |
| [9474](#L9474) | const isVertical = matches(this.$el, this.selVertical); |
| [9475](#L9475) | let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT && !isVertical || keyCode === keyMap.UP && isVertical ? "previous" : keyCode === keyMap.RIGHT && !isVertical || keyCode === keyMap.DOWN && isVertical ? "next" : -1; |
| [9476](#L9476) | if (~i) { |
| [9477](#L9477) | e.preventDefault(); |
| [9478](#L9478) | const toggles = this.toggles.filter((el) => !matches(el, selDisabled)); |
| [9479](#L9479) | const next = toggles[getIndex(i, toggles, toggles.indexOf(current))]; |
| [9480](#L9480) | next.focus(); |
| [9481](#L9481) | if (this.followFocus) { |
| [9482](#L9482) | this.show(next); |
| [9483](#L9483) | } |
| [9484](#L9484) | } |
| [9485](#L9485) | } |
| [9486](#L9486) | }, |
| [9487](#L9487) | { |
| [9488](#L9488) | name: "click", |
| [9489](#L9489) | el: ({ $el, connects, itemNav }) => connects.concat(itemNav ? queryAll(itemNav, $el) : []), |
| [9490](#L9490) | delegate: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`, |
| [9491](#L9491) | handler(e) { |
| [9492](#L9492) | if (e.target.closest("a,button")) { |
| [9493](#L9493) | e.preventDefault(); |
| [9494](#L9494) | this.show(data(e.current, this.attrItem)); |
| [9495](#L9495) | } |
| [9496](#L9496) | } |
| [9497](#L9497) | }, |
| [9498](#L9498) | { |
| [9499](#L9499) | name: "swipeRight swipeLeft", |
| [9500](#L9500) | filter: ({ swiping }) => swiping, |
| [9501](#L9501) | el: ({ connects }) => connects, |
| [9502](#L9502) | handler({ type }) { |
| [9503](#L9503) | this.show(endsWith(type, "Left") ? "next" : "previous"); |
| [9504](#L9504) | } |
| [9505](#L9505) | } |
| [9506](#L9506) | ], |
| [9507](#L9507) | update() { |
| [9508](#L9508) | var \_a; |
| [9509](#L9509) | for (const el of this.connects) { |
| [9510](#L9510) | if (isTag(el, "ul")) { |
| [9511](#L9511) | attr(el, "role", "presentation"); |
| [9512](#L9512) | } |
| [9513](#L9513) | } |
| [9514](#L9514) | attr(children(this.$el), "role", "presentation"); |
| [9515](#L9515) | for (const index in this.toggles) { |
| [9516](#L9516) | const toggle = this.toggles[index]; |
| [9517](#L9517) | const item = (\_a = this.connects[0]) == null ? void 0 : \_a.children[index]; |
| [9518](#L9518) | attr(toggle, "role", "tab"); |
| [9519](#L9519) | if (!item) { |
| [9520](#L9520) | continue; |
| [9521](#L9521) | } |
| [9522](#L9522) | toggle.id = generateId(this, toggle); |
| [9523](#L9523) | item.id = generateId(this, item); |
| [9524](#L9524) | attr(toggle, "aria-controls", item.id); |
| [9525](#L9525) | attr(item, { role: "tabpanel", "aria-labelledby": toggle.id }); |
| [9526](#L9526) | } |
| [9527](#L9527) | attr(this.$el, "aria-orientation", matches(this.$el, this.selVertical) ? "vertical" : null); |
| [9528](#L9528) | }, |
| [9529](#L9529) | methods: { |
| [9530](#L9530) | index() { |
| [9531](#L9531) | return findIndex(this.children, (el) => hasClass(el, this.cls)); |
| [9532](#L9532) | }, |
| [9533](#L9533) | show(item) { |
| [9534](#L9534) | const toggles = this.toggles.filter((el) => !matches(el, selDisabled)); |
| [9535](#L9535) | const prev = this.index(); |
| [9536](#L9536) | const next = getIndex( |
| [9537](#L9537) | !isNode(item) || includes(toggles, item) ? item : 0, |
| [9538](#L9538) | toggles, |
| [9539](#L9539) | getIndex(this.toggles[prev], toggles) |
| [9540](#L9540) | ); |
| [9541](#L9541) | const active = getIndex(toggles[next], this.toggles); |
| [9542](#L9542) | this.children.forEach((child, i) => { |
| [9543](#L9543) | toggleClass(child, this.cls, active === i); |
| [9544](#L9544) | attr(this.toggles[i], { |
| [9545](#L9545) | "aria-selected": active === i, |
| [9546](#L9546) | tabindex: active === i ? null : -1 |
| [9547](#L9547) | }); |
| [9548](#L9548) | }); |
| [9549](#L9549) | const animate = prev >= 0 && prev !== next; |
| [9550](#L9550) | this.connects.forEach(async ({ children: children2 }) => { |
| [9551](#L9551) | const actives = toArray(children2).filter( |
| [9552](#L9552) | (child, i) => i !== active && hasClass(child, this.cls) |
| [9553](#L9553) | ); |
| [9554](#L9554) | if (await this.toggleElement(actives, false, animate)) { |
| [9555](#L9555) | await this.toggleElement(children2[active], true, animate); |
| [9556](#L9556) | } |
| [9557](#L9557) | }); |
| [9558](#L9558) | } |
| [9559](#L9559) | } |
| [9560](#L9560) | }; |
| [9561](#L9561) |  |
| [9562](#L9562) | var tab = { |
| [9563](#L9563) | mixins: [Class], |
| [9564](#L9564) | extends: Switcher, |
| [9565](#L9565) | props: { |
| [9566](#L9566) | media: Boolean |
| [9567](#L9567) | }, |
| [9568](#L9568) | data: { |
| [9569](#L9569) | media: 960, |
| [9570](#L9570) | attrItem: "bdt-tab-item", |
| [9571](#L9571) | selVertical: ".bdt-tab-left,.bdt-tab-right" |
| [9572](#L9572) | }, |
| [9573](#L9573) | connected() { |
| [9574](#L9574) | const cls = hasClass(this.$el, "bdt-tab-left") ? "bdt-tab-left" : hasClass(this.$el, "bdt-tab-right") ? "bdt-tab-right" : false; |
| [9575](#L9575) | if (cls) { |
| [9576](#L9576) | this.$create("toggle", this.$el, { cls, mode: "media", media: this.media }); |
| [9577](#L9577) | } |
| [9578](#L9578) | } |
| [9579](#L9579) | }; |
| [9580](#L9580) |  |
| [9581](#L9581) | const KEY\_SPACE = 32; |
| [9582](#L9582) | var toggle = { |
| [9583](#L9583) | mixins: [Media, Togglable], |
| [9584](#L9584) | args: "target", |
| [9585](#L9585) | props: { |
| [9586](#L9586) | href: String, |
| [9587](#L9587) | target: null, |
| [9588](#L9588) | mode: "list", |
| [9589](#L9589) | queued: Boolean |
| [9590](#L9590) | }, |
| [9591](#L9591) | data: { |
| [9592](#L9592) | href: false, |
| [9593](#L9593) | target: false, |
| [9594](#L9594) | mode: "click", |
| [9595](#L9595) | queued: true |
| [9596](#L9596) | }, |
| [9597](#L9597) | computed: { |
| [9598](#L9598) | target: { |
| [9599](#L9599) | get: ({ target }, $el) => { |
| [9600](#L9600) | target = queryAll(target || $el.hash, $el); |
| [9601](#L9601) | return target.length ? target : [$el]; |
| [9602](#L9602) | }, |
| [9603](#L9603) | observe: ({ target }) => target |
| [9604](#L9604) | } |
| [9605](#L9605) | }, |
| [9606](#L9606) | connected() { |
| [9607](#L9607) | if (!includes(this.mode, "media")) { |
| [9608](#L9608) | if (!isFocusable(this.$el)) { |
| [9609](#L9609) | attr(this.$el, "tabindex", "0"); |
| [9610](#L9610) | } |
| [9611](#L9611) | if (!this.cls && isTag(this.$el, "a")) { |
| [9612](#L9612) | attr(this.$el, "role", "button"); |
| [9613](#L9613) | } |
| [9614](#L9614) | } |
| [9615](#L9615) | }, |
| [9616](#L9616) | observe: lazyload({ targets: ({ target }) => target }), |
| [9617](#L9617) | events: [ |
| [9618](#L9618) | { |
| [9619](#L9619) | name: pointerDown$1, |
| [9620](#L9620) | filter: ({ mode }) => includes(mode, "hover"), |
| [9621](#L9621) | handler(e) { |
| [9622](#L9622) | this.\_preventClick = null; |
| [9623](#L9623) | if (!isTouch(e) || isBoolean(this.\_showState) || this.$el.disabled) { |
| [9624](#L9624) | return; |
| [9625](#L9625) | } |
| [9626](#L9626) | trigger(this.$el, "focus"); |
| [9627](#L9627) | once( |
| [9628](#L9628) | document, |
| [9629](#L9629) | pointerDown$1, |
| [9630](#L9630) | () => trigger(this.$el, "blur"), |
| [9631](#L9631) | true, |
| [9632](#L9632) | (e2) => !this.$el.contains(e2.target) |
| [9633](#L9633) | ); |
| [9634](#L9634) | if (includes(this.mode, "click")) { |
| [9635](#L9635) | this.\_preventClick = true; |
| [9636](#L9636) | } |
| [9637](#L9637) | } |
| [9638](#L9638) | }, |
| [9639](#L9639) | { |
| [9640](#L9640) | // mouseenter mouseleave are added because of Firefox bug, |
| [9641](#L9641) | // where pointerleave is triggered immediately after pointerenter on scroll |
| [9642](#L9642) | name: `mouseenter mouseleave ${pointerEnter} ${pointerLeave} focus blur`, |
| [9643](#L9643) | filter: ({ mode }) => includes(mode, "hover"), |
| [9644](#L9644) | handler(e) { |
| [9645](#L9645) | if (isTouch(e) || this.$el.disabled) { |
| [9646](#L9646) | return; |
| [9647](#L9647) | } |
| [9648](#L9648) | const show = includes(["mouseenter", pointerEnter, "focus"], e.type); |
| [9649](#L9649) | const expanded = this.isToggled(this.target); |
| [9650](#L9650) | if (!show && (!isBoolean(this.\_showState) || e.type !== "blur" && matches(this.$el, ":focus") || e.type === "blur" && matches(this.$el, ":hover"))) { |
| [9651](#L9651) | if (expanded === this.\_showState) { |
| [9652](#L9652) | this.\_showState = null; |
| [9653](#L9653) | } |
| [9654](#L9654) | return; |
| [9655](#L9655) | } |
| [9656](#L9656) | if (show && isBoolean(this.\_showState) && expanded !== this.\_showState) { |
| [9657](#L9657) | return; |
| [9658](#L9658) | } |
| [9659](#L9659) | this.\_showState = show ? expanded : null; |
| [9660](#L9660) | this.toggle(`toggle${show ? "show" : "hide"}`); |
| [9661](#L9661) | } |
| [9662](#L9662) | }, |
| [9663](#L9663) | { |
| [9664](#L9664) | name: "keydown", |
| [9665](#L9665) | filter: ({ $el, mode }) => includes(mode, "click") && !isTag($el, "input"), |
| [9666](#L9666) | handler(e) { |
| [9667](#L9667) | if (e.keyCode === KEY\_SPACE) { |
| [9668](#L9668) | e.preventDefault(); |
| [9669](#L9669) | this.$el.click(); |
| [9670](#L9670) | } |
| [9671](#L9671) | } |
| [9672](#L9672) | }, |
| [9673](#L9673) | { |
| [9674](#L9674) | name: "click", |
| [9675](#L9675) | filter: ({ mode }) => ["click", "hover"].some((m) => includes(mode, m)), |
| [9676](#L9676) | handler(e) { |
| [9677](#L9677) | let link; |
| [9678](#L9678) | if (this.\_preventClick || e.target.closest('a[href="#"], a[href=""]') || (link = e.target.closest("a[href]")) && (!this.isToggled(this.target) || link.hash && matches(this.target, link.hash))) { |
| [9679](#L9679) | e.preventDefault(); |
| [9680](#L9680) | } |
| [9681](#L9681) | if (!this.\_preventClick && includes(this.mode, "click")) { |
| [9682](#L9682) | this.toggle(); |
| [9683](#L9683) | } |
| [9684](#L9684) | } |
| [9685](#L9685) | }, |
| [9686](#L9686) | { |
| [9687](#L9687) | name: "mediachange", |
| [9688](#L9688) | filter: ({ mode }) => includes(mode, "media"), |
| [9689](#L9689) | el: ({ target }) => target, |
| [9690](#L9690) | handler(e, mediaObj) { |
| [9691](#L9691) | if (mediaObj.matches ^ this.isToggled(this.target)) { |
| [9692](#L9692) | this.toggle(); |
| [9693](#L9693) | } |
| [9694](#L9694) | } |
| [9695](#L9695) | } |
| [9696](#L9696) | ], |
| [9697](#L9697) | methods: { |
| [9698](#L9698) | async toggle(type) { |
| [9699](#L9699) | if (!trigger(this.target, type || "toggle", [this])) { |
| [9700](#L9700) | return; |
| [9701](#L9701) | } |
| [9702](#L9702) | if (hasAttr(this.$el, "aria-expanded")) { |
| [9703](#L9703) | attr(this.$el, "aria-expanded", !this.isToggled(this.target)); |
| [9704](#L9704) | } |
| [9705](#L9705) | if (!this.queued) { |
| [9706](#L9706) | return this.toggleElement(this.target); |
| [9707](#L9707) | } |
| [9708](#L9708) | const leaving = this.target.filter((el) => hasClass(el, this.clsLeave)); |
| [9709](#L9709) | if (leaving.length) { |
| [9710](#L9710) | for (const el of this.target) { |
| [9711](#L9711) | const isLeaving = includes(leaving, el); |
| [9712](#L9712) | this.toggleElement(el, isLeaving, isLeaving); |
| [9713](#L9713) | } |
| [9714](#L9714) | return; |
| [9715](#L9715) | } |
| [9716](#L9716) | const toggled = this.target.filter(this.isToggled); |
| [9717](#L9717) | if (await this.toggleElement(toggled, false)) { |
| [9718](#L9718) | await this.toggleElement( |
| [9719](#L9719) | this.target.filter((el) => !includes(toggled, el)), |
| [9720](#L9720) | true |
| [9721](#L9721) | ); |
| [9722](#L9722) | } |
| [9723](#L9723) | } |
| [9724](#L9724) | } |
| [9725](#L9725) | }; |
| [9726](#L9726) |  |
| [9727](#L9727) | var components = /\*#\_\_PURE\_\_\*/Object.freeze({ |
| [9728](#L9728) | \_\_proto\_\_: null, |
| [9729](#L9729) | Accordion: Accordion, |
| [9730](#L9730) | Alert: alert, |
| [9731](#L9731) | Close: Close, |
| [9732](#L9732) | Cover: cover, |
| [9733](#L9733) | Drop: drop, |
| [9734](#L9734) | DropParentIcon: IconComponent, |
| [9735](#L9735) | Dropdown: drop, |
| [9736](#L9736) | Dropnav: Dropnav, |
| [9737](#L9737) | FormCustom: formCustom, |
| [9738](#L9738) | Grid: grid, |
| [9739](#L9739) | HeightMatch: heightMatch, |
| [9740](#L9740) | HeightPlaceholder: heightPlaceholder, |
| [9741](#L9741) | HeightViewport: heightViewport, |
| [9742](#L9742) | Icon: Icon, |
| [9743](#L9743) | Img: img, |
| [9744](#L9744) | Inverse: inverse, |
| [9745](#L9745) | Leader: leader, |
| [9746](#L9746) | Margin: Margin, |
| [9747](#L9747) | Marker: Marker, |
| [9748](#L9748) | Modal: modal, |
| [9749](#L9749) | Nav: nav, |
| [9750](#L9750) | NavParentIcon: NavParentIcon, |
| [9751](#L9751) | Navbar: navbar, |
| [9752](#L9752) | NavbarParentIcon: IconComponent, |
| [9753](#L9753) | NavbarToggleIcon: NavbarToggleIcon, |
| [9754](#L9754) | Offcanvas: offcanvas, |
| [9755](#L9755) | OverflowAuto: overflowAuto, |
| [9756](#L9756) | OverlayIcon: IconComponent, |
| [9757](#L9757) | PaginationNext: PaginationNext, |
| [9758](#L9758) | PaginationPrevious: PaginationPrevious, |
| [9759](#L9759) | Responsive: responsive, |
| [9760](#L9760) | Scroll: scroll, |
| [9761](#L9761) | Scrollspy: scrollspy, |
| [9762](#L9762) | ScrollspyNav: scrollspyNav, |
| [9763](#L9763) | SearchIcon: Search, |
| [9764](#L9764) | SlidenavNext: Slidenav, |
| [9765](#L9765) | SlidenavPrevious: Slidenav, |
| [9766](#L9766) | Spinner: Spinner, |
| [9767](#L9767) | Sticky: sticky, |
| [9768](#L9768) | Svg: svg, |
| [9769](#L9769) | Switcher: Switcher, |
| [9770](#L9770) | Tab: tab, |
| [9771](#L9771) | Toggle: toggle, |
| [9772](#L9772) | Totop: Totop, |
| [9773](#L9773) | Video: Video |
| [9774](#L9774) | }); |
| [9775](#L9775) |  |
| [9776](#L9776) | each(components, (component, name) => App.component(name, component)); |
| [9777](#L9777) | boot(App); |
| [9778](#L9778) |  |
| [9779](#L9779) | each(components$1, (component, name) => App.component(name, component)); |
| [9780](#L9780) |  |
| [9781](#L9781) | return App; |
| [9782](#L9782) |  |
| [9783](#L9783) | })); |

**Note:** See [TracBrowser](/wiki/TracBrowser)
for help on using the repository browser.

[Trac UI Preferences](/prefs)
### Download in other formats:

* [Plain Text](/browser/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js?format=txt)
* [Original Format](/export/3220493/bdthemes-element-pack-lite/trunk/assets/js/bdt-uikit.js)

* [About](https://wordpress.org/about/)
* [News](https://wordpress.org/news/)
* [Hosting](https://wordpress.org/hosting/)
* [Donate](https://wordpressfoundation.org/donate/)
* [Swag](https://mercantile.wordpress.org/)

* [Documentation](https://wordpress.org/documentation/)
* [Developers](https://developer.wordpress.org/)
* [Get Involved](https://make.wordpress.org/)
* [Learn](https://learn.wordpress.org/)

* [Showcase](https://wordpress.org/showcase/)
* [Plugins](https://wordpress.org/plugins/)
* [Themes](https://wordpress.org/themes/)
* [Patterns](https://wordpress.org/patterns/)

* [WordCamp](https://central.wordcamp.org/)
* [WordPress.TV](https://wordpress.tv/)
* [BuddyPress](https://buddypress.org/)
* [bbPress](https://bbpress.org/)

* [WordPress.com](https://wordpress.com/?ref=wporg-footer)
* [Matt](https://ma.tt/)
* [Privacy](https://wordpress.org/about/privacy/)
* [Public Code](https://publiccode.eu/)

[WordPress.org](https://wordpress.org/)

[WordPress.org](https://wordpress.org/)

* [Visit our Facebook page](https://www.facebook.com/WordPress/)
* [Visit our Twitter account](https://twitter.com/WordPress)
* [Visit our Instagram account](https://www.instagram.com/wordpress/)
* [Visit our LinkedIn account](https://www.linkedin.com/company/wordpress)

![Code is Poetry](https://s.w.org/style/images/code-is-poetry-for-dark-bg.svg)

