

| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | shamir rabinovitch <shamir.rabinovitch@oracle.com> | 2018-12-16 09:01:08 +0200 |
| --- | --- | --- |
| committer | David S. Miller <davem@davemloft.net> | 2018-12-19 10:27:58 -0800 |
| commit | [ea010070d0a7497253d5a6f919f6dd107450b31a](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ea010070d0a7497253d5a6f919f6dd107450b31a) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)) | |
| tree | [4bd1b33edd72bdd73d39e7f8160a73730704fa56](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=ea010070d0a7497253d5a6f919f6dd107450b31a) | |
| parent | [c6f4075e2f14a91f2180c98bc7715946f791cbe6](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c6f4075e2f14a91f2180c98bc7715946f791cbe6) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ea010070d0a7497253d5a6f919f6dd107450b31a&id2=c6f4075e2f14a91f2180c98bc7715946f791cbe6)) | |
| download | [linux-ea010070d0a7497253d5a6f919f6dd107450b31a.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-ea010070d0a7497253d5a6f919f6dd107450b31a.tar.gz) | |

net/rds: fix warn in rds\_message\_alloc\_sgsredundant copy\_from\_user in rds\_sendmsg system call expose rds
to issue where rds\_rdma\_extra\_size walk the rds iovec and and
calculate the number pf pages (sgs) it need to add to the tail of
rds message and later rds\_cmsg\_rdma\_args copy the rds iovec again
and re calculate the same number and get different result causing
WARN\_ON in rds\_message\_alloc\_sgs.
fix this by doing the copy\_from\_user only once per rds\_sendmsg
system call.
When issue occur the below dump is seen:
WARNING: CPU: 0 PID: 19789 at net/rds/message.c:316 rds\_message\_alloc\_sgs+0x10c/0x160 net/rds/message.c:316
Kernel panic - not syncing: panic\_on\_warn set ...
CPU: 0 PID: 19789 Comm: syz-executor827 Not tainted 4.19.0-next-20181030+ #101
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
Call Trace:
\_\_dump\_stack lib/dump\_stack.c:77 [inline]
dump\_stack+0x244/0x39d lib/dump\_stack.c:113
panic+0x2ad/0x55c kernel/panic.c:188
\_\_warn.cold.8+0x20/0x45 kernel/panic.c:540
report\_bug+0x254/0x2d0 lib/bug.c:186
fixup\_bug arch/x86/kernel/traps.c:178 [inline]
do\_error\_trap+0x11b/0x200 arch/x86/kernel/traps.c:271
do\_invalid\_op+0x36/0x40 arch/x86/kernel/traps.c:290
invalid\_op+0x14/0x20 arch/x86/entry/entry\_64.S:969
RIP: 0010:rds\_message\_alloc\_sgs+0x10c/0x160 net/rds/message.c:316
Code: c0 74 04 3c 03 7e 6c 44 01 ab 78 01 00 00 e8 2b 9e 35 fa 4c 89 e0 48 83 c4 08 5b 41 5c 41 5d 41 5e 41 5f 5d c3 e8 14 9e 35 fa <0f> 0b 31 ff 44 89 ee e8 18 9f 35 fa 45 85 ed 75 1b e8 fe 9d 35 fa
RSP: 0018:ffff8801c51b7460 EFLAGS: 00010293
RAX: ffff8801bc412080 RBX: ffff8801d7bf4040 RCX: ffffffff8749c9e6
RDX: 0000000000000000 RSI: ffffffff8749ca5c RDI: 0000000000000004
RBP: ffff8801c51b7490 R08: ffff8801bc412080 R09: ffffed003b5c5b67
R10: ffffed003b5c5b67 R11: ffff8801dae2db3b R12: 0000000000000000
R13: 000000000007165c R14: 000000000007165c R15: 0000000000000005
rds\_cmsg\_rdma\_args+0x82d/0x1510 net/rds/rdma.c:623
rds\_cmsg\_send net/rds/send.c:971 [inline]
rds\_sendmsg+0x19a2/0x3180 net/rds/send.c:1273
sock\_sendmsg\_nosec net/socket.c:622 [inline]
sock\_sendmsg+0xd5/0x120 net/socket.c:632
\_\_\_sys\_sendmsg+0x7fd/0x930 net/socket.c:2117
\_\_sys\_sendmsg+0x11d/0x280 net/socket.c:2155
\_\_do\_sys\_sendmsg net/socket.c:2164 [inline]
\_\_se\_sys\_sendmsg net/socket.c:2162 [inline]
\_\_x64\_sys\_sendmsg+0x78/0xb0 net/socket.c:2162
do\_syscall\_64+0x1b9/0x820 arch/x86/entry/common.c:290
entry\_SYSCALL\_64\_after\_hwframe+0x49/0xbe
RIP: 0033:0x44a859
Code: e8 dc e6 ff ff 48 83 c4 18 c3 0f 1f 80 00 00 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 6b cb fb ff c3 66 2e 0f 1f 84 00 00 00 00
RSP: 002b:00007f1d4710ada8 EFLAGS: 00000297 ORIG\_RAX: 000000000000002e
RAX: ffffffffffffffda RBX: 00000000006dcc28 RCX: 000000000044a859
RDX: 0000000000000000 RSI: 0000000020001600 RDI: 0000000000000003
RBP: 00000000006dcc20 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000297 R12: 00000000006dcc2c
R13: 646e732f7665642f R14: 00007f1d4710b9c0 R15: 00000000006dcd2c
Kernel Offset: disabled
Rebooting in 86400 seconds..
Reported-by: syzbot+26de17458aeda9d305d8@syzkaller.appspotmail.com
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: shamir rabinovitch <shamir.rabinovitch@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=ea010070d0a7497253d5a6f919f6dd107450b31a)

| -rw-r--r-- | [net/rds/rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/rds/rdma.c?id=ea010070d0a7497253d5a6f919f6dd107450b31a) | 63 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [net/rds/rds.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/rds/rds.h?id=ea010070d0a7497253d5a6f919f6dd107450b31a) | 20 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [net/rds/send.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/rds/send.c?id=ea010070d0a7497253d5a6f919f6dd107450b31a) | 50 | |  |  |  | | --- | --- | --- | |

3 files changed, 91 insertions, 42 deletions

| diff --git a/net/rds/rdma.c b/net/rds/rdma.cindex 98237feb607ac6..e1965d9cbcf829 100644--- a/[net/rds/rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/rdma.c?id=c6f4075e2f14a91f2180c98bc7715946f791cbe6)+++ b/[net/rds/rdma.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/rdma.c?id=ea010070d0a7497253d5a6f919f6dd107450b31a)@@ -517,9 +517,10 @@ static int rds\_rdma\_pages(struct rds\_iovec iov[], int nr\_iovecs) return tot\_pages; } -int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args)+int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args,+ struct rds\_iov\_vector \*iov) {- struct rds\_iovec vec;+ struct rds\_iovec \*vec; struct rds\_iovec \_\_user \*local\_vec; int tot\_pages = 0; unsigned int nr\_pages;@@ -530,13 +531,23 @@ int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args) if (args->nr\_local == 0) return -EINVAL; + iov->iov = kcalloc(args->nr\_local,+ sizeof(struct rds\_iovec),+ GFP\_KERNEL);+ if (!iov->iov)+ return -ENOMEM;++ vec = &iov->iov[0];++ if (copy\_from\_user(vec, local\_vec, args->nr\_local \*+ sizeof(struct rds\_iovec)))+ return -EFAULT;+ iov->len = args->nr\_local;+ /\* figure out the number of pages in the vector \*/- for (i = 0; i < args->nr\_local; i++) {- if (copy\_from\_user(&vec, &local\_vec[i],- sizeof(struct rds\_iovec)))- return -EFAULT;+ for (i = 0; i < args->nr\_local; i++, vec++) { - nr\_pages = rds\_pages\_in\_vec(&vec);+ nr\_pages = rds\_pages\_in\_vec(vec); if (nr\_pages == 0) return -EINVAL; @@ -558,15 +569,15 @@ int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args) \* Extract all arguments and set up the rdma\_op \*/ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm,- struct cmsghdr \*cmsg)+ struct cmsghdr \*cmsg,+ struct rds\_iov\_vector \*vec) { struct rds\_rdma\_args \*args; struct rm\_rdma\_op \*op = &rm->rdma; int nr\_pages; unsigned int nr\_bytes; struct page \*\*pages = NULL;- struct rds\_iovec iovstack[UIO\_FASTIOV], \*iovs = iovstack;- int iov\_size;+ struct rds\_iovec \*iovs; unsigned int i, j; int ret = 0; @@ -586,31 +597,23 @@ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm, goto out\_ret; } - /\* Check whether to allocate the iovec area \*/- iov\_size = args->nr\_local \* sizeof(struct rds\_iovec);- if (args->nr\_local > UIO\_FASTIOV) {- iovs = sock\_kmalloc(rds\_rs\_to\_sk(rs), iov\_size, GFP\_KERNEL);- if (!iovs) {- ret = -ENOMEM;- goto out\_ret;- }+ if (vec->len != args->nr\_local) {+ ret = -EINVAL;+ goto out\_ret; } - if (copy\_from\_user(iovs, (struct rds\_iovec \_\_user \*)(unsigned long) args->local\_vec\_addr, iov\_size)) {- ret = -EFAULT;- goto out;- }+ iovs = vec->iov;  nr\_pages = rds\_rdma\_pages(iovs, args->nr\_local); if (nr\_pages < 0) { ret = -EINVAL;- goto out;+ goto out\_ret; }  pages = kcalloc(nr\_pages, sizeof(struct page \*), GFP\_KERNEL); if (!pages) { ret = -ENOMEM;- goto out;+ goto out\_ret; }  op->op\_write = !!(args->flags & RDS\_RDMA\_READWRITE);@@ -623,7 +626,7 @@ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm, op->op\_sg = rds\_message\_alloc\_sgs(rm, nr\_pages); if (!op->op\_sg) { ret = -ENOMEM;- goto out;+ goto out\_pages; }  if (op->op\_notify || op->op\_recverr) {@@ -635,7 +638,7 @@ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm, op->op\_notifier = kmalloc(sizeof(struct rds\_notifier), GFP\_KERNEL); if (!op->op\_notifier) { ret = -ENOMEM;- goto out;+ goto out\_pages; } op->op\_notifier->n\_user\_token = args->user\_token; op->op\_notifier->n\_status = RDS\_RDMA\_SUCCESS;@@ -681,7 +684,7 @@ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm, \*/ ret = rds\_pin\_pages(iov->addr, nr, pages, !op->op\_write); if (ret < 0)- goto out;+ goto out\_pages; else ret = 0; @@ -714,13 +717,11 @@ int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm, nr\_bytes, (unsigned int) args->remote\_vec.bytes); ret = -EINVAL;- goto out;+ goto out\_pages; } op->op\_bytes = nr\_bytes; -out:- if (iovs != iovstack)- sock\_kfree\_s(rds\_rs\_to\_sk(rs), iovs, iov\_size);+out\_pages: kfree(pages); out\_ret: if (ret)diff --git a/net/rds/rds.h b/net/rds/rds.hindex 6bfaf05b63b21e..4d2523100093be 100644--- a/[net/rds/rds.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/rds.h?id=c6f4075e2f14a91f2180c98bc7715946f791cbe6)+++ b/[net/rds/rds.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/rds.h?id=ea010070d0a7497253d5a6f919f6dd107450b31a)@@ -386,6 +386,18 @@ static inline void rds\_message\_zcopy\_queue\_init(struct rds\_msg\_zcopy\_queue \*q) INIT\_LIST\_HEAD(&q->zcookie\_head); } +struct rds\_iov\_vector {+ struct rds\_iovec \*iov;+ int len;+};++struct rds\_iov\_vector\_arr {+ struct rds\_iov\_vector \*vec;+ int len;+ int indx;+ int incr;+};+ struct rds\_message { refcount\_t m\_refcount; struct list\_head m\_sock\_item;@@ -904,13 +916,13 @@ int rds\_get\_mr(struct rds\_sock \*rs, char \_\_user \*optval, int optlen); int rds\_get\_mr\_for\_dest(struct rds\_sock \*rs, char \_\_user \*optval, int optlen); int rds\_free\_mr(struct rds\_sock \*rs, char \_\_user \*optval, int optlen); void rds\_rdma\_drop\_keys(struct rds\_sock \*rs);-int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args);-int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm,- struct cmsghdr \*cmsg);+int rds\_rdma\_extra\_size(struct rds\_rdma\_args \*args,+ struct rds\_iov\_vector \*iov); int rds\_cmsg\_rdma\_dest(struct rds\_sock \*rs, struct rds\_message \*rm, struct cmsghdr \*cmsg); int rds\_cmsg\_rdma\_args(struct rds\_sock \*rs, struct rds\_message \*rm,- struct cmsghdr \*cmsg);+ struct cmsghdr \*cmsg,+ struct rds\_iov\_vector \*vec); int rds\_cmsg\_rdma\_map(struct rds\_sock \*rs, struct rds\_message \*rm, struct cmsghdr \*cmsg); void rds\_rdma\_free\_op(struct rm\_rdma\_op \*ro);diff --git a/net/rds/send.c b/net/rds/send.cindex fe785ee819ddb1..ec2267cbf85f0c 100644--- a/[net/rds/send.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/send.c?id=c6f4075e2f14a91f2180c98bc7715946f791cbe6)+++ b/[net/rds/send.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/rds/send.c?id=ea010070d0a7497253d5a6f919f6dd107450b31a)@@ -876,13 +876,15 @@ out: \* rds\_message is getting to be quite complicated, and we'd like to allocate \* it all in one go. This figures out how big it needs to be up front. \*/-static int rds\_rm\_size(struct msghdr \*msg, int num\_sgs)+static int rds\_rm\_size(struct msghdr \*msg, int num\_sgs,+ struct rds\_iov\_vector\_arr \*vct) { struct cmsghdr \*cmsg; int size = 0; int cmsg\_groups = 0; int retval; bool zcopy\_cookie = false;+ struct rds\_iov\_vector \*iov, \*tmp\_iov;  for\_each\_cmsghdr(cmsg, msg) { if (!CMSG\_OK(msg, cmsg))@@ -893,8 +895,24 @@ static int rds\_rm\_size(struct msghdr \*msg, int num\_sgs)  switch (cmsg->cmsg\_type) { case RDS\_CMSG\_RDMA\_ARGS:+ if (vct->indx >= vct->len) {+ vct->len += vct->incr;+ tmp\_iov =+ krealloc(vct->vec,+ vct->len \*+ sizeof(struct rds\_iov\_vector),+ GFP\_KERNEL);+ if (!tmp\_iov) {+ vct->len -= vct->incr;+ return -ENOMEM;+ }+ vct->vec = tmp\_iov;+ }+ iov = &vct->vec[vct->indx];+ memset(iov, 0, sizeof(struct rds\_iov\_vector));+ vct->indx++; cmsg\_groups |= 1;- retval = rds\_rdma\_extra\_size(CMSG\_DATA(cmsg));+ retval = rds\_rdma\_extra\_size(CMSG\_DATA(cmsg), iov); if (retval < 0) return retval; size += retval;@@ -951,10 +969,11 @@ static int rds\_cmsg\_zcopy(struct rds\_sock \*rs, struct rds\_message \*rm, }  static int rds\_cmsg\_send(struct rds\_sock \*rs, struct rds\_message \*rm,- struct msghdr \*msg, int \*allocated\_mr)+ struct msghdr \*msg, int \*allocated\_mr,+ struct rds\_iov\_vector\_arr \*vct) { struct cmsghdr \*cmsg;- int ret = 0;+ int ret = 0, ind = 0;  for\_each\_cmsghdr(cmsg, msg) { if (!CMSG\_OK(msg, cmsg))@@ -968,7 +987,10 @@ static int rds\_cmsg\_send(struct rds\_sock \*rs, struct rds\_message \*rm, \*/ switch (cmsg->cmsg\_type) { case RDS\_CMSG\_RDMA\_ARGS:- ret = rds\_cmsg\_rdma\_args(rs, rm, cmsg);+ if (ind >= vct->indx)+ return -ENOMEM;+ ret = rds\_cmsg\_rdma\_args(rs, rm, cmsg, &vct->vec[ind]);+ ind++; break;  case RDS\_CMSG\_RDMA\_DEST:@@ -1084,6 +1106,11 @@ int rds\_sendmsg(struct socket \*sock, struct msghdr \*msg, size\_t payload\_len) sock\_flag(rds\_rs\_to\_sk(rs), SOCK\_ZEROCOPY)); int num\_sgs = ceil(payload\_len, PAGE\_SIZE); int namelen;+ struct rds\_iov\_vector\_arr vct = {0};+ int ind;++ /\* expect 1 RDMA CMSG per rds\_sendmsg. can still grow if more needed. \*/+ vct.incr = 1;  /\* Mirror Linux UDP mirror of BSD error message compatibility \*/ /\* XXX: Perhaps MSG\_MORE someday \*/@@ -1220,7 +1247,7 @@ int rds\_sendmsg(struct socket \*sock, struct msghdr \*msg, size\_t payload\_len) num\_sgs = iov\_iter\_npages(&msg->msg\_iter, INT\_MAX); } /\* size of rm including all sgs \*/- ret = rds\_rm\_size(msg, num\_sgs);+ ret = rds\_rm\_size(msg, num\_sgs, &vct); if (ret < 0) goto out; @@ -1270,7 +1297,7 @@ int rds\_sendmsg(struct socket \*sock, struct msghdr \*msg, size\_t payload\_len) rm->m\_conn\_path = cpath;  /\* Parse any control messages the user may have included. \*/- ret = rds\_cmsg\_send(rs, rm, msg, &allocated\_mr);+ ret = rds\_cmsg\_send(rs, rm, msg, &allocated\_mr, &vct); if (ret) { /\* Trigger connection so that its ready for the next retry \*/ if (ret == -EAGAIN)@@ -1348,9 +1375,18 @@ int rds\_sendmsg(struct socket \*sock, struct msghdr \*msg, size\_t payload\_len) if (ret) goto out; rds\_message\_put(rm);++ for (ind = 0; ind < vct.indx; ind++)+ kfree(vct.vec[ind].iov);+ kfree(vct.vec);+ return payload\_len;  out:+ for (ind = 0; ind < vct.indx; ind++)+ kfree(vct.vec[ind].iov);+ kfree(vct.vec);+ /\* If the user included a RDMA\_MAP cmsg, we allocated a MR on the fly. \* If the sendmsg goes through, we keep the MR. If it fails with EAGAIN \* or in any other way, we need to destroy the MR again \*/ |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 15:17:14 +0000

