

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Aleksandr Loktionov <aleksandr.loktionov@intel.com> | 2024-03-13 10:56:39 +0100 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-13 12:59:29 +0200 |
| commit | [b8e82128b44fa40bf99a50b919488ef361e1683c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b8e82128b44fa40bf99a50b919488ef361e1683c) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)) | |
| tree | [3c004a70809a04e7f90ed7c9a63265591d15647a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b8e82128b44fa40bf99a50b919488ef361e1683c) | |
| parent | [a88765b0a59150b59eb9b97003e8cd09f9edbddc](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=a88765b0a59150b59eb9b97003e8cd09f9edbddc) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b8e82128b44fa40bf99a50b919488ef361e1683c&id2=a88765b0a59150b59eb9b97003e8cd09f9edbddc)) | |
| download | [linux-b8e82128b44fa40bf99a50b919488ef361e1683c.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b8e82128b44fa40bf99a50b919488ef361e1683c.tar.gz) | |

i40e: fix vf may be used uninitialized in this function warningcommit f37c4eac99c258111d414d31b740437e1925b8e8 upstream.
To fix the regression introduced by commit 52424f974bc5, which causes
servers hang in very hard to reproduce conditions with resets races.
Using two sources for the information is the root cause.
In this function before the fix bumping v didn't mean bumping vf
pointer. But the code used this variables interchangeably, so stale vf
could point to different/not intended vf.
Remove redundant "v" variable and iterate via single VF pointer across
whole function instead to guarantee VF pointer validity.
Fixes: 52424f974bc5 ("i40e: Fix VF hang when reset is triggered on another VF")
Signed-off-by: Aleksandr Loktionov <aleksandr.loktionov@intel.com>
Reviewed-by: Arkadiusz Kubalewski <arkadiusz.kubalewski@intel.com>
Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
Reviewed-by: Paul Menzel <pmenzel@molgen.mpg.de>
Tested-by: Rafal Romanowski <rafal.romanowski@intel.com>
Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b8e82128b44fa40bf99a50b919488ef361e1683c)

| -rw-r--r-- | [drivers/net/ethernet/intel/i40e/i40e\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c?id=b8e82128b44fa40bf99a50b919488ef361e1683c) | 34 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 16 insertions, 18 deletions

| diff --git a/drivers/net/ethernet/intel/i40e/i40e\_virtchnl\_pf.c b/drivers/net/ethernet/intel/i40e/i40e\_virtchnl\_pf.cindex f79795cc91521e..4f23243bbfbb62 100644--- a/[drivers/net/ethernet/intel/i40e/i40e\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c?id=a88765b0a59150b59eb9b97003e8cd09f9edbddc)+++ b/[drivers/net/ethernet/intel/i40e/i40e\_virtchnl\_pf.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c?id=b8e82128b44fa40bf99a50b919488ef361e1683c)@@ -1573,8 +1573,8 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) { struct i40e\_hw \*hw = &pf->hw; struct i40e\_vf \*vf;- int i, v; u32 reg;+ int i;  /\* If we don't have any VFs, then there is nothing to reset \*/ if (!pf->num\_alloc\_vfs)@@ -1585,11 +1585,10 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) return false;  /\* Begin reset on all VFs at once \*/- for (v = 0; v < pf->num\_alloc\_vfs; v++) {- vf = &pf->vf[v];+ for (vf = &pf->vf[0]; vf < &pf->vf[pf->num\_alloc\_vfs]; ++vf) { /\* If VF is being reset no need to trigger reset again \*/ if (!test\_bit(I40E\_VF\_STATE\_RESETTING, &vf->vf\_states))- i40e\_trigger\_vf\_reset(&pf->vf[v], flr);+ i40e\_trigger\_vf\_reset(vf, flr); }  /\* HW requires some time to make sure it can flush the FIFO for a VF@@ -1598,14 +1597,13 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) \* the VFs using a simple iterator that increments once that VF has \* finished resetting. \*/- for (i = 0, v = 0; i < 10 && v < pf->num\_alloc\_vfs; i++) {+ for (i = 0, vf = &pf->vf[0]; i < 10 && vf < &pf->vf[pf->num\_alloc\_vfs]; ++i) { usleep\_range(10000, 20000);  /\* Check each VF in sequence, beginning with the VF to fail \* the previous check. \*/- while (v < pf->num\_alloc\_vfs) {- vf = &pf->vf[v];+ while (vf < &pf->vf[pf->num\_alloc\_vfs]) { if (!test\_bit(I40E\_VF\_STATE\_RESETTING, &vf->vf\_states)) { reg = rd32(hw, I40E\_VPGEN\_VFRSTAT(vf->vf\_id)); if (!(reg & I40E\_VPGEN\_VFRSTAT\_VFRD\_MASK))@@ -1615,7 +1613,7 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) /\* If the current VF has finished resetting, move on \* to the next VF in sequence. \*/- v++;+ ++vf; } } @@ -1625,39 +1623,39 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) /\* Display a warning if at least one VF didn't manage to reset in \* time, but continue on with the operation. \*/- if (v < pf->num\_alloc\_vfs)+ if (vf < &pf->vf[pf->num\_alloc\_vfs]) dev\_err(&pf->pdev->dev, "VF reset check timeout on VF %d\n",- pf->vf[v].vf\_id);+ vf->vf\_id); usleep\_range(10000, 20000);  /\* Begin disabling all the rings associated with VFs, but do not wait \* between each VF. \*/- for (v = 0; v < pf->num\_alloc\_vfs; v++) {+ for (vf = &pf->vf[0]; vf < &pf->vf[pf->num\_alloc\_vfs]; ++vf) { /\* On initial reset, we don't have any queues to disable \*/- if (pf->vf[v].lan\_vsi\_idx == 0)+ if (vf->lan\_vsi\_idx == 0) continue;  /\* If VF is reset in another thread just continue \*/ if (test\_bit(I40E\_VF\_STATE\_RESETTING, &vf->vf\_states)) continue; - i40e\_vsi\_stop\_rings\_no\_wait(pf->vsi[pf->vf[v].lan\_vsi\_idx]);+ i40e\_vsi\_stop\_rings\_no\_wait(pf->vsi[vf->lan\_vsi\_idx]); }  /\* Now that we've notified HW to disable all of the VF rings, wait \* until they finish. \*/- for (v = 0; v < pf->num\_alloc\_vfs; v++) {+ for (vf = &pf->vf[0]; vf < &pf->vf[pf->num\_alloc\_vfs]; ++vf) { /\* On initial reset, we don't have any queues to disable \*/- if (pf->vf[v].lan\_vsi\_idx == 0)+ if (vf->lan\_vsi\_idx == 0) continue;  /\* If VF is reset in another thread just continue \*/ if (test\_bit(I40E\_VF\_STATE\_RESETTING, &vf->vf\_states)) continue; - i40e\_vsi\_wait\_queues\_disabled(pf->vsi[pf->vf[v].lan\_vsi\_idx]);+ i40e\_vsi\_wait\_queues\_disabled(pf->vsi[vf->lan\_vsi\_idx]); }  /\* Hw may need up to 50ms to finish disabling the RX queues. We@@ -1666,12 +1664,12 @@ bool i40e\_reset\_all\_vfs(struct i40e\_pf \*pf, bool flr) mdelay(50);  /\* Finish the reset on each VF \*/- for (v = 0; v < pf->num\_alloc\_vfs; v++) {+ for (vf = &pf->vf[0]; vf < &pf->vf[pf->num\_alloc\_vfs]; ++vf) { /\* If VF is reset in another thread just continue \*/ if (test\_bit(I40E\_VF\_STATE\_RESETTING, &vf->vf\_states)) continue; - i40e\_cleanup\_reset\_vf(&pf->vf[v]);+ i40e\_cleanup\_reset\_vf(vf); }  i40e\_flush(hw); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 17:57:09 +0000

