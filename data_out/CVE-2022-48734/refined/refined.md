```
{
  "cveId": "CVE-2022-48734",
  "source": "git.kernel.org_95d829db_20250110_154625.html",
  "vulnerability": {
    "rootCause": "A deadlock occurs due to a circular dependency between the quota disable ioctl, the qgroup rescan worker, and other tasks with transactions like block group relocation.",
    "weaknesses": [
      "The quota disable ioctl starts a transaction before waiting for the qgroup rescan worker to complete.",
      "The qgroup rescan worker can start a transaction while the quota disable ioctl is waiting for it to complete leading to a deadlock."
    ],
    "impact": "System deadlock and denial of service. The system becomes unresponsive, as demonstrated by the hung task messages.",
    "attackVectors": [
      "Calling the quota disable ioctl while a block group relocation or similar task is running and the qgroup rescan worker is also active."
    ],
    "requiredCapabilities": "An attacker would need the ability to trigger the quota disable ioctl and also trigger a block group relocation. This could be achieved with user-level access to the btrfs filesystem and knowledge of how to trigger a block group relocation, or by performing actions that cause it indirectly.",
      "details": "The deadlock occurs because:\n1. Task A calls ioctl to disable quota, starting a transaction and waiting for qgroup rescan worker to complete.\n2. Task B (e.g., block group relocation) starts a transaction and joins the one started by Task A, then commits, waiting for a commit by Task A.\n3. Task C (qgroup rescan worker) starts its job and a transaction, waiting for the completion of the transaction from Task A and Task B.\nThis creates a circular dependency, leading to a deadlock."
  }
}
```
```
{
  "cveId": "CVE-2022-48734",
  "source": "git.kernel.org_3352f4d0_20250110_154625.html",
  "vulnerability": {
    "rootCause": "A deadlock occurs due to a circular dependency between the quota disable ioctl, the qgroup rescan worker, and other tasks with transactions like block group relocation.",
    "weaknesses": [
      "The quota disable ioctl starts a transaction before waiting for the qgroup rescan worker to complete.",
      "The qgroup rescan worker can start a transaction while the quota disable ioctl is waiting for it to complete leading to a deadlock."
    ],
    "impact": "System deadlock and denial of service. The system becomes unresponsive, as demonstrated by the hung task messages.",
     "attackVectors": [
      "Calling the quota disable ioctl while a block group relocation or similar task is running and the qgroup rescan worker is also active."
    ],
    "requiredCapabilities": "An attacker would need the ability to trigger the quota disable ioctl and also trigger a block group relocation. This could be achieved with user-level access to the btrfs filesystem and knowledge of how to trigger a block group relocation, or by performing actions that cause it indirectly.",
     "details": "The deadlock occurs because:\n1. Task A calls ioctl to disable quota, starting a transaction and waiting for qgroup rescan worker to complete.\n2. Task B (e.g., block group relocation) starts a transaction and joins the one started by Task A, then commits, waiting for a commit by Task A.\n3. Task C (qgroup rescan worker) starts its job and a transaction, waiting for the completion of the transaction from Task A and Task B.\nThis creates a circular dependency, leading to a deadlock."
  }
}
```
```
{
  "cveId": "CVE-2022-48734",
  "source": "git.kernel.org_925bb7ef_20250110_154625.html",
  "vulnerability": {
    "rootCause": "A deadlock occurs due to a circular dependency between the quota disable ioctl, the qgroup rescan worker, and other tasks with transactions like block group relocation.",
    "weaknesses": [
      "The quota disable ioctl starts a transaction before waiting for the qgroup rescan worker to complete.",
      "The qgroup rescan worker can start a transaction while the quota disable ioctl is waiting for it to complete leading to a deadlock."
    ],
    "impact": "System deadlock and denial of service. The system becomes unresponsive, as demonstrated by the hung task messages.",
     "attackVectors": [
      "Calling the quota disable ioctl while a block group relocation or similar task is running and the qgroup rescan worker is also active."
    ],
    "requiredCapabilities": "An attacker would need the ability to trigger the quota disable ioctl and also trigger a block group relocation. This could be achieved with user-level access to the btrfs filesystem and knowledge of how to trigger a block group relocation, or by performing actions that cause it indirectly.",
     "details": "The deadlock occurs because:\n1. Task A calls ioctl to disable quota, starting a transaction and waiting for qgroup rescan worker to complete.\n2. Task B (e.g., block group relocation) starts a transaction and joins the one started by Task A, then commits, waiting for a commit by Task A.\n3. Task C (qgroup rescan worker) starts its job and a transaction, waiting for the completion of the transaction from Task A and Task B.\nThis creates a circular dependency, leading to a deadlock."
  }
}
```
```
{
  "cveId": "CVE-2022-48734",
  "source": "git.kernel.org_0fe0a760_20250110_154625.html",
  "vulnerability": {
    "rootCause": "A deadlock occurs due to a circular dependency between the quota disable ioctl, the qgroup rescan worker, and other tasks with transactions like block group relocation.",
    "weaknesses": [
      "The quota disable ioctl starts a transaction before waiting for the qgroup rescan worker to complete.",
      "The qgroup rescan worker can start a transaction while the quota disable ioctl is waiting for it to complete leading to a deadlock."
    ],
    "impact": "System deadlock and denial of service. The system becomes unresponsive, as demonstrated by the hung task messages.",
    "attackVectors": [
      "Calling the quota disable ioctl while a block group relocation or similar task is running and the qgroup rescan worker is also active."
    ],
    "requiredCapabilities": "An attacker would need the ability to trigger the quota disable ioctl and also trigger a block group relocation. This could be achieved with user-level access to the btrfs filesystem and knowledge of how to trigger a block group relocation, or by performing actions that cause it indirectly.",
      "details": "The deadlock occurs because:\n1. Task A calls ioctl to disable quota, starting a transaction and waiting for qgroup rescan worker to complete.\n2. Task B (e.g., block group relocation) starts a transaction and joins the one started by Task A, then commits, waiting for a commit by Task A.\n3. Task C (qgroup rescan worker) starts its job and a transaction, waiting for the completion of the transaction from Task A and Task B.\nThis creates a circular dependency, leading to a deadlock."
  }
}
```
```
{
  "cveId": "CVE-2022-48734",
  "source": "git.kernel.org_45c20cb0_20250110_154625.html",
  "vulnerability": {
    "rootCause": "A deadlock occurs due to a circular dependency between the quota disable ioctl, the qgroup rescan worker, and other tasks with transactions like block group relocation.",
    "weaknesses": [
      "The quota disable ioctl starts a transaction before waiting for the qgroup rescan worker to complete.",
      "The qgroup rescan worker can start a transaction while the quota disable ioctl is waiting for it to complete leading to a deadlock."
    ],
    "impact": "System deadlock and denial of service. The system becomes unresponsive, as demonstrated by the hung task messages.",
     "attackVectors": [
      "Calling the quota disable ioctl while a block group relocation or similar task is running and the qgroup rescan worker is also active."
    ],
   "requiredCapabilities": "An attacker would need the ability to trigger the quota disable ioctl and also trigger a block group relocation. This could be achieved with user-level access to the btrfs filesystem and knowledge of how to trigger a block group relocation, or by performing actions that cause it indirectly.",
      "details": "The deadlock occurs because:\n1. Task A calls ioctl to disable quota, starting a transaction and waiting for qgroup rescan worker to complete.\n2. Task B (e.g., block group relocation) starts a transaction and joins the one started by Task A, then commits, waiting for a commit by Task A.\n3. Task C (qgroup rescan worker) starts its job and a transaction, waiting for the completion of the transaction from Task A and Task B.\nThis creates a circular dependency, leading to a deadlock."
  }
}
```