
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpdm-project%2Fpdm%2Fblob%2F45d1dfa47d4900c14a31b9bb761e4c46eb5c9442%2Fsrc%2Fpdm%2Fmodels%2Fcandidates.py)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpdm-project%2Fpdm%2Fblob%2F45d1dfa47d4900c14a31b9bb761e4c46eb5c9442%2Fsrc%2Fpdm%2Fmodels%2Fcandidates.py)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=pdm-project%2Fpdm)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[pdm-project](/pdm-project)
/
**[pdm](/pdm-project/pdm)**
Public

* [Notifications](/login?return_to=%2Fpdm-project%2Fpdm) You must be signed in to change notification settings
* [Fork
  419](/login?return_to=%2Fpdm-project%2Fpdm)
* [Star
   8.1k](/login?return_to=%2Fpdm-project%2Fpdm)

* [Code](/pdm-project/pdm)
* [Issues
  41](/pdm-project/pdm/issues)
* [Pull requests
  3](/pdm-project/pdm/pulls)
* [Discussions](/pdm-project/pdm/discussions)
* [Actions](/pdm-project/pdm/actions)
* [Security](/pdm-project/pdm/security)
* [Insights](/pdm-project/pdm/pulse)

Additional navigation options

* [Code](/pdm-project/pdm)
* [Issues](/pdm-project/pdm/issues)
* [Pull requests](/pdm-project/pdm/pulls)
* [Discussions](/pdm-project/pdm/discussions)
* [Actions](/pdm-project/pdm/actions)
* [Security](/pdm-project/pdm/security)
* [Insights](/pdm-project/pdm/pulse)

## Files

 45d1dfa
## Breadcrumbs

1. [pdm](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442)
2. /[src](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src)
3. /[pdm](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm)
4. /[models](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm/models)
/
# candidates.py

 Blame  Blame
## Latest commit

## History

[History](/pdm-project/pdm/commits/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm/models/candidates.py)672 lines (593 loc) · 26.3 KB 45d1dfa
## Breadcrumbs

1. [pdm](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442)
2. /[src](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src)
3. /[pdm](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm)
4. /[models](/pdm-project/pdm/tree/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm/models)
/
# candidates.py

Top
## File metadata and controls

* Code
* Blame

672 lines (593 loc) · 26.3 KB[Raw](https://github.com/pdm-project/pdm/raw/45d1dfa47d4900c14a31b9bb761e4c46eb5c9442/src/pdm/models/candidates.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672from \_\_future\_\_ import annotations
import dataclassesimport hashlibimport osimport reimport warningsfrom functools import lru\_cachefrom pathlib import Pathfrom tempfile import TemporaryDirectoryfrom typing import TYPE\_CHECKING, Any, cast, no\_type\_checkfrom zipfile import ZipFile
from packaging.utils import parse\_wheel\_filename
from pdm import termuifrom pdm.builders import EditableBuilder, WheelBuilderfrom pdm.compat import cached\_propertyfrom pdm.compat import importlib\_metadata as imfrom pdm.exceptions import BuildError, CandidateNotFound, InvalidPyVersion, PDMWarningfrom pdm.models.backends import get\_backend, get\_backend\_by\_specfrom pdm.models.requirements import ( FileRequirement, Requirement, VcsRequirement, \_egg\_info\_re, filter\_requirements\_with\_extras,)from pdm.models.setup import Setupfrom pdm.models.specifiers import PySpecSetfrom pdm.utils import ( cd, convert\_hashes, create\_tracked\_tempdir, get\_rev\_from\_url, normalize\_name, path\_to\_url, url\_without\_fragments,)
if TYPE\_CHECKING: from unearth import Link, Package, PackageFinder
 from pdm.\_types import FileHash from pdm.environments import BaseEnvironment
def \_dist\_info\_files(whl\_zip: ZipFile) -> list[str]: """Identify the .dist-info folder inside a wheel ZipFile.""" res = [] for path in whl\_zip.namelist(): m = re.match(r"[^/\\]+-[^/\\]+\.dist-info/", path) if m: res.append(path) if res: return res raise Exception("No .dist-info folder found in wheel")
def \_get\_wheel\_metadata\_from\_wheel(whl\_file: Path, metadata\_directory: str) -> str: """Extract the metadata from a wheel. Fallback for when the build backend does not define the 'get\_wheel\_metadata' hook. """ with ZipFile(whl\_file) as zipf: dist\_info = \_dist\_info\_files(zipf) zipf.extractall(path=metadata\_directory, members=dist\_info) return os.path.join(metadata\_directory, dist\_info[0].split("/")[0])
def \_filter\_none(data: dict[str, Any]) -> dict[str, Any]: """Return a new dict without None values""" return {k: v for k, v in data.items() if v is not None}
def \_find\_best\_match\_link( finder: PackageFinder, req: Requirement, files: list[FileHash], ignore\_compatibility: bool = False,) -> Link | None: """Get the best matching link for a requirement"""
 # This function is called when a lock file candidate is given or incompatible wheel # In this case, the requirement must be pinned, so no need to pass allow\_prereleases # If links are not empty, find the best match from the links, otherwise find from # the package sources. from unearth import Link
 links = [Link(f["url"]) for f in files if "url" in f] hashes = convert\_hashes(files)
 def attempt\_to\_find() -> Link | None: if not links: best = finder.find\_best\_match(req.as\_line(), hashes=hashes).best else: # this branch won't be executed twice if ignore\_compatibility is True evaluator = finder.build\_evaluator(req.name) packages = finder.\_evaluate\_links(links, evaluator) best = max(packages, key=finder.\_sort\_key, default=None) return best.link if best is not None else None
 assert finder.ignore\_compatibility is False found = attempt\_to\_find() if ignore\_compatibility and (found is None or not found.is\_wheel): # try to find a wheel for easy metadata extraction finder.ignore\_compatibility = True new\_found = attempt\_to\_find() if new\_found is not None: found = new\_found finder.ignore\_compatibility = False return found
class MetadataDistribution(im.Distribution): """A wrapper around a single METADATA file to provide the Distribution interface"""
 def \_\_init\_\_(self, text: str) -> None: self.text = text
 def locate\_file(self, path: str | os.PathLike[str]) -> os.PathLike[str]: return Path()
 def read\_text(self, filename: str) -> str | None: if filename != "": return None return self.text
class Candidate: """A concrete candidate that can be downloaded and installed. A candidate comes from the PyPI index of a package, or from the requirement itself (for file or VCS requirements). Each candidate has a name, version and several dependencies together with package metadata. """
 \_\_slots\_\_ = ( "req", "name", "version", "link", "summary", "hashes", "\_prepared", "\_requires\_python", "\_preferred", )
 def \_\_init\_\_( self, req: Requirement, name: str | None = None, version: str | None = None, link: Link | None = None, ): """ :param req: the requirement that produces this candidate. :param name: the name of the candidate. :param version: the version of the candidate. :param link: the file link of the candidate. """ self.req = req self.name = name or self.req.project\_name self.version = version if link is None and not req.is\_named: link = cast("Link", req.as\_file\_link()) # type: ignore[attr-defined] self.link = link self.summary = "" self.hashes: list[FileHash] = []
 self.\_requires\_python: str | None = None self.\_prepared: PreparedCandidate | None = None
 def identify(self) -> str: return self.req.identify()
 @property def dep\_key(self) -> tuple[str, str | None]: """Key for retrieving and storing dependencies from the provider.
 Return a tuple of (name, version). For URL candidates, the version is None but there will be only one for the same name so it is also unique. """ return (self.identify(), self.version)
 @property def prepared(self) -> PreparedCandidate | None: return self.\_prepared
 def \_\_eq\_\_(self, other: Any) -> bool: if not isinstance(other, Candidate): return False if self.req.is\_named: return self.name == other.name and self.version == other.version return self.name == other.name and self.link == other.link
 def get\_revision(self) -> str: if not self.req.is\_vcs: raise AttributeError("Non-VCS candidate doesn't have revision attribute") if self.req.revision: # type: ignore[attr-defined] return self.req.revision # type: ignore[attr-defined] return self.\_prepared.revision if self.\_prepared else "unknown"
 def \_\_repr\_\_(self) -> str: source = getattr(self.link, "comes\_from", None) from\_source = f" from {source}" if source else "" return f"<Candidate {self}{from\_source}>"
 def \_\_str\_\_(self) -> str: if self.req.is\_named: return f"{self.name}@{self.version}" assert self.link is not None return f"{self.name}@{self.link.url\_without\_fragment}"
 @classmethod def from\_installation\_candidate(cls, candidate: Package, req: Requirement) -> Candidate: """Build a candidate from unearth's find result.""" return cls( req, name=candidate.name, version=str(candidate.version), link=candidate.link, )
 @property def requires\_python(self) -> str: """The Python version constraint of the candidate.""" if self.\_requires\_python is not None: return self.\_requires\_python if self.link: requires\_python = self.link.requires\_python if requires\_python is not None: if requires\_python.isdigit(): requires\_python = f">={requires\_python},<{int(requires\_python) + 1}" try: # ensure the specifier is valid PySpecSet(requires\_python) except InvalidPyVersion: pass else: self.\_requires\_python = requires\_python return self.\_requires\_python or ""
 @requires\_python.setter def requires\_python(self, value: str) -> None: self.\_requires\_python = value
 @no\_type\_check def as\_lockfile\_entry(self, project\_root: Path) -> dict[str, Any]: """Build a lockfile entry dictionary for the candidate.""" result = { "name": normalize\_name(self.name), "version": str(self.version), "extras": sorted(self.req.extras or ()), "requires\_python": str(self.requires\_python), "editable": self.req.editable, "subdirectory": getattr(self.req, "subdirectory", None), } if self.req.is\_vcs: result.update( { self.req.vcs: self.req.repo, "ref": self.req.ref, } ) if not self.req.editable: result.update(revision=self.get\_revision()) elif not self.req.is\_named: with cd(project\_root): if self.req.is\_file\_or\_url and self.req.is\_local: result.update(path=self.req.str\_path) else: result.update(url=self.req.url) return {k: v for k, v in result.items() if v}
 def format(self) -> str: """Format for output.""" return f"[req]{self.name}[/] [warning]{self.version}[/]"
 def prepare(self, environment: BaseEnvironment) -> PreparedCandidate: """Prepare the candidate for installation.""" if self.\_prepared is None: self.\_prepared = PreparedCandidate(self, environment) return self.\_prepared
class PreparedCandidate: """A candidate that has been prepared for installation. The metadata and built wheel are available. """
 def \_\_init\_\_(self, candidate: Candidate, environment: BaseEnvironment) -> None: self.candidate = candidate self.environment = environment self.req = candidate.req
 self.wheel: Path | None = None self.link = self.\_replace\_url\_vars(self.candidate.link)
 self.\_source\_dir: Path | None = None self.\_unpacked\_dir: Path | None = None self.\_metadata\_dir: str | None = None self.\_metadata: im.Distribution | None = None
 if self.link is not None and self.link.is\_file and self.link.file\_path.is\_dir(): self.\_source\_dir = self.link.file\_path self.\_unpacked\_dir = self.\_source\_dir / (self.link.subdirectory or "")
 def \_replace\_url\_vars(self, link: Link | None) -> Link | None: if link is None: return None url = self.environment.project.backend.expand\_line(link.normalized) return dataclasses.replace(link, url=url)
 @cached\_property def revision(self) -> str: from unearth import vcs\_support
 if not (self.\_source\_dir and os.path.exists(self.\_source\_dir)): # It happens because the cached wheel is hit and the source code isn't # pulled to local. In this case the link url must contain the full commit # hash which can be taken as the revision safely. # See more info at https://github.com/pdm-project/pdm/issues/349 rev = get\_rev\_from\_url(self.candidate.link.url) # type: ignore[union-attr] if rev: return rev assert isinstance(self.req, VcsRequirement) return vcs\_support.get\_backend(self.req.vcs, self.environment.project.core.ui.verbosity).get\_revision( cast(Path, self.\_source\_dir) )
 def direct\_url(self) -> dict[str, Any] | None: """PEP 610 direct\_url.json data""" req = self.req if isinstance(req, VcsRequirement): if req.editable: assert self.\_source\_dir return \_filter\_none( { "url": path\_to\_url(self.\_source\_dir.as\_posix()), "dir\_info": {"editable": True}, "subdirectory": req.subdirectory, } ) return \_filter\_none( { "url": url\_without\_fragments(req.repo), "vcs\_info": \_filter\_none( { "vcs": req.vcs, "requested\_revision": req.ref, "commit\_id": self.revision, } ), "subdirectory": req.subdirectory, } ) elif isinstance(req, FileRequirement): assert self.link is not None if self.link.is\_file and self.link.file\_path.is\_dir(): return \_filter\_none( { "url": self.link.url\_without\_fragment, "dir\_info": \_filter\_none({"editable": req.editable or None}), "subdirectory": req.subdirectory, } ) with self.environment.get\_finder() as finder: hash\_cache = self.environment.project.make\_hash\_cache() return \_filter\_none( { "url": self.link.url\_without\_fragment, "archive\_info": {"hash": hash\_cache.get\_hash(self.link, finder.session).replace(":", "=")}, "subdirectory": req.subdirectory, } ) else: return None
 def build(self) -> Path: """Call PEP 517 build hook to build the candidate into a wheel""" self.obtain(allow\_all=False) if self.wheel: return self.wheel if not self.req.editable: cached = self.\_get\_cached\_wheel() if cached: self.wheel = cached return self.wheel assert self.\_source\_dir, "Source directory isn't ready yet" builder\_cls = EditableBuilder if self.req.editable else WheelBuilder builder = builder\_cls(str(self.\_unpacked\_dir), self.environment) build\_dir = self.\_get\_wheel\_dir() os.makedirs(build\_dir, exist\_ok=True) termui.logger.info("Running PEP 517 backend to build a wheel for %s", self.link) self.wheel = Path(builder.build(build\_dir, metadata\_directory=self.\_metadata\_dir)) return self.wheel
 def obtain(self, allow\_all: bool = False, unpack: bool = True) -> None: """Fetch the link of the candidate and unpack to local if necessary.
 :param allow\_all: If true, don't validate the wheel tag nor hashes :param unpack: Whether to download and unpack the link if it's not local """ if self.wheel: if self.\_wheel\_compatible(self.wheel.name, allow\_all): return elif self.\_source\_dir and self.\_source\_dir.exists(): return
 with self.environment.get\_finder() as finder: if not self.link or self.link.is\_wheel and not self.\_wheel\_compatible(self.link.filename, allow\_all): if self.req.is\_file\_or\_url: raise CandidateNotFound(f"The URL requirement {self.req.as\_line()} is a wheel but incompatible") self.link = self.wheel = None # reset the incompatible wheel self.link = \_find\_best\_match\_link( finder, self.req.as\_pinned\_version(self.candidate.version), self.candidate.hashes, ignore\_compatibility=allow\_all, ) if not self.link: raise CandidateNotFound( f"No candidate is found for `{self.req.project\_name}` that matches the environment or hashes" ) if not self.candidate.link: self.candidate.link = self.link if allow\_all and not self.req.editable: cached = self.\_get\_cached\_wheel() if cached: self.wheel = cached return if unpack: self.\_unpack(validate\_hashes=not allow\_all)
 def \_unpack(self, validate\_hashes: bool = False) -> None: hash\_options = None if validate\_hashes and self.candidate.hashes: hash\_options = convert\_hashes(self.candidate.hashes) assert self.link is not None with self.environment.get\_finder() as finder: with TemporaryDirectory(prefix="pdm-download-") as tmpdir: build\_dir = self.\_get\_build\_dir() if self.link.is\_wheel: download\_dir = build\_dir else: download\_dir = tmpdir result = finder.download\_and\_unpack(self.link, build\_dir, download\_dir, hash\_options) if self.link.is\_wheel: self.wheel = result else: self.\_source\_dir = Path(build\_dir) self.\_unpacked\_dir = result
 def prepare\_metadata(self, force\_build: bool = False) -> im.Distribution: self.obtain(allow\_all=True, unpack=False)
 metadata\_parent = create\_tracked\_tempdir(prefix="pdm-meta-") if self.wheel: return self.\_get\_metadata\_from\_wheel(self.wheel, metadata\_parent)
 assert self.link is not None if self.link.dist\_info\_metadata: assert self.link.dist\_info\_link dist = self.\_get\_metadata\_from\_metadata\_link(self.link.dist\_info\_link, self.link.dist\_info\_metadata) if dist is not None: return dist
 self.\_unpack(validate\_hashes=False) if self.wheel: # check again if the wheel is downloaded to local return self.\_get\_metadata\_from\_wheel(self.wheel, metadata\_parent)
 assert self.\_unpacked\_dir, "Source directory isn't ready yet" pyproject\_toml = self.\_unpacked\_dir / "pyproject.toml" if not force\_build and pyproject\_toml.exists(): dist = self.\_get\_metadata\_from\_project(pyproject\_toml) if dist is not None: return dist
 # If all fail, try building the source to get the metadata return self.\_get\_metadata\_from\_build(self.\_unpacked\_dir, metadata\_parent)
 def \_get\_metadata\_from\_metadata\_link( self, link: Link, medata\_hash: bool | dict[str, str] | None ) -> im.Distribution | None: with self.environment.get\_finder() as finder: resp = finder.session.get(link.normalized, headers={"Cache-Control": "max-age=0"}) if isinstance(medata\_hash, dict): hash\_name, hash\_value = next(iter(medata\_hash.items())) if hashlib.new(hash\_name, resp.content).hexdigest() != hash\_value: termui.logger.warning("Metadata hash mismatch for %s, ignoring the metadata", link) return None return MetadataDistribution(resp.text)
 def \_get\_metadata\_from\_wheel(self, wheel: Path, metadata\_parent: str) -> im.Distribution: # Get metadata from METADATA inside the wheel self.\_metadata\_dir = \_get\_wheel\_metadata\_from\_wheel(wheel, metadata\_parent) return im.PathDistribution(Path(self.\_metadata\_dir))
 def \_get\_metadata\_from\_project(self, pyproject\_toml: Path) -> im.Distribution | None: # Try getting from PEP 621 metadata from pdm.formats import MetaConvertError from pdm.project.project\_file import PyProject
 try: pyproject = PyProject(pyproject\_toml, ui=self.environment.project.core.ui) except MetaConvertError as e: termui.logger.warning("Failed to parse pyproject.toml: %s", e) return None metadata = pyproject.metadata.unwrap() if not metadata: termui.logger.warning("Failed to parse pyproject.toml") return None
 dynamic\_fields = metadata.get("dynamic", []) # Use the parse result only when all are static if not set(dynamic\_fields).isdisjoint( { "name", "version", "dependencies", "optional-dependencies", "requires-python", } ): return None
 try: backend\_cls = get\_backend\_by\_spec(pyproject.build\_system) except Exception: # no variable expansion backend\_cls = get\_backend("setuptools") backend = backend\_cls(pyproject\_toml.parent) setup = Setup( name=metadata.get("name"), summary=metadata.get("description"), version=metadata.get("version"), install\_requires=list( map( backend.expand\_line, metadata.get("dependencies", []), ) ), extras\_require={ k: list(map(backend.expand\_line, v)) for k, v in metadata.get("optional-dependencies", {}).items() }, python\_requires=metadata.get("requires-python"), ) return setup.as\_dist()
 def \_get\_metadata\_from\_build(self, source\_dir: Path, metadata\_parent: str) -> im.Distribution: builder = EditableBuilder if self.req.editable else WheelBuilder try: termui.logger.info("Running PEP 517 backend to get metadata for %s", self.link) self.\_metadata\_dir = builder(source\_dir, self.environment).prepare\_metadata(metadata\_parent) except BuildError: termui.logger.warning("Failed to build package, try parsing project files.") try: setup = Setup.from\_directory(source\_dir) except Exception: message = "Failed to parse the project files, dependencies may be missing" termui.logger.warning(message) warnings.warn(message, PDMWarning, stacklevel=1) setup = Setup() return setup.as\_dist() else: return im.PathDistribution(Path(cast(str, self.\_metadata\_dir)))
 @property def metadata(self) -> im.Distribution: if self.\_metadata is None: result = self.prepare\_metadata() if not self.candidate.name: self.req.name = self.candidate.name = cast(str, result.metadata["Name"]) if not self.candidate.version: self.candidate.version = result.version if not self.candidate.requires\_python: self.candidate.requires\_python = cast(str, result.metadata["Requires-Python"] or "") self.\_metadata = result return self.\_metadata
 def get\_dependencies\_from\_metadata(self) -> list[str]: """Get the dependencies of a candidate from metadata.""" extras = self.req.extras or () return filter\_requirements\_with\_extras( self.req.project\_name, self.metadata.requires or [], extras # type: ignore[arg-type] )
 def should\_cache(self) -> bool: """Determine whether to cache the dependencies and built wheel.""" from unearth import vcs\_support
 link, source\_dir = self.candidate.link, self.\_source\_dir if self.req.editable: return False if self.req.is\_named: return True if self.req.is\_vcs: if not source\_dir: # If the candidate isn't prepared, we can't cache it return False assert link vcs\_backend = vcs\_support.get\_backend(link.vcs, self.environment.project.core.ui.verbosity) return vcs\_backend.is\_immutable\_revision(source\_dir, link) if link and not (link.is\_file and link.file\_path.is\_dir()): # Cache if the link contains egg-info like 'foo-1.0' return \_egg\_info\_re.search(link.filename) is not None return False
 def \_get\_cached\_wheel(self) -> Path | None: wheel\_cache = self.environment.project.make\_wheel\_cache() assert self.candidate.link cache\_entry = wheel\_cache.get(self.candidate.link, self.candidate.name, self.environment.target\_python) if cache\_entry is not None: termui.logger.info("Using cached wheel: %s", cache\_entry) return cache\_entry
 def \_get\_build\_dir(self) -> str: original\_link = self.candidate.link assert original\_link if original\_link.is\_file and original\_link.file\_path.is\_dir(): # Local directories are built in tree return str(original\_link.file\_path) if self.req.editable: # In this branch the requirement must be an editable VCS requirement. # The repository will be unpacked into a \*persistent\* src directory. prefix: Path | None = None if self.environment.is\_local: prefix = self.environment.packages\_path # type: ignore[attr-defined] else: venv = self.environment.interpreter.get\_venv() if venv is not None: prefix = venv.root if prefix is not None: src\_dir = prefix / "src" else: src\_dir = Path("src") src\_dir.mkdir(exist\_ok=True, parents=True) dirname = self.candidate.name or self.req.name if not dirname: dirname, \_ = os.path.splitext(original\_link.filename) return str(src\_dir / str(dirname)) # Otherwise, for source dists, they will be unpacked into a \*temp\* directory. return create\_tracked\_tempdir(prefix="pdm-build-")
 def \_wheel\_compatible(self, wheel\_file: str, allow\_all: bool = False) -> bool: if allow\_all: return True supported\_tags = self.environment.target\_python.supported\_tags() file\_tags = parse\_wheel\_filename(wheel\_file)[-1] return not file\_tags.isdisjoint(supported\_tags)
 def \_get\_wheel\_dir(self) -> str: assert self.candidate.link wheel\_cache = self.environment.project.make\_wheel\_cache() if self.should\_cache(): termui.logger.info("Saving wheel to cache: %s", self.candidate.link) return wheel\_cache.get\_path\_for\_link(self.candidate.link, self.environment.target\_python).as\_posix() else: return wheel\_cache.get\_ephemeral\_path\_for\_link( self.candidate.link, self.environment.target\_python ).as\_posix()
@lru\_cache(maxsize=None)def make\_candidate( req: Requirement, name: str | None = None, version: str | None = None, link: Link | None = None,) -> Candidate: """Construct a candidate and cache it in memory""" return Candidate(req, name, version, link)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

