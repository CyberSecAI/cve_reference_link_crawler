

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Aaron Lu <aaron.lu@intel.com> | 2024-09-05 16:08:54 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-10-04 16:28:55 +0200 |
| commit | [fb2d057539eda67ec7cfc369bf587e6518a9b99d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)) | |
| tree | [cf2c0dc82f0eceebe2abf818c041802f29dfd415](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d) | |
| parent | [6f68e1e9ade6775179e75c994178f90727015393](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6f68e1e9ade6775179e75c994178f90727015393) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d&id2=6f68e1e9ade6775179e75c994178f90727015393)) | |
| download | [linux-fb2d057539eda67ec7cfc369bf587e6518a9b99d.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-fb2d057539eda67ec7cfc369bf587e6518a9b99d.tar.gz) | |

x86/sgx: Fix deadlock in SGX NUMA node search[ Upstream commit 9c936844010466535bd46ea4ce4656ef17653644 ]
When the current node doesn't have an EPC section configured by firmware
and all other EPC sections are used up, CPU can get stuck inside the
while loop that looks for an available EPC page from remote nodes
indefinitely, leading to a soft lockup. Note how nid\_of\_current will
never be equal to nid in that while loop because nid\_of\_current is not
set in sgx\_numa\_mask.
Also worth mentioning is that it's perfectly fine for the firmware not
to setup an EPC section on a node. While setting up an EPC section on
each node can enhance performance, it is not a requirement for
functionality.
Rework the loop to start and end on \*a\* node that has SGX memory. This
avoids the deadlock looking for the current SGX-lacking node to show up
in the loop when it never will.
Fixes: 901ddbb9ecf5 ("x86/sgx: Add a basic NUMA allocation scheme to sgx\_alloc\_epc\_page()")
Reported-by: "Molina Sabido, Gerardo" <gerardo.molina.sabido@intel.com>
Signed-off-by: Aaron Lu <aaron.lu@intel.com>
Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
Reviewed-by: Kai Huang <kai.huang@intel.com>
Reviewed-by: Jarkko Sakkinen <jarkko@kernel.org>
Acked-by: Dave Hansen <dave.hansen@linux.intel.com>
Tested-by: Zhimin Luo <zhimin.luo@intel.com>
Link: <https://lore.kernel.org/all/20240905080855.1699814-2-aaron.lu%40intel.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)

| -rw-r--r-- | [arch/x86/kernel/cpu/sgx/main.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/arch/x86/kernel/cpu/sgx/main.c?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d) | 27 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 14 insertions, 13 deletions

| diff --git a/arch/x86/kernel/cpu/sgx/main.c b/arch/x86/kernel/cpu/sgx/main.cindex 166692f2d50111..c7f8c3200e8d7f 100644--- a/[arch/x86/kernel/cpu/sgx/main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kernel/cpu/sgx/main.c?id=6f68e1e9ade6775179e75c994178f90727015393)+++ b/[arch/x86/kernel/cpu/sgx/main.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/kernel/cpu/sgx/main.c?id=fb2d057539eda67ec7cfc369bf587e6518a9b99d)@@ -474,24 +474,25 @@ struct sgx\_epc\_page \*\_\_sgx\_alloc\_epc\_page(void) { struct sgx\_epc\_page \*page; int nid\_of\_current = numa\_node\_id();- int nid = nid\_of\_current;+ int nid\_start, nid; - if (node\_isset(nid\_of\_current, sgx\_numa\_mask)) {- page = \_\_sgx\_alloc\_epc\_page\_from\_node(nid\_of\_current);- if (page)- return page;- }-- /\* Fall back to the non-local NUMA nodes: \*/- while (true) {- nid = next\_node\_in(nid, sgx\_numa\_mask);- if (nid == nid\_of\_current)- break;+ /\*+ \* Try local node first. If it doesn't have an EPC section,+ \* fall back to the non-local NUMA nodes.+ \*/+ if (node\_isset(nid\_of\_current, sgx\_numa\_mask))+ nid\_start = nid\_of\_current;+ else+ nid\_start = next\_node\_in(nid\_of\_current, sgx\_numa\_mask); + nid = nid\_start;+ do { page = \_\_sgx\_alloc\_epc\_page\_from\_node(nid); if (page) return page;- }++ nid = next\_node\_in(nid, sgx\_numa\_mask);+ } while (nid != nid\_start);  return ERR\_PTR(-ENOMEM); } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 11:49:46 +0000

