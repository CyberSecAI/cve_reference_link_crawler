

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Shakeel Butt <shakeel.butt@linux.dev> | 2024-08-02 16:58:22 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-09-12 11:07:53 +0200 |
| commit | [e6cc9ff2ac0b5df9f25eb790934c3104f6710278](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)) | |
| tree | [6e465475bff7bf435ee254c17e36fe5138c6a30a](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278) | |
| parent | [d116a0b0e02f395cedfb8c725bd67480aa7c428c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d116a0b0e02f395cedfb8c725bd67480aa7c428c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278&id2=d116a0b0e02f395cedfb8c725bd67480aa7c428c)) | |
| download | [linux-e6cc9ff2ac0b5df9f25eb790934c3104f6710278.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-e6cc9ff2ac0b5df9f25eb790934c3104f6710278.tar.gz) | |

memcg: protect concurrent access to mem\_cgroup\_idrcommit 9972605a238339b85bd16b084eed5f18414d22db upstream.
Commit 73f576c04b94 ("mm: memcontrol: fix cgroup creation failure after
many small jobs") decoupled the memcg IDs from the CSS ID space to fix the
cgroup creation failures. It introduced IDR to maintain the memcg ID
space. The IDR depends on external synchronization mechanisms for
modifications. For the mem\_cgroup\_idr, the idr\_alloc() and idr\_replace()
happen within css callback and thus are protected through cgroup\_mutex
from concurrent modifications. However idr\_remove() for mem\_cgroup\_idr
was not protected against concurrency and can be run concurrently for
different memcgs when they hit their refcnt to zero. Fix that.
We have been seeing list\_lru based kernel crashes at a low frequency in
our fleet for a long time. These crashes were in different part of
list\_lru code including list\_lru\_add(), list\_lru\_del() and reparenting
code. Upon further inspection, it looked like for a given object (dentry
and inode), the super\_block's list\_lru didn't have list\_lru\_one for the
memcg of that object. The initial suspicions were either the object is
not allocated through kmem\_cache\_alloc\_lru() or somehow
memcg\_list\_lru\_alloc() failed to allocate list\_lru\_one() for a memcg but
returned success. No evidence were found for these cases.
Looking more deeply, we started seeing situations where valid memcg's id
is not present in mem\_cgroup\_idr and in some cases multiple valid memcgs
have same id and mem\_cgroup\_idr is pointing to one of them. So, the most
reasonable explanation is that these situations can happen due to race
between multiple idr\_remove() calls or race between
idr\_alloc()/idr\_replace() and idr\_remove(). These races are causing
multiple memcgs to acquire the same ID and then offlining of one of them
would cleanup list\_lrus on the system for all of them. Later access from
other memcgs to the list\_lru cause crashes due to missing list\_lru\_one.
Link: [https://lkml.kernel.org/r/20240802235822.1830976-1-shakeel.butt@linux.dev](https://lkml.kernel.org/r/20240802235822.1830976-1-shakeel.butt%40linux.dev)
Fixes: 73f576c04b94 ("mm: memcontrol: fix cgroup creation failure after many small jobs")
Signed-off-by: Shakeel Butt <shakeel.butt@linux.dev>
Acked-by: Muchun Song <muchun.song@linux.dev>
Reviewed-by: Roman Gushchin <roman.gushchin@linux.dev>
Acked-by: Johannes Weiner <hannes@cmpxchg.org>
Cc: Michal Hocko <mhocko@suse.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
[ Adapted over commit be740503ed03 ("mm: memcontrol: fix cannot alloc the
maximum memcg ID") and 6f0df8e16eb5 ("memcontrol: ensure memcg acquired by id
is properly set up") both are not in the tree ]
Signed-off-by: Tomas Krcka <krckatom@amazon.de>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)

| -rw-r--r-- | [mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/mm/memcontrol.c?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278) | 23 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 20 insertions, 3 deletions

| diff --git a/mm/memcontrol.c b/mm/memcontrol.cindex 69dd12a7994283..6dd32ed164eaff 100644--- a/[mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memcontrol.c?id=d116a0b0e02f395cedfb8c725bd67480aa7c428c)+++ b/[mm/memcontrol.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/mm/memcontrol.c?id=e6cc9ff2ac0b5df9f25eb790934c3104f6710278)@@ -5083,11 +5083,28 @@ static struct cftype mem\_cgroup\_legacy\_files[] = { \*/  static DEFINE\_IDR(mem\_cgroup\_idr);+static DEFINE\_SPINLOCK(memcg\_idr\_lock);++static int mem\_cgroup\_alloc\_id(void)+{+ int ret;++ idr\_preload(GFP\_KERNEL);+ spin\_lock(&memcg\_idr\_lock);+ ret = idr\_alloc(&mem\_cgroup\_idr, NULL, 1, MEM\_CGROUP\_ID\_MAX + 1,+ GFP\_NOWAIT);+ spin\_unlock(&memcg\_idr\_lock);+ idr\_preload\_end();+ return ret;+}  static void mem\_cgroup\_id\_remove(struct mem\_cgroup \*memcg) { if (memcg->id.id > 0) {+ spin\_lock(&memcg\_idr\_lock); idr\_remove(&mem\_cgroup\_idr, memcg->id.id);+ spin\_unlock(&memcg\_idr\_lock);+ memcg->id.id = 0; } }@@ -5201,9 +5218,7 @@ static struct mem\_cgroup \*mem\_cgroup\_alloc(void) if (!memcg) return ERR\_PTR(error); - memcg->id.id = idr\_alloc(&mem\_cgroup\_idr, NULL,- 1, MEM\_CGROUP\_ID\_MAX,- GFP\_KERNEL);+ memcg->id.id = mem\_cgroup\_alloc\_id(); if (memcg->id.id < 0) { error = memcg->id.id; goto fail;@@ -5244,7 +5259,9 @@ static struct mem\_cgroup \*mem\_cgroup\_alloc(void) INIT\_LIST\_HEAD(&memcg->deferred\_split\_queue.split\_queue); memcg->deferred\_split\_queue.split\_queue\_len = 0; #endif+ spin\_lock(&memcg\_idr\_lock); idr\_replace(&mem\_cgroup\_idr, memcg, memcg->id.id);+ spin\_unlock(&memcg\_idr\_lock); return memcg; fail: mem\_cgroup\_id\_remove(memcg); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 16:36:45 +0000

