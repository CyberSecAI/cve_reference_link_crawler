```
{
  "vulnerability": {
    "root_cause": "The `idr_remove()` function for `mem_cgroup_idr` was not protected against concurrency, allowing it to be run concurrently for different memory cgroups (memcgs) when their reference count reaches zero.",
    "weaknesses": [
      "Race condition in `idr_remove()`",
      "Missing synchronization for `mem_cgroup_idr` modifications"
    ],
    "impact": "Concurrent calls to `idr_remove()` or a race between `idr_alloc()`/`idr_replace()` and `idr_remove()` can lead to multiple memcgs acquiring the same ID. When one of these memcgs is offlined, it cleans up list_lrus on the system for all memcgs sharing the same ID. Later, other memcgs accessing these list_lrus can cause kernel crashes due to missing list_lru_one entries.",
    "attack_vectors": "Exploiting the race condition would require triggering the removal of memcgs concurrently, which could be done by manipulating the reference counts.",
    "required_capabilities": "The attacker would need to be able to create and destroy memcgs in a way that triggers the race condition. This generally requires some level of privileged access within the system."
  },
  "fixes": [
    "A spinlock (`memcg_idr_lock`) was added to protect the `idr_alloc`, `idr_remove`, and `idr_replace` operations on `mem_cgroup_idr`.",
    "The `idr_alloc()` call was moved to a new function `mem_cgroup_alloc_id()` which uses the new spinlock."
  ],
  "details": "The vulnerability stems from the fact that memcg IDs are maintained via an IDR, which requires external synchronization. While `idr_alloc` and `idr_replace` were protected by `cgroup_mutex`, `idr_remove` was not protected against concurrency. This could result in inconsistent states, leading to list_lru corruption and kernel crashes."
}
```