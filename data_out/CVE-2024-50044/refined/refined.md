- **Root cause of vulnerability:** A locking issue in the Linux kernel's Bluetooth RFCOMM implementation. The `rfcomm_sk_state_change` function attempts to acquire the `sock_lock` while it might already be held by the calling task, leading to a deadlock. This occurs because `rfcomm_sock_ioctl` always attempts to lock the socket, creating a potential circular locking dependency when `rfcomm_sk_state_change` is called.
- **Weaknesses/vulnerabilities present:** Circular locking dependency in the Bluetooth RFCOMM socket handling. Specifically, the `rfcomm_sk_state_change` function and `rfcomm_sock_ioctl` can attempt to acquire the same lock in a nested manner, causing a deadlock if not properly managed.
- **Impact of exploitation:** A deadlock can occur, leading to denial of service. The system may become unresponsive, requiring a reboot or manual intervention to recover.
- **Attack vectors:** Triggering a specific sequence of operations involving RFCOMM sockets, particularly relating to state changes and IOCTL calls which can be done through a local attacker by creating and manipulating RFCOMM sockets.
- **Required attacker capabilities/position:** The attacker needs to be able to create and manipulate Bluetooth RFCOMM sockets in a way that triggers both `rfcomm_sock_ioctl` and `rfcomm_sk_state_change` simultaneously or nested leading to the deadlock. This could be a local user on the system, or a process capable of using the bluetooth subsystem.