

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Baokun Li <libaokun1@huawei.com> | 2024-05-22 19:43:05 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-06-21 14:40:16 +0200 |
| commit | [b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)) | |
| tree | [6adeef1334a88e31ba3257908560645b63007ac3](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32) | |
| parent | [53e5207a045f9b0a4596046d89b79aeb86c7da5c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=53e5207a045f9b0a4596046d89b79aeb86c7da5c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32&id2=53e5207a045f9b0a4596046d89b79aeb86c7da5c)) | |
| download | [linux-b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32.tar.gz) | |

cachefiles: defer exposing anon\_fd until after copy\_to\_user() succeeds[ Upstream commit 4b4391e77a6bf24cba2ef1590e113d9b73b11039 ]
After installing the anonymous fd, we can now see it in userland and close
it. However, at this point we may not have gotten the reference count of
the cache, but we will put it during colse fd, so this may cause a cache
UAF.
So grab the cache reference count before fd\_install(). In addition, by
kernel convention, fd is taken over by the user land after fd\_install(),
and the kernel should not call close\_fd() after that, i.e., it should call
fd\_install() after everything is ready, thus fd\_install() is called after
copy\_to\_user() succeeds.
Fixes: c8383054506c ("cachefiles: notify the user daemon when looking up cookie")
Suggested-by: Hou Tao <houtao1@huawei.com>
Signed-off-by: Baokun Li <libaokun1@huawei.com>
Link: [https://lore.kernel.org/r/20240522114308.2402121-10-libaokun@huaweicloud.com](https://lore.kernel.org/r/20240522114308.2402121-10-libaokun%40huaweicloud.com)
Acked-by: Jeff Layton <jlayton@kernel.org>
Signed-off-by: Christian Brauner <brauner@kernel.org>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)

| -rw-r--r-- | [fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/cachefiles/ondemand.c?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32) | 53 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 33 insertions, 20 deletions

| diff --git a/fs/cachefiles/ondemand.c b/fs/cachefiles/ondemand.cindex dbcd4161ea3a11..89f118d68d1254 100644--- a/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=53e5207a045f9b0a4596046d89b79aeb86c7da5c)+++ b/[fs/cachefiles/ondemand.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/cachefiles/ondemand.c?id=b9f58cdae6a364a3270fd6b6a46e0fd4f7f8ce32)@@ -4,6 +4,11 @@ #include <linux/uio.h> #include "internal.h" +struct ondemand\_anon\_file {+ struct file \*file;+ int fd;+};+ static inline void cachefiles\_req\_put(struct cachefiles\_req \*req) { if (refcount\_dec\_and\_test(&req->ref))@@ -250,14 +255,14 @@ int cachefiles\_ondemand\_restore(struct cachefiles\_cache \*cache, char \*args) return 0; } -static int cachefiles\_ondemand\_get\_fd(struct cachefiles\_req \*req)+static int cachefiles\_ondemand\_get\_fd(struct cachefiles\_req \*req,+ struct ondemand\_anon\_file \*anon\_file) { struct cachefiles\_object \*object; struct cachefiles\_cache \*cache; struct cachefiles\_open \*load;- struct file \*file; u32 object\_id;- int ret, fd;+ int ret;  object = cachefiles\_grab\_object(req->object, cachefiles\_obj\_get\_ondemand\_fd);@@ -269,16 +274,16 @@ static int cachefiles\_ondemand\_get\_fd(struct cachefiles\_req \*req) if (ret < 0) goto err; - fd = get\_unused\_fd\_flags(O\_WRONLY);- if (fd < 0) {- ret = fd;+ anon\_file->fd = get\_unused\_fd\_flags(O\_WRONLY);+ if (anon\_file->fd < 0) {+ ret = anon\_file->fd; goto err\_free\_id; } - file = anon\_inode\_getfile("[cachefiles]", &cachefiles\_ondemand\_fd\_fops,- object, O\_WRONLY);- if (IS\_ERR(file)) {- ret = PTR\_ERR(file);+ anon\_file->file = anon\_inode\_getfile("[cachefiles]",+ &cachefiles\_ondemand\_fd\_fops, object, O\_WRONLY);+ if (IS\_ERR(anon\_file->file)) {+ ret = PTR\_ERR(anon\_file->file); goto err\_put\_fd; } @@ -286,16 +291,15 @@ static int cachefiles\_ondemand\_get\_fd(struct cachefiles\_req \*req) if (object->ondemand->ondemand\_id > 0) { spin\_unlock(&object->ondemand->lock); /\* Pair with check in cachefiles\_ondemand\_fd\_release(). \*/- file->private\_data = NULL;+ anon\_file->file->private\_data = NULL; ret = -EEXIST; goto err\_put\_file; } - file->f\_mode |= FMODE\_PWRITE | FMODE\_LSEEK;- fd\_install(fd, file);+ anon\_file->file->f\_mode |= FMODE\_PWRITE | FMODE\_LSEEK;  load = (void \*)req->msg.data;- load->fd = fd;+ load->fd = anon\_file->fd; object->ondemand->ondemand\_id = object\_id; spin\_unlock(&object->ondemand->lock); @@ -304,9 +308,11 @@ static int cachefiles\_ondemand\_get\_fd(struct cachefiles\_req \*req) return 0;  err\_put\_file:- fput(file);+ fput(anon\_file->file);+ anon\_file->file = NULL; err\_put\_fd:- put\_unused\_fd(fd);+ put\_unused\_fd(anon\_file->fd);+ anon\_file->fd = ret; err\_free\_id: xa\_erase(&cache->ondemand\_ids, object\_id); err:@@ -363,6 +369,7 @@ ssize\_t cachefiles\_ondemand\_daemon\_read(struct cachefiles\_cache \*cache, struct cachefiles\_msg \*msg; size\_t n; int ret = 0;+ struct ondemand\_anon\_file anon\_file; XA\_STATE(xas, &cache->reqs, cache->req\_id\_next);  xa\_lock(&cache->reqs);@@ -396,7 +403,7 @@ ssize\_t cachefiles\_ondemand\_daemon\_read(struct cachefiles\_cache \*cache, xa\_unlock(&cache->reqs);  if (msg->opcode == CACHEFILES\_OP\_OPEN) {- ret = cachefiles\_ondemand\_get\_fd(req);+ ret = cachefiles\_ondemand\_get\_fd(req, &anon\_file); if (ret) goto out; }@@ -404,10 +411,16 @@ ssize\_t cachefiles\_ondemand\_daemon\_read(struct cachefiles\_cache \*cache, msg->msg\_id = xas.xa\_index; msg->object\_id = req->object->ondemand->ondemand\_id; - if (copy\_to\_user(\_buffer, msg, n) != 0) {+ if (copy\_to\_user(\_buffer, msg, n) != 0) ret = -EFAULT;- if (msg->opcode == CACHEFILES\_OP\_OPEN)- close\_fd(((struct cachefiles\_open \*)msg->data)->fd);++ if (msg->opcode == CACHEFILES\_OP\_OPEN) {+ if (ret < 0) {+ fput(anon\_file.file);+ put\_unused\_fd(anon\_file.fd);+ goto out;+ }+ fd\_install(anon\_file.fd, anon\_file.file); } out: cachefiles\_put\_object(req->object, cachefiles\_obj\_put\_read\_req); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 20:38:23 +0000

