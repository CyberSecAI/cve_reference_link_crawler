

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Filipe Manana <fdmanana@suse.com> | 2024-02-23 16:38:43 +0000 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-03-06 14:45:10 +0000 |
| commit | [c34adc20b91a8e55e048b18d63f4f4ae003ecf8f](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)) | |
| tree | [8ffa554d24abfa2ae0b924139bcb7c65ac8fb84b](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) | |
| parent | [930e826962d9f01dcd2220176134427358d112f2](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=930e826962d9f01dcd2220176134427358d112f2) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f&id2=930e826962d9f01dcd2220176134427358d112f2)) | |
| download | [linux-c34adc20b91a8e55e048b18d63f4f4ae003ecf8f.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-c34adc20b91a8e55e048b18d63f4f4ae003ecf8f.tar.gz) | |

btrfs: fix double free of anonymous device after snapshot creation failurecommit e2b54eaf28df0c978626c9736b94f003b523b451 upstream.
When creating a snapshot we may do a double free of an anonymous device
in case there's an error committing the transaction. The second free may
result in freeing an anonymous device number that was allocated by some
other subsystem in the kernel or another btrfs filesystem.
The steps that lead to this:
1) At ioctl.c:create\_snapshot() we allocate an anonymous device number
and assign it to pending\_snapshot->anon\_dev;
2) Then we call btrfs\_commit\_transaction() and end up at
transaction.c:create\_pending\_snapshot();
3) There we call btrfs\_get\_new\_fs\_root() and pass it the anonymous device
number stored in pending\_snapshot->anon\_dev;
4) btrfs\_get\_new\_fs\_root() frees that anonymous device number because
btrfs\_lookup\_fs\_root() returned a root - someone else did a lookup
of the new root already, which could some task doing backref walking;
5) After that some error happens in the transaction commit path, and at
ioctl.c:create\_snapshot() we jump to the 'fail' label, and after
that we free again the same anonymous device number, which in the
meanwhile may have been reallocated somewhere else, because
pending\_snapshot->anon\_dev still has the same value as in step 1.
Recently syzbot ran into this and reported the following trace:
------------[ cut here ]------------
ida\_free called for id=51 which is not allocated.
WARNING: CPU: 1 PID: 31038 at lib/idr.c:525 ida\_free+0x370/0x420 lib/idr.c:525
Modules linked in:
CPU: 1 PID: 31038 Comm: syz-executor.2 Not tainted 6.8.0-rc4-syzkaller-00410-gc02197fc9076 #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/25/2024
RIP: 0010:ida\_free+0x370/0x420 lib/idr.c:525
Code: 10 42 80 3c 28 (...)
RSP: 0018:ffffc90015a67300 EFLAGS: 00010246
RAX: be5130472f5dd000 RBX: 0000000000000033 RCX: 0000000000040000
RDX: ffffc90009a7a000 RSI: 000000000003ffff RDI: 0000000000040000
RBP: ffffc90015a673f0 R08: ffffffff81577992 R09: 1ffff92002b4cdb4
R10: dffffc0000000000 R11: fffff52002b4cdb5 R12: 0000000000000246
R13: dffffc0000000000 R14: ffffffff8e256b80 R15: 0000000000000246
FS: 00007fca3f4b46c0(0000) GS:ffff8880b9500000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007f167a17b978 CR3: 000000001ed26000 CR4: 0000000000350ef0
Call Trace:
<TASK>
btrfs\_get\_root\_ref+0xa48/0xaf0 fs/btrfs/disk-io.c:1346
create\_pending\_snapshot+0xff2/0x2bc0 fs/btrfs/transaction.c:1837
create\_pending\_snapshots+0x195/0x1d0 fs/btrfs/transaction.c:1931
btrfs\_commit\_transaction+0xf1c/0x3740 fs/btrfs/transaction.c:2404
create\_snapshot+0x507/0x880 fs/btrfs/ioctl.c:848
btrfs\_mksubvol+0x5d0/0x750 fs/btrfs/ioctl.c:998
btrfs\_mksnapshot+0xb5/0xf0 fs/btrfs/ioctl.c:1044
\_\_btrfs\_ioctl\_snap\_create+0x387/0x4b0 fs/btrfs/ioctl.c:1306
btrfs\_ioctl\_snap\_create\_v2+0x1ca/0x400 fs/btrfs/ioctl.c:1393
btrfs\_ioctl+0xa74/0xd40
vfs\_ioctl fs/ioctl.c:51 [inline]
\_\_do\_sys\_ioctl fs/ioctl.c:871 [inline]
\_\_se\_sys\_ioctl+0xfe/0x170 fs/ioctl.c:857
do\_syscall\_64+0xfb/0x240
entry\_SYSCALL\_64\_after\_hwframe+0x6f/0x77
RIP: 0033:0x7fca3e67dda9
Code: 28 00 00 00 (...)
RSP: 002b:00007fca3f4b40c8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 00007fca3e7abf80 RCX: 00007fca3e67dda9
RDX: 00000000200005c0 RSI: 0000000050009417 RDI: 0000000000000003
RBP: 00007fca3e6ca47a R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
R13: 000000000000000b R14: 00007fca3e7abf80 R15: 00007fff6bf95658
</TASK>
Where we get an explicit message where we attempt to free an anonymous
device number that is not currently allocated. It happens in a different
code path from the example below, at btrfs\_get\_root\_ref(), so this change
may not fix the case triggered by syzbot.
To fix at least the code path from the example above, change
btrfs\_get\_root\_ref() and its callers to receive a dev\_t pointer argument
for the anonymous device number, so that in case it frees the number, it
also resets it to 0, so that up in the call chain we don't attempt to do
the double free.
CC: stable@vger.kernel.org # 5.10+
Link: [https://lore.kernel.org/linux-btrfs/000000000000f673a1061202f630@google.com/](https://lore.kernel.org/linux-btrfs/000000000000f673a1061202f630%40google.com/)
Fixes: e03ee2fe873e ("btrfs: do not ASSERT() if the newly created subvolume already got read")
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Reviewed-by: David Sterba <dsterba@suse.com>
Signed-off-by: David Sterba <dsterba@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)

| -rw-r--r-- | [fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/disk-io.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [fs/btrfs/disk-io.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/disk-io.h?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/ioctl.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/fs/btrfs/transaction.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f) | 2 | |  |  |  | | --- | --- | --- | |

4 files changed, 14 insertions, 14 deletions

| diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.cindex 0d1b05ded1e35b..5756edb37c61ed 100644--- a/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=930e826962d9f01dcd2220176134427358d112f2)+++ b/[fs/btrfs/disk-io.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)@@ -1643,12 +1643,12 @@ void btrfs\_free\_fs\_info(struct btrfs\_fs\_info \*fs\_info) \* \* @objectid: root id \* @anon\_dev: preallocated anonymous block device number for new roots,- \* pass 0 for new allocation.+ \* pass NULL for a new allocation. \* @check\_ref: whether to check root item references, If true, return -ENOENT \* for orphan roots \*/ static struct btrfs\_root \*btrfs\_get\_root\_ref(struct btrfs\_fs\_info \*fs\_info,- u64 objectid, dev\_t anon\_dev,+ u64 objectid, dev\_t \*anon\_dev, bool check\_ref) { struct btrfs\_root \*root;@@ -1668,9 +1668,9 @@ again: \* that common but still possible. In that case, we just need \* to free the anon\_dev. \*/- if (unlikely(anon\_dev)) {- free\_anon\_bdev(anon\_dev);- anon\_dev = 0;+ if (unlikely(anon\_dev && \*anon\_dev)) {+ free\_anon\_bdev(\*anon\_dev);+ \*anon\_dev = 0; }  if (check\_ref && btrfs\_root\_refs(&root->root\_item) == 0) {@@ -1692,7 +1692,7 @@ again: goto fail; } - ret = btrfs\_init\_fs\_root(root, anon\_dev);+ ret = btrfs\_init\_fs\_root(root, anon\_dev ? \*anon\_dev : 0); if (ret) goto fail; @@ -1728,7 +1728,7 @@ fail: \* root's anon\_dev to 0 to avoid a double free, once by btrfs\_put\_root() \* and once again by our caller. \*/- if (anon\_dev)+ if (anon\_dev && \*anon\_dev) root->anon\_dev = 0; btrfs\_put\_root(root); return ERR\_PTR(ret);@@ -1744,7 +1744,7 @@ fail: struct btrfs\_root \*btrfs\_get\_fs\_root(struct btrfs\_fs\_info \*fs\_info, u64 objectid, bool check\_ref) {- return btrfs\_get\_root\_ref(fs\_info, objectid, 0, check\_ref);+ return btrfs\_get\_root\_ref(fs\_info, objectid, NULL, check\_ref); }  /\*@@ -1752,11 +1752,11 @@ struct btrfs\_root \*btrfs\_get\_fs\_root(struct btrfs\_fs\_info \*fs\_info, \* the anonymous block device id \* \* @objectid: tree objectid- \* @anon\_dev: if zero, allocate a new anonymous block device or use the- \* parameter value+ \* @anon\_dev: if NULL, allocate a new anonymous block device or use the+ \* parameter value if not NULL \*/ struct btrfs\_root \*btrfs\_get\_new\_fs\_root(struct btrfs\_fs\_info \*fs\_info,- u64 objectid, dev\_t anon\_dev)+ u64 objectid, dev\_t \*anon\_dev) { return btrfs\_get\_root\_ref(fs\_info, objectid, anon\_dev, true); }diff --git a/fs/btrfs/disk-io.h b/fs/btrfs/disk-io.hindex 7322af63c0cc7d..24bddca86e9c9e 100644--- a/[fs/btrfs/disk-io.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.h?id=930e826962d9f01dcd2220176134427358d112f2)+++ b/[fs/btrfs/disk-io.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/disk-io.h?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)@@ -65,7 +65,7 @@ void btrfs\_free\_fs\_roots(struct btrfs\_fs\_info \*fs\_info); struct btrfs\_root \*btrfs\_get\_fs\_root(struct btrfs\_fs\_info \*fs\_info, u64 objectid, bool check\_ref); struct btrfs\_root \*btrfs\_get\_new\_fs\_root(struct btrfs\_fs\_info \*fs\_info,- u64 objectid, dev\_t anon\_dev);+ u64 objectid, dev\_t \*anon\_dev); struct btrfs\_root \*btrfs\_get\_fs\_root\_commit\_root(struct btrfs\_fs\_info \*fs\_info, struct btrfs\_path \*path, u64 objectid);diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.cindex 196e222749ccd2..64b37afb7c87ff 100644--- a/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=930e826962d9f01dcd2220176134427358d112f2)+++ b/[fs/btrfs/ioctl.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/ioctl.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)@@ -708,7 +708,7 @@ static noinline int create\_subvol(struct user\_namespace \*mnt\_userns, free\_extent\_buffer(leaf); leaf = NULL; - new\_root = btrfs\_get\_new\_fs\_root(fs\_info, objectid, anon\_dev);+ new\_root = btrfs\_get\_new\_fs\_root(fs\_info, objectid, &anon\_dev); if (IS\_ERR(new\_root)) { ret = PTR\_ERR(new\_root); btrfs\_abort\_transaction(trans, ret);diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.cindex 60db4c3b82fa1b..b172091f426122 100644--- a/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=930e826962d9f01dcd2220176134427358d112f2)+++ b/[fs/btrfs/transaction.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/btrfs/transaction.c?id=c34adc20b91a8e55e048b18d63f4f4ae003ecf8f)@@ -1809,7 +1809,7 @@ static noinline int create\_pending\_snapshot(struct btrfs\_trans\_handle \*trans, }  key.offset = (u64)-1;- pending->snap = btrfs\_get\_new\_fs\_root(fs\_info, objectid, pending->anon\_dev);+ pending->snap = btrfs\_get\_new\_fs\_root(fs\_info, objectid, &pending->anon\_dev); if (IS\_ERR(pending->snap)) { ret = PTR\_ERR(pending->snap); pending->snap = NULL; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 12:03:19 +0000

