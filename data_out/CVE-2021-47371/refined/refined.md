The provided content is related to CVE-2021-47371.

**Root Cause of the Vulnerability:**
- Memory leaks occur when a network device (mlxsw) unregisters from the nexthop notification chain.
- The mlxsw driver does not receive delete notifications for nexthops using netdevs that are not dismantled during a device reload (e.g., blackhole nexthops using the loopback interface).
- When unregistering from the notification chain, the mlxsw driver fails to flush its nexthop table, leading to memory leaks for those nexthops that were not properly notified as deleted.

**Weaknesses/Vulnerabilities:**
- Incomplete handling of nexthop object deletion during unregistration from the notification chain.
- Lack of symmetry between registration and unregistration paths of the nexthop notifier, specifically not replaying delete notifications on unregistration.
- The original unregister\_nexthop\_notifier() function did not take RTNL lock, which was needed to iterate over existing nexthops, creating a race condition and possible deadlock with other drivers like vxlan, which were using this function while holding RTNL.

**Impact of Exploitation:**
- Memory leaks, which can lead to resource exhaustion and potential system instability if the leak is continuous or large enough.

**Attack Vectors:**
- The vulnerability is triggered by reloading a device (`devlink dev reload`) after adding a nexthop using a different interface (e.g. a blackhole nexthop using the loopback device).
- The syzkaller fuzzer was able to identify the issue by crafting a sequence of commands.

**Required Attacker Capabilities/Position:**
- The attacker needs the ability to execute commands that add nexthops and trigger device reloads, suggesting the attacker needs root or some privileged access.
- No network access needed, the issue can be triggered locally.

**Additional Details:**

The fix introduces the following changes:
1.  When a nexthop notifier is unregistered, it now replays delete notifications for the listener being unregistered. This ensures a consistent state of the listeners after unregistering.
2.  The `unregister_nexthop_notifier()` now takes RTNL lock.
3.  The VXLAN driver is changed to unregister its nexthop listener without holding RTNL to avoid a deadlock when unregistering. This change makes the unregistration symmetric to the registration path.

The commit messages mention a syzkaller report that lead to this fix.