
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgpac%2Fgpac%2Fblob%2F105d67985ff3c3f4b98a98f312e3d84ae77a4463%2Fsrc%2Futils%2Futf.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fgpac%2Fgpac%2Fblob%2F105d67985ff3c3f4b98a98f312e3d84ae77a4463%2Fsrc%2Futils%2Futf.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=gpac%2Fgpac)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[gpac](/gpac)
/
**[gpac](/gpac/gpac)**
Public

* [Notifications](/login?return_to=%2Fgpac%2Fgpac) You must be signed in to change notification settings
* [Fork
  539](/login?return_to=%2Fgpac%2Fgpac)
* [Star
   2.8k](/login?return_to=%2Fgpac%2Fgpac)

* [Code](/gpac/gpac)
* [Issues
  71](/gpac/gpac/issues)
* [Pull requests
  11](/gpac/gpac/pulls)
* [Actions](/gpac/gpac/actions)
* [Wiki](/gpac/gpac/wiki)
* [Security](/gpac/gpac/security)
* [Insights](/gpac/gpac/pulse)

Additional navigation options

* [Code](/gpac/gpac)
* [Issues](/gpac/gpac/issues)
* [Pull requests](/gpac/gpac/pulls)
* [Actions](/gpac/gpac/actions)
* [Wiki](/gpac/gpac/wiki)
* [Security](/gpac/gpac/security)
* [Insights](/gpac/gpac/pulse)

## Files

 105d679
## Breadcrumbs

1. [gpac](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463)
2. /[src](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src)
3. /[utils](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src/utils)
/
# utf.c

 Blame  Blame
## Latest commit

## History

[History](/gpac/gpac/commits/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src/utils/utf.c)770 lines (703 loc) · 20.4 KB 105d679
## Breadcrumbs

1. [gpac](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463)
2. /[src](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src)
3. /[utils](/gpac/gpac/tree/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src/utils)
/
# utf.c

Top
## File metadata and controls

* Code
* Blame

770 lines (703 loc) · 20.4 KB[Raw](https://github.com/gpac/gpac/raw/105d67985ff3c3f4b98a98f312e3d84ae77a4463/src/utils/utf.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768/\* \* GPAC - Multimedia Framework C SDK \* \* Authors: Jean Le Feuvre \* Copyright (c) Telecom ParisTech 2007-2012 \* All rights reserved \* \* This file is part of GPAC / common tools sub-project \* \* GPAC is free software; you can redistribute it and/or modify \* it under the terms of the GNU Lesser General Public License as published by \* the Free Software Foundation; either version 2, or (at your option) \* any later version. \* \* GPAC is distributed in the hope that it will be useful, \* but WITHOUT ANY WARRANTY; without even the implied warranty of \* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \* GNU Lesser General Public License for more details. \* \* You should have received a copy of the GNU Lesser General Public \* License along with this library; see the file COPYING. If not, write to \* the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. \* \*/
#ifndef GPAC\_DISABLE\_CORE\_TOOLS
#include <gpac/utf.h>
#if 1
/\* \* Copyright 2001-2004 Unicode, Inc. \* \* Disclaimer \* \* This source code is provided as is by Unicode, Inc. No claims are \* made as to fitness for any particular purpose. No warranties of any \* kind are expressed or implied. The recipient agrees to determine \* applicability of information provided. If this file has been \* purchased on magnetic or optical media from Unicode, Inc., the \* sole remedy for any claim will be exchange of defective media \* within 90 days of receipt. \* \* Limitations on Rights to Redistribute This Code \* \* Unicode, Inc. hereby grants the right to freely use the information \* supplied in this file in the creation of products supporting the \* Unicode Standard, and to make copies of this file in any form \* for internal or external distribution as long as this notice \* remains attached. \*/
/\* ---------------------------------------------------------------------
 Conversions between UTF32, UTF-16, and UTF-8. Source code file. Author: Mark E. Davis, 1994. Rev History: Rick McGowan, fixes & updates May 2001. Sept 2001: fixed const & error conditions per mods suggested by S. Parent & A. Lillich. June 2002: Tim Dodd added detection and handling of incomplete source sequences, enhanced error detection, added casts to eliminate compiler warnings. July 2003: slight mods to back out aggressive FFFE detection. Jan 2004: updated switches in from-UTF8 conversions. Oct 2004: updated to use UNI\_MAX\_LEGAL\_UTF32 in UTF-32 conversions.
 See the header file "ConvertUTF.h" for complete documentation.
------------------------------------------------------------------------ \*/
typedef u32 UTF32; /\* at least 32 bits \*/typedef u16 UTF16; /\* at least 16 bits \*/typedef u8 UTF8; /\* typically 8 bits \*/typedef u8 Boolean; /\* 0 or 1 \*/
/\* Some fundamental constants \*/#define UNI\_REPLACEMENT\_CHAR (UTF32)0x0000FFFD#define UNI\_MAX\_BMP (UTF32)0x0000FFFF#define UNI\_MAX\_UTF16 (UTF32)0x0010FFFF#define UNI\_MAX\_UTF32 (UTF32)0x7FFFFFFF#define UNI\_MAX\_LEGAL\_UTF32 (UTF32)0x0010FFFF
typedef enum { conversionOK, /\* conversion successful \*/ sourceExhausted, /\* partial character in source, but hit end \*/ targetExhausted, /\* insuff. room in target for conversion \*/ sourceIllegal /\* source sequence is illegal/malformed \*/} ConversionResult;
typedef enum { strictConversion = 0, lenientConversion} ConversionFlags;
static const int halfShift = 10; /\* used for shifting by 10 bits \*/
static const UTF32 halfBase = 0x0010000UL;static const UTF32 halfMask = 0x3FFUL;
#define UNI\_SUR\_HIGH\_START (UTF32)0xD800#define UNI\_SUR\_HIGH\_END (UTF32)0xDBFF#define UNI\_SUR\_LOW\_START (UTF32)0xDC00#define UNI\_SUR\_LOW\_END (UTF32)0xDFFF#define false 0#define true 1
/\* \* Index into the table below with the first byte of a UTF-8 sequence to \* get the number of trailing bytes that are supposed to follow it. \* Note that \*legal\* UTF-8 values can't have 4 or 5-bytes. The table is \* left as-is for anyone who may want to do such conversion, which was \* allowed in earlier algorithms. \*/static const char trailingBytesForUTF8[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5};
/\* \* Magic values subtracted from a buffer value during UTF8 conversion. \* This table contains as many values as there might be trailing bytes \* in a UTF-8 sequence. \*/static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 0x03C82080UL, 0xFA082080UL, 0x82082080UL };
/\* \* Once the bits are split out into bytes of UTF-8, this is a mask OR-ed \* into the first byte, depending on how many bytes follow. There are \* as many entries in this table as there are UTF-8 sequence types. \* (I.e., one byte sequence, two byte... etc.). Remember that sequencs \* for \*legal\* UTF-8 will be 4 or fewer bytes total. \*/static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
/\* --------------------------------------------------------------------- \*/
/\* The interface converts a whole buffer to avoid function-call overhead. \* Constants have been gathered. Loops & conditionals have been removed as \* much as possible for efficiency, in favor of drop-through switches. \* (See "Note A" at the bottom of the file for equivalent code.) \* If your compiler supports it, the "isLegalUTF8" call can be turned \* into an inline function. \*/
/\* --------------------------------------------------------------------- \*/
ConversionResult ConvertUTF16toUTF8 ( const UTF16\*\* sourceStart, const UTF16\* sourceEnd, UTF8\*\* targetStart, UTF8\* targetEnd, ConversionFlags flags) { ConversionResult result = conversionOK; const UTF16\* source = \*sourceStart; UTF8\* target = \*targetStart; while (source < sourceEnd) { UTF32 ch; unsigned short bytesToWrite = 0; const UTF32 byteMask = 0xBF; const UTF32 byteMark = 0x80; const UTF16\* oldSource = source; /\* In case we have to back up because of target overflow. \*/ ch = \*source++; /\* If we have a surrogate pair, convert to UTF32 first. \*/ if (ch >= UNI\_SUR\_HIGH\_START && ch <= UNI\_SUR\_HIGH\_END) { /\* If the 16 bits following the high surrogate are in the source buffer... \*/ if (source < sourceEnd) { UTF32 ch2 = \*source; /\* If it's a low surrogate, convert to UTF32. \*/ if (ch2 >= UNI\_SUR\_LOW\_START && ch2 <= UNI\_SUR\_LOW\_END) { ch = ((ch - UNI\_SUR\_HIGH\_START) << halfShift) + (ch2 - UNI\_SUR\_LOW\_START) + halfBase; ++source; } else if (flags == strictConversion) { /\* it's an unpaired high surrogate \*/ --source; /\* return to the illegal value itself \*/ result = sourceIllegal; break; } } else { /\* We don't have the 16 bits following the high surrogate. \*/ --source; /\* return to the high surrogate \*/ result = sourceExhausted; break; } } else if (flags == strictConversion) { /\* UTF-16 surrogate values are illegal in UTF-32 \*/ if (ch >= UNI\_SUR\_LOW\_START && ch <= UNI\_SUR\_LOW\_END) { --source; /\* return to the illegal value itself \*/ result = sourceIllegal; break; } } /\* Figure out how many bytes the result will require \*/ if (ch < (UTF32)0x80) { bytesToWrite = 1; } else if (ch < (UTF32)0x800) { bytesToWrite = 2; } else if (ch < (UTF32)0x10000) { bytesToWrite = 3; } else if (ch < (UTF32)0x110000) { bytesToWrite = 4; } else { bytesToWrite = 3; ch = UNI\_REPLACEMENT\_CHAR; }
 target += bytesToWrite; if (target > targetEnd) { source = oldSource; /\* Back up source pointer! \*/ target -= bytesToWrite; result = targetExhausted; break; } switch (bytesToWrite) { /\* note: everything falls through. \*/ case 4: \*--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6; case 3: \*--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6; case 2: \*--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6; case 1: \*--target = (UTF8)(ch | firstByteMark[bytesToWrite]); } target += bytesToWrite; } \*sourceStart = source; \*targetStart = target; return result;}
/\* \* Utility routine to tell whether a sequence of bytes is legal UTF-8. \* This must be called with the length pre-determined by the first byte. \* If not calling this from ConvertUTF8to\*, then the length can be set by: \* length = trailingBytesForUTF8[\*source]+1; \* and the sequence is illegal right away if there aren't that many bytes \* available. \* If presented with a length > 4, this returns false. The Unicode \* definition of UTF-8 goes up to 4-byte sequences. \*/
Boolean isLegalUTF8(const UTF8 \*source, int length) { UTF8 a; const UTF8 \*srcptr = source+length; switch (length) { default: return false; /\* Everything else falls through when "true"... \*/ case 4: if ((a = (\*--srcptr)) < 0x80 || a > 0xBF) return false; case 3: if ((a = (\*--srcptr)) < 0x80 || a > 0xBF) return false; case 2: if ((a = (\*--srcptr)) > 0xBF) return false;
 switch (\*source) { /\* no fall-through in this inner switch \*/ case 0xE0: if (a < 0xA0) return false; break; case 0xED: if (a > 0x9F) return false; break; case 0xF0: if (a < 0x90) return false; break; case 0xF4: if (a > 0x8F) return false; break; default: if (a < 0x80) return false; }
 case 1: if (\*source >= 0x80 && \*source < 0xC2) return false; } if (\*source > 0xF4) return false; return true;}
/\* --------------------------------------------------------------------- \*/
ConversionResult ConvertUTF8toUTF16 ( const UTF8\*\* sourceStart, const UTF8\* sourceEnd, UTF16\*\* targetStart, UTF16\* targetEnd, ConversionFlags flags) { ConversionResult result = conversionOK; const UTF8\* source = \*sourceStart; UTF16\* target = \*targetStart; while (source < sourceEnd) { UTF32 ch = 0; unsigned short extraBytesToRead = trailingBytesForUTF8[\*source]; if (source + extraBytesToRead >= sourceEnd) { result = sourceExhausted; break; } /\* Do this check whether lenient or strict \*/ if (! isLegalUTF8(source, extraBytesToRead+1)) { result = sourceIllegal; break; } /\* \* The cases all fall through. See "Note A" below. \*/ switch (extraBytesToRead) { case 5: ch += \*source++; ch <<= 6; /\* remember, illegal UTF-8 \*/ case 4: ch += \*source++; ch <<= 6; /\* remember, illegal UTF-8 \*/ case 3: ch += \*source++; ch <<= 6; case 2: ch += \*source++; ch <<= 6; case 1: ch += \*source++; ch <<= 6; case 0: ch += \*source++; } ch -= offsetsFromUTF8[extraBytesToRead];
 if (target >= targetEnd) { source -= (extraBytesToRead+1); /\* Back up source pointer! \*/ result = targetExhausted; break; } if (ch <= UNI\_MAX\_BMP) { /\* Target is a character <= 0xFFFF \*/ /\* UTF-16 surrogate values are illegal in UTF-32 \*/ if (ch >= UNI\_SUR\_HIGH\_START && ch <= UNI\_SUR\_LOW\_END) { if (flags == strictConversion) { source -= (extraBytesToRead+1); /\* return to the illegal value itself \*/ result = sourceIllegal; break; } else { \*target++ = UNI\_REPLACEMENT\_CHAR; } } else { \*target++ = (UTF16)ch; /\* normal case \*/ } } else if (ch > UNI\_MAX\_UTF16) { if (flags == strictConversion) { result = sourceIllegal; source -= (extraBytesToRead+1); /\* return to the start \*/ break; /\* Bail out; shouldn't continue \*/ } else { \*target++ = UNI\_REPLACEMENT\_CHAR; } } else { /\* target is a character in range 0xFFFF - 0x10FFFF. \*/ if (target + 1 >= targetEnd) { source -= (extraBytesToRead+1); /\* Back up source pointer! \*/ result = targetExhausted; break; } ch -= halfBase; \*target++ = (UTF16)((ch >> halfShift) + UNI\_SUR\_HIGH\_START); \*target++ = (UTF16)((ch & halfMask) + UNI\_SUR\_LOW\_START); } } \*sourceStart = source; \*targetStart = target; return result;}
GF\_EXPORTBool gf\_utf8\_is\_legal(const u8 \*data, u32 length){ //we simply run ConvertUTF8toUTF16 without target const UTF8\*\* sourceStart = (const UTF8\*\*) &data; const UTF8\* sourceEnd = (const UTF8\*) ( data + length ); ConversionResult result = conversionOK; const UTF8\* source = \*sourceStart;
 while (source < sourceEnd) { UTF32 ch = 0; unsigned short extraBytesToRead = trailingBytesForUTF8[\*source]; if (source + extraBytesToRead >= sourceEnd) { result = sourceExhausted; break; } /\* Do this check whether lenient or strict \*/ if (! isLegalUTF8(source, extraBytesToRead+1)) { result = sourceIllegal; break; } /\* \* The cases all fall through. See "Note A" below. \*/ switch (extraBytesToRead) { case 5: ch += \*source++; ch <<= 6; /\* remember, illegal UTF-8 \*/ case 4: ch += \*source++; ch <<= 6; /\* remember, illegal UTF-8 \*/ case 3: ch += \*source++; ch <<= 6; case 2: ch += \*source++; ch <<= 6; case 1: ch += \*source++; ch <<= 6; case 0: ch += \*source++; } ch -= offsetsFromUTF8[extraBytesToRead];
 if (ch <= UNI\_MAX\_BMP) { /\* Target is a character <= 0xFFFF \*/ /\* UTF-16 surrogate values are illegal in UTF-32 \*/ if (ch >= UNI\_SUR\_HIGH\_START && ch <= UNI\_SUR\_LOW\_END) { result = sourceIllegal; break; } } else if (ch > UNI\_MAX\_UTF16) { result = sourceIllegal; break; /\* Bail out; shouldn't continue \*/ } } return (result==conversionOK) ? GF\_TRUE : GF\_FALSE;}
GF\_EXPORTu32 gf\_utf8\_wcslen (const unsigned short \*s){ const unsigned short\* ptr; if (!s) return 0; for (ptr = s; \*ptr != (unsigned short)'\0'; ptr++) { } return (u32) ( ptr - s );}
GF\_EXPORTu32 gf\_utf8\_wcstombs(char\* dest, size\_t len, const unsigned short\*\* srcp){ if (!srcp || !\*srcp) return 0; else { const UTF16\*\* sourceStart = srcp; const UTF16\* sourceEnd = \*srcp + gf\_utf8\_wcslen(\*srcp); UTF8\* targetStart = (UTF8\*) dest; UTF8\* targetEnd = (UTF8\*) dest + len; ConversionFlags flags = strictConversion;
 ConversionResult res = ConvertUTF16toUTF8(sourceStart, sourceEnd, &targetStart, targetEnd, flags); if (res != conversionOK) return GF\_UTF8\_FAIL; \*targetStart = 0; \*srcp=NULL; return (u32) strlen(dest); }}
GF\_EXPORTu32 gf\_utf8\_mbstowcs(unsigned short\* dest, size\_t len, const char\*\* srcp){ if (!srcp || !\*srcp) return 0; else { const UTF8\*\* sourceStart = (const UTF8\*\*) srcp; const UTF8\* sourceEnd = (const UTF8\*) ( \*srcp + strlen( \*srcp) ); UTF16\* targetStart = (UTF16\* ) dest; UTF16\* targetEnd = (UTF16\* ) (dest + len); ConversionFlags flags = strictConversion; ConversionResult res = ConvertUTF8toUTF16(sourceStart, sourceEnd, &targetStart, targetEnd, flags); if (res != conversionOK) return GF\_UTF8\_FAIL; \*targetStart = 0; \*srcp=NULL; return gf\_utf8\_wcslen(dest); }}
#else
GF\_EXPORTu32 gf\_utf8\_wcslen (const unsigned short \*s){ const unsigned short\* ptr; for (ptr = s; \*ptr != (unsigned short)'\0'; ptr++) { } return (u32) (ptr - s);}
GF\_EXPORTu32 gf\_utf8\_wcstombs(char\* dest, size\_t len, const unsigned short\*\* srcp){ /\* \* Original code from the GNU UTF-8 Library \*/ size\_t count; const unsigned short \* src = \*srcp;
 if (dest != NULL) { char\* destptr = dest; for (;; src++) { unsigned char c; unsigned short wc = \*src; if (wc < 0x80) { if (wc == (wchar\_t)'\0') { if (len == 0) { \*srcp = src; break; } \*destptr = '\0'; \*srcp = NULL; break; } count = 0; c = (unsigned char) wc; } else if (wc < 0x800) { count = 1; c = (unsigned char) ((wc >> 6) | 0xC0); } else { count = 2; c = (unsigned char) ((wc >> 12) | 0xE0); } if (len <= count) { \*srcp = src; break; } len -= count+1; \*destptr++ = c; if (count > 0) do { \*destptr++ = (unsigned char)(((wc >> (6 \* --count)) & 0x3F) | 0x80); } while (count > 0); } return (u32) (destptr - dest); } else { /\* Ignore dest and len. \*/ size\_t totalcount = 0; for (;; src++) { unsigned short wc = \*src; size\_t count; if (wc < 0x80) { if (wc == (wchar\_t)'\0') { \*srcp = NULL; break; } count = 1; } else if (wc < 0x800) { count = 2; } else { count = 3; } totalcount += count; } return (u32) totalcount; }}
typedef struct{ u32 count : 16; /\* number of bytes remaining to be processed \*/ u32 value : 16; /\* if count > 0: partial wide character \*/ /\* If WCHAR\_T\_BITS == 16, need 2 bits for count, 12 bits for value (10 for mbstowcs direction, 12 for wcstombs direction). \*/} gf\_utf8\_mbstate\_t;
static gf\_utf8\_mbstate\_t internal;
GF\_EXPORTu32 gf\_utf8\_mbstowcs(unsigned short\* dest, size\_t len, const char\*\* srcp){ gf\_utf8\_mbstate\_t\* ps = &internal; const char \*src = \*srcp;
 unsigned short\* destptr = dest; for (; len > 0; destptr++, len--) { const char\* backup\_src = src; unsigned char c; unsigned short wc; size\_t count; if (ps->count == 0) { c = (unsigned char) \*src; if (c < 0x80) { \*destptr = (wchar\_t) c; if (c == 0) { src = NULL; break; } src++; continue; } else if (c < 0xC0) { /\* Spurious 10XXXXXX byte is invalid. \*/ goto bad\_input; } if (c < 0xE0) { wc = (wchar\_t)(c & 0x1F) << 6; count = 1; if (c < 0xC2) goto bad\_input; } else if (c < 0xF0) { wc = (wchar\_t)(c & 0x0F) << 12; count = 2; } else goto bad\_input; src++; } else { wc = ps->value << 6; count = ps->count; } for (;;) { c = (unsigned char) \*src++ ^ 0x80; if (!(c < 0x40)) goto bad\_input\_backup; wc |= (unsigned short) c << (6 \* --count); if (count == 0) break; /\* The following test is only necessary once for every character, but it would be too complicated to perform it once only, on the first pass through this loop. \*/ if ((unsigned short) wc < ((unsigned short) 1 << (5 \* count + 6))) goto bad\_input\_backup; } \*destptr = wc; ps->count = 0; continue;
bad\_input\_backup: src = backup\_src; goto bad\_input; } \*srcp = src; return (u32) (destptr - dest);
bad\_input: \*srcp = src; return GF\_UTF8\_FAIL;}
#endif
GF\_EXPORTGF\_Err gf\_utf\_get\_utf8\_string\_from\_bom(const u8 \*data, u32 size, char \*\*out\_ptr, char \*\*result){ u32 unicode\_type = 0; if (!out\_ptr || !result || !data) return GF\_BAD\_PARAM; \*out\_ptr = NULL; \*result = (char \*) data;
 if (size>=5) { /\*0: no unicode, 1: UTF-16BE, 2: UTF-16LE\*/ if ((data[0]==0xFF) && (data[1]==0xFE)) { if (!data[2] && !data[3]) { return GF\_OK; } else { unicode\_type = 2; } } else if ((data[0]==0xFE) && (data[1]==0xFF)) { if (!data[2] && !data[3]) { return GF\_OK; } else { unicode\_type = 1; } } else if ((data[0]==0xEF) && (data[1]==0xBB) && (data[2]==0xBF)) { \*result = (char \*) (data+4); return GF\_OK; } }
 if (!unicode\_type) { \*result = (char \*) data; return GF\_OK; }
 if (size%2) size--; u16 \*str\_wc = gf\_malloc(size+2); if (!str\_wc) return GF\_OUT\_OF\_MEM; u16 \*srcwc; char \*dst = gf\_malloc(size+2); if (!dst) { gf\_free(str\_wc); return GF\_OUT\_OF\_MEM; } \*out\_ptr = dst; u32 i; for (i=0; i<size; i+=2) { u16 wchar=0; u8 c1 = data[i]; u8 c2 = data[i+1];
 /\*Little-endian order\*/ if (unicode\_type==2) { if (c2) { wchar = c2; wchar <<=8; wchar |= c1; } else wchar = c1; } else { wchar = c1; if (c2) { wchar <<= 8; wchar |= c2; } } str\_wc[i/2] = wchar; } str\_wc[i/2] = 0; srcwc = str\_wc; u32 res = gf\_utf8\_wcstombs(dst, size, (const unsigned short \*\*) &srcwc); gf\_free(str\_wc); if (res==GF\_UTF8\_FAIL) { gf\_free(dst); \*out\_ptr = NULL; return GF\_IO\_ERR; } \*result = dst; return GF\_OK;}
#if defined(WIN32)
GF\_EXPORTwchar\_t\* gf\_utf8\_to\_wcs(const char\* str){ size\_t source\_len; wchar\_t\* result; if (str == 0) return 0; source\_len = strlen(str); result = gf\_calloc(source\_len + 1, sizeof(wchar\_t)); if (!result) return 0; if (gf\_utf8\_mbstowcs(result, source\_len, &str) == GF\_UTF8\_FAIL) { gf\_free(result); return 0; } return result;}
GF\_EXPORTchar\* gf\_wcs\_to\_utf8(const wchar\_t\* str){ size\_t source\_len; char\* result; if (str == 0) return 0; source\_len = wcslen(str); result = gf\_calloc(source\_len + 1, UTF8\_MAX\_BYTES\_PER\_CHAR); if (!result) return 0; if (gf\_utf8\_wcstombs(result, source\_len \* UTF8\_MAX\_BYTES\_PER\_CHAR, &str) == GF\_UTF8\_FAIL) { gf\_free(result); return 0; } return result;}#endif
#endif /\* GPAC\_DISABLE\_CORE\_TOOLS \*/

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

