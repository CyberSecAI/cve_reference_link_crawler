
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdenoland%2Fdeno%2Fblob%2Fv1.39.0%2Fruntime%2Fpermissions%2Fprompter.rs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fdenoland%2Fdeno%2Fblob%2Fv1.39.0%2Fruntime%2Fpermissions%2Fprompter.rs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=denoland%2Fdeno)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[denoland](/denoland)
/
**[deno](/denoland/deno)**
Public

* [Notifications](/login?return_to=%2Fdenoland%2Fdeno) You must be signed in to change notification settings
* [Fork
  5.5k](/login?return_to=%2Fdenoland%2Fdeno)
* [Star
   101k](/login?return_to=%2Fdenoland%2Fdeno)

* [Code](/denoland/deno/tree/v1.39.0)
* [Issues
  2k](/denoland/deno/issues)
* [Pull requests
  140](/denoland/deno/pulls)
* [Discussions](/denoland/deno/discussions)
* [Actions](/denoland/deno/actions)
* [Wiki](/denoland/deno/wiki)
* [Security](/denoland/deno/security)
* [Insights](/denoland/deno/pulse)

Additional navigation options

* [Code](/denoland/deno/tree/v1.39.0)
* [Issues](/denoland/deno/issues)
* [Pull requests](/denoland/deno/pulls)
* [Discussions](/denoland/deno/discussions)
* [Actions](/denoland/deno/actions)
* [Wiki](/denoland/deno/wiki)
* [Security](/denoland/deno/security)
* [Insights](/denoland/deno/pulse)

## Files

 v1.39.0
## Breadcrumbs

1. [deno](/denoland/deno/tree/v1.39.0)
2. /[runtime](/denoland/deno/tree/v1.39.0/runtime)
3. /[permissions](/denoland/deno/tree/v1.39.0/runtime/permissions)
/
# prompter.rs

Copy path Blame  Blame
## Latest commit

## History

[History](/denoland/deno/commits/v1.39.0/runtime/permissions/prompter.rs)354 lines (313 loc) · 11 KB v1.39.0
## Breadcrumbs

1. [deno](/denoland/deno/tree/v1.39.0)
2. /[runtime](/denoland/deno/tree/v1.39.0/runtime)
3. /[permissions](/denoland/deno/tree/v1.39.0/runtime/permissions)
/
# prompter.rs

Top
## File metadata and controls

* Code
* Blame

354 lines (313 loc) · 11 KB[Raw](https://github.com/denoland/deno/raw/refs/tags/v1.39.0/runtime/permissions/prompter.rs)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.
use crate::colors;use deno\_core::error::AnyError;use deno\_core::parking\_lot::Mutex;use once\_cell::sync::Lazy;use std::fmt::Write;use std::io::BufRead;use std::io::IsTerminal;use std::io::StderrLock;use std::io::StdinLock;use std::io::Write as IoWrite;
/// Helper function to strip ansi codes and ASCII control characters.fn strip\_ansi\_codes\_and\_ascii\_control(s: &str) -> std::borrow::Cow<str> { console\_static\_text::ansi::strip\_ansi\_codes(s) .chars() .filter(|c| !c.is\_ascii\_control()) .collect()}
pub const PERMISSION\_EMOJI: &str = "⚠️";
#[derive(Debug, Eq, PartialEq)]pub enum PromptResponse { Allow, Deny, AllowAll,}
static PERMISSION\_PROMPTER: Lazy<Mutex<Box<dyn PermissionPrompter>>> = Lazy::new(|| Mutex::new(Box::new(TtyPrompter)));
static MAYBE\_BEFORE\_PROMPT\_CALLBACK: Lazy<Mutex<Option<PromptCallback>>> = Lazy::new(|| Mutex::new(None));
static MAYBE\_AFTER\_PROMPT\_CALLBACK: Lazy<Mutex<Option<PromptCallback>>> = Lazy::new(|| Mutex::new(None));
pub fn permission\_prompt( message: &str, flag: &str, api\_name: Option<&str>, is\_unary: bool,) -> PromptResponse { if let Some(before\_callback) = MAYBE\_BEFORE\_PROMPT\_CALLBACK.lock().as\_mut() { before\_callback(); } let r = PERMISSION\_PROMPTER .lock() .prompt(message, flag, api\_name, is\_unary); if let Some(after\_callback) = MAYBE\_AFTER\_PROMPT\_CALLBACK.lock().as\_mut() { after\_callback(); } r}
pub fn set\_prompt\_callbacks( before\_callback: PromptCallback, after\_callback: PromptCallback,) { \*MAYBE\_BEFORE\_PROMPT\_CALLBACK.lock() = Some(before\_callback); \*MAYBE\_AFTER\_PROMPT\_CALLBACK.lock() = Some(after\_callback);}
pub type PromptCallback = Box<dyn FnMut() + Send + Sync>;
pub trait PermissionPrompter: Send + Sync { fn prompt( &mut self, message: &str, name: &str, api\_name: Option<&str>, is\_unary: bool, ) -> PromptResponse;}
pub struct TtyPrompter;
impl PermissionPrompter for TtyPrompter { fn prompt( &mut self, message: &str, name: &str, api\_name: Option<&str>, is\_unary: bool, ) -> PromptResponse { if !std::io::stdin().is\_terminal() || !std::io::stderr().is\_terminal() { return PromptResponse::Deny; };
 #[cfg(unix)] fn clear\_stdin( \_stdin\_lock: &mut StdinLock, \_stderr\_lock: &mut StderrLock, ) -> Result<(), AnyError> { // TODO(bartlomieju): #[allow(clippy::undocumented\_unsafe\_blocks)] let r = unsafe { libc::tcflush(0, libc::TCIFLUSH) }; assert\_eq!(r, 0); Ok(()) }
 #[cfg(not(unix))] fn clear\_stdin( stdin\_lock: &mut StdinLock, stderr\_lock: &mut StderrLock, ) -> Result<(), AnyError> { use deno\_core::anyhow::bail; use winapi::shared::minwindef::TRUE; use winapi::shared::minwindef::UINT; use winapi::shared::minwindef::WORD; use winapi::shared::ntdef::WCHAR; use winapi::um::processenv::GetStdHandle; use winapi::um::winbase::STD\_INPUT\_HANDLE; use winapi::um::wincon::FlushConsoleInputBuffer; use winapi::um::wincon::PeekConsoleInputW; use winapi::um::wincon::WriteConsoleInputW; use winapi::um::wincontypes::INPUT\_RECORD; use winapi::um::wincontypes::KEY\_EVENT; use winapi::um::winnt::HANDLE; use winapi::um::winuser::MapVirtualKeyW; use winapi::um::winuser::MAPVK\_VK\_TO\_VSC; use winapi::um::winuser::VK\_RETURN;
 // SAFETY: winapi calls unsafe { let stdin = GetStdHandle(STD\_INPUT\_HANDLE); // emulate an enter key press to clear any line buffered console characters emulate\_enter\_key\_press(stdin)?; // read the buffered line or enter key press read\_stdin\_line(stdin\_lock)?; // check if our emulated key press was executed if is\_input\_buffer\_empty(stdin)? { // if so, move the cursor up to prevent a blank line move\_cursor\_up(stderr\_lock)?; } else { // the emulated key press is still pending, so a buffered line was read // and we can flush the emulated key press flush\_input\_buffer(stdin)?; } }
 return Ok(());
 unsafe fn flush\_input\_buffer(stdin: HANDLE) -> Result<(), AnyError> { let success = FlushConsoleInputBuffer(stdin); if success != TRUE { bail!( "Could not flush the console input buffer: {}", std::io::Error::last\_os\_error() ) } Ok(()) }
 unsafe fn emulate\_enter\_key\_press(stdin: HANDLE) -> Result<(), AnyError> { // https://github.com/libuv/libuv/blob/a39009a5a9252a566ca0704d02df8dabc4ce328f/src/win/tty.c#L1121-L1131 let mut input\_record: INPUT\_RECORD = std::mem::zeroed(); input\_record.EventType = KEY\_EVENT; input\_record.Event.KeyEvent\_mut().bKeyDown = TRUE; input\_record.Event.KeyEvent\_mut().wRepeatCount = 1; input\_record.Event.KeyEvent\_mut().wVirtualKeyCode = VK\_RETURN as WORD; input\_record.Event.KeyEvent\_mut().wVirtualScanCode = MapVirtualKeyW(VK\_RETURN as UINT, MAPVK\_VK\_TO\_VSC) as WORD; \*input\_record.Event.KeyEvent\_mut().uChar.UnicodeChar\_mut() = '\r' as WCHAR;
 let mut record\_written = 0; let success = WriteConsoleInputW(stdin, &input\_record, 1, &mut record\_written); if success != TRUE { bail!( "Could not emulate enter key press: {}", std::io::Error::last\_os\_error() ); } Ok(()) }
 unsafe fn is\_input\_buffer\_empty(stdin: HANDLE) -> Result<bool, AnyError> { let mut buffer = Vec::with\_capacity(1); let mut events\_read = 0; let success = PeekConsoleInputW(stdin, buffer.as\_mut\_ptr(), 1, &mut events\_read); if success != TRUE { bail!( "Could not peek the console input buffer: {}", std::io::Error::last\_os\_error() ) } Ok(events\_read == 0) }
 fn move\_cursor\_up(stderr\_lock: &mut StderrLock) -> Result<(), AnyError> { write!(stderr\_lock, "\x1B[1A")?; Ok(()) }
 fn read\_stdin\_line(stdin\_lock: &mut StdinLock) -> Result<(), AnyError> { let mut input = String::new(); stdin\_lock.read\_line(&mut input)?; Ok(()) } }
 // Clear n-lines in terminal and move cursor to the beginning of the line. fn clear\_n\_lines(stderr\_lock: &mut StderrLock, n: usize) { write!(stderr\_lock, "\x1B[{n}A\x1B[0J").unwrap(); }
 // Lock stdio streams, so no other output is written while the prompt is // displayed. let stdout\_lock = std::io::stdout().lock(); let mut stderr\_lock = std::io::stderr().lock(); let mut stdin\_lock = std::io::stdin().lock();
 // For security reasons we must consume everything in stdin so that previously // buffered data cannot affect the prompt. if let Err(err) = clear\_stdin(&mut stdin\_lock, &mut stderr\_lock) { eprintln!("Error clearing stdin for permission prompt. {err:#}"); return PromptResponse::Deny; // don't grant permission if this fails }
 let message = strip\_ansi\_codes\_and\_ascii\_control(message); let name = strip\_ansi\_codes\_and\_ascii\_control(name); let api\_name = api\_name.map(strip\_ansi\_codes\_and\_ascii\_control);
 // print to stderr so that if stdout is piped this is still displayed. let opts: String = if is\_unary { format!("[y/n/A] (y = yes, allow; n = no, deny; A = allow all {name} permissions)") } else { "[y/n] (y = yes, allow; n = no, deny)".to\_string() };
 // output everything in one shot to make the tests more reliable { let mut output = String::new(); write!(&mut output, "┌ {PERMISSION\_EMOJI} ").unwrap(); write!(&mut output, "{}", colors::bold("Deno requests ")).unwrap(); write!(&mut output, "{}", colors::bold(message.clone())).unwrap(); writeln!(&mut output, "{}", colors::bold(".")).unwrap(); if let Some(api\_name) = api\_name.clone() { writeln!(&mut output, "├ Requested by `{api\_name}` API.").unwrap(); } let msg = format!("Run again with --allow-{name} to bypass this prompt."); writeln!(&mut output, "├ {}", colors::italic(&msg)).unwrap(); write!(&mut output, "└ {}", colors::bold("Allow?")).unwrap(); write!(&mut output, " {opts} > ").unwrap();
 stderr\_lock.write\_all(output.as\_bytes()).unwrap(); }
 let value = loop { let mut input = String::new(); let result = stdin\_lock.read\_line(&mut input); if result.is\_err() { break PromptResponse::Deny; }; let ch = match input.chars().next() { None => break PromptResponse::Deny, Some(v) => v, }; match ch { 'y' | 'Y' => { clear\_n\_lines( &mut stderr\_lock, if api\_name.is\_some() { 4 } else { 3 }, ); let msg = format!("Granted {message}."); writeln!(stderr\_lock, "✅ {}", colors::bold(&msg)).unwrap(); break PromptResponse::Allow; } 'n' | 'N' => { clear\_n\_lines( &mut stderr\_lock, if api\_name.is\_some() { 4 } else { 3 }, ); let msg = format!("Denied {message}."); writeln!(stderr\_lock, "❌ {}", colors::bold(&msg)).unwrap(); break PromptResponse::Deny; } 'A' if is\_unary => { clear\_n\_lines( &mut stderr\_lock, if api\_name.is\_some() { 4 } else { 3 }, ); let msg = format!("Granted all {name} access."); writeln!(stderr\_lock, "✅ {}", colors::bold(&msg)).unwrap(); break PromptResponse::AllowAll; } \_ => { // If we don't get a recognized option try again. clear\_n\_lines(&mut stderr\_lock, 1); write!( stderr\_lock, "└ {} {opts} > ", colors::bold("Unrecognized option. Allow?") ) .unwrap(); } }; };
 drop(stdout\_lock); drop(stderr\_lock); drop(stdin\_lock);
 value }}
#[cfg(test)]pub mod tests { use super::\*; use std::sync::atomic::AtomicBool; use std::sync::atomic::Ordering;
 pub struct TestPrompter;
 impl PermissionPrompter for TestPrompter { fn prompt( &mut self, \_message: &str, \_name: &str, \_api\_name: Option<&str>, \_is\_unary: bool, ) -> PromptResponse { if STUB\_PROMPT\_VALUE.load(Ordering::SeqCst) { PromptResponse::Allow } else { PromptResponse::Deny } } }
 static STUB\_PROMPT\_VALUE: AtomicBool = AtomicBool::new(true);
 pub static PERMISSION\_PROMPT\_STUB\_VALUE\_SETTER: Lazy< Mutex<PermissionPromptStubValueSetter>, > = Lazy::new(|| Mutex::new(PermissionPromptStubValueSetter));
 pub struct PermissionPromptStubValueSetter;
 impl PermissionPromptStubValueSetter { pub fn set(&self, value: bool) { STUB\_PROMPT\_VALUE.store(value, Ordering::SeqCst); } }
 pub fn set\_prompter(prompter: Box<dyn PermissionPrompter>) { \*PERMISSION\_PROMPTER.lock() = prompter; }}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

