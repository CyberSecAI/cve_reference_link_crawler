```
{
  "vulnerability_details": {
    "root_cause": "A race condition occurs when a task group is being destroyed. Specifically, the `unregister_fair_sched_group()` function unlinks cfs_rqs from a dying task group but doesn't protect against interrupts. A timer interrupt can trigger `sched_cfs_period_timer()`, which can re-add cfs_rqs to the dying group while it's being unlinked or after it has been unlinked, but before it is freed. This leads to a use-after-free when `free_fair_sched_group()` is called, as the cfs_rqs are still linked in the dying group.",
    "weaknesses": [
      "Race condition due to lack of interrupt protection during task group destruction.",
      "Use-after-free vulnerability when freeing task groups with active cfs_rqs."
    ],
    "impact": "A use-after-free vulnerability that can lead to system crashes.",
    "attack_vectors": "The vulnerability is triggered by a timer interrupt at an inopportune time during task group destruction.",
    "required_capabilities": "The attacker needs to trigger task group destruction, typically by creating and destroying cgroups or tasks within cgroups. The race condition is timing-dependent and requires the timer interrupt to occur at a precise time during the destruction process."
  },
   "additional_notes": "The patch addresses the race condition by unlinking the dying task group first before unregistering and freeing its resources, as well as waiting for RCU grace periods to ensure no concurrent users are accessing the dying task group. This commit provides significantly more detail than a standard CVE description."
}
```