

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hugo Villeneuve <hvilleneuve@dimonoff.com> | 2024-07-23 08:53:00 -0400 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-08-14 15:34:30 +0200 |
| commit | [09cfe05e9907f3276887a20e267cc40e202f4fdd](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)) | |
| tree | [ea32773f8797374f4745d67a13f7e8c127161c2f](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd) | |
| parent | [68dc02f319b9ee54dc23caba742a5c754d1cccc8](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=68dc02f319b9ee54dc23caba742a5c754d1cccc8) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd&id2=68dc02f319b9ee54dc23caba742a5c754d1cccc8)) | |
| download | [linux-09cfe05e9907f3276887a20e267cc40e202f4fdd.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-09cfe05e9907f3276887a20e267cc40e202f4fdd.tar.gz) | |

serial: sc16is7xx: fix TX fifo corruptioncommit 133f4c00b8b2bfcacead9b81e7e8edfceb4b06c4 upstream.
Sometimes, when a packet is received on channel A at almost the same time
as a packet is about to be transmitted on channel B, we observe with a
logic analyzer that the received packet on channel A is transmitted on
channel B. In other words, the Tx buffer data on channel B is corrupted
with data from channel A.
The problem appeared since commit 4409df5866b7 ("serial: sc16is7xx: change
EFR lock to operate on each channels"), which changed the EFR locking to
operate on each channel instead of chip-wise.
This commit has introduced a regression, because the EFR lock is used not
only to protect the EFR registers access, but also, in a very obscure and
undocumented way, to protect access to the data buffer, which is shared by
the Tx and Rx handlers, but also by each channel of the IC.
Fix this regression first by switching to kfifo\_out\_linear\_ptr() in
sc16is7xx\_handle\_tx() to eliminate the need for a shared Rx/Tx buffer.
Secondly, replace the chip-wise Rx buffer with a separate Rx buffer for
each channel.
Fixes: 4409df5866b7 ("serial: sc16is7xx: change EFR lock to operate on each channels")
Cc: stable@vger.kernel.org
Signed-off-by: Hugo Villeneuve <hvilleneuve@dimonoff.com>
Link: [https://lore.kernel.org/r/20240723125302.1305372-2-hugo@hugovil.com](https://lore.kernel.org/r/20240723125302.1305372-2-hugo%40hugovil.com)
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)

| -rw-r--r-- | [drivers/tty/serial/sc16is7xx.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/tty/serial/sc16is7xx.c?id=09cfe05e9907f3276887a20e267cc40e202f4fdd) | 21 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 11 insertions, 10 deletions

| diff --git a/drivers/tty/serial/sc16is7xx.c b/drivers/tty/serial/sc16is7xx.cindex bf0065d1c8e9c3..9f2fcd1c1916cb 100644--- a/[drivers/tty/serial/sc16is7xx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/serial/sc16is7xx.c?id=68dc02f319b9ee54dc23caba742a5c754d1cccc8)+++ b/[drivers/tty/serial/sc16is7xx.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/tty/serial/sc16is7xx.c?id=09cfe05e9907f3276887a20e267cc40e202f4fdd)@@ -326,6 +326,7 @@ struct sc16is7xx\_one { struct kthread\_work reg\_work; struct kthread\_delayed\_work ms\_work; struct sc16is7xx\_one\_config config;+ unsigned char buf[SC16IS7XX\_FIFO\_SIZE]; /\* Rx buffer. \*/ unsigned int old\_mctrl; u8 old\_lcr; /\* Value before EFR access. \*/ bool irda\_mode;@@ -339,7 +340,6 @@ struct sc16is7xx\_port { unsigned long gpio\_valid\_mask; #endif u8 mctrl\_mask;- unsigned char buf[SC16IS7XX\_FIFO\_SIZE]; struct kthread\_worker kworker; struct task\_struct \*kworker\_task; struct sc16is7xx\_one p[];@@ -611,18 +611,18 @@ static int sc16is7xx\_set\_baud(struct uart\_port \*port, int baud) static void sc16is7xx\_handle\_rx(struct uart\_port \*port, unsigned int rxlen, unsigned int iir) {- struct sc16is7xx\_port \*s = dev\_get\_drvdata(port->dev);+ struct sc16is7xx\_one \*one = to\_sc16is7xx\_one(port, port); unsigned int lsr = 0, bytes\_read, i; bool read\_lsr = (iir == SC16IS7XX\_IIR\_RLSE\_SRC) ? true : false; u8 ch, flag; - if (unlikely(rxlen >= sizeof(s->buf))) {+ if (unlikely(rxlen >= sizeof(one->buf))) { dev\_warn\_ratelimited(port->dev, "ttySC%i: Possible RX FIFO overrun: %d\n", port->line, rxlen); port->icount.buf\_overrun++; /\* Ensure sanity of RX level \*/- rxlen = sizeof(s->buf);+ rxlen = sizeof(one->buf); }  while (rxlen) {@@ -635,10 +635,10 @@ static void sc16is7xx\_handle\_rx(struct uart\_port \*port, unsigned int rxlen, lsr = 0;  if (read\_lsr) {- s->buf[0] = sc16is7xx\_port\_read(port, SC16IS7XX\_RHR\_REG);+ one->buf[0] = sc16is7xx\_port\_read(port, SC16IS7XX\_RHR\_REG); bytes\_read = 1; } else {- sc16is7xx\_fifo\_read(port, s->buf, rxlen);+ sc16is7xx\_fifo\_read(port, one->buf, rxlen); bytes\_read = rxlen; } @@ -671,7 +671,7 @@ static void sc16is7xx\_handle\_rx(struct uart\_port \*port, unsigned int rxlen, }  for (i = 0; i < bytes\_read; ++i) {- ch = s->buf[i];+ ch = one->buf[i]; if (uart\_handle\_sysrq\_char(port, ch)) continue; @@ -689,10 +689,10 @@ static void sc16is7xx\_handle\_rx(struct uart\_port \*port, unsigned int rxlen,  static void sc16is7xx\_handle\_tx(struct uart\_port \*port) {- struct sc16is7xx\_port \*s = dev\_get\_drvdata(port->dev); struct tty\_port \*tport = &port->state->port; unsigned long flags; unsigned int txlen;+ unsigned char \*tail;  if (unlikely(port->x\_char)) { sc16is7xx\_port\_write(port, SC16IS7XX\_THR\_REG, port->x\_char);@@ -717,8 +717,9 @@ static void sc16is7xx\_handle\_tx(struct uart\_port \*port) txlen = 0; } - txlen = uart\_fifo\_out(port, s->buf, txlen);- sc16is7xx\_fifo\_write(port, s->buf, txlen);+ txlen = kfifo\_out\_linear\_ptr(&tport->xmit\_fifo, &tail, txlen);+ sc16is7xx\_fifo\_write(port, tail, txlen);+ uart\_xmit\_advance(port, txlen);  uart\_port\_lock\_irqsave(port, &flags); if (kfifo\_len(&tport->xmit\_fifo) < WAKEUP\_CHARS) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:00:34 +0000

