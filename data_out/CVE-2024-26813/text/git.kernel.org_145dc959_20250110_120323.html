

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alex Williamson <alex.williamson@redhat.com> | 2024-03-08 16:05:27 -0700 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-03 15:32:19 +0200 |
| commit | [0f8d8f9c2173a541812dd750529f4a415117eb29](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=0f8d8f9c2173a541812dd750529f4a415117eb29) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)) | |
| tree | [3eba7997052b4310afe81c0f8cd8c7c94e0f657c](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=0f8d8f9c2173a541812dd750529f4a415117eb29) | |
| parent | [b565c2fd3831935674089ae6f5bf2c39a56bf99d](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=b565c2fd3831935674089ae6f5bf2c39a56bf99d) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f8d8f9c2173a541812dd750529f4a415117eb29&id2=b565c2fd3831935674089ae6f5bf2c39a56bf99d)) | |
| download | [linux-0f8d8f9c2173a541812dd750529f4a415117eb29.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-0f8d8f9c2173a541812dd750529f4a415117eb29.tar.gz) | |

vfio/platform: Create persistent IRQ handlers[ Upstream commit 675daf435e9f8e5a5eab140a9864dfad6668b375 ]
The vfio-platform SET\_IRQS ioctl currently allows loopback triggering of
an interrupt before a signaling eventfd has been configured by the user,
which thereby allows a NULL pointer dereference.
Rather than register the IRQ relative to a valid trigger, register all
IRQs in a disabled state in the device open path. This allows mask
operations on the IRQ to nest within the overall enable state governed
by a valid eventfd signal. This decouples @masked, protected by the
@locked spinlock from @trigger, protected via the @igate mutex.
In doing so, it's guaranteed that changes to @trigger cannot race the
IRQ handlers because the IRQ handler is synchronously disabled before
modifying the trigger, and loopback triggering of the IRQ via ioctl is
safe due to serialization with trigger changes via igate.
For compatibility, request\_irq() failures are maintained to be local to
the SET\_IRQS ioctl rather than a fatal error in the open device path.
This allows, for example, a userspace driver with polling mode support
to continue to work regardless of moving the request\_irq() call site.
This necessarily blocks all SET\_IRQS access to the failed index.
Cc: Eric Auger <eric.auger@redhat.com>
Cc: <stable@vger.kernel.org>
Fixes: 57f972e2b341 ("vfio/platform: trigger an interrupt via eventfd")
Reviewed-by: Kevin Tian <kevin.tian@intel.com>
Reviewed-by: Eric Auger <eric.auger@redhat.com>
Link: [https://lore.kernel.org/r/20240308230557.805580-7-alex.williamson@redhat.com](https://lore.kernel.org/r/20240308230557.805580-7-alex.williamson%40redhat.com)
Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=0f8d8f9c2173a541812dd750529f4a415117eb29)

| -rw-r--r-- | [drivers/vfio/platform/vfio\_platform\_irq.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/vfio/platform/vfio_platform_irq.c?id=0f8d8f9c2173a541812dd750529f4a415117eb29) | 100 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 68 insertions, 32 deletions

| diff --git a/drivers/vfio/platform/vfio\_platform\_irq.c b/drivers/vfio/platform/vfio\_platform\_irq.cindex e5dcada9e86c45..ef41ecef83af11 100644--- a/[drivers/vfio/platform/vfio\_platform\_irq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vfio/platform/vfio_platform_irq.c?id=b565c2fd3831935674089ae6f5bf2c39a56bf99d)+++ b/[drivers/vfio/platform/vfio\_platform\_irq.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/vfio/platform/vfio_platform_irq.c?id=0f8d8f9c2173a541812dd750529f4a415117eb29)@@ -136,6 +136,16 @@ static int vfio\_platform\_set\_irq\_unmask(struct vfio\_platform\_device \*vdev, return 0; } +/\*+ \* The trigger eventfd is guaranteed valid in the interrupt path+ \* and protected by the igate mutex when triggered via ioctl.+ \*/+static void vfio\_send\_eventfd(struct vfio\_platform\_irq \*irq\_ctx)+{+ if (likely(irq\_ctx->trigger))+ eventfd\_signal(irq\_ctx->trigger);+}+ static irqreturn\_t vfio\_automasked\_irq\_handler(int irq, void \*dev\_id) { struct vfio\_platform\_irq \*irq\_ctx = dev\_id;@@ -155,7 +165,7 @@ static irqreturn\_t vfio\_automasked\_irq\_handler(int irq, void \*dev\_id) spin\_unlock\_irqrestore(&irq\_ctx->lock, flags);  if (ret == IRQ\_HANDLED)- eventfd\_signal(irq\_ctx->trigger);+ vfio\_send\_eventfd(irq\_ctx);  return ret; }@@ -164,52 +174,40 @@ static irqreturn\_t vfio\_irq\_handler(int irq, void \*dev\_id) { struct vfio\_platform\_irq \*irq\_ctx = dev\_id; - eventfd\_signal(irq\_ctx->trigger);+ vfio\_send\_eventfd(irq\_ctx);  return IRQ\_HANDLED; }  static int vfio\_set\_trigger(struct vfio\_platform\_device \*vdev, int index,- int fd, irq\_handler\_t handler)+ int fd) { struct vfio\_platform\_irq \*irq = &vdev->irqs[index]; struct eventfd\_ctx \*trigger;- int ret;  if (irq->trigger) {- irq\_clear\_status\_flags(irq->hwirq, IRQ\_NOAUTOEN);- free\_irq(irq->hwirq, irq);- kfree(irq->name);+ disable\_irq(irq->hwirq); eventfd\_ctx\_put(irq->trigger); irq->trigger = NULL; }  if (fd < 0) /\* Disable only \*/ return 0;- irq->name = kasprintf(GFP\_KERNEL\_ACCOUNT, "vfio-irq[%d](%s)",- irq->hwirq, vdev->name);- if (!irq->name)- return -ENOMEM;  trigger = eventfd\_ctx\_fdget(fd);- if (IS\_ERR(trigger)) {- kfree(irq->name);+ if (IS\_ERR(trigger)) return PTR\_ERR(trigger);- }  irq->trigger = trigger; - irq\_set\_status\_flags(irq->hwirq, IRQ\_NOAUTOEN);- ret = request\_irq(irq->hwirq, handler, 0, irq->name, irq);- if (ret) {- kfree(irq->name);- eventfd\_ctx\_put(trigger);- irq->trigger = NULL;- return ret;- }-- if (!irq->masked)- enable\_irq(irq->hwirq);+ /\*+ \* irq->masked effectively provides nested disables within the overall+ \* enable relative to trigger. Specifically request\_irq() is called+ \* with NO\_AUTOEN, therefore the IRQ is initially disabled. The user+ \* may only further disable the IRQ with a MASK operations because+ \* irq->masked is initially false.+ \*/+ enable\_irq(irq->hwirq);  return 0; }@@ -228,7 +226,7 @@ static int vfio\_platform\_set\_irq\_trigger(struct vfio\_platform\_device \*vdev, handler = vfio\_irq\_handler;  if (!count && (flags & VFIO\_IRQ\_SET\_DATA\_NONE))- return vfio\_set\_trigger(vdev, index, -1, handler);+ return vfio\_set\_trigger(vdev, index, -1);  if (start != 0 || count != 1) return -EINVAL;@@ -236,7 +234,7 @@ static int vfio\_platform\_set\_irq\_trigger(struct vfio\_platform\_device \*vdev, if (flags & VFIO\_IRQ\_SET\_DATA\_EVENTFD) { int32\_t fd = \*(int32\_t \*)data; - return vfio\_set\_trigger(vdev, index, fd, handler);+ return vfio\_set\_trigger(vdev, index, fd); }  if (flags & VFIO\_IRQ\_SET\_DATA\_NONE) {@@ -260,6 +258,14 @@ int vfio\_platform\_set\_irqs\_ioctl(struct vfio\_platform\_device \*vdev, unsigned start, unsigned count, uint32\_t flags, void \*data) = NULL; + /\*+ \* For compatibility, errors from request\_irq() are local to the+ \* SET\_IRQS path and reflected in the name pointer. This allows,+ \* for example, polling mode fallback for an exclusive IRQ failure.+ \*/+ if (IS\_ERR(vdev->irqs[index].name))+ return PTR\_ERR(vdev->irqs[index].name);+ switch (flags & VFIO\_IRQ\_SET\_ACTION\_TYPE\_MASK) { case VFIO\_IRQ\_SET\_ACTION\_MASK: func = vfio\_platform\_set\_irq\_mask;@@ -280,7 +286,7 @@ int vfio\_platform\_set\_irqs\_ioctl(struct vfio\_platform\_device \*vdev,  int vfio\_platform\_irq\_init(struct vfio\_platform\_device \*vdev) {- int cnt = 0, i;+ int cnt = 0, i, ret = 0;  while (vdev->get\_irq(vdev, cnt) >= 0) cnt++;@@ -292,29 +298,54 @@ int vfio\_platform\_irq\_init(struct vfio\_platform\_device \*vdev)  for (i = 0; i < cnt; i++) { int hwirq = vdev->get\_irq(vdev, i);+ irq\_handler\_t handler = vfio\_irq\_handler; - if (hwirq < 0)+ if (hwirq < 0) {+ ret = -EINVAL; goto err;+ }  spin\_lock\_init(&vdev->irqs[i].lock);  vdev->irqs[i].flags = VFIO\_IRQ\_INFO\_EVENTFD; - if (irq\_get\_trigger\_type(hwirq) & IRQ\_TYPE\_LEVEL\_MASK)+ if (irq\_get\_trigger\_type(hwirq) & IRQ\_TYPE\_LEVEL\_MASK) { vdev->irqs[i].flags |= VFIO\_IRQ\_INFO\_MASKABLE | VFIO\_IRQ\_INFO\_AUTOMASKED;+ handler = vfio\_automasked\_irq\_handler;+ }  vdev->irqs[i].count = 1; vdev->irqs[i].hwirq = hwirq; vdev->irqs[i].masked = false;+ vdev->irqs[i].name = kasprintf(GFP\_KERNEL\_ACCOUNT,+ "vfio-irq[%d](%s)", hwirq,+ vdev->name);+ if (!vdev->irqs[i].name) {+ ret = -ENOMEM;+ goto err;+ }++ ret = request\_irq(hwirq, handler, IRQF\_NO\_AUTOEN,+ vdev->irqs[i].name, &vdev->irqs[i]);+ if (ret) {+ kfree(vdev->irqs[i].name);+ vdev->irqs[i].name = ERR\_PTR(ret);+ } }  vdev->num\_irqs = cnt;  return 0; err:+ for (--i; i >= 0; i--) {+ if (!IS\_ERR(vdev->irqs[i].name)) {+ free\_irq(vdev->irqs[i].hwirq, &vdev->irqs[i]);+ kfree(vdev->irqs[i].name);+ }+ } kfree(vdev->irqs);- return -EINVAL;+ return ret; }  void vfio\_platform\_irq\_cleanup(struct vfio\_platform\_device \*vdev)@@ -324,7 +355,12 @@ void vfio\_platform\_irq\_cleanup(struct vfio\_platform\_device \*vdev) for (i = 0; i < vdev->num\_irqs; i++) { vfio\_virqfd\_disable(&vdev->irqs[i].mask); vfio\_virqfd\_disable(&vdev->irqs[i].unmask);- vfio\_set\_trigger(vdev, i, -1, NULL);+ if (!IS\_ERR(vdev->irqs[i].name)) {+ free\_irq(vdev->irqs[i].hwirq, &vdev->irqs[i]);+ if (vdev->irqs[i].trigger)+ eventfd\_ctx\_put(vdev->irqs[i].trigger);+ kfree(vdev->irqs[i].name);+ } }  vdev->num\_irqs = 0; |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-10 12:02:00 +0000

