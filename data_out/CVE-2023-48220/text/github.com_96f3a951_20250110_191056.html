
[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fscambra%2Fdevise_invitable%2Fblob%2F41f58970ff76fb64382a9b9ea1bd530f7c3adab2%2Flib%2Fdevise_invitable%2Fmodels.rb)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fscambra%2Fdevise_invitable%2Fblob%2F41f58970ff76fb64382a9b9ea1bd530f7c3adab2%2Flib%2Fdevise_invitable%2Fmodels.rb)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=scambra%2Fdevise_invitable)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[scambra](/scambra)
/
**[devise\_invitable](/scambra/devise_invitable)**
Public

* [Notifications](/login?return_to=%2Fscambra%2Fdevise_invitable) You must be signed in to change notification settings
* [Fork
  552](/login?return_to=%2Fscambra%2Fdevise_invitable)
* [Star
   2.7k](/login?return_to=%2Fscambra%2Fdevise_invitable)

* [Code](/scambra/devise_invitable)
* [Issues
  72](/scambra/devise_invitable/issues)
* [Pull requests
  0](/scambra/devise_invitable/pulls)
* [Actions](/scambra/devise_invitable/actions)
* [Projects
  0](/scambra/devise_invitable/projects)
* [Wiki](/scambra/devise_invitable/wiki)
* [Security](/scambra/devise_invitable/security)
* [Insights](/scambra/devise_invitable/pulse)

Additional navigation options

* [Code](/scambra/devise_invitable)
* [Issues](/scambra/devise_invitable/issues)
* [Pull requests](/scambra/devise_invitable/pulls)
* [Actions](/scambra/devise_invitable/actions)
* [Projects](/scambra/devise_invitable/projects)
* [Wiki](/scambra/devise_invitable/wiki)
* [Security](/scambra/devise_invitable/security)
* [Insights](/scambra/devise_invitable/pulse)

## Files

 41f5897
## Breadcrumbs

1. [devise\_invitable](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2)
2. /[lib](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib)
3. /[devise\_invitable](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib/devise_invitable)
/
# models.rb

Copy path Blame  Blame
## Latest commit

## History

[History](/scambra/devise_invitable/commits/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib/devise_invitable/models.rb)409 lines (347 loc) · 16.4 KB 41f5897
## Breadcrumbs

1. [devise\_invitable](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2)
2. /[lib](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib)
3. /[devise\_invitable](/scambra/devise_invitable/tree/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib/devise_invitable)
/
# models.rb

Top
## File metadata and controls

* Code
* Blame

409 lines (347 loc) · 16.4 KB[Raw](https://github.com/scambra/devise_invitable/raw/41f58970ff76fb64382a9b9ea1bd530f7c3adab2/lib/devise_invitable/models.rb)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409require 'active\_support/deprecation'require 'devise\_invitable/models/authenticatable'
module Devise module Models # Invitable is responsible for sending invitation emails. # When an invitation is sent to an email address, an account is created for it. # Invitation email contains a link allowing the user to accept the invitation # by setting a password (as reset password from Devise's recoverable module). # # Configuration: # # invite\_for: The period the generated invitation token is valid. # After this period, the invited resource won't be able to accept the invitation. # When invite\_for is 0 (the default), the invitation won't expire. # # Examples: # # User.find(1).invited\_to\_sign\_up? # => true/false # User.invite!(email: 'someone@example.com') # => send invitation # User.accept\_invitation!(invitation\_token: '...') # => accept invitation with a token # User.find(1).accept\_invitation! # => accept invitation # User.find(1).invite! # => reset invitation status and send invitation again module Invitable extend ActiveSupport::Concern
 attr\_accessor :skip\_invitation attr\_accessor :completing\_invite attr\_reader :raw\_invitation\_token
 included do include ::DeviseInvitable::Inviter belongs\_to\_options = if Devise.invited\_by\_class\_name { class\_name: Devise.invited\_by\_class\_name } else { polymorphic: true } end if fk = Devise.invited\_by\_foreign\_key belongs\_to\_options[:foreign\_key] = fk end if defined?(ActiveRecord) && defined?(ActiveRecord::Base) && self < ActiveRecord::Base counter\_cache = Devise.invited\_by\_counter\_cache belongs\_to\_options.merge! counter\_cache: counter\_cache if counter\_cache belongs\_to\_options.merge! optional: true if ActiveRecord::VERSION::MAJOR >= 5 elsif defined?(Mongoid) && defined?(Mongoid::Document) && self < Mongoid::Document && Mongoid::VERSION >= '6.0.0' belongs\_to\_options.merge! optional: true end belongs\_to :invited\_by, \*\*belongs\_to\_options
 extend ActiveModel::Callbacks define\_model\_callbacks :invitation\_created define\_model\_callbacks :invitation\_accepted
 scope :no\_active\_invitation, lambda { where(invitation\_token: nil) } if defined?(Mongoid) && defined?(Mongoid::Document) && self < Mongoid::Document scope :created\_by\_invite, lambda { where(:invitation\_created\_at.ne => nil) } scope :invitation\_not\_accepted, lambda { where(invitation\_accepted\_at: nil, :invitation\_token.ne => nil) } scope :invitation\_accepted, lambda { where(:invitation\_accepted\_at.ne => nil) } else scope :created\_by\_invite, lambda { where(arel\_table[:invitation\_created\_at].not\_eq(nil)) } scope :invitation\_not\_accepted, lambda { where(arel\_table[:invitation\_token].not\_eq(nil)).where(invitation\_accepted\_at: nil) } scope :invitation\_accepted, lambda { where(arel\_table[:invitation\_accepted\_at].not\_eq(nil)) }
 callbacks = [ :before\_invitation\_created, :after\_invitation\_created, :before\_invitation\_accepted, :after\_invitation\_accepted, ]
 callbacks.each do |callback\_method| send callback\_method end end end
 def self.required\_fields(klass) fields = [:invitation\_token, :invitation\_created\_at, :invitation\_sent\_at, :invitation\_accepted\_at, :invitation\_limit, Devise.invited\_by\_foreign\_key || :invited\_by\_id, :invited\_by\_type] fields << :invitations\_count if defined?(ActiveRecord) && self < ActiveRecord::Base fields -= [:invited\_by\_type] if Devise.invited\_by\_class\_name fields end
 # Accept an invitation by clearing invitation token and and setting invitation\_accepted\_at def accept\_invitation self.invitation\_accepted\_at = Time.now.utc self.invitation\_token = nil end
 # Accept an invitation by clearing invitation token and and setting invitation\_accepted\_at # Saves the model and confirms it if model is confirmable, running invitation\_accepted callbacks def accept\_invitation! if self.invited\_to\_sign\_up? @accepting\_invitation = true run\_callbacks :invitation\_accepted do self.accept\_invitation self.confirmed\_at ||= self.invitation\_accepted\_at if self.respond\_to?(:confirmed\_at=) self.save end.tap do |saved| self.rollback\_accepted\_invitation if !saved @accepting\_invitation = false end end end
 def rollback\_accepted\_invitation self.invitation\_token = self.invitation\_token\_was self.invitation\_accepted\_at = nil self.confirmed\_at = nil if self.respond\_to?(:confirmed\_at=) end
 # Verify wheather a user is created by invitation, irrespective to invitation status def created\_by\_invite? invitation\_created\_at.present? end
 # Verifies whether a user has been invited or not def invited\_to\_sign\_up? accepting\_invitation? || (persisted? && invitation\_token.present?) end
 # Returns true if accept\_invitation! was called def accepting\_invitation? @accepting\_invitation end
 # Verifies whether a user accepted an invitation (false when user is accepting it) def invitation\_accepted? !accepting\_invitation? && invitation\_accepted\_at.present? end
 # Verifies whether a user has accepted an invitation (false when user is accepting it), or was never invited def accepted\_or\_not\_invited? invitation\_accepted? || !invited\_to\_sign\_up? end
 # Reset invitation token and send invitation again def invite!(invited\_by = nil, options = {}) # This is an order-dependant assignment, this can't be moved was\_invited = invited\_to\_sign\_up?
 # Required to workaround confirmable model's confirmation\_required? method # being implemented to check for non-nil value of confirmed\_at if new\_record\_and\_responds\_to?(:confirmation\_required?) def self.confirmation\_required?; false; end end
 yield self if block\_given? generate\_invitation\_token if no\_token\_present\_or\_skip\_invitation?
 run\_callbacks :invitation\_created do self.invitation\_created\_at = Time.now.utc self.invitation\_sent\_at = self.invitation\_created\_at unless skip\_invitation self.invited\_by = invited\_by if invited\_by
 # Call these before\_validate methods since we aren't validating on save self.downcase\_keys if new\_record\_and\_responds\_to?(:downcase\_keys) self.strip\_whitespace if new\_record\_and\_responds\_to?(:strip\_whitespace)
 validate = options.key?(:validate) ? options[:validate] : self.class.validate\_on\_invite if save(validate: validate) self.invited\_by.decrement\_invitation\_limit! if !was\_invited and self.invited\_by.present? deliver\_invitation(options) unless skip\_invitation end end end
 # Verify whether a invitation is active or not. If the user has been # invited, we need to calculate if the invitation time has not expired # for this user, in other words, if the invitation is still valid. def valid\_invitation? invited\_to\_sign\_up? && invitation\_period\_valid? end
 # Only verify password when is not invited def valid\_password?(password) super unless !accepting\_invitation? && block\_from\_invitation? end
 # Prevent password changed email when accepting invitation def send\_password\_change\_notification? super && !accepting\_invitation? end
 # Enforce password when invitation is being accepted def password\_required? (accepting\_invitation? && self.class.require\_password\_on\_accepting) || super end
 def unauthenticated\_message block\_from\_invitation? ? :invited : super end
 def clear\_reset\_password\_token reset\_password\_token\_present = reset\_password\_token.present? super accept\_invitation! if reset\_password\_token\_present && invited\_to\_sign\_up? end
 def clear\_errors\_on\_valid\_keys self.class.invite\_key.each do |key, value| self.errors.delete(key) if value === self.send(key) end end
 # Deliver the invitation email def deliver\_invitation(options = {}) generate\_invitation\_token! unless @raw\_invitation\_token self.update\_attribute :invitation\_sent\_at, Time.now.utc unless self.invitation\_sent\_at send\_devise\_notification(:invitation\_instructions, @raw\_invitation\_token, options) end
 # provide alias to the encrypted invitation\_token stored by devise def encrypted\_invitation\_token self.invitation\_token end
 def confirmation\_required\_for\_invited? respond\_to?(:confirmation\_required?, true) && confirmation\_required? end
 def invitation\_due\_at return nil if (self.class.invite\_for == 0 || self.class.invite\_for.nil?) #return nil unless self.class.invite\_for
 time = self.invitation\_created\_at || self.invitation\_sent\_at time + self.class.invite\_for end
 def add\_taken\_error(key) errors.add(key, :taken) end  def invitation\_taken? !invited\_to\_sign\_up? end
 protected
 def block\_from\_invitation? invited\_to\_sign\_up? end
 # Checks if the invitation for the user is within the limit time. # We do this by calculating if the difference between today and the # invitation sent date does not exceed the invite for time configured. # Invite\_for is a model configuration, must always be an integer value. # # Example: # # # invite\_for = 1.day and invitation\_sent\_at = today # invitation\_period\_valid? # returns true # # # invite\_for = 5.days and invitation\_sent\_at = 4.days.ago # invitation\_period\_valid? # returns true # # # invite\_for = 5.days and invitation\_sent\_at = 5.days.ago # invitation\_period\_valid? # returns false # # # invite\_for = nil # invitation\_period\_valid? # will always return true # def invitation\_period\_valid? time = invitation\_created\_at || invitation\_sent\_at self.class.invite\_for.to\_i.zero? || (time && time.utc >= self.class.invite\_for.ago) end
 # Generates a new random token for invitation, and stores the time # this token is being generated def generate\_invitation\_token raw, enc = Devise.token\_generator.generate(self.class, :invitation\_token) @raw\_invitation\_token = raw self.invitation\_token = enc end
 def generate\_invitation\_token! generate\_invitation\_token && save(validate: false) end
 def new\_record\_and\_responds\_to?(method) self.new\_record? && self.respond\_to?(method, true) end
 def no\_token\_present\_or\_skip\_invitation? self.invitation\_token.nil? || (!skip\_invitation || @raw\_invitation\_token.nil?) end
 module ClassMethods # Return fields to invite def invite\_key\_fields invite\_key.keys end
 # Attempt to find a user by its email. If a record is not found, # create a new user and send an invitation to it. If the user is found, # return the user with an email already exists error. # If the user is found and still has a pending invitation, invitation # email is resent unless resend\_invitation is set to false. # Attributes must contain the user's email, other attributes will be # set in the record def \_invite(attributes = {}, invited\_by = nil, options = {}, &block) invite\_key\_array = invite\_key\_fields attributes\_hash = {} invite\_key\_array.each do |k,v| attribute = attributes.delete(k) attribute = attribute.to\_s.strip if strip\_whitespace\_keys.include?(k) attributes\_hash[k] = attribute end
 invitable = find\_or\_initialize\_with\_errors(invite\_key\_array, attributes\_hash) invitable.assign\_attributes(attributes) invitable.invited\_by = invited\_by unless invitable.password || invitable.encrypted\_password.present? invitable.password = random\_password end
 invitable.valid? if self.validate\_on\_invite if invitable.new\_record? invitable.clear\_errors\_on\_valid\_keys if !self.validate\_on\_invite elsif invitable.invitation\_taken? || !self.resend\_invitation invite\_key\_array.each do |key| invitable.add\_taken\_error(key) end end
 yield invitable if block\_given? mail = invitable.invite!(nil, options.merge(validate: false)) if invitable.errors.empty? [invitable, mail] end
 def invite!(attributes = {}, invited\_by = nil, options = {}, &block) attr\_hash = ActiveSupport::HashWithIndifferentAccess.new(attributes.to\_h) \_invite(attr\_hash, invited\_by, options, &block).first end
 def invite\_mail!(attributes = {}, invited\_by = nil, options = {}, &block) \_invite(attributes, invited\_by, options, &block).last end
 # Attempt to find a user by it's invitation\_token to set it's password. # If a user is found, reset it's password and automatically try saving # the record. If not user is found, returns a new user containing an # error in invitation\_token attribute. # Attributes must contain invitation\_token, password and confirmation def accept\_invitation!(attributes = {}) original\_token = attributes.delete(:invitation\_token) invitable = find\_by\_invitation\_token(original\_token, false) if invitable.errors.empty? invitable.assign\_attributes(attributes) invitable.accept\_invitation! end invitable end
 def find\_by\_invitation\_token(original\_token, only\_valid) invitation\_token = Devise.token\_generator.digest(self, :invitation\_token, original\_token)
 invitable = find\_or\_initialize\_with\_error\_by(:invitation\_token, invitation\_token) invitable.errors.add(:invitation\_token, :invalid) if invitable.invitation\_token && invitable.persisted? && !invitable.valid\_invitation? invitable unless only\_valid && invitable.errors.present? end
 # Callback convenience methods def before\_invitation\_created(\*args, &blk) set\_callback(:invitation\_created, :before, \*args, &blk) end
 def after\_invitation\_created(\*args, &blk) set\_callback(:invitation\_created, :after, \*args, &blk) end
 def before\_invitation\_accepted(\*args, &blk) set\_callback(:invitation\_accepted, :before, \*args, &blk) end
 def after\_invitation\_accepted(\*args, &blk) set\_callback(:invitation\_accepted, :after, \*args, &blk) end
 Devise::Models.config(self, :invite\_for) Devise::Models.config(self, :validate\_on\_invite) Devise::Models.config(self, :invitation\_limit) Devise::Models.config(self, :invite\_key) Devise::Models.config(self, :resend\_invitation) Devise::Models.config(self, :invited\_by\_class\_name) Devise::Models.config(self, :invited\_by\_foreign\_key) Devise::Models.config(self, :invited\_by\_counter\_cache) Devise::Models.config(self, :allow\_insecure\_sign\_in\_after\_accept) Devise::Models.config(self, :require\_password\_on\_accepting)
 private
 # The random password, as set after an invitation, must conform # to any password format validation rules of the application. # This default fixes the most common scenarios: Passwords must contain # lower + upper case, a digit and a symbol. # For more unusual rules, this method can be overridden. def random\_password length = respond\_to?(:password\_length) ? password\_length : Devise.password\_length
 prefix = 'aA1!' prefix + Devise.friendly\_token(length.last - prefix.length) end end end endend

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.

