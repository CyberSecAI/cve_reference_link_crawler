
[![vusec](/wp-content/uploads/2022/09/cropped-vusec.png)](/)

# [vusec](/)

[Search](#search-container)

Primary Menu
[Skip to content](#content)

* [About VUSec](/)
* [People](/people/)
  + [Faculty](/people#faculty)
  + [PhD Students](/people#phd-students)
  + [Support](/people#support)
  + [Alumni](/people#alumni)
* [Projects](/projects/)
  + [Binary Armoring](/projects#armoring)
  + [Binary and Malware Analysis](/projects#bama)
  + [Hardware Vulnerabilities](/projects#hardware-vulnerabilities)
  + [Mobile Security](/projects#mobile)
  + [Side Channels](/projects#side-channels)
  + [Software Exploitation](/projects#software-exploitation)
  + [Software Reliability](/projects#reliability)
  + [Software Testing](/projects#testing)
* [Highlights](/highlights/)
* [Publications](/publications/)
* [News](/news/)
* [Join](/join/)
* [Student projects](/student-projects/)
* [Funding](/funding/)
* [Contacts](/contacts/)

Search for:

# GhostRace

**Exploiting and Mitigating Speculative Race Conditions**

### [GhostRace: CVE-2024-2193](https://www.cve.org/CVERecord?id=CVE-2024-2193)

Race conditions arise when multiple threads attempt to access a shared resource without proper synchronization, often leading to vulnerabilities such as concurrent use-after-free. To mitigate their occurrence, operating systems rely on synchronization primitives such as mutexes, spinlocks, etc.

**In this work, we present GhostRace, the first security analysis of these primitives on speculatively executed code paths.**

**Our key finding is that all the common synchronization primitives implemented using conditional branches ([Figure 1](#mutex-lock)) can be microarchitecturally bypassed on speculative paths using a Spectre-v1 attack, turning all architecturally race-free critical regions into Speculative Race Conditions (SRCs), allowing attackers to leak information from the target software.**

![Figure 1: Top part: The core implementation of the mutex_lock synchronization primitive in the Linux x86-64 kernel, with the conditional branch that can be abused to craft SRCs in red. Bottom part: The branch ultimately checks the outcome of the lock cmpxchgq instruction, which does not serialize the execution.](https://lh7-us.googleusercontent.com/A5mtFcjtk0myeLsZ-QqmBi7iFv_h_3wrIdzAVSwGwRiFe35KkzdgkIIiCjko7ORcEoCf7B8-PvbAlpf8nJ92oFNDS3uFdaVSm24VCzdK5dSBPSK-WUKDkXSRf-bWNxK6-Bru6g4W0iC8zA8x3UFcy9Q "Figure 1")

*Figure 1: Top part: The core implementation of the mutex\_lock synchronization primitive in the Linux x86-64 kernel, with the conditional branch that can be abused to craft SRCs in red. Bottom part: The branch ultimately checks the outcome of the lock cmpxchgq instruction, which does not serialize the execution.*

---

**Our [GhostRace Paper (PDF)](http://download.vusec.net/papers/ghostrace_sec24.pdf) is accepted for publication at the 33rd USENIX Security Symposium 2024.** **This is a joint project with the [Systems Security Research Group](https://ibm.github.io/system-security-research-updates/2024/03/12/ghostrace) at IBM Research Europe**.

---

## Speculative Synchronization Primitives

**Our analysis shows *all* the other common write-side synchronization primitives in the Linux kernel are ultimately implemented through a conditional branch and are therefore vulnerable to speculative race conditions.**

To experimentally confirm this intuition, we tested all such synchronization primitives under speculative execution after mistraining the vulnerable branch. **In all cases, we confirmed transient execution of the guarded critical region despite another victim thread already architecturally executing in the region.** To determine the transient window size, we measured the maximum number of speculative load instructions we could speculatively execute inside the critical region ([Figure 2](#speculative-window)).

![Figure 2: Transient window size for different write-side synchronization mechanisms, i.e., the number of speculative loads that leave an observable microarchitectural trace.](https://lh7-us.googleusercontent.com/W2JoafY-Chy0JQdu9ihuVmr0G2gq3U4P4RAjvjVbZXGSqvG6Qy2MDPB6SUWb1UnYEHwM0rWRbl33eND2PK9oIS0mGWPxvPy7KfOca9oGK5Ewfe8MFPMYkz2TM6rjmAX6x4pZA7O_aGcACISPdxgYo1U "Figure 2")

*Figure 2: Speculative window size for different write-side synchronization mechanisms, i.e., the number of speculative loads that leave an observable microarchitectural trace.*

## SCUAF Gadget Scanner

To investigate the severity of SRCs, **we concentrate on Speculative Concurrent Use-After-Free (SCUAF) and statically scan the Linux kernel with Coccinelle ([Figure 3](#cocci-script)),** **discovering 1,283 potentially exploitable gadgets**.

![Figure 3: Simplified Cocci scripts (left Free and right Use) scanning for SCUAF gadgets in the Linux kernel.](https://lh7-us.googleusercontent.com/k-oVgKvuKIRcC7XY9rj2RwuZKN54Dri-xlgnKnGXf5fDlNeptlXJI8F-yZSkpfi_1r3x2RnsCxjyAynYRgt_jCOBKOUskRZfC2Rxpy1ko3hWRSVZo_mr0JdMV34y235LlLOVpOQ9K01R_rckQ-0AFWE "Figure 3")

*Figure 3: Simplified Cocci scripts (left Free and right Use) scanning for SCUAF gadgets in the Linux kernel.*

### [IPI Storming: CVE-2024-26602](https://lore.kernel.org/lkml/2024022614-unhappily-python-2cd0%40gregkh/)

To win an SRC, we need to interrupt the execution of the victim process at the right point (i.e., when the dangling pointer is created), and keep the victim there forever so that the attacker can perform the SCUAF attack. In order to achieve this, we created a new exploitation technique called Inter-Process Interrupt (IPI) Storming, which consists of infinitely flooding the victim process’s CPU core with IPIs once interrupted so that it never finishes handling the incoming interrupts, **resulting in creating an unbounded exploitation window that allows the attacker to execute an arbitrary number of SCUAF invocations to mount an end-to-end attack within a single race window.** In [Figure 4](#IPI-storming) we show how the increasing number of storming SMTs widens the UAF exploitation window.

![Figure 4: Size of the UAF exploitation window vs. number of IPI storming cores targeting the victim core.](https://lh7-us.googleusercontent.com/MKaHNmZBeMuo9s0UQxTYuDHsvBHGF5ESIx38LAav9IXwcfpG_CG3UULkDrWFNzyjjrydVIHnFz6O172oktSAiegAkwsqeSHiv_NsTjtdFYM1SVsBsStW4TpdawvWe12sXRrIuhBoiBjINO969rMiI4k "Figure 4")

*Figure 4: Size of the UAF exploitation window vs. number of IPI storming cores targeting the victim core.* Our test CPU contains 16 cores and 24 SMTs.

### SCUAF Information Disclosure Attacks

Furthermore, we show that SCUAF information disclosure attacks ([Figure 5](#SCUAF-attack)) on the kernel are feasible and can match the reliability of typical Spectre attacks, with **our proof of concept leaking kernel memory at 12 KB/s**.

![Figure 5: Speculative information disclosure attack exploiting a speculative race condition. Steps 1-4 and 8-10 run in user mode, issuing syscalls to trigger the relevant kernel code. The other steps run in kernel mode. Our gadget scanner identified the nfc_hci_msg_tx_work function as a SCUAF gadget in the Linux kernel.](https://lh7-us.googleusercontent.com/fwbNm1aDJw8BM6BTUTesMeblQ3_umrNPB86olhS8i8HDwionIkY1lXfnzn6DhPXp4SDQRjdYeqO1YK2ry_j-A5DPqYOrhlQRBbEEzVgq9P-OikA5ZBc6gTx0FKHoP86RgRCvlQ_q1MhE8PdPZE0lEbg "Figure 5")

*Figure 5: Speculative information disclosure attack exploiting a speculative race condition. Steps 1-4 and 8-10 run in user mode, issuing syscalls to trigger the relevant kernel code. The other steps run in kernel mode. Our gadget scanner identified the nfc\_hci\_msg\_tx\_work function as a SCUAF gadget in the Linux kernel.*

## Code

You can find a minimalistic PoC exemplifying the concept of SRC in a step-by-step single-threaded fashion, Coccinelle SCUAF-scanning scripts, and 1200+ SCUAF gadgets found in the Linux kernel at <https://github.com/vusec/ghostrace>

## Affected Hardware & Software

While we have explicitly focused on x86 and Linux in the paper, SRCs also affect other hardware and software targets.

**Hardware**: We have confirmed that all the major hardware vendors are affected by SRCs since, regardless of the particular compare-and-exchange instruction implementation, the conditional branch that follows is subject to branch (mis)prediction. In other words, all the microarchitectures affected by Spectre-v1 are also affected by SRCs.

**Software**: Any target relying on conditional branches to determine whether to enter critical regions—a common design pattern that extends well beyond Linux—is vulnerable to SRCs.

**In summary, any software, e.g., operating system, hypervisor, etc., implementing synchronization primitives through conditional branches without any serializing instruction on that path and running on any microarchitecture (e.g., x86, ARM, RISC-V, etc.), which allows conditional branches to be speculatively executed, is vulnerable to SRCs. As in other speculative execution attacks, this allows leaking data from the target software.**

## Mitigation

To address the new attack surface, **we also propose a generic SRC mitigation to serialize all the affected synchronization primitives on Linux** (i.e., adding an `lfence` instruction after the `lock cmpxchq` in [Figure 1](#mutex-lock))**.** Our mitigation requires minimal kernel changes **(i.e., 2 LoC)** **and incurs only ≈5% geomean performance overhead on LMBench.**

## Disclosure

We disclosed Speculative Race Conditions to the major hardware vendors (Intel, AMD, ARM, and IBM) and the Linux kernel in late 2023.

Hardware vendors have further notified other affected software (OS/hypervisors) vendors, and all parties have acknowledged the reported issue ([**CVE-2024-2193**](https://www.cve.org/CVERecord?id=CVE-2024-2193)). Specifically, AMD responded with an explicit impact statement (i.e., “existing [Spectre-v1] mitigations apply”), pointing to the attacks relying on conditional branch mis-speculation, like Spectre-v1.

**The Linux kernel developers have no immediate plans to implement our proposed serialization of synchronization primitives due to performance concerns**. However, they confirmed the IPI storming issue ([**CVE-2024-26602**](https://lore.kernel.org/lkml/2024022614-unhappily-python-2cd0%40gregkh/)) and **implemented an** [**IPI rate-limiting feature**](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=944d5fe50f3f03daacfea16300e656a1691c4a23) to address the CPU saturation issue by adding a synchronization mutex on the path of sys\_membarrier and avoiding its concurrent execution on multiple cores. **Unfortunately, as our experiments show (Figure 4), hindering IPI storming primitives (i.e., 0 storming cores) is insufficient to close the attack surface completely.**

## Acknowledgments

We would like to thank the anonymous reviewers for their feedback, Andrew Cooper for his early comments on the paper, Julia Lawall for the Coccinelle clarifications, and Alessandro Sorniotti for the early discussions about the project. This work was partially supported by Intel Corporation through the “Allocamelus” project, by the Dutch Research Council (NWO) through project “INTERSECT”, and by the European Union’s Horizon Europe program under grant agreement No. 101120962 (“Rescale”).

## Systems and Network Security Group at VU Amsterdam

## Recent Tweets

[Recent Tweets](https://twitter.com/vu5ec?ref_src=twsrc%5Etfw)

## Recent Posts

# Archives

* [August 2021](/2021/08/)
* [December 2020](/2020/12/)
* [August 2020](/2020/08/)
* [May 2020](/2020/05/)
* [March 2020](/2020/03/)
* [January 2020](/2020/01/)
* [November 2019](/2019/11/)
* [May 2019](/2019/05/)
* [March 2019](/2019/03/)
* [November 2018](/2018/11/)
* [July 2018](/2018/07/)
* [May 2018](/2018/05/)
* [March 2018](/2018/03/)
* [January 2018](/2018/01/)
* [December 2017](/2017/12/)
* [November 2017](/2017/11/)
* [October 2017](/2017/10/)
* [September 2017](/2017/09/)
* [August 2017](/2017/08/)
* [July 2017](/2017/07/)
* [April 2017](/2017/04/)
* [March 2017](/2017/03/)
* [February 2017](/2017/02/)
* [January 2017](/2017/01/)
* [December 2016](/2016/12/)
* [November 2016](/2016/11/)
* [October 2016](/2016/10/)
* [September 2016](/2016/09/)
* [August 2016](/2016/08/)
* [July 2016](/2016/07/)
* [May 2016](/2016/05/)
* [April 2016](/2016/04/)
* [February 2016](/2016/02/)
* [January 2016](/2016/01/)
* [June 2014](/2014/06/)
# Categories

* [award](/category/award/)
* [grant](/category/grant/)
* [presentation](/category/presentation/)
* [press](/category/press/)
* [publication](/category/publication/)
* [statement](/category/statement/)
* [strategy](/category/strategy/)
* [Uncategorized](/category/uncategorized/)
* [uptake](/category/uptake/)

[Proudly powered by WordPress](https://wordpress.org/)

