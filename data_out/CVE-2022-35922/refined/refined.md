Based on the provided content, here's an analysis of CVE-2022-35922:

**Root Cause of Vulnerability:**
The vulnerability stems from the way the `rust-websocket` library handled incoming WebSocket dataframes. It allocated a buffer based on the declared size of the dataframe, which is obtained from an untrusted source. If the declared size was excessively large, memory allocation would fail, leading to a process abort (OOM).

**Weaknesses/Vulnerabilities Present:**
- **Unbounded Memory Allocation:** The core issue was that the library did not impose limits on the size of dataframes it would attempt to allocate, based on the size specified in the dataframe header.
- **Process Abortion on Allocation Failure:** When memory allocation failed, the default Rust allocator would abort the current process, terminating all threads.
- **Lack of Input Sanitization:** The library was not sanitizing or validating the declared size of incoming dataframes.

**Impact of Exploitation:**
- **Denial of Service (DoS):** An attacker could send specially crafted WebSocket messages with excessively large declared dataframe sizes, causing the server or client to crash due to an out-of-memory error, thus leading to a denial of service.

**Attack Vectors:**
- **Untrusted WebSocket Connections:** The attack vector is through handling untrusted WebSocket connections. An attacker only needs to control the size field in the header of the websocket dataframe.

**Required Attacker Capabilities/Position:**
- **Network Access:** The attacker needs network access to send malicious WebSocket messages to the vulnerable server or client.
- **Ability to Forge WebSocket Dataframes:** The attacker needs to be able to manipulate the WebSocket protocol and craft specific dataframes with large size declarations.

**Additional Details:**
- The vulnerability affects the synchronous (non-Tokio) implementation of the library.
- The fix implemented in version 0.26.5 imposes default limits on dataframe and message sizes (100MB and 200MB respectively).
- A new API has been added to allow fine-tuning of these limits.
- The GitHub Security Advisory also notes that an async version exists that does not use `with_capacity` and would only crash when the bytes for the over sized dataframe are actually delivered.

The provided content includes a commit message which introduces the limits for the dataframe and message size, to resolve the vulnerability. It also includes a Fedora update notification that rebuilds `rust-ffsend` against a fixed version of `rust-websocket` and references the associated bugzilla issues.