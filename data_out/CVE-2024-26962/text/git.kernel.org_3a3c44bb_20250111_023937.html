

| [cgit logo](/) | [index](/) : [kernel/git/stable/linux.git](/pub/scm/linux/kernel/git/stable/linux.git/) | linux-2.6.11.y linux-2.6.12.y linux-2.6.13.y linux-2.6.14.y linux-2.6.15.y linux-2.6.16.y linux-2.6.17.y linux-2.6.18.y linux-2.6.19.y linux-2.6.20.y linux-2.6.21.y linux-2.6.22.y linux-2.6.23.y linux-2.6.24.y linux-2.6.25.y linux-2.6.26.y linux-2.6.27.y linux-2.6.28.y linux-2.6.29.y linux-2.6.30.y linux-2.6.31.y linux-2.6.32.y linux-2.6.33.y linux-2.6.34.y linux-2.6.35.y linux-2.6.36.y linux-2.6.37.y linux-2.6.38.y linux-2.6.39.y linux-3.0.y linux-3.1.y linux-3.10.y linux-3.11.y linux-3.12.y linux-3.13.y linux-3.14.y linux-3.15.y linux-3.16.y linux-3.17.y linux-3.18.y linux-3.19.y linux-3.2.y linux-3.3.y linux-3.4.y linux-3.5.y linux-3.6.y linux-3.7.y linux-3.8.y linux-3.9.y linux-4.0.y linux-4.1.y linux-4.10.y linux-4.11.y linux-4.12.y linux-4.13.y linux-4.14.y linux-4.15.y linux-4.16.y linux-4.17.y linux-4.18.y linux-4.19.y linux-4.2.y linux-4.20.y linux-4.3.y linux-4.4.y linux-4.5.y linux-4.6.y linux-4.7.y linux-4.8.y linux-4.9.y linux-5.0.y linux-5.1.y linux-5.10.y linux-5.11.y linux-5.12.y linux-5.13.y linux-5.14.y linux-5.15.y linux-5.16.y linux-5.17.y linux-5.18.y linux-5.19.y linux-5.2.y linux-5.3.y linux-5.4.y linux-5.5.y linux-5.6.y linux-5.7.y linux-5.8.y linux-5.9.y linux-6.0.y linux-6.1.y linux-6.10.y linux-6.11.y linux-6.12.y linux-6.2.y linux-6.3.y linux-6.4.y linux-6.5.y linux-6.6.y linux-6.7.y linux-6.8.y linux-6.9.y linux-rolling-lts linux-rolling-stable master |
| --- | --- | --- |
| Linux kernel stable tree | Stable Group |

| [about](/pub/scm/linux/kernel/git/stable/linux.git/about/)[summary](/pub/scm/linux/kernel/git/stable/linux.git/)[refs](/pub/scm/linux/kernel/git/stable/linux.git/refs/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)[log](/pub/scm/linux/kernel/git/stable/linux.git/log/)[tree](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)[commit](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)[diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)[stats](/pub/scm/linux/kernel/git/stable/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Yu Kuai <yukuai3@huawei.com> | 2024-03-05 15:23:05 +0800 |
| --- | --- | --- |
| committer | Greg Kroah-Hartman <gregkh@linuxfoundation.org> | 2024-04-03 15:11:18 +0200 |
| commit | [5943a34bf6bab5801e08a55f63e1b8d5bc90dae1](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) ([patch](/pub/scm/linux/kernel/git/stable/linux.git/patch/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)) | |
| tree | [19ea64ab75964cae27f86b523d0b3d6f52a12f7d](/pub/scm/linux/kernel/git/stable/linux.git/tree/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) | |
| parent | [66a7ae8a5b5319284e81490a5bccbb43078d889c](/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=66a7ae8a5b5319284e81490a5bccbb43078d889c) ([diff](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1&id2=66a7ae8a5b5319284e81490a5bccbb43078d889c)) | |
| download | [linux-5943a34bf6bab5801e08a55f63e1b8d5bc90dae1.tar.gz](/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-5943a34bf6bab5801e08a55f63e1b8d5bc90dae1.tar.gz) | |

dm-raid456, md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape[ Upstream commit 41425f96d7aa59bc865f60f5dda3d7697b555677 ]
For raid456, if reshape is still in progress, then IO across reshape
position will wait for reshape to make progress. However, for dm-raid,
in following cases reshape will never make progress hence IO will hang:
1) the array is read-only;
2) MD\_RECOVERY\_WAIT is set;
3) MD\_RECOVERY\_FROZEN is set;
After commit c467e97f079f ("md/raid6: use valid sector values to determine
if an I/O should wait on the reshape") fix the problem that IO across
reshape position doesn't wait for reshape, the dm-raid test
shell/lvconvert-raid-reshape.sh start to hang:
[root@fedora ~]# cat /proc/979/stack
[<0>] wait\_woken+0x7d/0x90
[<0>] raid5\_make\_request+0x929/0x1d70 [raid456]
[<0>] md\_handle\_request+0xc2/0x3b0 [md\_mod]
[<0>] raid\_map+0x2c/0x50 [dm\_raid]
[<0>] \_\_map\_bio+0x251/0x380 [dm\_mod]
[<0>] dm\_submit\_bio+0x1f0/0x760 [dm\_mod]
[<0>] \_\_submit\_bio+0xc2/0x1c0
[<0>] submit\_bio\_noacct\_nocheck+0x17f/0x450
[<0>] submit\_bio\_noacct+0x2bc/0x780
[<0>] submit\_bio+0x70/0xc0
[<0>] mpage\_readahead+0x169/0x1f0
[<0>] blkdev\_readahead+0x18/0x30
[<0>] read\_pages+0x7c/0x3b0
[<0>] page\_cache\_ra\_unbounded+0x1ab/0x280
[<0>] force\_page\_cache\_ra+0x9e/0x130
[<0>] page\_cache\_sync\_ra+0x3b/0x110
[<0>] filemap\_get\_pages+0x143/0xa30
[<0>] filemap\_read+0xdc/0x4b0
[<0>] blkdev\_read\_iter+0x75/0x200
[<0>] vfs\_read+0x272/0x460
[<0>] ksys\_read+0x7a/0x170
[<0>] \_\_x64\_sys\_read+0x1c/0x30
[<0>] do\_syscall\_64+0xc6/0x230
[<0>] entry\_SYSCALL\_64\_after\_hwframe+0x6c/0x74
This is because reshape can't make progress.
For md/raid, the problem doesn't exist because register new sync\_thread
doesn't rely on the IO to be done any more:
1) If array is read-only, it can switch to read-write by ioctl/sysfs;
2) md/raid never set MD\_RECOVERY\_WAIT;
3) If MD\_RECOVERY\_FROZEN is set, mddev\_suspend() doesn't hold
'reconfig\_mutex', hence it can be cleared and reshape can continue by
sysfs api 'sync\_action'.
However, I'm not sure yet how to avoid the problem in dm-raid yet. This
patch on the one hand make sure raid\_message() can't change
sync\_thread() through raid\_message() after presuspend(), on the other
hand detect the above 3 cases before wait for IO do be done in
dm\_suspend(), and let dm-raid requeue those IO.
Cc: stable@vger.kernel.org # v6.7+
Signed-off-by: Yu Kuai <yukuai3@huawei.com>
Signed-off-by: Xiao Ni <xni@redhat.com>
Acked-by: Mike Snitzer <snitzer@kernel.org>
Signed-off-by: Song Liu <song@kernel.org>
Link: [https://lore.kernel.org/r/20240305072306.2562024-9-yukuai1@huaweicloud.com](https://lore.kernel.org/r/20240305072306.2562024-9-yukuai1%40huaweicloud.com)
Signed-off-by: Sasha Levin <sashal@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/stable/linux.git/diff/?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)

| -rw-r--r-- | [drivers/md/dm-raid.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/dm-raid.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) | 22 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/md/md.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/md.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/md.h](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/md.h?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) | 3 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/md/raid5.c](/pub/scm/linux/kernel/git/stable/linux.git/diff/drivers/md/raid5.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1) | 32 | |  |  |  | | --- | --- | --- | |

4 files changed, 74 insertions, 7 deletions

| diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.cindex b8f5304ca00d15..063f1266ec4625 100644--- a/[drivers/md/dm-raid.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/dm-raid.c?id=66a7ae8a5b5319284e81490a5bccbb43078d889c)+++ b/[drivers/md/dm-raid.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/dm-raid.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)@@ -213,6 +213,7 @@ struct raid\_dev { #define RT\_FLAG\_RS\_IN\_SYNC 6 #define RT\_FLAG\_RS\_RESYNCING 7 #define RT\_FLAG\_RS\_GROW 8+#define RT\_FLAG\_RS\_FROZEN 9  /\* Array elements of 64 bit needed for rebuild/failed disk bits \*/ #define DISKS\_ARRAY\_ELEMS ((MAX\_RAID\_DEVICES + (sizeof(uint64\_t) \* 8 - 1)) / sizeof(uint64\_t) / 8)@@ -3340,7 +3341,8 @@ static int raid\_map(struct dm\_target \*ti, struct bio \*bio) if (unlikely(bio\_has\_data(bio) && bio\_end\_sector(bio) > mddev->array\_sectors)) return DM\_MAPIO\_REQUEUE; - md\_handle\_request(mddev, bio);+ if (unlikely(!md\_handle\_request(mddev, bio)))+ return DM\_MAPIO\_REQUEUE;  return DM\_MAPIO\_SUBMITTED; }@@ -3724,7 +3726,8 @@ static int raid\_message(struct dm\_target \*ti, unsigned int argc, char \*\*argv, if (!mddev->pers || !mddev->pers->sync\_request) return -EINVAL; - if (test\_bit(RT\_FLAG\_RS\_SUSPENDED, &rs->runtime\_flags))+ if (test\_bit(RT\_FLAG\_RS\_SUSPENDED, &rs->runtime\_flags) ||+ test\_bit(RT\_FLAG\_RS\_FROZEN, &rs->runtime\_flags)) return -EBUSY;  if (!strcasecmp(argv[0], "frozen")) {@@ -3808,6 +3811,12 @@ static void raid\_presuspend(struct dm\_target \*ti) struct raid\_set \*rs = ti->private; struct mddev \*mddev = &rs->md; + /\*+ \* From now on, disallow raid\_message() to change sync\_thread until+ \* resume, raid\_postsuspend() is too late.+ \*/+ set\_bit(RT\_FLAG\_RS\_FROZEN, &rs->runtime\_flags);+ if (!reshape\_interrupted(mddev)) return; @@ -3820,6 +3829,13 @@ static void raid\_presuspend(struct dm\_target \*ti) mddev->pers->prepare\_suspend(mddev); } +static void raid\_presuspend\_undo(struct dm\_target \*ti)+{+ struct raid\_set \*rs = ti->private;++ clear\_bit(RT\_FLAG\_RS\_FROZEN, &rs->runtime\_flags);+}+ static void raid\_postsuspend(struct dm\_target \*ti) { struct raid\_set \*rs = ti->private;@@ -4085,6 +4101,7 @@ static void raid\_resume(struct dm\_target \*ti)  WARN\_ON\_ONCE(!test\_bit(MD\_RECOVERY\_FROZEN, &mddev->recovery)); WARN\_ON\_ONCE(test\_bit(MD\_RECOVERY\_RUNNING, &mddev->recovery));+ clear\_bit(RT\_FLAG\_RS\_FROZEN, &rs->runtime\_flags); mddev\_lock\_nointr(mddev); mddev->ro = 0; mddev->in\_sync = 0;@@ -4105,6 +4122,7 @@ static struct target\_type raid\_target = { .iterate\_devices = raid\_iterate\_devices, .io\_hints = raid\_io\_hints, .presuspend = raid\_presuspend,+ .presuspend\_undo = raid\_presuspend\_undo, .postsuspend = raid\_postsuspend, .preresume = raid\_preresume, .resume = raid\_resume,diff --git a/drivers/md/md.c b/drivers/md/md.cindex c052edeb21606c..67befb598cdd0c 100644--- a/[drivers/md/md.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/md.c?id=66a7ae8a5b5319284e81490a5bccbb43078d889c)+++ b/[drivers/md/md.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/md.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)@@ -366,7 +366,7 @@ static bool is\_suspended(struct mddev \*mddev, struct bio \*bio) return true; } -void md\_handle\_request(struct mddev \*mddev, struct bio \*bio)+bool md\_handle\_request(struct mddev \*mddev, struct bio \*bio) { check\_suspended: if (is\_suspended(mddev, bio)) {@@ -374,7 +374,7 @@ check\_suspended: /\* Bail out if REQ\_NOWAIT is set for the bio \*/ if (bio->bi\_opf & REQ\_NOWAIT) { bio\_wouldblock\_error(bio);- return;+ return true; } for (;;) { prepare\_to\_wait(&mddev->sb\_wait, &\_\_wait,@@ -390,10 +390,13 @@ check\_suspended:  if (!mddev->pers->make\_request(mddev, bio)) { percpu\_ref\_put(&mddev->active\_io);+ if (!mddev->gendisk && mddev->pers->prepare\_suspend)+ return false; goto check\_suspended; }  percpu\_ref\_put(&mddev->active\_io);+ return true; } EXPORT\_SYMBOL(md\_handle\_request); @@ -8790,6 +8793,23 @@ void md\_account\_bio(struct mddev \*mddev, struct bio \*\*bio) } EXPORT\_SYMBOL\_GPL(md\_account\_bio); +void md\_free\_cloned\_bio(struct bio \*bio)+{+ struct md\_io\_clone \*md\_io\_clone = bio->bi\_private;+ struct bio \*orig\_bio = md\_io\_clone->orig\_bio;+ struct mddev \*mddev = md\_io\_clone->mddev;++ if (bio->bi\_status && !orig\_bio->bi\_status)+ orig\_bio->bi\_status = bio->bi\_status;++ if (md\_io\_clone->start\_time)+ bio\_end\_io\_acct(orig\_bio, md\_io\_clone->start\_time);++ bio\_put(bio);+ percpu\_ref\_put(&mddev->active\_io);+}+EXPORT\_SYMBOL\_GPL(md\_free\_cloned\_bio);+ /\* md\_allow\_write(mddev) \* Calling this ensures that the array is marked 'active' so that writes \* may proceed without blocking. It is important to call this beforediff --git a/drivers/md/md.h b/drivers/md/md.hindex 24261f9b676d51..375ad4a2df71d3 100644--- a/[drivers/md/md.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/md.h?id=66a7ae8a5b5319284e81490a5bccbb43078d889c)+++ b/[drivers/md/md.h](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/md.h?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)@@ -783,6 +783,7 @@ extern void md\_finish\_reshape(struct mddev \*mddev); void md\_submit\_discard\_bio(struct mddev \*mddev, struct md\_rdev \*rdev, struct bio \*bio, sector\_t start, sector\_t size); void md\_account\_bio(struct mddev \*mddev, struct bio \*\*bio);+void md\_free\_cloned\_bio(struct bio \*bio);  extern bool \_\_must\_check md\_flush\_request(struct mddev \*mddev, struct bio \*bio); extern void md\_super\_write(struct mddev \*mddev, struct md\_rdev \*rdev,@@ -811,7 +812,7 @@ extern void md\_stop\_writes(struct mddev \*mddev); extern int md\_rdev\_init(struct md\_rdev \*rdev); extern void md\_rdev\_clear(struct md\_rdev \*rdev); -extern void md\_handle\_request(struct mddev \*mddev, struct bio \*bio);+extern bool md\_handle\_request(struct mddev \*mddev, struct bio \*bio); extern int mddev\_suspend(struct mddev \*mddev, bool interruptible); extern void mddev\_resume(struct mddev \*mddev); extern void md\_idle\_sync\_thread(struct mddev \*mddev);diff --git a/drivers/md/raid5.c b/drivers/md/raid5.cindex 8cdf759a5d2727..e1d8b5199f81e2 100644--- a/[drivers/md/raid5.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/raid5.c?id=66a7ae8a5b5319284e81490a5bccbb43078d889c)+++ b/[drivers/md/raid5.c](/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/md/raid5.c?id=5943a34bf6bab5801e08a55f63e1b8d5bc90dae1)@@ -763,6 +763,7 @@ enum stripe\_result { STRIPE\_RETRY, STRIPE\_SCHEDULE\_AND\_RETRY, STRIPE\_FAIL,+ STRIPE\_WAIT\_RESHAPE, };  struct stripe\_request\_ctx {@@ -5991,7 +5992,8 @@ static enum stripe\_result make\_stripe\_request(struct mddev \*mddev, if (ahead\_of\_reshape(mddev, logical\_sector, conf->reshape\_safe)) { spin\_unlock\_irq(&conf->device\_lock);- return STRIPE\_SCHEDULE\_AND\_RETRY;+ ret = STRIPE\_SCHEDULE\_AND\_RETRY;+ goto out; } } spin\_unlock\_irq(&conf->device\_lock);@@ -6070,6 +6072,12 @@ static enum stripe\_result make\_stripe\_request(struct mddev \*mddev,  out\_release: raid5\_release\_stripe(sh);+out:+ if (ret == STRIPE\_SCHEDULE\_AND\_RETRY && reshape\_interrupted(mddev)) {+ bi->bi\_status = BLK\_STS\_RESOURCE;+ ret = STRIPE\_WAIT\_RESHAPE;+ pr\_err\_ratelimited("dm-raid456: io across reshape position while reshape can't make progress");+ } return ret; } @@ -6191,7 +6199,7 @@ static bool raid5\_make\_request(struct mddev \*mddev, struct bio \* bi) while (1) { res = make\_stripe\_request(mddev, conf, &ctx, logical\_sector, bi);- if (res == STRIPE\_FAIL)+ if (res == STRIPE\_FAIL || res == STRIPE\_WAIT\_RESHAPE) break;  if (res == STRIPE\_RETRY)@@ -6229,6 +6237,11 @@ static bool raid5\_make\_request(struct mddev \*mddev, struct bio \* bi)  if (rw == WRITE) md\_write\_end(mddev);+ if (res == STRIPE\_WAIT\_RESHAPE) {+ md\_free\_cloned\_bio(bi);+ return false;+ }+ bio\_endio(bi); return true; }@@ -8983,6 +8996,18 @@ static int raid5\_start(struct mddev \*mddev) return r5l\_start(conf->log); } +/\*+ \* This is only used for dm-raid456, caller already frozen sync\_thread, hence+ \* if rehsape is still in progress, io that is waiting for reshape can never be+ \* done now, hence wake up and handle those IO.+ \*/+static void raid5\_prepare\_suspend(struct mddev \*mddev)+{+ struct r5conf \*conf = mddev->private;++ wake\_up(&conf->wait\_for\_overlap);+}+ static struct md\_personality raid6\_personality = { .name = "raid6",@@ -9006,6 +9031,7 @@ static struct md\_personality raid6\_personality = .quiesce = raid5\_quiesce, .takeover = raid6\_takeover, .change\_consistency\_policy = raid5\_change\_consistency\_policy,+ .prepare\_suspend = raid5\_prepare\_suspend, }; static struct md\_personality raid5\_personality = {@@ -9030,6 +9056,7 @@ static struct md\_personality raid5\_personality = .quiesce = raid5\_quiesce, .takeover = raid5\_takeover, .change\_consistency\_policy = raid5\_change\_consistency\_policy,+ .prepare\_suspend = raid5\_prepare\_suspend, };  static struct md\_personality raid4\_personality =@@ -9055,6 +9082,7 @@ static struct md\_personality raid4\_personality = .quiesce = raid5\_quiesce, .takeover = raid4\_takeover, .change\_consistency\_policy = raid5\_change\_consistency\_policy,+ .prepare\_suspend = raid5\_prepare\_suspend, };  static int \_\_init raid5\_init(void) |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-11 02:38:14 +0000

